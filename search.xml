<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>2.2字符串篇(2)</title>
      <link href="/posts/1f30e95.html"/>
      <url>/posts/1f30e95.html</url>
      
        <content type="html"><![CDATA[<h1 id="7-字符串子序列问题"><a href="#7-字符串子序列问题" class="headerlink" title="7.字符串子序列问题"></a>7.字符串子序列问题</h1><p>可以用双指针/动态规划完成。</p><p>如392、524题</p><p>注：compare方法模板<code>str1.compare(str2);</code>用来比较两个字符串哪个的<mark>字符序</mark>更小（而非长度）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">std::string str1 = <span class="string">&quot;abc&quot;</span>;</span><br><span class="line">std::string str2 = <span class="string">&quot;def&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> result = str1.<span class="built_in">compare</span>(str2);<span class="comment">//返回负数</span></span><br></pre></td></tr></table></figure><ul><li>如果 <code>str1</code> 小于 <code>str2</code>，则 <code>result</code> 将为负数。</li><li>如果 <code>str1</code> 等于 <code>str2</code>，则 <code>result</code> 将为 0。</li><li>如果 <code>str1</code> 大于 <code>str2</code>，则 <code>result</code> 将为正数。</li></ul><hr><p>判断s是否是t的子字符串 </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isSubsequence</span><span class="params">(string s, string t)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> sPos=<span class="number">0</span>,tPos=<span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> n=s.<span class="built_in">length</span>(),m=t.<span class="built_in">length</span>();</span><br><span class="line">        <span class="keyword">while</span>(sPos&lt;n&amp;&amp;tPos&lt;m)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s[sPos]==t[tPos])&#123;</span><br><span class="line">                sPos++;</span><br><span class="line">            &#125;</span><br><span class="line">            tPos++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sPos==n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="8-高精度运算"><a href="#8-高精度运算" class="headerlink" title="8.高精度运算"></a>8.高精度运算</h1><h2 id="8-1-加一：66"><a href="#8-1-加一：66" class="headerlink" title="8-1.加一：66"></a>8-1.加一：66</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">plusOne</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; digits)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = digits.<span class="built_in">size</span>(), pos = n - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (pos &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (digits[pos] != <span class="number">9</span>) &#123;</span><br><span class="line">                digits[pos]++;</span><br><span class="line">                <span class="keyword">return</span> digits;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                digits[pos--] = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//全是9的情况</span></span><br><span class="line">        digits.<span class="built_in">emplace_back</span>(<span class="number">0</span>);</span><br><span class="line">        digits[<span class="number">0</span>] = <span class="number">1</span>; <span class="comment">//其他数字已经在while循环中被改成9了</span></span><br><span class="line">        <span class="keyword">return</span> digits;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="8-2-二进制求和：67"><a href="#8-2-二进制求和：67" class="headerlink" title="8-2.二进制求和：67"></a>8-2.二进制求和：67</h2><p>法一：模拟(最优)</p><p>关键在于多次进行reverse方便运算和进位；同时进位数carry的处理也很巧妙。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">addBinary</span><span class="params">(string a, string b)</span> </span>&#123;</span><br><span class="line">        string ans;</span><br><span class="line">        <span class="built_in">reverse</span>(a.<span class="built_in">begin</span>(), a.<span class="built_in">end</span>());</span><br><span class="line">        <span class="built_in">reverse</span>(b.<span class="built_in">begin</span>(), b.<span class="built_in">end</span>());</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> n = <span class="built_in">max</span>(a.<span class="built_in">size</span>(), b.<span class="built_in">size</span>()), carry = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            carry += i &lt; a.<span class="built_in">size</span>() ? (a[i] == <span class="string">&#x27;1&#x27;</span>) : <span class="number">0</span>;</span><br><span class="line">            carry += i &lt; b.<span class="built_in">size</span>() ? (b[i] == <span class="string">&#x27;1&#x27;</span>) : <span class="number">0</span>;</span><br><span class="line">            ans += carry % <span class="number">2</span> ? <span class="string">&quot;1&quot;</span> : <span class="string">&quot;0&quot;</span>;</span><br><span class="line">            carry /= <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (carry) &#123;</span><br><span class="line">            ans += <span class="string">&quot;1&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">reverse</span>(ans.<span class="built_in">begin</span>(), ans.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>法二：位运算</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">addBinary</span><span class="params">(string a, string b)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 使用bitset来处理二进制相加</span></span><br><span class="line">        <span class="function">bitset&lt;10000&gt; <span class="title">x</span><span class="params">(a)</span></span>;</span><br><span class="line">        <span class="function">bitset&lt;10000&gt; <span class="title">y</span><span class="params">(b)</span></span>;</span><br><span class="line">        <span class="keyword">while</span> (y.<span class="built_in">any</span>()) &#123;</span><br><span class="line">            <span class="comment">// 计算当前位的和和进位</span></span><br><span class="line">            bitset&lt;10000&gt; sum = x ^ y;</span><br><span class="line">            bitset&lt;10000&gt; carry = (x &amp; y) &lt;&lt; <span class="number">1</span>;</span><br><span class="line">            <span class="comment">// 更新x和y</span></span><br><span class="line">            x = sum;</span><br><span class="line">            y = carry;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 将bitset转换为字符串，并去除前导零</span></span><br><span class="line">        string ans = x.<span class="built_in">to_string</span>();</span><br><span class="line">        <span class="type">size_t</span> startPos = ans.<span class="built_in">find</span>(<span class="string">&#x27;1&#x27;</span>);</span><br><span class="line">        <span class="keyword">if</span> (startPos != string::npos) &#123;  <span class="comment">//能找到</span></span><br><span class="line">            <span class="keyword">return</span> ans.<span class="built_in">substr</span>(startPos);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;0&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><p>根据题干，由于<code>1 &lt;= a.length, b.length &lt;= 10^4</code>，因此a可能位数很长，需要很长的二进制数来存储，常规的<code>int x=stoi(a,0,2)</code>会导致溢出，因此这里使用1e4位的bitset来存储转换的a.a不需要转换为其他参数，string或者int等等都可以直接转换为bitset。一般来说，如果a仅仅是一个int型整数，那么只需要<code>bitset&lt;32&gt;</code>即可，因为int范围在$-2^{31}$ 到 $2^{31} - 1$，</p></li><li><p>while循环中应该使用y.any()而非y：在C++中，<code>std::bitset</code> 类型的对象不可以隐式地被转换为 <code>bool</code> 类型。如果 <code>y</code> 是一个 <code>std::bitset</code> 对象，<code>y</code> 会被用作一个条件表达式时，它无法隐式地转换为 <code>bool</code>。使用 <code>y.any()</code> 是一种更明确的方式来表达循环的终止条件，因为它直接检查 <code>std::bitset</code> <u>是否有任何</u>非零位，所有位均为0时为false退出循环。</p></li><li><p><code>(x&amp;y)&lt;&lt;1</code>:处理进位。</p><ol><li><p><code>x &amp; y</code>: 这是 <code>x</code> 和 <code>y</code> 的按位与运算。在二进制中，每一位上的结果是取两个数对应位上的逻辑与（AND）运算。例如，如果 <code>x</code> 的某一位是1，而 <code>y</code> 的相同位置也是1，那么结果的相应位就是1；否则为0。</p></li><li><p><code>(x &amp; y) &lt;&lt; 1</code>: 这是将上述按位与运算的结果左移一位。左移运算是将二进制数的每一位向左移动指定的位数，右侧空出的位补0。因此，<code>(x &amp; y) &lt;&lt; 1</code> 就是将 <code>(x &amp; y)</code> 的所有位都向左移动一位。</p></li></ol></li><li><p><code>x.to_string()</code>:x为bitset类型的对象。<code>x.to_string()</code> 是用于调用对象的成员函数，而 <code>to_string(x)</code> 是用于将基本数据类型(比如int)转换为字符串。</p></li><li><p><code>size_t startPos = ans.find(&#39;1&#39;)</code>:字符串中的find方法在找寻到第一个‘1’后，返回size_t类型的结果。如果没有找到，则返回<code>std::string::npos</code>。<code>size_t</code> 是一种无符号整数类型，通常用于表示对象的大小、索引或长度。它是通过包含头文件 <code>&lt;cstddef&gt;</code>（或 <code>&lt;stddef.h&gt;</code>，在C语言中）来引入的。</p><p>C++标准规定了 <code>size_t</code> 的属性，它被定义为一个足够大以容纳程序中可能的最大对象大小的无符号整数类型。因此，<code>size_t</code> 的大小在不同的平台和编译器中可能会有所不同，但通常足够大以满足实际需求。</p></li><li><p><code>ans.substr(startPos);</code>：substr方法可以只接受一个参数pos,表示这个子字符串时从pos这个位置开始一直到最后(这时候不用再特地说明长度length)</p></li><li><p><code>stoi(a,0,2)或者stoi(a,nullptr,2)</code>:将字符串a转换为2进制的数，并用int表达。比如a=”10101111”，则转换为int x=101011111。<code>0</code>或者<code>nullptr</code> 是用于存储转换错误位置的指针。如果转换过程中发生错误，<code>stoi</code> 函数会将错误的位置存储在这个指针指向的位置。在这里，<code>0</code>或者<code>nullptr</code>表示不存储错误位置。2表示基数，即转换为几进制。</p></li></ul><h2 id="8-3-字符串相加：415、字符串相乘：43"><a href="#8-3-字符串相加：415、字符串相乘：43" class="headerlink" title="8-3.字符串相加：415、字符串相乘：43"></a>8-3.字符串相加：415、字符串相乘：43</h2><p>类似8-2，使用模拟法</p><p>字符串相乘法二：优化竖式</p><p><img src="https://s2.loli.net/2024/01/29/vsTbwaM5f2H6Pum.png" alt=""></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">multiply</span><span class="params">(string num1, string num2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (num1 == <span class="string">&quot;0&quot;</span> || num2 == <span class="string">&quot;0&quot;</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;0&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> n = num1.<span class="built_in">length</span>() + num2.<span class="built_in">length</span>();</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">res</span><span class="params">(n)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = num1.<span class="built_in">length</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = num2.<span class="built_in">length</span>() - <span class="number">1</span>; j &gt;= <span class="number">0</span>; j--) &#123;</span><br><span class="line">                <span class="type">int</span> sum = res[i + j + <span class="number">1</span>] + (num1[i] - <span class="string">&#x27;0&#x27;</span>) * (num2[j] - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">                res[i + j + <span class="number">1</span>] = sum % <span class="number">10</span>;</span><br><span class="line">                res[i + j] += sum / <span class="number">10</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        string ans = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i == <span class="number">0</span> &amp;&amp; res[i] == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">continue</span>; <span class="comment">//去掉前置0</span></span><br><span class="line">            &#125;</span><br><span class="line">            ans += <span class="built_in">to_string</span>(res[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这里也可以先像前面的题一样反转字符串以后再从前往后算，之后再倒回来。</p><h2 id="8-4-累加数：306"><a href="#8-4-累加数：306" class="headerlink" title="8-4.累加数：306"></a>8-4.累加数：306</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h1 id="9-字符串变换"><a href="#9-字符串变换" class="headerlink" title="9.字符串变换"></a>9.字符串变换</h1><h2 id="9-1-Z字形变换：6"><a href="#9-1-Z字形变换：6" class="headerlink" title="9-1.Z字形变换：6"></a>9-1.Z字形变换：6</h2><p>法一：压缩矩阵存储</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">convert</span><span class="params">(string s, <span class="type">int</span> numRows)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = s.<span class="built_in">length</span>(), r = numRows;</span><br><span class="line">        <span class="keyword">if</span> (r == <span class="number">1</span> || r == n) &#123;</span><br><span class="line">            <span class="keyword">return</span> s;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function">vector&lt;string&gt; <span class="title">mat</span><span class="params">(r)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>, x = <span class="number">0</span>, t = r * <span class="number">2</span> - <span class="number">2</span>; i &lt; n; i++) &#123;</span><br><span class="line">            mat[x] += s[i];<span class="comment">//x记录行数</span></span><br><span class="line">            i % t &lt; r - <span class="number">1</span> ? ++x : --x;<span class="comment">//第i%t行读取结束就继续下一行</span></span><br><span class="line">        &#125;</span><br><span class="line">        string ans;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; row : mat) &#123;</span><br><span class="line">            ans += row;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>法二：直接构造</p><p>观察下标规律：</p><p><img src="https://s2.loli.net/2024/02/03/g97q4Kv86TSiy1b.png" alt=""></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">convert</span><span class="params">(string s, <span class="type">int</span> numRows)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = s.<span class="built_in">length</span>(), r = numRows;</span><br><span class="line">        <span class="keyword">if</span> (r == <span class="number">1</span> || r == n) &#123;</span><br><span class="line">            <span class="keyword">return</span> s;</span><br><span class="line">        &#125;</span><br><span class="line">        string ans;</span><br><span class="line">        <span class="type">int</span> t = r * <span class="number">2</span> - <span class="number">2</span>; <span class="comment">//使得s[t]是第二个竖直列的第一个元素</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; r; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j + i &lt; n; j += t) &#123; <span class="comment">//遍历第i行的元素</span></span><br><span class="line">                ans += s[j + i];</span><br><span class="line">                <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; i &lt; r - <span class="number">1</span> &amp;&amp; j + t - i &lt; n) &#123;</span><br><span class="line">                    ans += s[j + t - i];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="9-2-文本左右对齐：68"><a href="#9-2-文本左右对齐：68" class="headerlink" title="9-2.文本左右对齐：68"></a>9-2.文本左右对齐：68</h2><p>贪心算法+模拟</p><p>详见：<a href="https://leetcode.cn/problems/text-justification/solutions/181651/text-justification-by-ikaruga/">平均分布额外空格</a></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">fillWords</span><span class="params">(vector&lt;string&gt;&amp; words, <span class="type">int</span> bg, <span class="type">int</span> ed, <span class="type">int</span> maxWidth,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">bool</span> lastLine = <span class="literal">false</span>)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> wordCount = ed - bg + <span class="number">1</span>;<span class="comment">//end减去begin后再加1</span></span><br><span class="line">        <span class="type">int</span> spaceCount =</span><br><span class="line">            maxWidth + <span class="number">1</span> - wordCount; <span class="comment">// 除去每个单词尾部空格， + 1</span></span><br><span class="line">                                      <span class="comment">// 是最后一个单词的尾部空格的特殊处理</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = bg; i &lt;= ed; i++) &#123;</span><br><span class="line">            spaceCount -= words[i].<span class="built_in">size</span>(); <span class="comment">// 除去所有单词的长度</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> spaceSuffix = <span class="number">1</span>; <span class="comment">// 词尾空格</span></span><br><span class="line">        <span class="type">int</span> spaceAvg = (wordCount == <span class="number">1</span>)</span><br><span class="line">                           ? <span class="number">1</span></span><br><span class="line">                           : spaceCount / (wordCount - <span class="number">1</span>); <span class="comment">// 额外空格的平均值</span></span><br><span class="line">        <span class="type">int</span> spaceExtra = (wordCount == <span class="number">1</span>)</span><br><span class="line">                             ? <span class="number">0</span></span><br><span class="line">                             : spaceCount % (wordCount - <span class="number">1</span>); <span class="comment">// 额外空格的余数</span></span><br><span class="line">        string ans;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = bg; i &lt; ed; i++) &#123;</span><br><span class="line">            ans += words[i]; <span class="comment">// 填入单词</span></span><br><span class="line">            <span class="keyword">if</span> (lastLine) &#123;  <span class="comment">// 特殊处理最后一行</span></span><br><span class="line">                <span class="built_in">fill_n</span>(<span class="built_in">back_inserter</span>(ans), <span class="number">1</span>, <span class="string">&#x27; &#x27;</span>);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">fill_n</span>(<span class="built_in">back_inserter</span>(ans),</span><br><span class="line">                   spaceSuffix + spaceAvg + ((i - bg) &lt; spaceExtra),</span><br><span class="line">                   <span class="string">&#x27; &#x27;</span>); <span class="comment">// 根据计算结果补上空格</span></span><br><span class="line">        &#125;</span><br><span class="line">        ans += words[ed]; <span class="comment">// 填入最后一个单词</span></span><br><span class="line">        <span class="built_in">fill_n</span>(<span class="built_in">back_inserter</span>(ans), maxWidth - ans.<span class="built_in">size</span>(), <span class="string">&#x27; &#x27;</span>);</span><br><span class="line">        <span class="comment">// 补上这一行最后的空格</span></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">vector&lt;string&gt; <span class="title">fullJustify</span><span class="params">(vector&lt;string&gt;&amp; words, <span class="type">int</span> maxWidth)</span> </span>&#123;</span><br><span class="line">        vector&lt;string&gt; ans;</span><br><span class="line">        <span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> bg = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; words.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            cnt += words[i].<span class="built_in">size</span>() + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (i + <span class="number">1</span> == words.<span class="built_in">size</span>() ||</span><br><span class="line">                cnt + words[i + <span class="number">1</span>].<span class="built_in">size</span>() &gt;</span><br><span class="line">                    maxWidth) &#123; <span class="comment">// 如果是最后一个单词，或者加上下一个词就超过长度了，即可凑成一行</span></span><br><span class="line">                ans.<span class="built_in">push_back</span>(</span><br><span class="line">                    <span class="built_in">fillWords</span>(words, bg, i, maxWidth, i + <span class="number">1</span> == words.<span class="built_in">size</span>()));</span><br><span class="line">                bg = i + <span class="number">1</span>;</span><br><span class="line">                cnt = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="10-字符串匹配-难度较高"><a href="#10-字符串匹配-难度较高" class="headerlink" title="10.字符串匹配(难度较高)"></a>10.字符串匹配(难度较高)</h1><h2 id="10-1-找出字符串中第一个匹配项的下标-28"><a href="#10-1-找出字符串中第一个匹配项的下标-28" class="headerlink" title="10-1.找出字符串中第一个匹配项的下标:28"></a>10-1.找出字符串中第一个匹配项的下标:28</h2><p>法一：暴力匹配</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">strStr</span><span class="params">(string haystack, string needle)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = haystack.<span class="built_in">size</span>(), m = needle.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i + m &lt;= n; i++) &#123;</span><br><span class="line">            <span class="type">bool</span> flag = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; m; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (haystack[i + j] != needle[j]) &#123;</span><br><span class="line">                    flag = <span class="literal">false</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (flag) &#123;</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>使用substr与之同理：</p><p><code>substr()</code>的时间复杂度为$O(n)$,空间复杂度是$O(1)$.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">strStr</span><span class="params">(string haystack, string needle)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; haystack.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (haystack[i] == needle[<span class="number">0</span>]) &#123; <span class="comment">//第一个字符是否相等再决定是不是要尝试匹配整个字符串</span></span><br><span class="line">                string x = haystack.<span class="built_in">substr</span>(i, needle.<span class="built_in">size</span>());</span><br><span class="line">                <span class="keyword">if</span> (x == needle) &#123;</span><br><span class="line">                    <span class="keyword">return</span> i;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>法二：KMP算法</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">strStr</span><span class="params">(string haystack, string needle)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = haystack.<span class="built_in">size</span>(), m = needle.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span> (m == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">next</span><span class="params">(m)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>, j = <span class="number">0</span>; i &lt; m; i++) &#123; <span class="comment">//计算出next数组</span></span><br><span class="line">            <span class="keyword">while</span> (j &gt; <span class="number">0</span> &amp;&amp; needle[i] != needle[j]) &#123;</span><br><span class="line">                j = next[j - <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (needle[i] == needle[j]) &#123;</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">            next[i] = j;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>; i &lt; n; i++) &#123; <span class="comment">//根据next数组进行匹配</span></span><br><span class="line">            <span class="keyword">while</span> (j &gt; <span class="number">0</span> &amp;&amp; haystack[i] != needle[j]) &#123;</span><br><span class="line">                j = next[j - <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (haystack[i] == needle[j]) &#123;</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (j == m) &#123;</span><br><span class="line">                <span class="keyword">return</span> i - m + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="关于KMP"><a href="#关于KMP" class="headerlink" title="关于KMP"></a>关于KMP</h2><p><img src="https://s2.loli.net/2024/02/03/SAhEnMkz5LfJD1W.png" alt=""></p><p><img src="https://s2.loli.net/2024/02/03/B6Z1blgJqCnyRpv.png" title="" alt="" width="473"></p><h2 id="常见字符串匹配算法"><a href="#常见字符串匹配算法" class="headerlink" title="常见字符串匹配算法"></a>常见字符串匹配算法</h2><p>讲解：<a href="https://zhuanlan.zhihu.com/p/159879354">字符串匹配之Sunday、KMP和BM算法入门级讲解</a></p><ol><li><p><strong>暴力匹配算法（Brute Force）</strong>：也称为朴素字符串匹配算法，它通过逐个比较文本和模式串的字符来进行匹配。</p></li><li><p><strong>KMP算法</strong>：KMP算法利用模式串自身的特点，通过构建部分匹配表（next数组）来实现快速匹配。</p></li><li><p><strong>Boyer-Moore算法</strong>：该算法通过从右往左比较模式串和文本串，利用坏字符规则和好后缀规则来快速定位匹配位置。</p></li><li><p><strong>Rabin-Karp算法</strong>：Rabin-Karp算法利用哈希函数来快速比较文本中的子串和模式串，以确定是否需要进行进一步的精确比较（首先是计算两个字符串的哈希值，然后通过比较这两个哈希值的大小来判断是否出现匹配）。</p></li><li><p><strong>Sunday算法</strong>：Sunday算法是一种简单而高效的字符串匹配算法，它利用预处理模式串得到的偏移表，以便在匹配失败时快速移动模式串。</p></li></ol><hr><h2 id="10-2-重复叠加字符串匹配：686"><a href="#10-2-重复叠加字符串匹配：686" class="headerlink" title="10-2.重复叠加字符串匹配：686"></a>10-2.重复叠加字符串匹配：686</h2><p>法一：KMP.</p><p>时间复杂度：$O(n+m)$，空间复杂度：$O(m)$。</p><p>该题代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">strStr</span><span class="params">(string haystack, string needle)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = haystack.<span class="built_in">size</span>(), m = needle.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span> (m == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">next</span><span class="params">(m)</span></span>;</span><br><span class="line">        <span class="comment">// 计算出next数组</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>, j = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">            <span class="keyword">while</span> (j &gt; <span class="number">0</span> &amp;&amp; needle[i] != needle[j]) &#123;</span><br><span class="line">                j = next[j - <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (needle[i] == needle[j]) &#123;</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">            next[i] = j;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 根据next数值进行匹配</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>; i - j &lt; n; i++) &#123; <span class="comment">// b 开始匹配的位置是否超过第一个叠加的 a</span></span><br><span class="line">            <span class="keyword">while</span> (j &gt; <span class="number">0</span> &amp;&amp; haystack[i % n] != needle[j]) &#123; <span class="comment">//i%n,因为可能是多个haystack重复</span></span><br><span class="line">                j = next[j - <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (haystack[i % n] == needle[j]) &#123;</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (j == m) &#123;</span><br><span class="line">                <span class="keyword">return</span> i - m + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">repeatedStringMatch</span><span class="params">(string a, string b)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> an = a.<span class="built_in">size</span>(), bn = b.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> index = <span class="built_in">strStr</span>(a, b);</span><br><span class="line">        <span class="keyword">if</span> (index == <span class="number">-1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (an - index &gt;= bn) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (bn + index - an - <span class="number">1</span>) / an + <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>法二：Rabin-Karp算法</p><p>时间复杂度：O(n+m)，空间复杂度：O(1)。</p><p>关于Rabin-Karp的讲解:<a href="https://zhuanlan.zhihu.com/p/563551141?utm_id=0">Rabin–Karp 算法</a></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> BASE 256</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MODULUS 101</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">RabinKarp</span><span class="params">(<span class="type">char</span> t[], <span class="type">char</span> p[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> t_len = <span class="built_in">strlen</span>(t);</span><br><span class="line">    <span class="type">int</span> p_len = <span class="built_in">strlen</span>(p);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 哈希滚动之用</span></span><br><span class="line">    <span class="type">int</span> h = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; p_len - <span class="number">1</span>; i++)</span><br><span class="line">        h = (h * BASE) % MODULUS;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> t_hash = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> p_hash = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; p_len; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        t_hash = (BASE * t_hash + t[i]) % MODULUS;</span><br><span class="line">        p_hash = (BASE * p_hash + p[i]) % MODULUS;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt;= t_len - p_len)</span><br><span class="line">    &#123;</span><br><span class="line">         <span class="comment">// 考虑到哈希碰撞的可能性，还需要用 memcmp 再比对一下</span></span><br><span class="line">        <span class="keyword">if</span> (t_hash == p_hash &amp;&amp; <span class="built_in">memcmp</span>(p, t + i, p_len) == <span class="number">0</span>)</span><br><span class="line">            cout &lt;&lt; p &lt;&lt; <span class="string">&quot; is found at index &quot;</span> &lt;&lt; i &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 哈希滚动</span></span><br><span class="line">        t_hash = (BASE * (t_hash - t[i] * h) + t[i + p_len]) % MODULUS;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 防止出现负数</span></span><br><span class="line">        <span class="keyword">if</span> (t_hash &lt; <span class="number">0</span>)</span><br><span class="line">            t_hash = t_hash + MODULUS;</span><br><span class="line"></span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="C:\Users\huangjiakun\Pictures\Marktext全局图片\09710814ec32b4e67959fb730df10269ff888601.png" alt=""></p><p>该题代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">strStr</span><span class="params">(string haystack, string needle)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = haystack.<span class="built_in">size</span>(), m = needle.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span> (m == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> k1 = <span class="number">1e9</span> + <span class="number">7</span>;  <span class="comment">// 选择一个较大的质数作为模数</span></span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> k2 = <span class="number">1337</span>;  <span class="comment">// 另选一个较小的质数</span></span><br><span class="line">        <span class="built_in">srand</span>((<span class="type">unsigned</span>)<span class="built_in">time</span>(<span class="literal">NULL</span>));  <span class="comment">// 初始化随机数种子</span></span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> kMod1 = <span class="built_in">rand</span>() % k1 + k1;  <span class="comment">// 生成一个随机数作为模数</span></span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> kMod2 = <span class="built_in">rand</span>() % k2 + k2;  <span class="comment">// 生成另一个随机数作为模数</span></span><br><span class="line"></span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> hash_needle = <span class="number">0</span>;  <span class="comment">// 初始化模式串的哈希值</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> c : needle) &#123;</span><br><span class="line">            hash_needle = (hash_needle * kMod2 + c) % kMod1;  <span class="comment">// 计算模式串的哈希值</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> hash_haystack = <span class="number">0</span>, extra = <span class="number">1</span>;  <span class="comment">// 初始化文本串的哈希值和额外变量</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            hash_haystack = (hash_haystack * kMod2 + haystack[i % n]) % kMod1;  <span class="comment">// 计算文本串的哈希值</span></span><br><span class="line">            extra = (extra * kMod2) % kMod1;  <span class="comment">// 更新额外变量</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = m - <span class="number">1</span>; (i - m + <span class="number">1</span>) &lt; n; i++) &#123;</span><br><span class="line">            hash_haystack = (hash_haystack * kMod2 + haystack[i % n]) % kMod1;  <span class="comment">// 更新文本串的哈希值</span></span><br><span class="line">            <span class="keyword">if</span> (hash_haystack == hash_needle) &#123;  <span class="comment">// 检查哈希值是否匹配</span></span><br><span class="line">                <span class="keyword">return</span> i - m + <span class="number">1</span>;  <span class="comment">// 返回匹配位置</span></span><br><span class="line">            &#125;</span><br><span class="line">            hash_haystack = (hash_haystack - extra * haystack[(i - m + <span class="number">1</span>) % n]) % kMod1;  <span class="comment">// 更新文本串的哈希值</span></span><br><span class="line">            hash_haystack = (hash_haystack + kMod1) % kMod1;  <span class="comment">// 处理负数情况</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;  <span class="comment">// 未找到匹配，返回-1</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">repeatedStringMatch</span><span class="params">(string a, string b)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> an = a.<span class="built_in">size</span>(), bn = b.<span class="built_in">size</span>();  <span class="comment">// 获取字符串a和b的长度</span></span><br><span class="line">        <span class="type">int</span> index = <span class="built_in">strStr</span>(a, b);  <span class="comment">// 调用strStr函数查找b在a中的匹配位置</span></span><br><span class="line">        <span class="keyword">if</span> (index == <span class="number">-1</span>) &#123;  <span class="comment">// 如果未找到匹配位置</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;  <span class="comment">// 返回-1</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (an - index &gt;= bn) &#123;  <span class="comment">// 如果匹配位置之后的长度大于等于b的长度</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;  <span class="comment">// 返回1，表示a本身就包含了至少一个b</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (bn + index - an - <span class="number">1</span>) / an + <span class="number">2</span>;  <span class="comment">// 返回重复拼接a后能够包含b的最小次数</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="10-3-重复的子字符串：459"><a href="#10-3-重复的子字符串：459" class="headerlink" title="10-3.重复的子字符串：459"></a>10-3.重复的子字符串：459</h2><h2 id="10-4-最短回文串：214（困难）"><a href="#10-4-最短回文串：214（困难）" class="headerlink" title="10-4.最短回文串：214（困难）"></a>10-4.最短回文串：214（困难）</h2><h1 id="11-中心拓展法"><a href="#11-中心拓展法" class="headerlink" title="11.中心拓展法"></a>11.中心拓展法</h1><p>中心拓展法的基本思想是以字符串中的每个字符（或者每两个字符之间）为中心，向两边扩展，以<u>寻找最长的回文串</u>。这种方法的时间复杂度较低，因为在中心拓展时，只需要线性的时间。</p><p>具体步骤如下：</p><ol><li>遍历字符串，以每个字符（或者每两个字符之间）为中心，向两边扩展，直到不再满足回文串的条件。</li><li>在扩展的过程中，记录下最长的回文串的起始位置和长度。</li></ol><p>中心拓展法在解决回文串相关问题时非常有效，例如在寻找最长回文子串或者统计回文子串的个数时，该方法可以提供较高的效率。</p><h2 id="11-1-最长回文子串：5"><a href="#11-1-最长回文子串：5" class="headerlink" title="11-1.最长回文子串：5"></a>11-1.最长回文子串：5</h2><p>法一：动态规划</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">longestPalindrome</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = s.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span> (n &lt; <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> s;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> maxLen = <span class="number">1</span>, begin = <span class="number">0</span>;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(n, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n));</span><br><span class="line">        <span class="comment">// 边界条件P(i,i)=true</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            dp[i][i] = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 枚举子串长度L</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> L = <span class="number">2</span>; L &lt;= n; L++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">                <span class="type">int</span> j = L + i - <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span> (j &gt;= n) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (s[i] != s[j]) &#123;</span><br><span class="line">                    dp[i][j] = <span class="literal">false</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (j - i &lt; <span class="number">3</span>) &#123; <span class="comment">//(j-1)-(i+1)&lt;=0</span></span><br><span class="line">                        dp[i][j] = <span class="literal">true</span>;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        dp[i][j] = dp[i + <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 只要 dp[i][j] == true 成立，就表示子串 s[i..j]</span></span><br><span class="line">                <span class="comment">// 是回文，此时记录回文长度和起始位置</span></span><br><span class="line">                <span class="keyword">if</span> (dp[i][j]) &#123;</span><br><span class="line">                    maxLen = <span class="built_in">max</span>(maxLen, j - i + <span class="number">1</span>);</span><br><span class="line">                    begin = i;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s.<span class="built_in">substr</span>(begin, maxLen);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>法二：中心扩展法</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; <span class="title">expandAroundCenter</span><span class="params">(<span class="type">const</span> string&amp; s, <span class="type">int</span> left, <span class="type">int</span> right)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (left &gt;= <span class="number">0</span> &amp;&amp; right &lt; s.<span class="built_in">size</span>() &amp;&amp; s[left] == s[right]) &#123;</span><br><span class="line">            <span class="comment">// 满足回文条件，向两边扩展</span></span><br><span class="line">            --left;</span><br><span class="line">            ++right;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> &#123;left + <span class="number">1</span>, right - <span class="number">1</span>&#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">string <span class="title">longestPalindrome</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> start = <span class="number">0</span>, end = <span class="number">0</span>; <span class="comment">// 从最左侧边界开始</span></span><br><span class="line">        <span class="comment">// 如果从最右侧边界，则start和end初始值应为s.size;同时auto [left2,right2]=expandAroundCenter(s,i-1,i);</span></span><br><span class="line">        <span class="comment">// 然后i从s.size()-1反向遍历nter(s,i-1,i);</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="keyword">auto</span> [left1, right1] = <span class="built_in">expandAroundCenter</span>(s, i, i);     <span class="comment">// a&#x27;b&#x27;a</span></span><br><span class="line">            <span class="keyword">auto</span> [left2, right2] = <span class="built_in">expandAroundCenter</span>(s, i, i + <span class="number">1</span>); <span class="comment">// a&#x27;bb&#x27;a</span></span><br><span class="line">            <span class="keyword">if</span> (right1 - left1 &gt; end - start) &#123;</span><br><span class="line">                start = left1;</span><br><span class="line">                end = right1;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (right2 - left2 &gt; end - start) &#123;</span><br><span class="line">                start = left2;</span><br><span class="line">                end = right2;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s.<span class="built_in">substr</span>(start, end - start + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>法三：Manacher算法(了解)</p><h2 id="11-2-统计回文子串数目：647"><a href="#11-2-统计回文子串数目：647" class="headerlink" title="11-2.统计回文子串数目：647"></a>11-2.统计回文子串数目：647</h2><p>三个方法类似11-1，这里展示中心扩展法代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">expandAroundCenter</span><span class="params">(<span class="type">const</span> string&amp; s, <span class="type">int</span> left, <span class="type">int</span> right)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (left &gt;= <span class="number">0</span> &amp;&amp; right &lt; s.<span class="built_in">size</span>() &amp;&amp; s[left] == s[right]) &#123;</span><br><span class="line">            --left;</span><br><span class="line">            ++right;</span><br><span class="line">            ++ans;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">countSubstrings</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> left = <span class="number">0</span>, right = <span class="number">0</span>, ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            ans +=<span class="built_in">expandAroundCenter</span>(s, i, i) + <span class="built_in">expandAroundCenter</span>(s, i, i + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> leetcode刷题笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> leetcode </tag>
            
            <tag> string </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2.1字符串篇(2)</title>
      <link href="/posts/283bba67.html"/>
      <url>/posts/283bba67.html</url>
      
        <content type="html"><![CDATA[<h1 id="6-数字与字符串之间转换"><a href="#6-数字与字符串之间转换" class="headerlink" title="6.数字与字符串之间转换"></a>6.数字与字符串之间转换</h1><p>299:使用额外两个数组记录Bulls,cows</p><h2 id="6-1-相对名次：506"><a href="#6-1-相对名次：506" class="headerlink" title="6-1.相对名次：506"></a>6-1.相对名次：506</h2><p><code>make_pair(a,b)</code>:形成诸如<code>pair&lt;int,int&gt;</code>的形式</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;string&gt; <span class="title">findRelativeRanks</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; score)</span> </span>&#123;</span><br><span class="line">        vector&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt; arr;</span><br><span class="line">        <span class="type">int</span> n = score.<span class="built_in">size</span>();</span><br><span class="line">        string rankTop[<span class="number">3</span>] = &#123;<span class="string">&quot;Gold Medal&quot;</span>, <span class="string">&quot;Silver Medal&quot;</span>, <span class="string">&quot;Bronze Medal&quot;</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            arr.<span class="built_in">emplace_back</span>(</span><br><span class="line">                <span class="built_in">make_pair</span>(-score[i], i)); <span class="comment">//-score[i]以保证sort排序时由大到小</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">sort</span>(arr.<span class="built_in">begin</span>(), arr.<span class="built_in">end</span>());<span class="comment">//根据arr[index].first的大小排序</span></span><br><span class="line">        <span class="function">vector&lt;string&gt; <span class="title">res</span><span class="params">(n)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i &lt; <span class="number">3</span>) &#123;</span><br><span class="line">                res[arr[i].second] = rankTop[i];<span class="comment">//arr[i].second记录原下标</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                res[arr[i].second] = <span class="built_in">to_string</span>(i + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在C++中，<code>arr</code>可以是任何<u>支持随机访问迭代器的容器</u>类型，例如：</p><ul><li><code>std::vector</code></li><li><code>std::array</code></li><li><code>std::deque</code></li><li><code>std::string</code></li><li>内置数组（例如<code>int arr[5]</code>）</li></ul><p>这些类型都支持<code>begin()</code>和<code>end()</code>成员函数，因此可以作为<code>sort</code>函数的参数。</p><hr><p><code>vector</code>中每个元素都是<code>pair</code>类型时，也可以使用<code>sort</code>函数。因为<code>vector&lt;pair&lt;T1, T2&gt;&gt;</code>支持随机访问迭代器，所以可以直接作为<code>sort</code>函数的参数,排序默认是按照<code>pair</code>的<mark>第一个</mark>元素进行比较的。如果第一个元素相等，则会比较第二个元素。</p><hr><p>法二：使用map(不是unordered_map),它能够实现自主排序</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;string&gt; <span class="title">findRelativeRanks</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; score)</span> </span>&#123;</span><br><span class="line">        map&lt;<span class="type">int</span>, <span class="type">int</span>, greater&lt;<span class="type">int</span>&gt;&gt; mp; <span class="comment">//由大到小,看第一个int</span></span><br><span class="line">        <span class="type">int</span> n = score.<span class="built_in">size</span>();</span><br><span class="line">        string rankTop[<span class="number">3</span>] = &#123;<span class="string">&quot;Gold Medal&quot;</span>, <span class="string">&quot;Silver Medal&quot;</span>, <span class="string">&quot;Bronze Medal&quot;</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            mp[score[i]] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function">vector&lt;string&gt; <span class="title">res</span><span class="params">(n)</span></span>;</span><br><span class="line">        <span class="keyword">auto</span> it = mp.<span class="built_in">begin</span>(); <span class="comment">// it是迭代器</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i &lt; <span class="number">3</span>) &#123;</span><br><span class="line">                res[(*it).second] = rankTop[i];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                res[(*it).second] = <span class="built_in">to_string</span>(i + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            it++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>法三：使用set,方法与使用map类似</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;string&gt; <span class="title">findRelativeRanks</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; score)</span> </span>&#123;</span><br><span class="line">        set&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;, greater&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt;&gt; s; <span class="comment">//由大到小</span></span><br><span class="line">        <span class="type">int</span> n = score.<span class="built_in">size</span>();</span><br><span class="line">        string rankTop[<span class="number">3</span>] = &#123;<span class="string">&quot;Gold Medal&quot;</span>, <span class="string">&quot;Silver Medal&quot;</span>, <span class="string">&quot;Bronze Medal&quot;</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            s.<span class="built_in">emplace</span>(score[i], i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function">vector&lt;string&gt; <span class="title">res</span><span class="params">(n)</span></span>;</span><br><span class="line">        <span class="keyword">auto</span> it = s.<span class="built_in">begin</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i &lt; <span class="number">3</span>) &#123;</span><br><span class="line">                res[(*it).second] = rankTop[i];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                res[(*it).second] = <span class="built_in">to_string</span>(i + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            it++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>值得注意的是:1.set<mark>不存在</mark>类似s[i]的表示形式</p><p>2.向set中加入元素应该使用<code>emplace</code>而非empalce_back</p><p>3.元素形式为pair时，定义应该为<code>set&lt;pair&lt;int, int&gt;, greater&lt;pair&lt;int, int&gt;&gt;&gt; s</code>，这里的排序写法不是greater<int>!<code>greater&lt;int&gt;</code>表示<mark>按照键值</mark>进行降序排序，只有map、vector这种元素对应键值才是固定的，set则随时改变元素的位置，在元素为int类型时greater<int>没有问题，但在pair<int,int>类型时，会出错。</p><p>在这种情况下，我们需要使用<code>greater&lt;pair&lt;int, int&gt;&gt;</code>而不是<code>greater&lt;int&gt;</code>，因为我们想要按照分数降序排列，并且在分数相同时，按照索引升序排列。使用<code>greater&lt;pair&lt;int, int&gt;&gt;</code>可以确保首先按照分数降序排列，然后按照索引升序排列。 </p><hr><p>鸽巢原理：539法二。由鸽巢原理可知，如果 timePoints 的长度超过 1440，那么必然会有两个相同的时间，此时可以直接返回 0.</p><h2 id="6-2-正则表达式：537"><a href="#6-2-正则表达式：537" class="headerlink" title="6-2.正则表达式：537"></a>6-2.正则表达式：537</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">string <span class="title">complexNumberMultiply</span><span class="params">(string num1, string num2)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 定义正则表达式，用于匹配&quot;+&quot;和&quot;i&quot;</span></span><br><span class="line">    <span class="function">regex <span class="title">re</span><span class="params">(<span class="string">&quot;\\+|i&quot;</span>)</span></span>; </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 用正则表达式对复数字符串进行分割，存储到vector中</span></span><br><span class="line">    <span class="function">vector&lt;string&gt; <span class="title">complex1</span><span class="params">(sregex_token_iterator(num1.begin(), num1.end(), re, <span class="number">-1</span>), std::sregex_token_iterator())</span></span>;</span><br><span class="line">    <span class="function">vector&lt;string&gt; <span class="title">complex2</span><span class="params">(sregex_token_iterator(num2.begin(), num2.end(), re, <span class="number">-1</span>), std::sregex_token_iterator())</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将分割后的字符串转换为整数部分和虚数部分</span></span><br><span class="line">    <span class="type">int</span> real1 = <span class="built_in">stoi</span>(complex1[<span class="number">0</span>]);</span><br><span class="line">    <span class="type">int</span> imag1 = <span class="built_in">stoi</span>(complex1[<span class="number">1</span>]);</span><br><span class="line">    <span class="type">int</span> real2 = <span class="built_in">stoi</span>(complex2[<span class="number">0</span>]);</span><br><span class="line">    <span class="type">int</span> imag2 = <span class="built_in">stoi</span>(complex2[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算两个复数的乘积</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">to_string</span>(real1 * real2 - imag1 * imag2) + <span class="string">&quot;+&quot;</span> + <span class="built_in">to_string</span>(real1 * imag2 + imag1 * real2) + <span class="string">&quot;i&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="关于正则"><a href="#关于正则" class="headerlink" title="关于正则"></a>关于正则</h2><p>1.<strong>regex</strong>:<code>regex</code>是C++标准库中用于处理正则表达式的类。它允许你使用正则表达式来进行字符串的匹配、搜索和替换操作。通过使用<code>regex</code>类，你可以在C++中执行与正则表达式相关的操作，例如查找模式匹配、提取部分字符串、替换文本等。需要头文件<code>&lt;regex&gt;</code></p><p>2.<strong>sregex_token_iterator</strong>:<code>sregex_token_iterator</code>是C++标准库中用于在字符串上执行正则表达式分词操作的迭代器。它允许你在字符串中使用正则表达式来进行分词，从而将字符串分割为符合特定模式的子字符串。在上面的代码中，<code>sregex_token_iterator</code>来将复数字符串根据正则表达式分割为整数部分和虚数部分。</p><p><mark>语法</mark>：sregex_token_iterator(起始位置，终止位置，正则, 返回的匹配类型（-1是返回未匹配的部分，即分隔操作）)。</p><p>会返回一个迭代器的首地址，<code>std::sregex_token_iterator()</code>会返回一个end。vector用这两个迭代器构造得到符合匹配的序列</p><p>3.<strong>正则匹配</strong>：<a href="https://www.cnblogs.com/yongchao/p/17165643.html">正则表达式-菜鸟教程 - Theseus‘Ship - 博客园</a></p><p><a href="https://www.cnblogs.com/chen-cs/p/13387914.html">C++ 正则表达式 - Chen沉尘 - 博客园</a></p><p><a href="https://blog.51cto.com/u_12071646/3752288">[笔记]c++基础实践《二》regex正则表达式_51CTO博客_c++ 正则表达式</a></p><p>4.<code>&quot;\\+|i&quot;</code> 这个正则表达式中，<code>\\+</code> 匹配加号 “+”，<code>|</code> 表示或，<code>i</code> 匹配字符 “i”。因此，这个正则表达式可以用于匹配复数字符串中的加号和虚数单位 “i”。</p><p>  <code>&quot;(-?\\d+)/(\\d+)([+-])(-?\\d+)/(\\d+)&quot;</code>表示两个分数相加。</p><ul><li><code>-?</code>：表示匹配一个可选的减号（负号）。<code>-</code> 表示减号，<code>?</code> 表示前面的字符（这里是减号）在文本中可以出现 0 次或 1 次。</li><li><code>\\d+</code>：表示匹配一个或多个数字。<code>\\d</code> 表示一个数字，<code>+</code> 表示前面的元素（这里是数字）可以出现一次或多次。(<code>\\.</code>用来表示小数点)</li><li><code>[+-]</code> 是一个正则表达式模式，用于匹配加号(+)或减号(-)。在正则表达式中，方括号 <code>[]</code> 用于表示一个字符集，其中列出的字符之一都可以匹配成功。因此，<code>[+-]</code> 表示匹配一个加号或减号。</li></ul><p>5.<strong>smatch</strong>:<code>smatch</code> 是 C++ 标准库中的一种数据结构，用于存储正则表达式匹配的结果。它是 <code>std::match_results</code> 类型的别名，用于保存正则表达式匹配的结果和子匹配的位置信息。当使用正则表达式进行匹配时，匹配结果会被存储在 <code>smatch</code> 对象中，可以通过索引或迭代器来访问匹配的子字符串。在T592中，使用 <code>smatch</code> 对象来存储正则表达式匹配的结果，并从中提取分数的分子、分母以及操作符等信息。</p><p>  <code>matches[5].str()</code> 表示从 <code>smatch</code> 对象中获取第 5 个匹配的子字符串，并将其作为 <code>std::string</code> 类型返回。在这种情况下，<code>matches[5]</code> 用于访问正则表达式匹配中的第 5 个捕获组，即第 5 个括号内匹配的内容。在T592中，<code>matches[5].str()</code> 用于获取第 5 个捕获组的字符串表示形式<code>(\\d+)</code>，这个捕获组对应于分数的分母。</p><p>  <code>matches.prefix().str()</code> 表示从 <code>smatch</code> 对象中获取<mark>匹配的子字符串之前</mark>的部分，并将其作为 <code>std::string</code> 类型返回。在这种情况下，<code>matches.prefix()</code> 用于获取匹配子字符串之前的部分，然后通过 <code>str()</code> 方法将其转换为字符串表示形式。</p><p>  <code>matches.suffix().str()</code>则表示之后的那部分。</p><p>6.<strong>用括号将正则表达式分成多组</strong></p><p>在正则表达式中使用括号可以将匹配的部分分组，这样做有几个好处：</p><ul><li><p><strong>提取子匹配</strong>：括号可以将匹配的部分分成多个组，这样可以方便地从整个匹配中提取出我们感兴趣的部分。在这个例子中，括号将分数的分子、分母以及操作符分成了多个组，方便后续的处理。</p></li><li><p><strong>方便后续处理</strong>：分组可以让我们更方便地对匹配到的内容进行后续处理，比如在这个例子中，可以方便地提取出分数的分子和分母，然后进行加减法运算。</p></li><li><p><strong>捕获匹配信息</strong>：分组可以捕获匹配的信息，方便后续的引用。在这个例子中，我们可以使用 <code>matches[1]</code>、<code>matches[2]</code>、<code>matches[3]</code> 等来引用不同的匹配组。</p></li></ul><p>因此，使用括号将正则表达式的部分分成多个组可以使代码更清晰、更易于理解，并且方便后续的处理和提取。</p><p>7.<strong>regex_search</strong>:<code>regex_search(expression, matches, pattern)</code>用于在字符串 <code>expression</code> 中搜索满足正则表达式模式 <code>pattern</code> 的部分，并将匹配的结果存储在 <code>matches</code> 对象中，以便后续的处理和提取。</p><p>8.<strong>regex_match</strong>:<code>regex_match(string code, regex pattern)</code>用于检查字符串是否与给定的正则表达式模式匹配。在这种情况下，它会尝试使用给定的正则表达式模式pattern来匹配输入的代码字符串code，并返回bool值。</p><p>9.<strong>相关学习网站</strong>：<a href="https://r2coding.com/#/?id=正则表达式">Road 2 Coding</a></p><p>正则表达式测试网站：<a href="https://regex101.com/">regex101</a></p><blockquote><p>在对性能敏感的程序中尽量避免使用正则表达式，尽量使用更加高效、更加简单的字符串匹配方案来提高程序性能。在C++中，正则表达式使用<u>ECMAScript语法</u>作为默认语法。这意味着它使用类似于JavaScript和Python的正则表达式语法。但C++的正则表达式与其他语言的正则表达式相比，<u>缺少了独占模式</u>，只有贪婪模式和非贪婪模式(懒惰模式)，这使得匹配所消耗的时间更长。</p><p>ECMAScript语法：<a href="https://zhuanlan.zhihu.com/p/634341574">Modern C++ 学习笔记——正则表达式</a></p><p><a href="https://zhuanlan.zhihu.com/p/38278481/">藏在正则表达式中的陷阱—知乎</a></p><p><a href="https://www.cnblogs.com/lixuwu/p/16201714.html">正则表达式引起的性能下降—博客园</a></p></blockquote><hr><h2 id="正则规则汇总"><a href="#正则规则汇总" class="headerlink" title="正则规则汇总"></a>正则规则汇总</h2><hr><h2 id="6-3-分数加减运算：592"><a href="#6-3-分数加减运算：592" class="headerlink" title="6-3.分数加减运算：592"></a>6-3.分数加减运算：592</h2><p>法一：模拟，遍历整个字符串</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">fractionAddition</span><span class="params">(string expression)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = expression.<span class="built_in">size</span>(), index = <span class="number">0</span>;</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> x = <span class="number">0</span>, y = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (index &lt; n) &#123;</span><br><span class="line">            <span class="comment">//分子</span></span><br><span class="line">            <span class="type">long</span> <span class="type">long</span> x1 = <span class="number">0</span>, sign = <span class="number">1</span>; <span class="comment">// x1记录当前数字,sign记录正负号</span></span><br><span class="line">            <span class="keyword">if</span> (expression[index] == <span class="string">&#x27;-&#x27;</span> || expression[index] == <span class="string">&#x27;+&#x27;</span>) &#123;</span><br><span class="line">                sign = expression[index] == <span class="string">&#x27;-&#x27;</span> ? <span class="number">-1</span> : <span class="number">1</span>;</span><br><span class="line">                index++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> (index &lt; n &amp;&amp; <span class="built_in">isdigit</span>(expression[index])) &#123; <span class="comment">// index&lt;n别忘了</span></span><br><span class="line">                x1 = x1 * <span class="number">10</span> + expression[index] - <span class="string">&#x27;0&#x27;</span>;       <span class="comment">//更新x1</span></span><br><span class="line">                index++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//遇到“/”</span></span><br><span class="line">            x1 *= sign; <span class="comment">//最后把符号带上</span></span><br><span class="line">            index++;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//分母.再次遇到+/-时则结束</span></span><br><span class="line">            <span class="type">long</span> <span class="type">long</span> y1 = <span class="number">0</span>; <span class="comment">//分母不可能有符号，所以无需sign</span></span><br><span class="line">            <span class="keyword">while</span> (index &lt; n &amp;&amp; <span class="built_in">isdigit</span>(expression[index])) &#123;</span><br><span class="line">                y1 = y1 * <span class="number">10</span> + expression[index] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">                index++;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//更新当前数字(再次遇到“+/-”时),x/y+=x1/y1</span></span><br><span class="line">            x = x * y1 + x1 * y;</span><br><span class="line">            y *= y1;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (x == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;0/1&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> g = <span class="built_in">gcd</span>(<span class="built_in">abs</span>(x), y); <span class="comment">//获取最大公约数，用来化简分数</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">to_string</span>(x / g) + <span class="string">&quot;/&quot;</span> + <span class="built_in">to_string</span>(y / g);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>法二：正则匹配,该解法的时间复杂度为$ O(n^2)$，空间复杂度为 $O(1)$,但法一时间复杂度仅为$O(n+log⁡C)$。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;regex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">performOperation</span><span class="params">(<span class="type">int</span> num1, <span class="type">int</span> den1, <span class="type">int</span> num2, <span class="type">int</span> den2, <span class="type">char</span> op)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> numerator, denominator;</span><br><span class="line">        <span class="keyword">if</span> (op == <span class="string">&#x27;+&#x27;</span>) &#123;</span><br><span class="line">            numerator = num1 * den2 + num2 * den1;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            numerator = num1 * den2 - num2 * den1;</span><br><span class="line">        &#125;</span><br><span class="line">        denominator = den1 * den2;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">toLowestTerms</span>(numerator, denominator);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">string <span class="title">toLowestTerms</span><span class="params">(<span class="type">int</span> numerator, <span class="type">int</span> denominator)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> divisor = <span class="built_in">gcd</span>(<span class="built_in">abs</span>(numerator), <span class="built_in">abs</span>(denominator));</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">to_string</span>(numerator / divisor) + <span class="string">&quot;/&quot;</span> +</span><br><span class="line">               <span class="built_in">to_string</span>(denominator / divisor);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">string <span class="title">fractionAddition</span><span class="params">(string expression)</span> </span>&#123;</span><br><span class="line">        <span class="function">regex <span class="title">pattern</span><span class="params">(<span class="string">&quot;(-?\\d+)/(\\d+)([+-])(-?\\d+)/(\\d+)&quot;</span>)</span></span>;</span><br><span class="line">        smatch matches;</span><br><span class="line">        <span class="keyword">while</span> (<span class="built_in">regex_search</span>(expression, matches, pattern)) &#123;</span><br><span class="line">            <span class="type">int</span> num1 = std::<span class="built_in">stoi</span>(matches[<span class="number">1</span>].<span class="built_in">str</span>());</span><br><span class="line">            <span class="type">int</span> den1 = std::<span class="built_in">stoi</span>(matches[<span class="number">2</span>].<span class="built_in">str</span>());</span><br><span class="line">            <span class="type">int</span> num2 = std::<span class="built_in">stoi</span>(matches[<span class="number">4</span>].<span class="built_in">str</span>());</span><br><span class="line">            <span class="type">int</span> den2 = std::<span class="built_in">stoi</span>(matches[<span class="number">5</span>].<span class="built_in">str</span>());</span><br><span class="line">            <span class="type">char</span> op = matches[<span class="number">3</span>].<span class="built_in">str</span>()[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">            expression = matches.<span class="built_in">prefix</span>().<span class="built_in">str</span>() +</span><br><span class="line">                         <span class="built_in">performOperation</span>(num1, den1, num2, den2, op) +</span><br><span class="line">                         matches.<span class="built_in">suffix</span>().<span class="built_in">str</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> expression;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>关于最大公约数gcd和最小公倍数lcm:</p><p>(Greatest Common Divisor、Least Common Multiple)</p><p>需要的头文件为<code>&lt;numeric&gt;</code></p><h2 id="6-4-分数到小数-分数乘除运算-：166"><a href="#6-4-分数到小数-分数乘除运算-：166" class="headerlink" title="6-4.分数到小数(分数乘除运算)：166"></a>6-4.分数到小数(分数乘除运算)：166</h2><p>两个整数相除，结果一定是有理数，一定有循环。使用了哈希表存储竖式模拟过程中出现过的余数。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">fractionToDecimal</span><span class="params">(<span class="type">int</span> numerator, <span class="type">int</span> denominator)</span> </span>&#123;</span><br><span class="line">        <span class="type">long</span> numeratorLong = numerator;</span><br><span class="line">        <span class="type">long</span> denominatorLong = denominator;</span><br><span class="line">        <span class="keyword">if</span> (numeratorLong % denominatorLong == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">to_string</span>(numeratorLong / denominatorLong);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        string ans;</span><br><span class="line">        <span class="keyword">if</span> (numeratorLong &lt; <span class="number">0</span> ^ denominatorLong &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            ans.<span class="built_in">push_back</span>(<span class="string">&#x27;-&#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 整数部分</span></span><br><span class="line">        numeratorLong = <span class="built_in">abs</span>(numeratorLong);</span><br><span class="line">        denominatorLong = <span class="built_in">abs</span>(denominatorLong);</span><br><span class="line">        <span class="type">long</span> integerPart = numeratorLong / denominatorLong;</span><br><span class="line">        ans += <span class="built_in">to_string</span>(integerPart);</span><br><span class="line">        ans.<span class="built_in">push_back</span>(<span class="string">&#x27;.&#x27;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 小数部分</span></span><br><span class="line">        string fractionPart;</span><br><span class="line">        unordered_map&lt;<span class="type">long</span>, <span class="type">int</span>&gt; remainderIndexMap;</span><br><span class="line">        <span class="type">long</span> remainder = numeratorLong % denominatorLong;</span><br><span class="line">        <span class="type">int</span> index = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (remainder != <span class="number">0</span> &amp;&amp; !remainderIndexMap.<span class="built_in">count</span>(remainder)) &#123;</span><br><span class="line">            remainderIndexMap[remainder] = index;</span><br><span class="line">            remainder *= <span class="number">10</span>;</span><br><span class="line">            fractionPart += <span class="built_in">to_string</span>(remainder / denominatorLong);</span><br><span class="line">            remainder %= denominatorLong;</span><br><span class="line">            index++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (remainder != <span class="number">0</span>) &#123; <span class="comment">// 有循环节</span></span><br><span class="line">            <span class="type">int</span> insertIndex = remainderIndexMap[remainder];</span><br><span class="line">            fractionPart = fractionPart.<span class="built_in">substr</span>(<span class="number">0</span>,insertIndex) + <span class="string">&#x27;(&#x27;</span> + fractionPart.<span class="built_in">substr</span>(insertIndex);</span><br><span class="line">            fractionPart.<span class="built_in">push_back</span>(<span class="string">&#x27;)&#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        ans += fractionPart;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="6-5-求解方程：640"><a href="#6-5-求解方程：640" class="headerlink" title="6-5.求解方程：640"></a>6-5.求解方程：640</h2><p><img src="https://s2.loli.net/2024/01/23/NfTy7ME3SJHCcKV.png" alt=""></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">solveEquation</span><span class="params">(string equation)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> index = <span class="number">0</span>, n = equation.<span class="built_in">size</span>(), sign1 = <span class="number">1</span>; <span class="comment">// sign1记录等式右边系数</span></span><br><span class="line">        <span class="type">int</span> factor = <span class="number">0</span>, val = <span class="number">0</span>; <span class="comment">//记录变量的系数，常量值</span></span><br><span class="line">        <span class="keyword">while</span> (index &lt; n) &#123;</span><br><span class="line">            <span class="keyword">if</span> (equation[index] == <span class="string">&#x27;=&#x27;</span>) &#123;</span><br><span class="line">                sign1 = <span class="number">-1</span>; <span class="comment">//等式右边默认系数为负</span></span><br><span class="line">                index++;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">int</span> sign2 = sign1, number = <span class="number">0</span>;</span><br><span class="line">            <span class="type">bool</span> valid = <span class="literal">false</span>; <span class="comment">//记录number是否有效</span></span><br><span class="line">            <span class="keyword">if</span> (equation[index] == <span class="string">&#x27;-&#x27;</span> ||</span><br><span class="line">                equation[index] == <span class="string">&#x27;+&#x27;</span>) &#123; <span class="comment">//去掉前面的符号</span></span><br><span class="line">                sign2 = (equation[index] == <span class="string">&#x27;-&#x27;</span>) ? -sign1 : sign1;</span><br><span class="line">                index++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> (index &lt; n &amp;&amp; <span class="built_in">isdigit</span>(equation[index])) &#123;</span><br><span class="line">                number = number * <span class="number">10</span> + equation[index] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">                index++;</span><br><span class="line">                valid = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (index &lt; n &amp;&amp; equation[index] == <span class="string">&#x27;x&#x27;</span>) &#123; <span class="comment">//变量</span></span><br><span class="line">                factor += valid ? sign2 * number : sign2;</span><br><span class="line">                index++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123; <span class="comment">//数值</span></span><br><span class="line">                val += sign2 * number;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!factor) &#123;  <span class="comment">//factor * x + val = 0</span></span><br><span class="line">            <span class="keyword">return</span> val == <span class="number">0</span> ? <span class="string">&quot;Infinite solutions&quot;</span> : <span class="string">&quot;No solution&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;x=&quot;</span> + <span class="built_in">to_string</span>(-val / factor);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="6-6-外观数列：38"><a href="#6-6-外观数列：38" class="headerlink" title="6-6.外观数列：38"></a>6-6.外观数列：38</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">countAndSay</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        string prev = <span class="string">&quot;1&quot;</span>; <span class="comment">//记录下前一个字符串是什么，默认为第一个字符串&quot;1&quot;</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            string curr = <span class="string">&quot;&quot;</span>;</span><br><span class="line">            <span class="type">int</span> start = <span class="number">0</span>, pos = <span class="number">0</span>;<span class="comment">//双指针</span></span><br><span class="line">            <span class="keyword">while</span> (pos &lt; prev.<span class="built_in">size</span>()) &#123;</span><br><span class="line">                <span class="keyword">while</span> (pos &lt; prev.<span class="built_in">size</span>() &amp;&amp; prev[pos] == prev[start]) &#123;</span><br><span class="line">                    pos++;</span><br><span class="line">                &#125;</span><br><span class="line">                curr += <span class="built_in">to_string</span>(pos - start) + prev[start];</span><br><span class="line">                start = pos; <span class="comment">//更新start</span></span><br><span class="line">            &#125;</span><br><span class="line">            prev = curr; <span class="comment">//更新prev为下一个字符串</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> prev;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>6-6.自定义字符串转换整数：8</p><p>法一：依次遍历</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">strToInt</span><span class="params">(string str)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (str.<span class="built_in">empty</span>()) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> index = <span class="number">0</span>, n = str.<span class="built_in">size</span>(), sign = <span class="number">1</span>, res = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 处理前置空格</span></span><br><span class="line">        <span class="keyword">while</span> (index &lt; n &amp;&amp; str[index] == <span class="string">&#x27; &#x27;</span>) &#123;</span><br><span class="line">            ++index;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 处理符号，应该继续向后，因为+-12的结果应为0</span></span><br><span class="line">        <span class="keyword">if</span> (index &lt; n &amp;&amp; (str[index] == <span class="string">&#x27;+&#x27;</span> || str[index] == <span class="string">&#x27;-&#x27;</span>)) &#123;</span><br><span class="line">            sign = str[index++] == <span class="string">&#x27;+&#x27;</span> ? <span class="number">1</span> : <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 处理数字</span></span><br><span class="line">        <span class="keyword">while</span> (index &lt; n &amp;&amp; <span class="built_in">isdigit</span>(str[index])) &#123;</span><br><span class="line">            <span class="type">int</span> digit = str[index++] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">            <span class="comment">// 判断是否溢出</span></span><br><span class="line">            <span class="keyword">if</span> (res &gt; (INT_MAX - digit) / <span class="number">10</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> sign == <span class="number">1</span> ? INT_MAX : INT_MIN;</span><br><span class="line">            &#125;</span><br><span class="line">            res = res * <span class="number">10</span> + digit;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res * sign;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>本题关键：处理整数溢出的情况，原题：如果整数数超过 32 位有符号整数范围 $[−2^{31},  2^{31} − 1]$ ，需要截断这个整数，使其保持在这个范围内。具体来说，小于 $2^{31}$ 的整数应该被固定为 $2^{31}$ ，大于 $2^{31}− 1$ 的整数应该被固定为 $2^{31}− 1 $。</p><hr><p>法二：自动机</p><p><img src="https://s2.loli.net/2024/01/24/TAa7d6Hgjy4iYqC.png" alt=""></p><p><img src="https://s2.loli.net/2024/01/24/QxOmc2DHh3U51nf.png" alt=""></p><p><img src="https://s2.loli.net/2024/01/24/d13ieFt2Aa4SQIX.png" alt=""></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Automaton</span> &#123;</span><br><span class="line">    string state = <span class="string">&quot;start&quot;</span>;</span><br><span class="line">    unordered_map&lt;string, vector&lt;string&gt;&gt; table = &#123;</span><br><span class="line">        &#123;<span class="string">&quot;start&quot;</span>, &#123;<span class="string">&quot;start&quot;</span>, <span class="string">&quot;signed&quot;</span>, <span class="string">&quot;in_number&quot;</span>, <span class="string">&quot;end&quot;</span>&#125;&#125;,</span><br><span class="line">        &#123;<span class="string">&quot;signed&quot;</span>, &#123;<span class="string">&quot;end&quot;</span>, <span class="string">&quot;end&quot;</span>, <span class="string">&quot;in_number&quot;</span>, <span class="string">&quot;end&quot;</span>&#125;&#125;,</span><br><span class="line">        &#123;<span class="string">&quot;in_number&quot;</span>, &#123;<span class="string">&quot;end&quot;</span>, <span class="string">&quot;end&quot;</span>, <span class="string">&quot;in_number&quot;</span>, <span class="string">&quot;end&quot;</span>&#125;&#125;,</span><br><span class="line">        &#123;<span class="string">&quot;end&quot;</span>, &#123;<span class="string">&quot;end&quot;</span>, <span class="string">&quot;end&quot;</span>, <span class="string">&quot;end&quot;</span>, <span class="string">&quot;end&quot;</span>&#125;&#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">get_col</span><span class="params">(<span class="type">char</span> c)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">isspace</span>(c)) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="string">&#x27;+&#x27;</span> <span class="keyword">or</span> c == <span class="string">&#x27;-&#x27;</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">isdigit</span>(c)) <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">3</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> sign = <span class="number">1</span>;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> ans = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">get</span><span class="params">(<span class="type">char</span> c)</span> </span>&#123;</span><br><span class="line">        state = table[state][<span class="built_in">get_col</span>(c)];</span><br><span class="line">        <span class="keyword">if</span> (state == <span class="string">&quot;in_number&quot;</span>) &#123;</span><br><span class="line">            ans = ans * <span class="number">10</span> + c - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">            ans = sign == <span class="number">1</span> ? <span class="built_in">min</span>(ans, (<span class="type">long</span> <span class="type">long</span>)INT_MAX) : <span class="built_in">min</span>(ans, -(<span class="type">long</span> <span class="type">long</span>)INT_MIN);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (state == <span class="string">&quot;signed&quot;</span>)</span><br><span class="line">            sign = c == <span class="string">&#x27;+&#x27;</span> ? <span class="number">1</span> : <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">myAtoi</span><span class="params">(string str)</span> </span>&#123;</span><br><span class="line">        Automaton automaton;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">char</span> c : str)</span><br><span class="line">            automaton.<span class="built_in">get</span>(c);</span><br><span class="line">        <span class="keyword">return</span> automaton.sign * automaton.ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="关于自动机"><a href="#关于自动机" class="headerlink" title="关于自动机"></a>关于自动机</h2><p>在C++中，自动机通常指的是有限状态自动机（Finite State Machine，FSM），它是一种抽象的数学模型，用于描述系统的状态及状态之间的转移。</p><p>一个简单的有限状态自动机由以下几部分组成：</p><ul><li>一组状态：描述系统可能处于的状态。</li><li>一组转移：描述状态之间的转移条件。</li><li>初始状态：描述系统的初始状态。</li><li>终止状态：描述系统的结束状态。</li></ul><p>在C++中，我们可以使用类和枚举类型来实现有限状态自动机。以下是一个简单的示例，演示了一个有限状态自动机，用于模拟一个简单的灯的状态变化。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 枚举类型表示灯的状态</span></span><br><span class="line"><span class="keyword">enum class</span> <span class="title class_">LightState</span> &#123;</span><br><span class="line">    OFF,</span><br><span class="line">    ON,</span><br><span class="line">    DIM</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LightStateMachine</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    LightState state;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">LightStateMachine</span>() : <span class="built_in">state</span>(LightState::OFF) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">transition</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">switch</span> (state) &#123;</span><br><span class="line">            <span class="keyword">case</span> LightState::OFF:</span><br><span class="line">                state = LightState::ON;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> LightState::ON:</span><br><span class="line">                state = LightState::DIM;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> LightState::DIM:</span><br><span class="line">                state = LightState::OFF;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">LightState <span class="title">getState</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> state;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    LightStateMachine light;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Initial state: &quot;</span> &lt;&lt; <span class="built_in">static_cast</span>&lt;<span class="type">int</span>&gt;(light.<span class="built_in">getState</span>()) &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    light.<span class="built_in">transition</span>();</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;State after transition: &quot;</span> &lt;&lt; <span class="built_in">static_cast</span>&lt;<span class="type">int</span>&gt;(light.<span class="built_in">getState</span>()) &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    light.<span class="built_in">transition</span>();</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;State after transition: &quot;</span> &lt;&lt; <span class="built_in">static_cast</span>&lt;<span class="type">int</span>&gt;(light.<span class="built_in">getState</span>()) &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面的示例中，我们定义了一个简单的有限状态自动机 <code>LightStateMachine</code>，用于模拟灯的状态变化。通过调用 <code>transition</code> 方法，状态机会根据当前状态进行转移，并可以通过 <code>getState</code> 方法获取当前状态。</p><h2 id="6-6-整数转罗马数字：12"><a href="#6-6-整数转罗马数字：12" class="headerlink" title="6-6.整数转罗马数字：12"></a>6-6.整数转罗马数字：12</h2><p>法一：模拟</p><p>注意，这里<mark>不能</mark>用unordered_map，因为其遍历的时候是乱序的，应该用能设置排列规则的map，用<code>greater&lt;int&gt;</code>保证由大到小遍历。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">const</span> map&lt;<span class="type">int</span>, string, greater&lt;<span class="type">int</span>&gt;&gt; valueSymbols = &#123;</span><br><span class="line">        &#123;<span class="number">1000</span>, <span class="string">&quot;M&quot;</span>&#125;,</span><br><span class="line">        &#123;<span class="number">900</span>,  <span class="string">&quot;CM&quot;</span>&#125;,</span><br><span class="line">        &#123;<span class="number">500</span>,  <span class="string">&quot;D&quot;</span>&#125;,</span><br><span class="line">        &#123;<span class="number">400</span>,  <span class="string">&quot;CD&quot;</span>&#125;,</span><br><span class="line">        &#123;<span class="number">100</span>,  <span class="string">&quot;C&quot;</span>&#125;,</span><br><span class="line">        &#123;<span class="number">90</span>,   <span class="string">&quot;XC&quot;</span>&#125;,</span><br><span class="line">        &#123;<span class="number">50</span>,   <span class="string">&quot;L&quot;</span>&#125;,</span><br><span class="line">        &#123;<span class="number">40</span>,   <span class="string">&quot;XL&quot;</span>&#125;,</span><br><span class="line">        &#123;<span class="number">10</span>,   <span class="string">&quot;X&quot;</span>&#125;,</span><br><span class="line">        &#123;<span class="number">9</span>,    <span class="string">&quot;IX&quot;</span>&#125;,</span><br><span class="line">        &#123;<span class="number">5</span>,    <span class="string">&quot;V&quot;</span>&#125;,</span><br><span class="line">        &#123;<span class="number">4</span>,    <span class="string">&quot;IV&quot;</span>&#125;,</span><br><span class="line">        &#123;<span class="number">1</span>,    <span class="string">&quot;I&quot;</span>&#125;,</span><br><span class="line">    &#125;;</span><br><span class="line"><span class="comment">//使用了greater&lt;int&gt;才能保证遍历顺序是按照当前1000-&gt;500-&gt;...</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">intToRoman</span><span class="params">(<span class="type">int</span> num)</span> </span>&#123;</span><br><span class="line">        string roman;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; [value, symbol] : valueSymbols) &#123; <span class="comment">//注意auto前面这里需要加上const</span></span><br><span class="line">            <span class="keyword">while</span> (num &gt;= value) &#123;</span><br><span class="line">                num -= value;</span><br><span class="line">                roman += symbol;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (num == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> roman;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>也可以直接使用数组，其中每个元素均为pair类型。遍历数组的顺序并不是乱序。pair数组除了第一行的定义以外，其他代码几乎没有区别。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> pair&lt;<span class="type">int</span>, string&gt; valueSymbols[] = &#123;</span><br><span class="line">    &#123;<span class="number">1000</span>, <span class="string">&quot;M&quot;</span>&#125;,</span><br><span class="line">    &#123;<span class="number">900</span>,  <span class="string">&quot;CM&quot;</span>&#125;,</span><br><span class="line">    &#123;<span class="number">500</span>,  <span class="string">&quot;D&quot;</span>&#125;,</span><br><span class="line">    &#123;<span class="number">400</span>,  <span class="string">&quot;CD&quot;</span>&#125;,</span><br><span class="line">    &#123;<span class="number">100</span>,  <span class="string">&quot;C&quot;</span>&#125;,</span><br><span class="line">    &#123;<span class="number">90</span>,   <span class="string">&quot;XC&quot;</span>&#125;,</span><br><span class="line">    &#123;<span class="number">50</span>,   <span class="string">&quot;L&quot;</span>&#125;,</span><br><span class="line">    &#123;<span class="number">40</span>,   <span class="string">&quot;XL&quot;</span>&#125;,</span><br><span class="line">    &#123;<span class="number">10</span>,   <span class="string">&quot;X&quot;</span>&#125;,</span><br><span class="line">    &#123;<span class="number">9</span>,    <span class="string">&quot;IX&quot;</span>&#125;,</span><br><span class="line">    &#123;<span class="number">5</span>,    <span class="string">&quot;V&quot;</span>&#125;,</span><br><span class="line">    &#123;<span class="number">4</span>,    <span class="string">&quot;IV&quot;</span>&#125;,</span><br><span class="line">    &#123;<span class="number">1</span>,    <span class="string">&quot;I&quot;</span>&#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">intToRoman</span><span class="params">(<span class="type">int</span> num)</span> </span>&#123;</span><br><span class="line">        string roman;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span> &amp;[value, symbol] : valueSymbols) &#123;</span><br><span class="line">            <span class="keyword">while</span> (num &gt;= value) &#123;</span><br><span class="line">                num -= value;</span><br><span class="line">                roman += symbol;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (num == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> roman;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>法二：硬编码数字</p><p><img src="https://s2.loli.net/2024/01/24/wqVmOtoUaXb4H7A.png" alt=""></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> string thousands[] = &#123;<span class="string">&quot;&quot;</span>, <span class="string">&quot;M&quot;</span>, <span class="string">&quot;MM&quot;</span>, <span class="string">&quot;MMM&quot;</span>&#125;;</span><br><span class="line"><span class="type">const</span> string hundreds[]  = &#123;<span class="string">&quot;&quot;</span>, <span class="string">&quot;C&quot;</span>, <span class="string">&quot;CC&quot;</span>, <span class="string">&quot;CCC&quot;</span>, <span class="string">&quot;CD&quot;</span>, <span class="string">&quot;D&quot;</span>, <span class="string">&quot;DC&quot;</span>, <span class="string">&quot;DCC&quot;</span>, <span class="string">&quot;DCCC&quot;</span>, <span class="string">&quot;CM&quot;</span>&#125;;</span><br><span class="line"><span class="type">const</span> string tens[]      = &#123;<span class="string">&quot;&quot;</span>, <span class="string">&quot;X&quot;</span>, <span class="string">&quot;XX&quot;</span>, <span class="string">&quot;XXX&quot;</span>, <span class="string">&quot;XL&quot;</span>, <span class="string">&quot;L&quot;</span>, <span class="string">&quot;LX&quot;</span>, <span class="string">&quot;LXX&quot;</span>, <span class="string">&quot;LXXX&quot;</span>, <span class="string">&quot;XC&quot;</span>&#125;;</span><br><span class="line"><span class="type">const</span> string ones[]      = &#123;<span class="string">&quot;&quot;</span>, <span class="string">&quot;I&quot;</span>, <span class="string">&quot;II&quot;</span>, <span class="string">&quot;III&quot;</span>, <span class="string">&quot;IV&quot;</span>, <span class="string">&quot;V&quot;</span>, <span class="string">&quot;VI&quot;</span>, <span class="string">&quot;VII&quot;</span>, <span class="string">&quot;VIII&quot;</span>, <span class="string">&quot;IX&quot;</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">intToRoman</span><span class="params">(<span class="type">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> thousands[num / <span class="number">1000</span>] + hundreds[num % <span class="number">1000</span> / <span class="number">100</span>] + tens[num % <span class="number">100</span> / <span class="number">10</span>] + ones[num % <span class="number">10</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="6-7-比较版本号：165"><a href="#6-7-比较版本号：165" class="headerlink" title="6-7.比较版本号：165"></a>6-7.比较版本号：165</h2><p>注意其中细节即可，双指针法，尽可能简化代码</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">compareVersion</span><span class="params">(string version1, string version2)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> pos1 = <span class="number">0</span>, pos2 = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> n1 = version1.<span class="built_in">length</span>(), n2 = version2.<span class="built_in">length</span>();</span><br><span class="line">        <span class="keyword">while</span> (pos1 &lt; n1 || pos2 &lt; n2) &#123; <span class="comment">//用或，需要把两个都遍历完</span></span><br><span class="line">            <span class="type">long</span> <span class="type">int</span> v1 = <span class="number">0</span>, v2 = <span class="number">0</span>; <span class="comment">//版本号可能是&quot;1.2147483647&quot;</span></span><br><span class="line">            <span class="keyword">while</span> (pos1 &lt; n1 &amp;&amp; version1[pos1] != <span class="string">&#x27;.&#x27;</span>) &#123;</span><br><span class="line">                v1 = v1 * <span class="number">10</span> + version1[pos1++] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> (pos2 &lt; n2 &amp;&amp; version2[pos2] != <span class="string">&#x27;.&#x27;</span>) &#123;</span><br><span class="line">                v2 = v2 * <span class="number">10</span> + version2[pos2++] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (v1 != v2) &#123;</span><br><span class="line">                <span class="keyword">return</span> v1 &gt; v2 ? <span class="number">1</span> : <span class="number">-1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            pos1++;</span><br><span class="line">            pos2++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><code>stoi(stringVar)</code>中，stringVar不能为空。</p><h2 id="6-8-神奇字符串：481"><a href="#6-8-神奇字符串：481" class="headerlink" title="6-8.神奇字符串：481"></a>6-8.神奇字符串：481</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">magicalString</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        string s = <span class="string">&quot;\1\2\2&quot;</span>; <span class="comment">//需要用反斜杠</span></span><br><span class="line">        <span class="comment">// 值就是 1,2,2，这样就可以直接用 s[i] 当作个数</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; s.<span class="built_in">length</span>() &lt; n; ++i) &#123;</span><br><span class="line">            s += <span class="built_in">string</span>(s[i], s.<span class="built_in">back</span>() ^ <span class="number">3</span>);</span><br><span class="line">            <span class="comment">// 1^3=2, 2^3=1，这样就能在 1 和 2 之间转换</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">count</span>(s.<span class="built_in">begin</span>(), s.<span class="built_in">begin</span>() + n, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ol><li><p><code>string s = &quot;\1\2\2&quot;;</code>和<code>string s = &quot;122&quot;;</code>的区别:在C++中，字符串字面值中的转义序列是以反斜杠（<code>\</code>）开头的字符序列。<code>&quot;\1\2\2&quot;</code> 和 <code>&quot;122&quot;</code> 的区别在于<mark>转义序列</mark>的使用。<code>&quot;\1\2\2&quot;</code>：这个字符串包含了转义序列 <code>\1</code>、<code>\2</code> 和 <code>\2</code>。这些是八进制转义序列，代表特定的ASCII字符。具体而言，<code>\1</code> 对应ASCII值1，<code>\2</code> 对应ASCII值2。因此，这个字符串实际上是包含了三个字符，分别是1、2和2。<code>&quot;122&quot;</code>这个字符串没有使用八进制转义序列，它只包含了三个字符，分别是’1’、’2’和’2’。前者的s[i]可以直接用来当做个数。</p></li><li><p><code>s += string(s[i], s.back()^3)</code>：<code>string(int count,char value);</code>这是表示s加上一个包含value字符，且长度为count的字符串。比如<code>s+=string(&#39;\2&#39;, 1)</code>就是<code>s+=&quot;11&quot;</code>,常规写法是<code>string(2, &#39;1&#39;)</code>;</p></li><li><p><code>s.back()^3</code>:s.back()就是字符串s的最后一个字符。<code>^3</code>用于实现1与2的不断切换，1^3=2, 2^3=1.(二进制运算)</p></li><li><p><code>count(s.begin(), s.begin()+n, 1)</code>:计数特定区间内有多少个值为1的字符。模板<code>count(T.begin(),T.end(),value)</code>。</p></li></ol><hr><p>现在不用反斜杠：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">magicalString</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        string s = <span class="string">&quot;122&quot;</span>; <span class="comment">//不用反斜杠</span></span><br><span class="line">        <span class="comment">// 这样就不可以直接用 s[i] 当作个数</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; s.<span class="built_in">length</span>() &lt; n; ++i) &#123;</span><br><span class="line">            s += <span class="built_in">string</span>(s[i]-<span class="string">&#x27;0&#x27;</span>, (s.<span class="built_in">back</span>()-<span class="string">&#x27;0&#x27;</span>) ^ <span class="number">3</span> +<span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">            <span class="comment">// 1^3=2, 2^3=1，这样就能在 1 和 2 之间转换</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">count</span>(s.<span class="built_in">begin</span>(), s.<span class="built_in">begin</span>() + n, <span class="string">&#x27;1&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> leetcode刷题笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> leetcode </tag>
            
            <tag> string </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2.0字符串篇</title>
      <link href="/posts/10e5d792.html"/>
      <url>/posts/10e5d792.html</url>
      
        <content type="html"><![CDATA[<h1 id="关于string和cstring"><a href="#关于string和cstring" class="headerlink" title="关于string和cstring"></a>关于string和cstring</h1><p><code>&lt;string&gt;</code> 和 <code>&lt;cstring&gt;</code> 是 C++ 中的两个不同的头文件，它们有不同的作用和功能：</p><ul><li><p><code>&lt;string&gt;</code> 头文件包含了 C++ 标准库中的字符串类 <code>std::string</code>，以及与字符串相关的一些函数和操作符重载。这个头文件用于处理 C++ 中的字符串操作，提供了更多的字符串处理功能和便利。</p></li><li><p><code>&lt;cstring&gt;</code> 头文件是 C 标准库中的头文件，其中定义了一些 C 语言字符串操作的函数，比如字符串复制、连接、比较等。在 C++ 中，这些函数通常被包含在 <code>std</code> 命名空间中，比如 <code>std::strcpy</code>、<code>std::strcat</code> 等。</p></li></ul><p>总的来说，<code>&lt;string&gt;</code> 更适合用于 C++ 中的字符串操作，而 <code>&lt;cstring&gt;</code> 则更适合用于 C 风格的字符串操作。</p><hr><h1 id="关于string包含的常见函数"><a href="#关于string包含的常见函数" class="headerlink" title="关于string包含的常见函数"></a>关于string包含的常见函数</h1><ul><li><code>length()</code> 或 <code>size()</code>: 返回字符串的长度。</li><li><code>append(str)</code>: 在字符串末尾添加另一个字符串。</li><li><code>insert(pos, str)</code>: 在指定位置插入另一个字符串。</li><li><code>erase(pos, len)</code>: 从指定位置删除指定长度的字符。</li><li><code>find(str)</code>: 查找字符串中是否包含指定的子字符串。</li><li><code>substr(pos, len)</code>: 返回从指定位置开始的指定长度的子字符串。</li><li><code>compare(str)</code>: 比较两个字符串。</li><li><code>replace(pos, len, str)</code>: 用另一个字符串替换指定位置的指定长度的字符。</li><li><code>push_back()、pop_back()</code>:类似数组的操作方式，对字符串依然使用。</li></ul><hr><p>异或：<code>^</code>.运算规则：<code>N^0=N;N^N=0;</code></p><p>判断大小写：<code>islower</code>、<code>isupper</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">detectCapitalUse</span><span class="params">(string word)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (word.<span class="built_in">size</span>() &gt;= <span class="number">2</span> &amp;&amp; <span class="built_in">islower</span>(word[<span class="number">0</span>]) &amp;&amp; <span class="built_in">isupper</span>(word[<span class="number">1</span>])) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;<span class="comment">//排除形如uSA的情况</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt; word.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">islower</span>(word[i]) ^ <span class="built_in">islower</span>(word[<span class="number">1</span>])) &#123;</span><br><span class="line">                <span class="comment">//除了第一个字母以外的字母大小写不一致</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>转为小写：<code>tolower</code>/转为大写:<code>toupper</code>(注意，返回值类型为int。可以写作<code>char ch = tolower(c);</code>或者<code>auto ch = char(tolower(c));</code>)。如果是数字，则无变化，<mark>可以接受数字</mark></p><p>检查一个字符是否是字母或数字:<code>isalnum</code>,需要头文件<code>&lt;cctype&gt;</code>.如果判断是否为字母:<code>isalpha</code>,判断是否为数字:<code>isdigit</code>.也是需要头文件<code>&lt;cctype&gt;</code></p><p>定义b为a的逆序字符串：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">string b(a.rbgin(),a.rend());</span><br></pre></td></tr></table></figure><h1 id="1-回文串的定义"><a href="#1-回文串的定义" class="headerlink" title="1.回文串的定义"></a>1.回文串的定义</h1><h2 id="验证回文串：125"><a href="#验证回文串：125" class="headerlink" title="验证回文串：125"></a>验证回文串：125</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isPalindrome</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        string schange;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">char</span> ch : s) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">isalnum</span>(ch)) &#123;</span><br><span class="line">                schange += <span class="built_in">tolower</span>(ch); <span class="comment">//防止大小写干扰之后的相等判断</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function">string <span class="title">schangeReverse</span><span class="params">(schange.rbegin(), schange.rend())</span></span>;</span><br><span class="line">        <span class="keyword">return</span> schange == schangeReverse;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>空间优化:使用双指针，在原字符串上直接判断</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isPalindrome</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n=s.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> left=<span class="number">0</span>,right=n<span class="number">-1</span>;</span><br><span class="line">        <span class="comment">//每次将指针移到下一个字母字符或数字字符，再判断这两个指针指向的字符是否相同</span></span><br><span class="line">        <span class="keyword">while</span>(left&lt;right)&#123;</span><br><span class="line">            <span class="keyword">while</span>(left&lt;right&amp;&amp;!<span class="built_in">isalnum</span>(s[left]))&#123;</span><br><span class="line">                ++left;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span>(left&lt;right&amp;&amp;!<span class="built_in">isalnum</span>(s[right]))&#123;</span><br><span class="line">                --right;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(left&lt;right)&#123;</span><br><span class="line">                <span class="keyword">if</span>(<span class="built_in">tolower</span>(s[left])!=<span class="built_in">tolower</span>(s[right]))&#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                ++left;</span><br><span class="line">                --right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>取字符串str从索引 0 开始、长度为 index 的子字符串：(注意包括的是str[0]到str[i-1]的部分！)</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">str.<span class="built_in">substr</span>(<span class="number">0</span>, index);</span><br></pre></td></tr></table></figure><h1 id="2-公共前缀"><a href="#2-公共前缀" class="headerlink" title="2.公共前缀"></a>2.公共前缀</h1><h2 id="最长公共前缀：14"><a href="#最长公共前缀：14" class="headerlink" title="最长公共前缀：14"></a>最长公共前缀：14</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//纵向扫描</span></span><br><span class="line"><span class="comment">//从前往后遍历所有字符串的每一列，比较相同列上的字符是否相同，</span></span><br><span class="line"><span class="comment">//如果相同则继续对下一列进行比较，如果不相同则当前列不再属于公共前缀，</span></span><br><span class="line"><span class="comment">//当前列之前的部分为最长公共前缀。</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">longestCommonPrefix</span><span class="params">(vector&lt;string&gt;&amp; strs)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!strs.<span class="built_in">size</span>()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; strs[<span class="number">0</span>].<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt; strs.<span class="built_in">size</span>(); j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (strs[<span class="number">0</span>][i] != strs[j][i]) &#123;</span><br><span class="line">                    <span class="keyword">return</span> strs[<span class="number">0</span>].<span class="built_in">substr</span>(<span class="number">0</span>, i) ;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> strs[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="3-单词"><a href="#3-单词" class="headerlink" title="3.单词"></a>3.单词</h1><h2 id="判断单词数：434"><a href="#判断单词数：434" class="headerlink" title="判断单词数：434"></a>判断单词数：434</h2><p>关键在于看该字符的<u>前一个</u>字符s[i-1]是否为空(这样可以遍历到所有字符而且不需要额外判断)，而不是看下一个字符s[i+1]是否为空</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">countSegments</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s[i] != <span class="string">&#x27; &#x27;</span> &amp;&amp; (i == <span class="number">0</span> || s[i - <span class="number">1</span>] == <span class="string">&#x27; &#x27;</span>)) &#123;</span><br><span class="line">                <span class="comment">// i==0必须写在s[i-1]前面，否则会溢出</span></span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="4-字符串的反转"><a href="#4-字符串的反转" class="headerlink" title="4.字符串的反转"></a>4.字符串的反转</h1><h2 id="反转字符串s"><a href="#反转字符串s" class="headerlink" title="反转字符串s"></a>反转字符串s</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">reverseString</span><span class="params">(vector&lt;<span class="type">char</span>&gt;&amp; s)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//法一</span></span><br><span class="line">    <span class="type">int</span> n = s.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= n / <span class="number">2</span> - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="built_in">swap</span>(s[i], s[n - <span class="number">1</span> - i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//法二：自带方法</span></span><br><span class="line">    <span class="built_in">reverse</span>(s.<span class="built_in">begin</span>(),s.<span class="built_in">end</span>());</span><br><span class="line">    <span class="comment">//法三：双指针</span></span><br><span class="line">    <span class="type">int</span> n = s.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> left = <span class="number">0</span>, right = n - <span class="number">1</span>; left &lt; right; ++left, --right) &#123;</span><br><span class="line">        <span class="built_in">swap</span>(s[left], s[right]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注：关于min()，两个参数都必须是int类型，而s.size()是unsigned int类型，需要转换！(或者一开始就写成<code>int n=s.size()</code>，然后后面用n代替)</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">reverse</span>(s.<span class="built_in">begin</span>() + i, s.<span class="built_in">begin</span>() + <span class="built_in">min</span>(i + k, (<span class="type">int</span>)s.<span class="built_in">size</span>()));</span><br></pre></td></tr></table></figure><p>反转字符串中的各个单词：557(进阶：包括前置后置以后中间与多个空格时，stringstream能够很好解决,只不过用到了额外空间ans和t并非原地解法,时间复杂度为O(n * m + k)，空间复杂度为O(n)。原地解法应该用双指针)</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">string <span class="title">reverseWords</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">    <span class="function">stringstream <span class="title">ss</span><span class="params">(s)</span></span>;</span><br><span class="line">    string t, ans;</span><br><span class="line">    <span class="keyword">while</span> (ss &gt;&gt; t) &#123;</span><br><span class="line">        <span class="built_in">reverse</span>(t.<span class="built_in">begin</span>(), t.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">if</span> (!ans.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            ans += <span class="string">&quot; &quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ans += t;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="5-统计字符串-哈希表"><a href="#5-统计字符串-哈希表" class="headerlink" title="5.统计字符串(哈希表)"></a>5.统计字符串(哈希表)</h1><h2 id="5-1-字符串中的第一个唯一字符：387"><a href="#5-1-字符串中的第一个唯一字符：387" class="headerlink" title="5-1.字符串中的第一个唯一字符：387"></a>5-1.字符串中的第一个唯一字符：387</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">firstUniqChar</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n = s.<span class="built_in">length</span>();</span><br><span class="line">    unordered_map&lt;<span class="type">char</span>, <span class="type">int</span>&gt; count;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">char</span> ch : s) &#123;</span><br><span class="line">        count[ch]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (count[s[i]] == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>还可以用find()和rfind():(空间复杂度为$O(1)$,时间复杂度$O(n^2)$)</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">firstUniqChar</span><span class="params">(string s)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>( i = <span class="number">0</span>; i &lt; s.<span class="built_in">size</span>(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(s.<span class="built_in">find</span>(s[i]) == s.<span class="built_in">rfind</span>(s[i]))<span class="comment">//find()时间复杂度O(n)</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>优化：记录频数改为记录<strong>索引</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">firstUniqChar</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = s.<span class="built_in">length</span>();</span><br><span class="line">        unordered_map&lt;<span class="type">char</span>, <span class="type">int</span>&gt; position;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (position.<span class="built_in">count</span>(s[i])) &#123; <span class="comment">//该字符已经出现过至少一次</span></span><br><span class="line">                position[s[i]] = <span class="number">-1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                position[s[i]] = i; <span class="comment">//只出现第一次的，记录下对应索引</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> first = n;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; [_, pos] : position) &#123;</span><br><span class="line">            <span class="keyword">if</span> (pos != <span class="number">-1</span>) &#123;</span><br><span class="line">                first = <span class="built_in">min</span>(first, pos);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> first == n ? <span class="number">-1</span> : first;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>注：（用纯数组更快，尽管时间复杂度和空间复杂度相同，但是哈希表牵涉到建表、哈希碰撞等等）</p><p>方法二：使用队列queue（时间空间复杂度同法一）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">firstUniqChar</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = s.<span class="built_in">length</span>();</span><br><span class="line">        unordered_map&lt;<span class="type">char</span>, <span class="type">int</span>&gt; position;</span><br><span class="line">        queue&lt;pair&lt;<span class="type">char</span>, <span class="type">int</span>&gt;&gt; q;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (position.<span class="built_in">count</span>(s[i])) &#123; <span class="comment">//该字符已经出现过至少一次</span></span><br><span class="line">                position[s[i]] = <span class="number">-1</span>;</span><br><span class="line">                <span class="keyword">while</span> (!q.<span class="built_in">empty</span>() &amp;&amp; position[q.<span class="built_in">front</span>().first] == <span class="number">-1</span>) &#123;</span><br><span class="line">                    q.<span class="built_in">pop</span>();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                position[s[i]] = i; <span class="comment">//只出现第一次的，记录下对应索引</span></span><br><span class="line">                q.<span class="built_in">emplace</span>(s[i], i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> q.<span class="built_in">empty</span>() ? <span class="number">-1</span> : q.<span class="built_in">front</span>().second;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><code>emplace()</code> 是 C++ 中容器类的一个成员函数，用于在容器中就地构造元素，而不是通过拷贝或移动构造函数。</p><p>对于<mark>容器类</mark>（如 <code>std::vector</code>、<code>std::map</code>、<code>std::unordered_map</code> 等），<code>emplace()</code> 函数接受构造函数的参数，并在容器中直接构造一个新的元素，而不是将一个已经构造好的对象插入容器。</p><p>这种就地构造的方式可以避免额外的拷贝或移动操作，提高代码的效率。它对于大型对象或者不可复制/移动的对象特别有用。</p><hr><h3 id="注：关于哈希表"><a href="#注：关于哈希表" class="headerlink" title="注：关于哈希表"></a>注：关于哈希表</h3><p>统计出现次数(时间复杂度$O(1)$)：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">position.<span class="built_in">count</span>(s[i]);</span><br></pre></td></tr></table></figure><p>内部定义：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">unordered_map&lt;<span class="type">char</span>, <span class="type">int</span>&gt; mp = &#123;</span><br><span class="line">        &#123;<span class="string">&#x27;I&#x27;</span>, <span class="number">1</span>&#125;,  </span><br><span class="line">        &#123;<span class="string">&#x27;V&#x27;</span>, <span class="number">5</span>&#125;,   </span><br><span class="line">        &#123;<span class="string">&#x27;X&#x27;</span>, <span class="number">10</span>&#125;,   </span><br><span class="line">        &#123;<span class="string">&#x27;L&#x27;</span>, <span class="number">50</span>&#125;,</span><br><span class="line">        &#123;<span class="string">&#x27;C&#x27;</span>, <span class="number">100</span>&#125;, </span><br><span class="line">        &#123;<span class="string">&#x27;D&#x27;</span>, <span class="number">500</span>&#125;, </span><br><span class="line">        &#123;<span class="string">&#x27;M&#x27;</span>, <span class="number">1000</span>&#125;,</span><br><span class="line">    &#125;;</span><br></pre></td></tr></table></figure><p>遍历元素：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span>&amp; [_, pos] : position) &#123;</span><br><span class="line">     <span class="keyword">if</span> (pos != <span class="number">-1</span>) &#123;</span><br><span class="line">          first = <span class="built_in">min</span>(first, pos);</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码使用了 C++17 中的结构化绑定（structured bindings）语法，用于遍历名为 <code>position</code> 的容器中的元素。遍历的顺序并不是unordered_map中元素的插入顺序，由于unordered_map<mark>没有保证</mark>元素的插入顺序，遍历顺序为乱序，从而影响结果。这是因为 <code>std::unordered_map</code> 使用哈希表实现，元素的存储位置是根据哈希值计算得到的，而不是按照插入顺序或其他特定顺序。</p><p>在每次循环迭代中，<code>auto&amp; [_, pos]</code> 将容器中的键值对解构为两个变量 <code>_</code> 和 <code>pos</code>。这里使用 <code>_</code> 表示<u>不需要使用</u>的变量，而 <code>pos</code> 则表示容器中的值。</p><p>这两个for循环等价：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span>&amp; [_,strArray]:mp)&#123;</span><br><span class="line">    res.<span class="built_in">emplace_back</span>(strArray);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> it = mp.<span class="built_in">begin</span>(); it != mp.<span class="built_in">end</span>(); ++it) &#123;</span><br><span class="line">     res.<span class="built_in">emplace_back</span>(it-&gt;second);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//注：unordered_map&lt;string, vector&lt;string&gt;&gt; mp;</span></span><br><span class="line"><span class="comment">//vector&lt;vector&lt;string&gt;&gt; res;详细可见49题</span></span><br></pre></td></tr></table></figure><p>哈希表中的每个元素的类型为pair</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">unordered_map&lt;<span class="type">char</span>, <span class="type">int</span>&gt; mp;</span><br><span class="line">vector&lt;pair&lt;<span class="type">char</span>, <span class="type">int</span>&gt;&gt; cnt;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span>&amp; it : mp) &#123; <span class="comment">// it的类型是pair&lt;char,int&gt;</span></span><br><span class="line">     cnt.<span class="built_in">emplace_back</span>(it);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>自定义比较方法(这里second值大的排在前面)</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sort</span>(cnt.<span class="built_in">begin</span>(), cnt.<span class="built_in">end</span>(),</span><br><span class="line">     [](<span class="type">const</span> pair&lt;<span class="type">char</span>, <span class="type">int</span>&gt;&amp; a, <span class="type">const</span> pair&lt;<span class="type">char</span>, <span class="type">int</span>&gt;&amp; b) &#123;</span><br><span class="line">         <span class="keyword">return</span> a.second &gt; b.second;</span><br><span class="line">     &#125;);</span><br></pre></td></tr></table></figure><hr><h2 id="5-2-字符串找不同：389、242"><a href="#5-2-字符串找不同：389、242" class="headerlink" title="5-2.字符串找不同：389、242"></a>5-2.字符串找不同：389、242</h2><p>一、计数：首先遍历字符串 s，对其中的每个字符都将计数值加 1；然后遍历字符串 t，对其中的每个字符都将计数值减 1。也可以使用哈希表，但法一空间复杂度较高。(如果是Unicode字符就老老实实用这种方法)</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">char</span> <span class="title">findTheDifference</span><span class="params">(string s, string t)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = t.<span class="built_in">size</span>(), n1 = s.<span class="built_in">size</span>();</span><br><span class="line">        unordered_map&lt;<span class="type">char</span>, <span class="type">int</span>&gt; count;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n1; i++) &#123;</span><br><span class="line">            count[t[i]]++;</span><br><span class="line">            count[s[i]]--;</span><br><span class="line">        &#125;</span><br><span class="line">        count[t[n - <span class="number">1</span>]]++;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; [pos, cnt] : count) &#123;<span class="comment">//pos是key,cnt是值。都用到了不能写为_</span></span><br><span class="line">            <span class="keyword">if</span> (cnt != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> pos;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>二、求和:将字符串 s 中每个字符的 ASCII 码的值求和，得到 $A_s$​；对字符串 t 同样的方法得到 $A_t$。两者的差值 $A_t-A_s$​ 即代表了被添加的字符。</p><p>三、<mark>位运算</mark>:将两个字符串拼接成一个字符串，则问题转换成求字符串中出现<u>奇数次</u>的字符。(136题也是位运算，用到了异或<code>^</code>)</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">char</span> <span class="title">findTheDifference</span><span class="params">(string s, string t)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> ret = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">char</span> ch: s) &#123;</span><br><span class="line">            ret ^= ch;<span class="comment">//异或运算时ch会先被转换成ASCII码(此处为int型)</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">char</span> ch: t) &#123;</span><br><span class="line">            ret ^= ch;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>因为在s和t之中都出现的ch,在异或运算之后变成了0，相当于<code>ret^s[0]^s[1]...^t[0]^t[1]...=0^(s[0]^t[0])^(s[1]^t[1])^...^t[more]=0^0^0^...^0^t[more]=t[more].</code></p><p>(这里假设s[0]==t[0],s[1]==t[1]…)</p><p>容器角度一般的优化思路。完整的是多容器-&gt;多次新建容器-&gt;单容器-&gt;数组-&gt;二进制位。</p><h2 id="5-3-字母异位词分组：49"><a href="#5-3-字母异位词分组：49" class="headerlink" title="5-3.字母异位词分组：49"></a>5-3.字母异位词分组：49</h2><p>法一：排序(由于互为字母异位词的两个字符串包含的字母相同，因此对两个字符串分别进行排序之后得到的字符串一定是相同的，故可以将<strong>排序之后的字符串作为哈希表的键</strong>。)可以不用sort()来排序以节省时间开销，但是可能增加空间开销。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;string&gt;&gt; <span class="built_in">groupAnagrams</span>(vector&lt;string&gt;&amp; strs) &#123;</span><br><span class="line">        unordered_map&lt;string, vector&lt;string&gt;&gt; mp;</span><br><span class="line">        <span class="keyword">for</span> (string&amp; str : strs) &#123;</span><br><span class="line">            string key = str;</span><br><span class="line">            <span class="built_in">sort</span>(key.<span class="built_in">begin</span>(), key.<span class="built_in">end</span>());</span><br><span class="line">            mp[key].<span class="built_in">emplace_back</span>(str);</span><br><span class="line">        &#125;</span><br><span class="line">        vector&lt;vector&lt;string&gt;&gt; res;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> it = mp.<span class="built_in">begin</span>(); it != mp.<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line">            res.<span class="built_in">emplace_back</span>(it-&gt;second);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>法二：计数(将每个字母出现的次数使用字符串表示，作为哈希表的键。时间复杂度更低，空间复杂度更高)</p><h2 id="5-4-根据字符串出现频率排序：451"><a href="#5-4-根据字符串出现频率排序：451" class="headerlink" title="5-4.根据字符串出现频率排序：451"></a>5-4.根据字符串出现频率排序：451</h2><p>桶排序：速度比sort()快</p><p>1.遍历字符串，统计每个字符出现的频率，同时记录最高频率 maxFreq；</p><p>2.创建桶，存储从 1 到 maxFreq 的每个出现频率的字符；</p><p>3.按照出现频率从大到小的顺序遍历桶，对于每个出现频率，获得对应的字符，然后将每个字符按照出现频率拼接到排序后的字符串。</p><h2 id="5-5-求连续递增子串的个数，并去重：467"><a href="#5-5-求连续递增子串的个数，并去重：467" class="headerlink" title="5-5.求连续递增子串的个数，并去重：467"></a>5-5.求连续递增子串的个数，并去重：467</h2><p>动态规划</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findSubstringInWraproundString</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> k = <span class="number">0</span>;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(<span class="number">26</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">length</span>(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i &amp;&amp; (s[i] - s[i - <span class="number">1</span>] + <span class="number">26</span>) % <span class="number">26</span> == <span class="number">1</span>) &#123; <span class="comment">// s[i-1]在s[i]前面</span></span><br><span class="line">                k++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                k = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            dp[s[i] - <span class="string">&#x27;a&#x27;</span>] = <span class="built_in">max</span>(dp[s[i] - <span class="string">&#x27;a&#x27;</span>], k);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">accumulate</span>(dp.<span class="built_in">begin</span>(), dp.<span class="built_in">end</span>(), <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="5-6-URL的解密与加密：535"><a href="#5-6-URL的解密与加密：535" class="headerlink" title="5-6.URL的解密与加密：535"></a>5-6.URL的解密与加密：535</h2><p>如果想要实现相同的 URL 加密成同一个 TinyURL，则额外保存一个从 URL到 TinyURL 的映射。</p><p>注：int-&gt;string:<code>to_string(intVar);</code></p><p>string-&gt;int:<code>stoi(stringVar);</code></p><h3 id="关于随机数"><a href="#关于随机数" class="headerlink" title="关于随机数"></a>关于随机数</h3><p><code>time(0)</code>函数返回当前的系统时间（从某一时刻开始的秒数），而<code>srand</code>函数是用来设置随机数生成器的种子。将<code>time(0)</code>的返回值传递给<code>srand</code>函数，可以使用当前时间作为随机数生成器的种子，从而使得每次程序运行时生成的随机数序列都不同。</p><p>在C++中，通常在使用随机数生成函数<code>rand</code>之前，会调用<code>srand(time(0))</code>来<u>初始化随机数生成器</u>。这样可以确保每次程序运行时都会生成不同的随机数序列，因为种子不同会导致不同的随机数序列。之后就可以使用<code>randomNumber=rand();</code></p>]]></content>
      
      
      <categories>
          
          <category> leetcode刷题笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> leetcode </tag>
            
            <tag> string </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>1.数组篇</title>
      <link href="/posts/254d58d4.html"/>
      <url>/posts/254d58d4.html</url>
      
        <content type="html"><![CDATA[<p>数组的遍历:414</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">thirdMax</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//sort(nums.begin(),nums.end(),greater&lt;&gt;());//从大到小排序</span></span><br><span class="line">        <span class="comment">//使用了set就没有必要sort()，排序需要 O(nlog⁡n)的时间</span></span><br><span class="line">        set&lt;<span class="type">int</span>&gt;s;<span class="comment">//set会自动从小到大排序（默认时）,一个元素只能出现一次</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> num:nums)&#123;</span><br><span class="line">            s.<span class="built_in">insert</span>(num);<span class="comment">//set自动去重</span></span><br><span class="line">            <span class="keyword">if</span>(s.<span class="built_in">size</span>()&gt;<span class="number">3</span>)&#123;</span><br><span class="line">                s.<span class="built_in">erase</span>(s.<span class="built_in">begin</span>());<span class="comment">//注意s.begin()是迭代器类型</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s.<span class="built_in">size</span>()==<span class="number">3</span>?*s.<span class="built_in">begin</span>():*s.<span class="built_in">rbegin</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>统计数组中的元素：645(哈希表解法)。关键思想:<strong>原地哈希</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">findErrorNums</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt;<span class="built_in">res</span>(<span class="number">2</span>);</span><br><span class="line">        unordered_map&lt;<span class="type">int</span>,<span class="type">int</span>&gt;mp;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; num:nums)&#123;    <span class="comment">//需要利用迭代器进行遍历</span></span><br><span class="line">            mp[num]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=nums.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            <span class="type">int</span> count=mp[i];</span><br><span class="line">            <span class="keyword">if</span>(count==<span class="number">2</span>)&#123;</span><br><span class="line">                res[<span class="number">0</span>]=i;<span class="comment">//重复的数字</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(count==<span class="number">0</span>)&#123;</span><br><span class="line">                res[<span class="number">1</span>]=i;<span class="comment">//缺失的数字</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>难题：41</p><p>二分搜索：274</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">hIndex</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; citations)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//双指针，二分搜索</span></span><br><span class="line">        <span class="type">int</span> left = <span class="number">0</span>, right = citations.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> mid = <span class="number">0</span>, count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">            mid = (left + right + <span class="number">1</span>) / <span class="number">2</span>;<span class="comment">//加1防止死循环</span></span><br><span class="line">            count = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; citations.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (citations[i] &gt;= mid) &#123;</span><br><span class="line">                    count++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (count &gt;= mid) &#123;</span><br><span class="line">                left = mid;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                right = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>类似min的函数：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> minNum = *<span class="built_in">min_element</span>(nums.<span class="built_in">begin</span>(),nums.<span class="built_in">end</span>());</span><br></pre></td></tr></table></figure><p>扫描：419</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">countBattleships</span><span class="params">(vector&lt;vector&lt;<span class="type">char</span>&gt;&gt;&amp; board)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> row = board.<span class="built_in">size</span>(), col = board[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; row; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; col; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (board[i][j] == <span class="string">&#x27;X&#x27;</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> ((i &gt;= <span class="number">1</span> &amp;&amp; board[i - <span class="number">1</span>][j] == <span class="string">&#x27;X&#x27;</span>) ||</span><br><span class="line">                        (j &gt;= <span class="number">1</span> &amp;&amp; board[i][j - <span class="number">1</span>] == <span class="string">&#x27;X&#x27;</span>)) &#123;</span><br><span class="line">                        <span class="comment">//如果发现其上方或者左边有过X,则继续向右下扫描</span></span><br><span class="line">                        <span class="comment">//此时res不增加，直接continue进入下一次循环</span></span><br><span class="line">                        <span class="comment">//直到确实走到尽头才会结束，然后计数+1</span></span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    res++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>迭代：396</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;climits&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;numeric&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxRotateFunction</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">size</span>(), res = INT_MIN, Fk = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> sum = <span class="built_in">accumulate</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>(), <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            Fk += i * nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        res = Fk; <span class="comment">//也就是让res=F(0)，避免nums只有一个元素时return INT_MIN</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = n - <span class="number">1</span>; i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">            Fk += sum - n * nums[i];</span><br><span class="line">            res = <span class="built_in">max</span>(res, Fk);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>模拟：54、59</p><p>对角线遍历498：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m + n - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i % <span class="number">2</span>) &#123;</span><br><span class="line">                <span class="type">int</span> x = (i &lt; n ? <span class="number">0</span> : i - n + <span class="number">1</span>);</span><br><span class="line">                <span class="type">int</span> y = (i &lt; n ? i : n - <span class="number">1</span>);</span><br><span class="line">                <span class="keyword">while</span> (x &lt; m &amp;&amp; y &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                    res.<span class="built_in">emplace_back</span>(mat[x][y]);</span><br><span class="line">                    x++;</span><br><span class="line">                    y--; </span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="type">int</span> x = (i &lt; m ? i : m - <span class="number">1</span>);</span><br><span class="line">                <span class="type">int</span> y = (i &lt; m ? <span class="number">0</span> : i - m + <span class="number">1</span>);</span><br><span class="line">                <span class="keyword">while</span> (x &gt;= <span class="number">0</span> &amp;&amp; y &lt; n) &#123;</span><br><span class="line">                    res.<span class="built_in">emplace_back</span>(mat[x][y]);</span><br><span class="line">                    x--;</span><br><span class="line">                    y++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在选择使用 <code>emplace_back</code> 还是 <code>push_back</code> 时，通常情况下，<code>emplace_back</code> 更好一些。这是因为 <code>emplace_back</code> 可以避免创建临时对象，从而提高了性能。</p><p>另外，<code>emplace_back</code> 也更加灵活，因为它允许你直接传递构造元素所需的参数，而不需要显式地创建对象。</p><p>总的来说，如果你需要向 <code>vector</code> 中添加新元素，通常情况下优先考虑使用 <code>emplace_back</code>。</p><p>二维数组变换行列长宽：566</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> m = mat.<span class="built_in">size</span>(), n = mat[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m * n; i++) &#123;</span><br><span class="line">     res[i / c][i % c] =mat[i / n][i % n]; </span><br><span class="line">     <span class="comment">//找到第i个数到底分别在数组的哪个位置</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>二维矩阵顺时针旋转（48）=<code>水平</code>翻转(竖直线对称翻转)+(沿)<code>主对角</code>线翻转</p><p><u>矩阵原地置换(73)</u>：用矩阵第一行和第一列代替标记行和列的两个标记数组，使得空间复杂度为$O(1)$，时间复杂度为$O(row*col)$.但这样会导致原数组的第一行和第一列被修改，无法记录它们是否原本包含 0。因此我们需要额外使用两个标记变量分别记录第一行和第一列是否原本包含 0。</p><p>   在实际代码中，我们首先预处理出两个标记变量，接着使用其他行与列去处理第一行与第一列，然后反过来使用第一行与第一列去更新其他行与列，最后使用两个标记变量更新第一行与第一列即可。</p><pre><code>我们可以对方法二进一步优化，只使用一个标记变量记录第一列是否原本存在 0。这样，第一列的第一个元素即可以标记第一行是否出现 0。但为了防止每一列的第一个元素被提前更新，我们需要从最后一行开始，倒序地处理矩阵元素。</code></pre><p><u>矩阵原地置换拓展(289)</u>：创建复合状态2，可以知道修改前是0，而之后变为1.常用于需要同步更新情况。</p><p>涉及到类：303</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">NumArray</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; sum;</span><br><span class="line">    <span class="built_in">NumArray</span>(vector&lt;<span class="type">int</span>&gt;&amp; nums) &#123; <span class="comment">//初始化sum数组</span></span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        sum.<span class="built_in">resize</span>(n + <span class="number">1</span>); <span class="comment">//注意</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            sum[i + <span class="number">1</span>] = sum[i] + nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">sumRange</span><span class="params">(<span class="type">int</span> left, <span class="type">int</span> right)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//错误：nums是临时数组，应该用sum</span></span><br><span class="line">        <span class="comment">// return accumulate(nums.begin() + left, nums.begin() + right, 0);</span></span><br><span class="line">        <span class="keyword">return</span> sum[right + <span class="number">1</span>] - sum[left];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>二维数组resize:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sums.<span class="built_in">resize</span>(m + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n + <span class="number">1</span>));</span><br></pre></td></tr></table></figure><p>二维数组定义：(创建n×n的数组，默认初始化所有元素为0)</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">res</span>(n, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n));</span><br></pre></td></tr></table></figure><p>前缀/后缀之和/之积：238</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">productExceptSelf</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">res</span><span class="params">(nums.size())</span></span>;</span><br><span class="line">        res[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; nums.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            res[i]=res[i<span class="number">-1</span>]*nums[i<span class="number">-1</span>];<span class="comment">//先用res存储前缀之积</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> r=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=nums.<span class="built_in">size</span>()<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">            res[i]=res[i]*r;<span class="comment">//更新res,res[i]最终应为nums[i]的前缀之积×后缀之积</span></span><br><span class="line">            r*=nums[i];<span class="comment">//用R存储当前对应元素的后缀之积</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> leetcode刷题笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> leetcode </tag>
            
            <tag> 数组 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>0.常用的C++ STL用法</title>
      <link href="/posts/123456.html"/>
      <url>/posts/123456.html</url>
      
        <content type="html"><![CDATA[<p>转载自github.</p><p><strong>C++ 标准模板库 (STL, Standard Template Library)</strong>：包含一些常用数据结构与算法的模板的 C++ 软件库。其包含四个组件——算法 (Algorithms)、容器 (Containers)、仿函数 (Functors)、迭代器 (Iterators).</p><span id="more"></span><p>示例：</p><ul><li>算法：<code>sort(a.begin(), a.end())</code></li><li>容器：<code>priority_queue&lt;int&gt; pque</code></li><li>仿函数：<code>greater&lt;int&gt;()</code></li><li>迭代器：<code>vector&lt;int&gt;::iterator it = a.begin()</code></li></ul><h1 id="1-前言"><a href="#1-前言" class="headerlink" title="1 前言"></a>1 前言</h1><p>STL 作为一个封装良好，性能合格的 C++ 标准库，在算法竞赛中运用极其常见。灵活且正确使用 STL 可以节省非常多解题时间，这一点不仅是由于可以直接调用，还是因为它封装良好，可以让代码的可读性变高，解题思路更清晰，调试过程 <del>往往</del> 更顺利。</p><p>不过 STL 毕竟使用了很多复杂的结构来实现丰富的功能，它的效率往往是比不上自己手搓针对特定题目的数据结构与算法的。因此，STL 的使用相当于使用更长的运行时间换取更高的编程效率。因此，在实际比赛中要权衡 STL 的利弊，不过这一点就得靠经验了。</p><p>接下来，我会分享在算法竞赛中常用的 STL 容器和算法，对于函数和迭代器，就不着重展开讲了。</p><h1 id="2-常用容器"><a href="#2-常用容器" class="headerlink" title="2 常用容器"></a>2 常用容器</h1><h2 id="2-1-内容总览"><a href="#2-1-内容总览" class="headerlink" title="2.1 内容总览"></a>2.1 内容总览</h2><p>打勾的是本次将会详细讲解的，加粗的是算法竞赛中有必要学习的。</p><ul><li><p>顺序容器</p><ul><li><p>[ ] <strong>array</strong></p></li><li><p>[x] <strong>vector</strong></p></li><li><p>[ ] <strong>deque</strong></p></li><li><p>[ ] forward_list</p></li><li><p>[ ] <strong>list</strong></p></li></ul></li><li><p>关联容器</p><ul><li>[x] <strong>set</strong></li><li>[x] <strong>map</strong></li><li>[ ] <strong>multiset</strong></li><li>[ ] <strong>multimap</strong></li></ul></li><li><p>无序关联容器</p><ul><li>[ ] <strong>unordered_set</strong></li><li>[ ] <strong>unordered_map</strong></li><li>[ ] <strong>unordered_multiset</strong></li><li>[ ] <strong>unordered_multimap</strong></li></ul></li><li><p>容器适配器</p><ul><li>[x] <strong>stack</strong></li><li>[x] <strong>queue</strong></li><li>[x] <strong>priority_queue</strong></li><li>[ ] flat_set</li><li>[ ] flat_map</li><li>[ ] flat_multiset</li><li>[ ] flat_multimap</li></ul></li><li><p>字符串</p><ul><li>[x] <strong>string</strong> (basic_string\<char\>)</li></ul></li><li><p>对与元组</p><ul><li>[x] <strong>pair</strong></li><li>[ ] <strong>tuple</strong></li></ul></li></ul><h2 id="2-2-向量-vector"><a href="#2-2-向量-vector" class="headerlink" title="2.2 向量 vector"></a>2.2 向量 <a href="https://zh.cppreference.com/w/cpp/container/vector">vector</a></h2><p><strong><code>#include &lt;vector&gt;</code></strong></p><p>连续的顺序的储存结构（和数组一样的类别），但是有长度可变的特性。</p><h3 id="2-2-1-常用方法"><a href="#2-2-1-常用方法" class="headerlink" title="2.2.1 常用方法"></a>2.2.1 常用方法</h3><h4 id="构造"><a href="#构造" class="headerlink" title="构造"></a>构造</h4><p><strong><code>vector&lt;类型&gt; arr(长度, [初值])</code></strong></p><p>时间复杂度：$O(n)$</p><p>常用的一维和二维数组构造示例，高维也是一样的（就是会有点长）.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; arr;         <span class="comment">// 构造int数组</span></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">arr</span><span class="params">(<span class="number">100</span>)</span></span>;    <span class="comment">// 构造初始长100的int数组</span></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">arr</span><span class="params">(<span class="number">100</span>, <span class="number">1</span>)</span></span>; <span class="comment">// 构造初始长100的int数组，初值为1</span></span><br><span class="line"></span><br><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">mat</span>(<span class="number">100</span>, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt; ());       <span class="comment">// 构造初始100行，不指定列数的二维数组</span></span><br><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">mat</span>(<span class="number">100</span>, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt; (<span class="number">666</span>, <span class="number">-1</span>)) <span class="comment">// 构造初始100行，初始666列的二维数组，初值为-1</span></span><br></pre></td></tr></table></figure><p>构造二维数组的奇葩写法，千万别用：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; arr[<span class="number">100</span>];         <span class="comment">// 正确，构造初始100行，不指定列数的二维数组，可用于链式前向星存图</span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; arr[<span class="number">100</span>](<span class="number">100</span>, <span class="number">1</span>); <span class="comment">// 语法错误！</span></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">arr</span><span class="params">(<span class="number">100</span>, <span class="number">1</span>)</span>[100]</span>; <span class="comment">// 语法错误！</span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; arr[<span class="number">100</span>] &#123;&#123;<span class="number">100</span>, <span class="number">1</span>&#125;, 这里省略<span class="number">98</span>个 ,&#123;<span class="number">100</span>, <span class="number">1</span>&#125;&#125;; <span class="comment">// 正确但奇葩，使用列表初始化</span></span><br></pre></td></tr></table></figure><h4 id="尾接-amp-尾删"><a href="#尾接-amp-尾删" class="headerlink" title="尾接 &amp; 尾删"></a>尾接 &amp; 尾删</h4><ul><li><strong><code>.push_back(元素)</code></strong>：在 vector 尾接一个元素，数组长度 $+1$.</li><li><strong><code>.pop_back()</code></strong>：删除 vector 尾部的一个元素，数组长度 $-1$</li></ul><p>时间复杂度：均摊 $O(1)$</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// init: arr = []</span></span><br><span class="line">arr.<span class="built_in">push_back</span>(<span class="number">1</span>);</span><br><span class="line"><span class="comment">// after: arr = [1]</span></span><br><span class="line">arr.<span class="built_in">push_back</span>(<span class="number">2</span>);</span><br><span class="line"><span class="comment">// after: arr = [1, 2]</span></span><br><span class="line">arr.<span class="built_in">pop_back</span>();</span><br><span class="line"><span class="comment">// after: arr = [1]</span></span><br><span class="line">arr.<span class="built_in">pop_back</span>();</span><br><span class="line"><span class="comment">// after: arr = []</span></span><br></pre></td></tr></table></figure><h4 id="中括号运算符"><a href="#中括号运算符" class="headerlink" title="中括号运算符"></a>中括号运算符</h4><p>和一般数组一样的作用</p><p>时间复杂度：$O(1)$</p><h4 id="获取长度"><a href="#获取长度" class="headerlink" title="获取长度"></a>获取长度</h4><p><strong><code>.size()</code></strong></p><p>获取当前 vector 的长度</p><p>时间复杂度：$O(1)$</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; arr.<span class="built_in">size</span>(); i++)</span><br><span class="line">    cout &lt;&lt; a[i] &lt;&lt; endl;</span><br></pre></td></tr></table></figure><h4 id="清空"><a href="#清空" class="headerlink" title="清空"></a>清空</h4><p><strong><code>.clear()</code></strong></p><p>清空 vector</p><p>时间复杂度：$O(n)$</p><h4 id="判空"><a href="#判空" class="headerlink" title="判空"></a>判空</h4><p><strong><code>.empty()</code></strong></p><p>如果是空返回 <code>true</code> 反之返回 <code>false</code>.</p><p>时间复杂度：$O(1)$</p><h4 id="改变长度"><a href="#改变长度" class="headerlink" title="改变长度"></a>改变长度</h4><p><strong><code>.resize(新长度, [默认值])</code></strong></p><p>修改 vector 的长度</p><ul><li>如果是缩短，则删除多余的值</li><li>如果是扩大，且指定了默认值，则新元素均为默认值<strong>（旧元素不变）</strong></li></ul><p>时间复杂度：$O(n)$</p><h3 id="2-2-2-适用情形"><a href="#2-2-2-适用情形" class="headerlink" title="2.2.2 适用情形"></a>2.2.2 适用情形</h3><p>一般情况 <code>vector</code> 可以替换掉普通数组，除非该题卡常。</p><p>有些情况普通数组没法解决：$n\times m$ 的矩阵，$1\leq n,m\leq 10^6$ 且 $n\times m \leq 10^6$</p><ul><li>如果用普通数组 <code>int mat[1000010][1000010]</code>，浪费内存，会导致 MLE。</li><li>如果使用 <code>vector&lt;vector&lt;int&gt;&gt; mat(n + 10, vector&lt;int&gt; (m + 10))</code>，完美解决该问题。</li></ul><p>另外，<code>vector</code> 的数据储存在堆空间中，不会爆栈。</p><h3 id="2-2-3-注意事项"><a href="#2-2-3-注意事项" class="headerlink" title="2.2.3 注意事项"></a>2.2.3 注意事项</h3><h4 id="提前指定长度"><a href="#提前指定长度" class="headerlink" title="提前指定长度"></a>提前指定长度</h4><p>如果长度已经确定，那么应当直接在构造函数指定长度，而不是一个一个 <code>.push_back()</code>. 因为 <code>vector</code> 额外内存耗尽后的重分配是有时间开销的，直接指定长度就不会出现重分配了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 优化前: 522ms</span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; a;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1e8</span>; i++)</span><br><span class="line">    a.<span class="built_in">push_back</span>(i);</span><br><span class="line"><span class="comment">// 优化后: 259ms</span></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">a</span><span class="params">(<span class="number">1e8</span>)</span></span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; a.<span class="built_in">size</span>(); i++)</span><br><span class="line">    a[i] = i;</span><br></pre></td></tr></table></figure><h4 id="当心-size-t-溢出"><a href="#当心-size-t-溢出" class="headerlink" title="当心 size_t 溢出"></a>当心 size_t 溢出</h4><p>vector 获取长度的方法 <code>.size()</code> 返回值类型为 <code>size_t</code>，通常 OJ 平台使用的是 32 位编译器（有些平台例如 cf 可选 64 位），那么该类型范围为 $[0,2^{32})$.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">a</span><span class="params">(<span class="number">65536</span>)</span></span>;</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> a = a.<span class="built_in">size</span>() * a.<span class="built_in">size</span>(); <span class="comment">// 直接溢出变成0了</span></span><br></pre></td></tr></table></figure><h2 id="2-3-栈-stack"><a href="#2-3-栈-stack" class="headerlink" title="2.3 栈 stack"></a>2.3 栈 <a href="https://zh.cppreference.com/w/cpp/container/stack">stack</a></h2><p><strong><code>#include &lt;stack&gt;</code></strong></p><p>通过二次封装双端队列 (deque) 容器，实现先进后出的栈数据结构。</p><h3 id="2-3-1-常用方法"><a href="#2-3-1-常用方法" class="headerlink" title="2.3.1 常用方法"></a>2.3.1 常用方法</h3><div class="table-container"><table><thead><tr><th>作用</th><th>用法</th><th>示例</th></tr></thead><tbody><tr><td>构造</td><td><code>stack&lt;类型&gt; stk</code></td><td><code>stack&lt;int&gt; stk;</code></td></tr><tr><td>进栈</td><td><code>.push(元素)</code></td><td><code>stk.push(1);</code></td></tr><tr><td>出栈</td><td><code>.pop()</code></td><td><code>stk.pop();</code></td></tr><tr><td>取栈顶</td><td><code>.top()</code></td><td><code>int a = stk.top();</code></td></tr><tr><td>查看大小 / 清空 / 判空</td><td>略</td><td>略</td></tr></tbody></table></div><h3 id="2-3-2-适用情形"><a href="#2-3-2-适用情形" class="headerlink" title="2.3.2 适用情形"></a>2.3.2 适用情形</h3><p>如果不卡常的话，就可以直接用它而不需要手写栈了。</p><p>另外，vector 也可以当栈用，vector 的 <code>.back()</code> 取尾部元素，就相当于取栈顶，<code>.push_back()</code> 相当于进栈，<code>.pop_back()</code> 相当于出栈。</p><h3 id="2-3-3-注意事项"><a href="#2-3-3-注意事项" class="headerlink" title="2.3.3 注意事项"></a>2.3.3 注意事项</h3><p>不可访问内部元素！<strong>下面都是错误用法</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; stk.<span class="built_in">size</span>(); i++)</span><br><span class="line">    cout &lt;&lt; stk[i] &lt;&lt; endl;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> ele : stk)</span><br><span class="line">    cout &lt;&lt; stk &lt;&lt; endl;</span><br></pre></td></tr></table></figure><h2 id="2-4-队列-queue"><a href="#2-4-队列-queue" class="headerlink" title="2.4 队列 queue"></a>2.4 队列 <a href="https://zh.cppreference.com/w/cpp/container/queue">queue</a></h2><p><strong><code>#include &lt;queue&gt;</code></strong></p><p>通过二次封装双端队列 (deque) 容器，实现先进先出的队列数据结构。</p><h3 id="2-4-1-常用方法"><a href="#2-4-1-常用方法" class="headerlink" title="2.4.1 常用方法"></a>2.4.1 常用方法</h3><div class="table-container"><table><thead><tr><th>作用</th><th>用法</th><th>示例</th></tr></thead><tbody><tr><td>构造</td><td><code>queue&lt;类型&gt; que</code></td><td><code>queue&lt;int&gt; que;</code></td></tr><tr><td>进队</td><td><code>.push(元素)</code></td><td><code>que.push(1);</code></td></tr><tr><td>出队</td><td><code>.pop()</code></td><td><code>que.pop();</code></td></tr><tr><td>取队首</td><td><code>.front()</code></td><td><code>int a = que.front();</code></td></tr><tr><td>取队尾</td><td><code>.back()</code></td><td><code>int a = que.back();</code></td></tr><tr><td>查看大小 / 清空 / 判空</td><td>略</td><td>略</td></tr></tbody></table></div><h3 id="2-4-2-适用情形"><a href="#2-4-2-适用情形" class="headerlink" title="2.4.2 适用情形"></a>2.4.2 适用情形</h3><p>如果不卡常的话，就可以直接用它而不需要手写队列了。</p><h3 id="2-4-3-注意事项"><a href="#2-4-3-注意事项" class="headerlink" title="2.4.3 注意事项"></a>2.4.3 注意事项</h3><p>不可访问内部元素！<strong>下面都是错误用法</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; que.<span class="built_in">size</span>(); i++)</span><br><span class="line">    cout &lt;&lt; que[i] &lt;&lt; endl;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> ele : que)</span><br><span class="line">    cout &lt;&lt; ele &lt;&lt; endl;</span><br></pre></td></tr></table></figure><h2 id="2-5-优先队列-priority-queue"><a href="#2-5-优先队列-priority-queue" class="headerlink" title="2.5 优先队列 priority_queue"></a>2.5 优先队列 <a href="https://zh.cppreference.com/w/cpp/container/priority_queue">priority_queue</a></h2><p><strong><code>#include &lt;queue&gt;</code></strong></p><p>提供常数时间的最大元素查找，对数时间的插入与提取，底层原理是二叉堆。</p><h3 id="2-5-1-常用方法"><a href="#2-5-1-常用方法" class="headerlink" title="2.5.1 常用方法"></a>2.5.1 常用方法</h3><h4 id="构造-1"><a href="#构造-1" class="headerlink" title="构造"></a>构造</h4><p><strong><code>priority_queue&lt;类型, 容器, 比较器&gt; pque</code></strong></p><ul><li>类型：要储存的数据类型</li><li>容器：储存数据的底层容器，默认为 <code>vector&lt;类型&gt;</code>，竞赛中保持默认即可</li><li>比较器：比较大小使用的比较器，默认为 <code>less&lt;类型&gt;</code>，可自定义</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">priority_queue&lt;<span class="type">int</span>&gt; pque1;                            <span class="comment">// 储存int的大顶堆</span></span><br><span class="line">priority_queue&lt;<span class="type">int</span>, vector&lt;<span class="type">int</span>&gt;, greater&lt;<span class="type">int</span>&gt;&gt; pque2; <span class="comment">// 储存int的小顶堆</span></span><br></pre></td></tr></table></figure><blockquote><p>对于需要自定义比较器的情况，涉及一些初学时容易看迷糊的语法（重载小括号运算符 / lambda 表达式），在此就不展开讲了。如果想要了解，可以查阅 cppreference 中的代码示例。</p></blockquote><h4 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h4><div class="table-container"><table><thead><tr><th>作用</th><th>用法</th><th>示例</th></tr></thead><tbody><tr><td>进堆</td><td><code>.push(元素)</code></td><td><code>que.push(1);</code></td></tr><tr><td>出堆</td><td><code>.pop()</code></td><td><code>que.pop();</code></td></tr><tr><td>取堆顶</td><td><code>.top()</code></td><td><code>int a = que.top();</code></td></tr><tr><td>查看大小 / 判空</td><td>略</td><td>略</td></tr></tbody></table></div><p>进出队复杂度 $O(\log n)$，取堆顶 $O(1)$.</p><h3 id="2-5-2-适用情形"><a href="#2-5-2-适用情形" class="headerlink" title="2.5.2 适用情形"></a>2.5.2 适用情形</h3><p>持续维护元素的有序性：每次向队列插入大小不定的元素，或者每次从队列里取出大小最小/最大的元素，元素数量 $n$，插入操作数量 $k$.</p><ul><li>每次插入后进行快速排序：$k\cdot n\log n$</li><li>使用优先队列维护：$k\cdot\log n$</li></ul><h3 id="2-5-3-注意事项"><a href="#2-5-3-注意事项" class="headerlink" title="2.5.3 注意事项"></a>2.5.3 注意事项</h3><h4 id="仅堆顶可读"><a href="#仅堆顶可读" class="headerlink" title="仅堆顶可读"></a>仅堆顶可读</h4><p>只可访问堆顶，其他元素都无法读取到。<strong>下面是错误用法：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cout &lt;&lt; pque[<span class="number">1</span>] &lt;&lt; endl;</span><br></pre></td></tr></table></figure><h4 id="所有元素不可写"><a href="#所有元素不可写" class="headerlink" title="所有元素不可写"></a>所有元素不可写</h4><p>堆中所有元素是不可修改的。<strong>下面是错误用法：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pque[<span class="number">1</span>] = <span class="number">2</span>;</span><br><span class="line">pque.<span class="built_in">top</span>() = <span class="number">1</span>;</span><br></pre></td></tr></table></figure><p>如果你恰好要修改的是堆顶元素，那么是可以完成的：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> tp = pque.<span class="built_in">top</span>();</span><br><span class="line">pque.<span class="built_in">pop</span>();</span><br><span class="line">pque.<span class="built_in">push</span>(tp + <span class="number">1</span>);</span><br></pre></td></tr></table></figure><h2 id="2-6-集合-set"><a href="#2-6-集合-set" class="headerlink" title="2.6 集合 set"></a>2.6 集合 <a href="https://zh.cppreference.com/w/cpp/container/set">set</a></h2><p><strong><code>#include &lt;set&gt;</code></strong></p><p>提供对数时间的插入、删除、查找的集合数据结构。底层原理是红黑树。</p><div class="table-container"><table><thead><tr><th>集合三要素</th><th>解释</th><th>set</th><th>multiset</th><th>unordered_set</th></tr></thead><tbody><tr><td>确定性</td><td>一个元素要么在集合中，要么不在</td><td>✔</td><td>✔</td><td>✔</td></tr><tr><td>互异性</td><td>一个元素仅可以在集合中出现一次</td><td>✔</td><td>❌（任意次）</td><td>✔</td></tr><tr><td>无序性</td><td>集合中的元素是没有顺序的</td><td>❌（从小到大）</td><td>❌（从小到大）</td><td>✔</td></tr></tbody></table></div><h3 id="2-6-1-常用方法"><a href="#2-6-1-常用方法" class="headerlink" title="2.6.1 常用方法"></a>2.6.1 常用方法</h3><h4 id="构造-2"><a href="#构造-2" class="headerlink" title="构造"></a>构造</h4><p><strong><code>set&lt;类型, 比较器&gt; st</code></strong></p><ul><li>类型：要储存的数据类型</li><li>比较器：比较大小使用的比较器，默认为 <code>less&lt;类型&gt;</code>，可自定义</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">set&lt;<span class="type">int</span>&gt; st1;               <span class="comment">// 储存int的集合（从小到大）</span></span><br><span class="line">set&lt;<span class="type">int</span>, greater&lt;<span class="type">int</span>&gt;&gt; st2; <span class="comment">// 储存int的集合（从大到小）</span></span><br></pre></td></tr></table></figure><blockquote><p>对于需要自定义比较器的情况，涉及一些初学时容易看迷糊的语法（重载小括号运算符 / lambda 表达式），在此就不展开讲了。</p></blockquote><h4 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h4><p>可使用迭代器进行遍历：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (set&lt;<span class="type">int</span>&gt;::iterator it = st.<span class="built_in">begin</span>(); it != st.<span class="built_in">end</span>(); ++it)</span><br><span class="line">    cout &lt;&lt; *it &lt;&lt; endl;</span><br></pre></td></tr></table></figure><p>基于范围的循环（C++ 11）：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> &amp;ele : st)</span><br><span class="line">    cout &lt;&lt; ele &lt;&lt; endl;</span><br></pre></td></tr></table></figure><h4 id="其他-1"><a href="#其他-1" class="headerlink" title="其他"></a>其他</h4><div class="table-container"><table><thead><tr><th>作用</th><th>用法</th><th>示例</th></tr></thead><tbody><tr><td>插入元素</td><td><code>.insert(元素)</code></td><td><code>st.insert(1);</code></td></tr><tr><td>删除元素</td><td><code>.erase(元素)</code></td><td><code>st.erase(2);</code></td></tr><tr><td>查找元素</td><td><code>.find(元素)</code></td><td><code>auto it = st.find(1);</code></td></tr><tr><td>判断元素是否存在</td><td><code>.count(元素)</code></td><td><code>st.count(3);</code></td></tr><tr><td>查看大小 / 清空 / 判空</td><td>略</td><td>略</td></tr></tbody></table></div><p>增删查时间复杂度均为 $O(\log n)$</p><h3 id="2-6-2-适用情形"><a href="#2-6-2-适用情形" class="headerlink" title="2.6.2 适用情形"></a>2.6.2 适用情形</h3><ul><li>元素去重：$[1,1,3,2,4,4]\to[1,2,3,4]$</li><li>维护顺序：$[1,5,3,7,9]\to[1,3,5,7,9]$</li><li>元素是否出现过：元素大小 $[-10^{18},10^{18}]$，元素数量 $10^6$，vis 数组无法实现，通过 set 可以完成。</li></ul><h3 id="2-6-3-注意事项"><a href="#2-6-3-注意事项" class="headerlink" title="2.6.3 注意事项"></a>2.6.3 注意事项</h3><h4 id="不存在下标索引"><a href="#不存在下标索引" class="headerlink" title="不存在下标索引"></a>不存在下标索引</h4><p>set 虽说可遍历，但仅可使用迭代器进行遍历，它不存在下标这一概念，无法通过下标访问到数据。<strong>下面是错误用法：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cout &lt;&lt; st[<span class="number">0</span>] &lt;&lt; endl;</span><br></pre></td></tr></table></figure><h4 id="元素只读"><a href="#元素只读" class="headerlink" title="元素只读"></a>元素只读</h4><p>set 的迭代器取到的元素是只读的（因为是 const 迭代器），不可修改其值。如果要改，需要先 erase 再 insert. <strong>下面是错误用法：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cout &lt;&lt; *st.<span class="built_in">begin</span>() &lt;&lt; endl; <span class="comment">// 正确。可读。</span></span><br><span class="line">*st.<span class="built_in">begin</span>() = <span class="number">1</span>;             <span class="comment">// 错误！不可写！</span></span><br></pre></td></tr></table></figure><h4 id="不可用迭代器计算下标"><a href="#不可用迭代器计算下标" class="headerlink" title="不可用迭代器计算下标"></a>不可用迭代器计算下标</h4><p>set 的迭代器不能像 vector 一样相减得到下标。<strong>下面是错误用法：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> it = st.<span class="built_in">find</span>(<span class="number">2</span>);      <span class="comment">// 正确，返回2所在位置的迭代器。</span></span><br><span class="line"><span class="type">int</span> idx = it - st.<span class="built_in">begin</span>(); <span class="comment">// 错误！不可相减得到下标。</span></span><br></pre></td></tr></table></figure><h2 id="2-7-映射-map"><a href="#2-7-映射-map" class="headerlink" title="2.7 映射 map"></a>2.7 映射 <a href="https://zh.cppreference.com/w/cpp/container/map">map</a></h2><p><strong><code>#include &lt;map&gt;</code></strong></p><p>提供对数时间的有序键值对结构。底层原理是红黑树。</p><p>映射：</p><script type="math/tex; mode=display">\begin{matrix}1&\to&2\\2&\to&2\\3&\to&1\\4&\to&5\\&\vdots\end{matrix}</script><div class="table-container"><table><thead><tr><th>性质</th><th>解释</th><th>map</th><th>multimap</th><th>unordered_map</th></tr></thead><tbody><tr><td>互异性</td><td>一个键仅可以在映射中出现一次</td><td>✔</td><td>❌（任意次）</td><td>✔</td></tr><tr><td>无序性</td><td>键是没有顺序的</td><td>❌（从小到大）</td><td>❌（从小到大）</td><td>✔</td></tr></tbody></table></div><h3 id="2-7-1-常用方法"><a href="#2-7-1-常用方法" class="headerlink" title="2.7.1 常用方法"></a>2.7.1 常用方法</h3><h4 id="构造-3"><a href="#构造-3" class="headerlink" title="构造"></a>构造</h4><p><strong><code>map&lt;键类型, 值类型, 比较器&gt; mp</code></strong></p><ul><li>键类型：要储存键的数据类型</li><li>值类型：要储存值的数据类型</li><li>比较器：键比较大小使用的比较器，默认为 <code>less&lt;类型&gt;</code>，可自定义</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; mp1;               <span class="comment">// int-&gt;int 的映射（键从小到大）</span></span><br><span class="line">map&lt;<span class="type">int</span>, <span class="type">int</span>, greater&lt;<span class="type">int</span>&gt;&gt; st2; <span class="comment">// int-&gt;int 的映射（键从大到小）</span></span><br></pre></td></tr></table></figure><blockquote><p>对于需要自定义比较器的情况，涉及一些初学时容易看迷糊的语法（重载小括号运算符 / lambda 表达式），在此就不展开讲了。</p></blockquote><h4 id="遍历-1"><a href="#遍历-1" class="headerlink" title="遍历"></a>遍历</h4><p>可使用迭代器进行遍历：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (map&lt;<span class="type">int</span>, <span class="type">int</span>&gt;::iterator it = mp.<span class="built_in">begin</span>(); it != mp.<span class="built_in">end</span>(); ++it)</span><br><span class="line">    cout &lt;&lt; it-&gt;first &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; it-&gt;second &lt;&lt; endl;</span><br></pre></td></tr></table></figure><p>基于范围的循环（C++ 11）：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> &amp;pr : mp)</span><br><span class="line">    cout &lt;&lt; pr.first &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; pr.second &lt;&lt; endl;</span><br></pre></td></tr></table></figure><p>结构化绑定 + 基于范围的循环（C++17）：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> &amp;[key, val] : mp)</span><br><span class="line">    cout &lt;&lt; key &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; val &lt;&lt; endl;</span><br></pre></td></tr></table></figure><h4 id="其他-2"><a href="#其他-2" class="headerlink" title="其他"></a>其他</h4><div class="table-container"><table><thead><tr><th>作用</th><th>用法</th><th>示例</th></tr></thead><tbody><tr><td>增 / 改 / 查元素</td><td>中括号</td><td><code>mp[1] = 2;</code></td></tr><tr><td>查元素（返回迭代器）</td><td><code>.find(元素)</code></td><td><code>auto it = mp.find(1);</code></td></tr><tr><td>删除元素</td><td><code>.erase(元素)</code></td><td><code>mp.erase(2);</code></td></tr><tr><td>判断元素是否存在</td><td><code>.count(元素)</code></td><td><code>mp.count(3);</code></td></tr><tr><td>查看大小 / 清空 / 判空</td><td>略</td><td>略</td></tr></tbody></table></div><p>增删改查时间复杂度均为 $O(\log n)$</p><h3 id="2-7-2-适用情形"><a href="#2-7-2-适用情形" class="headerlink" title="2.7.2 适用情形"></a>2.7.2 适用情形</h3><p>需要维护映射的场景可以使用：输入若干字符串，统计每种字符串的出现次数。(<code>map&lt;string, int&gt; mp</code>)</p><h3 id="2-7-3-注意事项"><a href="#2-7-3-注意事项" class="headerlink" title="2.7.3 注意事项"></a>2.7.3 注意事项</h3><h4 id="中括号访问时默认值"><a href="#中括号访问时默认值" class="headerlink" title="中括号访问时默认值"></a>中括号访问时默认值</h4><p>如果使用中括号访问 map 时对应的键不存在，那么会新增这个键，并且值为默认值，因此中括号会影响键的存在性。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">map&lt;<span class="type">char</span>, <span class="type">int</span>&gt; mp;</span><br><span class="line">cout &lt;&lt; mp.<span class="built_in">count</span>(<span class="string">&#x27;a&#x27;</span>) &lt;&lt; endl; <span class="comment">// 0</span></span><br><span class="line">mp[<span class="string">&#x27;a&#x27;</span>];                       <span class="comment">// 即使什么都没做，此时mp[&#x27;a&#x27;]=0已经插入了</span></span><br><span class="line">cout &lt;&lt; mp.<span class="built_in">count</span>(<span class="string">&#x27;a&#x27;</span>) &lt;&lt; endl; <span class="comment">// 1</span></span><br><span class="line">cout &lt;&lt; mp[<span class="string">&#x27;a&#x27;</span>] &lt;&lt; endl;       <span class="comment">// 0</span></span><br></pre></td></tr></table></figure><h4 id="不可用迭代器计算下标-1"><a href="#不可用迭代器计算下标-1" class="headerlink" title="不可用迭代器计算下标"></a>不可用迭代器计算下标</h4><p>map 的迭代器不能像 vector 一样相减得到下标。<strong>下面是错误用法：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> it = mp.<span class="built_in">find</span>(<span class="string">&#x27;a&#x27;</span>);      <span class="comment">// 正确，返回2所在位置的迭代器。</span></span><br><span class="line"><span class="type">int</span> idx = it - mp.<span class="built_in">begin</span>();   <span class="comment">// 错误！不可相减得到下标。</span></span><br></pre></td></tr></table></figure><h2 id="2-8-字符串-string"><a href="#2-8-字符串-string" class="headerlink" title="2.8 字符串 string"></a>2.8 字符串 <a href="https://zh.cppreference.com/w/cpp/string">string</a></h2><p><strong><code>#include &lt;string&gt;</code></strong></p><p>顾名思义，就是储存字符串的。</p><h3 id="2-8-1-常用方法"><a href="#2-8-1-常用方法" class="headerlink" title="2.8.1 常用方法"></a>2.8.1 常用方法</h3><h4 id="构造-4"><a href="#构造-4" class="headerlink" title="构造"></a>构造</h4><p>构造函数：<code>string(长度, 初值)</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">string s1;           <span class="comment">// 构造字符串，为空</span></span><br><span class="line">string s2 = <span class="string">&quot;awa!&quot;</span>;  <span class="comment">// 构造字符串，并赋值awa!</span></span><br><span class="line"><span class="function">string <span class="title">s3</span><span class="params">(<span class="number">10</span>, <span class="string">&#x27;6&#x27;</span>)</span></span>;  <span class="comment">// 构造字符串，通过构造函数构造为6666666666</span></span><br></pre></td></tr></table></figure><h4 id="输入输出"><a href="#输入输出" class="headerlink" title="输入输出"></a>输入输出</h4><p>C++</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">string s;</span><br><span class="line">cin &gt;&gt; s;</span><br><span class="line">cout &lt;&lt; s;</span><br></pre></td></tr></table></figure><p>C</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">string s;</span><br><span class="line"><span class="type">char</span> buf[<span class="number">100</span>];</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, &amp;buf);</span><br><span class="line">s = buf;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>, s.<span class="built_in">c_str</span>());</span><br></pre></td></tr></table></figure><h4 id="其他-3"><a href="#其他-3" class="headerlink" title="其他"></a>其他</h4><div class="table-container"><table><thead><tr><th>作用</th><th>用法</th><th>示例</th></tr></thead><tbody><tr><td>修改、查询指定下标字符</td><td><code>[]</code></td><td><code>s[1] = &#39;a&#39;;</code></td></tr><tr><td>是否相同</td><td><code>==</code></td><td><code>if (s1 == s2) ...</code></td></tr><tr><td>字符串连接</td><td><code>+</code></td><td><code>string s = s1 + s2;</code></td></tr><tr><td>尾接字符串</td><td><code>+=</code></td><td><code>s += &quot;awa&quot;;</code></td></tr><tr><td>取子串</td><td><code>.substr(起始下标, 子串长度)</code></td><td><code>string sub = s.substr(2, 10);</code></td></tr><tr><td>查找字符串</td><td><code>.find(字符串, 起始下标)</code></td><td><code>int pos = s.find(&quot;awa&quot;);</code></td></tr></tbody></table></div><h4 id="数值与字符串互转（C-11）"><a href="#数值与字符串互转（C-11）" class="headerlink" title="数值与字符串互转（C++11）"></a>数值与字符串互转（C++11）</h4><div class="table-container"><table><thead><tr><th>源</th><th>目的</th><th>函数</th></tr></thead><tbody><tr><td>int / long long / float / double / long double</td><td>string</td><td>to_string()</td></tr><tr><td>string</td><td>int</td><td>stoi()</td></tr><tr><td>string</td><td>long long</td><td>stoll()</td></tr><tr><td>string</td><td>float</td><td>stof()</td></tr><tr><td>string</td><td>double</td><td>stod()</td></tr><tr><td>string</td><td>long double</td><td>stold()</td></tr></tbody></table></div><h3 id="2-8-2-适用情形"><a href="#2-8-2-适用情形" class="headerlink" title="2.8.2 适用情形"></a>2.8.2 适用情形</h3><p>非常好用！<del>建议直接把字符数组扔了，赶快投入 string 的怀抱。</del></p><h3 id="2-8-3-注意事项"><a href="#2-8-3-注意事项" class="headerlink" title="2.8.3 注意事项"></a>2.8.3 注意事项</h3><h4 id="尾接字符串一定要用"><a href="#尾接字符串一定要用" class="headerlink" title="尾接字符串一定要用 +="></a>尾接字符串一定要用 <code>+=</code></h4><p>string 的 += 运算符，将会在原字符串原地尾接字符串。而 + 了再 = 赋值，会先生成一个临时变量，在复制给 string.</p><p>通常字符串长度可以很长，如果使用 + 字符串很容易就 TLE 了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 优化前: 15139ms</span></span><br><span class="line">string s;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5e5</span>; i++)</span><br><span class="line">    s = s + <span class="string">&quot;a&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 优化后: &lt; 1ms (计时器显示0)</span></span><br><span class="line">string s;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5e5</span>; i++)</span><br><span class="line">    s += <span class="string">&quot;a&quot;</span>;</span><br></pre></td></tr></table></figure><h4 id="substr-方法的奇葩参数"><a href="#substr-方法的奇葩参数" class="headerlink" title=".substr() 方法的奇葩参数"></a><code>.substr()</code> 方法的奇葩参数</h4><p>一定要注意，C++ string 的取子串的第一个参数是<strong>子串起点下标</strong>，第二个参数是<strong>子串长度</strong>。</p><p>第二个参数不是子串终点！不是子串终点！要与 java 等其他语言区分开来。</p><h4 id="find-方法的复杂度"><a href="#find-方法的复杂度" class="headerlink" title=".find() 方法的复杂度"></a><code>.find()</code> 方法的复杂度</h4><p>该方法实现为暴力实现，时间复杂度为 $O(n^2)$.</p><p><del>不要幻想 STL 内置了个 $O(n)$ 的 KMP 算法</del></p><h2 id="2-9-二元组-pair"><a href="#2-9-二元组-pair" class="headerlink" title="2.9 二元组 pair"></a>2.9 二元组 <a href="https://zh.cppreference.com/w/cpp/utility/pair">pair</a></h2><p><strong><code>#include &lt;utility&gt;</code></strong></p><p>顾名思义，就是储存二元组的。</p><h3 id="2-9-1-常用方法"><a href="#2-9-1-常用方法" class="headerlink" title="2.9.1 常用方法"></a>2.9.1 常用方法</h3><h4 id="构造-5"><a href="#构造-5" class="headerlink" title="构造"></a>构造</h4><p><strong><code>pair&lt;第一个值类型, 第二个值类型&gt; pr</code></strong></p><ul><li>第一个值类型：要储存的第一个值的数据类型</li><li>第二个值类型：要储存的第二个值的数据类型</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; p1;</span><br><span class="line">pair&lt;<span class="type">int</span>, <span class="type">long</span> <span class="type">long</span>&gt; p2;</span><br><span class="line">pair&lt;<span class="type">char</span>, <span class="type">int</span>&gt; p3;</span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure><h4 id="赋值"><a href="#赋值" class="headerlink" title="赋值"></a>赋值</h4><p>老式</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pair&lt;<span class="type">int</span>, <span class="type">char</span>&gt; pr = <span class="built_in">make_pair</span>(<span class="number">1</span>, <span class="string">&#x27;a&#x27;</span>);</span><br></pre></td></tr></table></figure><p>列表构造 C++11</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pair&lt;<span class="type">int</span>, <span class="type">char</span>&gt; pr = &#123;<span class="number">1</span>, <span class="string">&#x27;a&#x27;</span>&#125;;</span><br></pre></td></tr></table></figure><h4 id="取值"><a href="#取值" class="headerlink" title="取值"></a>取值</h4><p>直接取值</p><ul><li>取第一个值：<code>.first</code></li><li>取第二个值：<code>.second</code></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pair&lt;<span class="type">int</span>, <span class="type">char</span>&gt; pr = &#123;<span class="number">1</span>, <span class="string">&#x27;a&#x27;</span>&#125;;</span><br><span class="line"><span class="type">int</span> awa = pr.first;</span><br><span class="line"><span class="type">char</span> bwb = pr.second;</span><br></pre></td></tr></table></figure><p>结构化绑定 C++17</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pair&lt;<span class="type">int</span>, <span class="type">char</span>&gt; pr = &#123;<span class="number">1</span>, <span class="string">&#x27;a&#x27;</span>&#125;;</span><br><span class="line"><span class="keyword">auto</span> &amp;[awa, bwb] = pr;</span><br></pre></td></tr></table></figure><h4 id="判同"><a href="#判同" class="headerlink" title="判同"></a>判同</h4><p>直接用 <code>==</code> 运算符</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; p1 = &#123;<span class="number">1</span>, <span class="number">2</span>&#125;;</span><br><span class="line">pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; p2 = &#123;<span class="number">1</span>, <span class="number">3</span>&#125;;</span><br><span class="line"><span class="keyword">if</span> (p1 == p2) &#123; ... &#125; <span class="comment">// false</span></span><br></pre></td></tr></table></figure><h3 id="2-9-2-适用场景"><a href="#2-9-2-适用场景" class="headerlink" title="2.9.2 适用场景"></a>2.9.2 适用场景</h3><p>所有需要二元组的场景均可使用，效率和自己定义结构体差不多。</p><h3 id="2-9-3-注意事项"><a href="#2-9-3-注意事项" class="headerlink" title="2.9.3 注意事项"></a>2.9.3 注意事项</h3><p>无</p><h1 id="3-迭代器简介"><a href="#3-迭代器简介" class="headerlink" title="3 迭代器简介"></a>3 迭代器简介</h1><h2 id="3-1-迭代器是什么？"><a href="#3-1-迭代器是什么？" class="headerlink" title="3.1 迭代器是什么？"></a>3.1 迭代器是什么？</h2><p>不搞抽象，直接举例。</p><p>对于一个 vector，我们可以用下标遍历：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; a.<span class="built_in">size</span>(); i++)</span><br><span class="line">    cout &lt;&lt; a[i] &lt;&lt; endl;</span><br></pre></td></tr></table></figure><p>我们同时也可以用迭代器来遍历：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (vector&lt;<span class="type">int</span>&gt;::iterator it = a.<span class="built_in">begin</span>(); it != a.<span class="built_in">end</span>(); ++it)</span><br><span class="line">    cout &lt;&lt; *it &lt;&lt; endl;</span><br></pre></td></tr></table></figure><ul><li><code>a.begin()</code> 是一个迭代器，指向的是第一个元素</li><li><code>a.end()</code> 是一个迭代器，指向的是最后一个元素<strong>再后面一位</strong></li><li>上述迭代器具有自增运算符，自增则迭代器向下一个元素移动</li><li>迭代器与指针相似，如果对它使用解引用运算符，即 <code>*it</code>，就能取到对应值了</li></ul><h2 id="3-2-为何需要迭代器？"><a href="#3-2-为何需要迭代器？" class="headerlink" title="3.2 为何需要迭代器？"></a>3.2 为何需要迭代器？</h2><p>很多数据结构并不是线性的（例如红黑树），对于非线性数据结构，下标是无意义的。无法使用下标来遍历整个数据结构。</p><p>迭代器的作用就是定义某个数据结构的遍历方式，通过迭代器的增减，代表遍历到的位置，通过迭代器便能成功遍历非线性结构了。</p><p>例如，set 的实现是红黑树，我们是没法用下标来访问元素的。但是通过迭代器，我们就能遍历 set 中的元素了：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (set&lt;<span class="type">int</span>&gt;::iterator it = st.<span class="built_in">begin</span>(); it != st.<span class="built_in">end</span>(); ++it)</span><br><span class="line">    cout &lt;&lt; *it &lt;&lt; endl;</span><br></pre></td></tr></table></figure><h2 id="3-3-迭代器用法"><a href="#3-3-迭代器用法" class="headerlink" title="3.3 迭代器用法"></a>3.3 迭代器用法</h2><p>对于 vector 容器，它的迭代器功能比较完整，以它举例：</p><ul><li><code>.begin()</code>：头迭代器</li><li><code>.end()</code>：尾迭代器</li><li><code>.rbegin()</code>：反向头迭代器</li><li><code>.rend()</code>：反向尾迭代器</li><li>迭代器 <code>+</code> 整型：将迭代器向后移动</li><li>迭代器 <code>-</code> 整型：将迭代器向前移动</li><li>迭代器 <code>++</code>：将迭代器向后移动 1 位</li><li>迭代器 <code>--</code>：将迭代器向前移动 1 位</li><li>迭代器 <code>-</code> 迭代器：两个迭代器的距离</li><li><code>prev(it)</code>：返回 it 的前一个迭代器</li><li><code>next(it)</code>：返回 it 的后一个迭代器</li></ul><p>对于其他容器，由于其结构特性，上面的功能不一定都有（例如 set 的迭代器是不能相减求距离的）</p><h2 id="3-4-常见问题"><a href="#3-4-常见问题" class="headerlink" title="3.4 常见问题"></a>3.4 常见问题</h2><p><strong><code>.end()</code> 和 <code>.rend()</code> 指向的位置是无意义的值</strong></p><p>对于一个长度为 10 的数组：<code>for (int i = 0; i &lt; 10; i++)</code>，第 10 位是不可访问的</p><p>对于一个长度为 10 的容器：<code>for (auto it = a.begin(); it != a.end(); ++it)</code>，.end 是不可访问的</p><p><strong>不同容器的迭代器功能可能不一样</strong></p><p>迭代器细化的话有正向、反向、双向，每个容器的迭代器支持的运算符也可能不同，因此不同容器的迭代器细节很有可能是不一样的。</p><p><strong>删除操作时需要警惕</strong></p><p>为什么 3 没删掉？</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; a&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> it = a.<span class="built_in">begin</span>(); it != a.<span class="built_in">end</span>(); ++it)</span><br><span class="line">    <span class="keyword">if</span> (*it == <span class="number">2</span> || *it == <span class="number">3</span>)</span><br><span class="line">        a.<span class="built_in">erase</span>(it);</span><br><span class="line"><span class="comment">// a = [1, 3, 4]</span></span><br></pre></td></tr></table></figure><p>为啥 RE 了？</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; a&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> it = a.<span class="built_in">begin</span>(); it != a.<span class="built_in">end</span>(); ++it)</span><br><span class="line">    <span class="keyword">if</span> (*it == <span class="number">4</span>)</span><br><span class="line">        a.<span class="built_in">erase</span>(it);</span><br></pre></td></tr></table></figure><center><b>建议：如无必要，别用迭代器操作容器。（遍历与访问没关系）</b></center><h1 id="4-常用算法"><a href="#4-常用算法" class="headerlink" title="4 常用算法"></a>4 常用算法</h1><h2 id="4-1-内容总览"><a href="#4-1-内容总览" class="headerlink" title="4.1 内容总览"></a>4.1 内容总览</h2><p>打勾的是本次将会详细讲解的，其他的是算法竞赛中建议学习的，不在下表列出的在比赛中基本用不到。</p><p>（很多函数的功能很简单，自己都能快速写出来，但是使用函数可以让代码可读性变得更高，这在比赛中是至关紧要的）</p><ul><li><p>算法库 Algorithm</p><ul><li>[ ] <code>count()</code></li><li>[ ] <code>find()</code></li><li>[ ] <code>fill()</code></li><li>[x] <a href="https://zh.cppreference.com/w/cpp/algorithm/swap"><code>swap()</code></a></li><li>[x] <a href="https://zh.cppreference.com/w/cpp/algorithm/reverse"><code>reverse()</code></a></li><li>[ ] <code>shuffle()</code> C++11</li><li>[x] <a href="https://zh.cppreference.com/w/cpp/algorithm/unique"><code>unique()</code></a></li><li>[x] <a href="https://zh.cppreference.com/w/cpp/algorithm/sort"><code>sort()</code></a></li><li>[x] <a href="https://zh.cppreference.com/w/cpp/algorithm/lower_bound"><code>lower_bound()</code></a> / <a href="https://zh.cppreference.com/w/cpp/algorithm/upper_bound"><code>upper_bound()</code></a></li><li>[x] <a href="https://zh.cppreference.com/w/cpp/algorithm/max"><code>max()</code></a> / <a href="https://zh.cppreference.com/w/cpp/algorithm/min"><code>min()</code></a></li><li>[ ] <code>max_element()</code> / <code>min_element()</code></li><li>[ ] <code>prev_permutation()</code> / <code>next_permutation()</code></li></ul></li><li><p>数学函数 cmath</p><ul><li>[x] <a href="https://zh.cppreference.com/w/cpp/numeric/math/fabs"><code>abs()</code></a></li><li>[x] <a href="https://zh.cppreference.com/w/cpp/numeric/math/exp"><code>exp()</code></a></li><li>[x] <a href="https://zh.cppreference.com/w/cpp/numeric/math/log"><code>log()</code></a> / <code>log10()</code> / <code>log2()</code></li><li>[x] <a href="https://zh.cppreference.com/w/cpp/numeric/math/pow"><code>pow()</code></a></li><li>[x] <a href="https://zh.cppreference.com/w/cpp/numeric/math/sqrt"><code>sqrt()</code></a></li><li>[ ] <code>sin()</code> / <code>cos()</code> / <code>tan()</code></li><li>[ ] <code>asin()</code> / <code>acos()</code> / <code>atan()</code></li><li>[ ] <code>sinh()</code> / <code>cosh()</code> / <code>tanh()</code></li><li>[ ] <code>asinh()</code> / <code>acosh()</code> / <code>atanh()</code> C++11</li><li>[x] <a href="https://zh.cppreference.com/w/cpp/numeric/math/ceil"><code>ceil()</code></a> / <a href="https://zh.cppreference.com/w/cpp/numeric/math/floor"><code>floor()</code></a></li><li>[x] <a href="https://zh.cppreference.com/w/cpp/numeric/math/round"><code>round()</code></a> C++11</li></ul></li><li><p>数值算法 numeric</p><ul><li>[ ] <code>iota()</code> C++11</li><li>[ ] <code>accumulate()</code></li><li>[x] <a href="https://zh.cppreference.com/w/cpp/numeric/gcd"><code>gcd()</code></a> C++17</li><li>[x] <a href="https://zh.cppreference.com/w/cpp/numeric/lcm"><code>lcm()</code></a> C++17</li></ul></li><li><p>伪随机数生成 random</p><ul><li>[ ] <code>mt19937</code></li><li>[ ] <code>random_device()</code></li></ul></li></ul><h2 id="4-2-swap"><a href="#4-2-swap" class="headerlink" title="4.2 swap()"></a>4.2 <code>swap()</code></h2><p>交换两个变量的值</p><p><strong>用法示例</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt; <span class="keyword">class</span> T &gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">( T&amp; a, T&amp; b )</span></span>;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">0</span>, b = <span class="number">1</span>;</span><br><span class="line"><span class="built_in">swap</span>(a, b);</span><br><span class="line"><span class="comment">// now a = 1, b = 0</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> arr[<span class="number">10</span>] &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>&#125;;</span><br><span class="line"><span class="built_in">swap</span>(arr[<span class="number">4</span>], arr[<span class="number">6</span>]);</span><br><span class="line"><span class="comment">// now arr = &#123;0, 1, 2, 3, 6, 5, 4, 7, 8, 9&#125;</span></span><br></pre></td></tr></table></figure><p><strong>注意事项</strong></p><p>这个 swap 参数是引用的，不需要像 C 语言一样取地址。</p><h2 id="4-3-sort"><a href="#4-3-sort" class="headerlink" title="4.3 sort()"></a>4.3 <code>sort()</code></h2><p>使用快速排序给一个可迭代对象排序</p><p><strong>用法示例</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt; <span class="keyword">class</span> RandomIt, <span class="keyword">class</span> Compare &gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sort</span><span class="params">( RandomIt first, RandomIt last, Compare comp )</span></span>;</span><br></pre></td></tr></table></figure><p>默认排序从小到大</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; arr&#123;<span class="number">1</span>, <span class="number">9</span>, <span class="number">1</span>, <span class="number">9</span>, <span class="number">8</span>, <span class="number">1</span>, <span class="number">0</span>&#125;;</span><br><span class="line"><span class="built_in">sort</span>(arr.<span class="built_in">begin</span>(), arr.<span class="built_in">end</span>());</span><br><span class="line"><span class="comment">// arr = [0, 1, 1, 1, 8, 9, 9]</span></span><br></pre></td></tr></table></figure><p>如果要从大到小，则需要传比较器进去。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; arr&#123;<span class="number">1</span>, <span class="number">9</span>, <span class="number">1</span>, <span class="number">9</span>, <span class="number">8</span>, <span class="number">1</span>, <span class="number">0</span>&#125;;</span><br><span class="line"><span class="built_in">sort</span>(arr.<span class="built_in">begin</span>(), arr.<span class="built_in">end</span>(), <span class="built_in">greater</span>&lt;<span class="type">int</span>&gt;());</span><br><span class="line"><span class="comment">// arr = [9, 9, 8, 1, 1, 1, 0]</span></span><br></pre></td></tr></table></figure><p>如果需要完成特殊比较，则需要手写比较器。</p><p>比较器函数返回值是 bool 类型，传参是需要比较的两个元素。记我们定义的该比较操作为 $\star$：</p><ul><li>若 $a\star b$，则比较器函数应当返回 <code>true</code></li><li>若 $a\not\star b$，则比较器函数应当返回 <code>false</code></li></ul><p><strong>注意：</strong>如果 $a=b$，比较器函数必须返回 <code>false</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; a, pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (a.second != b.second)</span><br><span class="line">        <span class="keyword">return</span> a.second &lt; b.second;</span><br><span class="line">    <span class="keyword">return</span> a.first &gt; b.first;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt; arr&#123;&#123;<span class="number">1</span>, <span class="number">9</span>&#125;, &#123;<span class="number">2</span>, <span class="number">9</span>&#125;, &#123;<span class="number">8</span>, <span class="number">1</span>&#125;, &#123;<span class="number">0</span>, <span class="number">0</span>&#125;&#125;;</span><br><span class="line">    <span class="built_in">sort</span>(arr.<span class="built_in">begin</span>(), arr.<span class="built_in">end</span>(), cmp);</span><br><span class="line">    <span class="comment">// arr = [(0, 0), (8, 1), (2, 9), (1, 9)]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-4-lower-bound-upper-bound"><a href="#4-4-lower-bound-upper-bound" class="headerlink" title="4.4 lower_bound() / upper_bound()"></a>4.4 <code>lower_bound()</code> / <code>upper_bound()</code></h2><p>在<strong>已升序排序</strong>的元素中，应用二分查找检索指定元素，返回对应元素迭代器位置。<strong>找不到则返回尾迭代器。</strong></p><ul><li><code>lower_bound()</code>: 寻找 $\geq x$ 的第一个元素的位置</li><li><code>upper_bound()</code>: 寻找 $&gt;x$ 的第一个元素的位置</li></ul><p>怎么找 $\leq x$ / $&lt; x$ 的第一个元素呢？</p><ul><li>$&gt;x$ 的第一个元素的前一个元素（如果有）便是 $\leq x$ 的第一个元素</li><li>$\geq x$ 的第一个元素的前一个元素（如果有）便是 $&lt;x$ 的第一个元素</li></ul><p>返回的是迭代器，如何转成下标索引呢？减去头迭代器即可。</p><p><strong>用法示例</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt; <span class="keyword">class</span> ForwardIt, <span class="keyword">class</span> T &gt;</span></span><br><span class="line"><span class="function">ForwardIt <span class="title">lower_bound</span><span class="params">( ForwardIt first, ForwardIt last, <span class="type">const</span> T&amp; value )</span></span>;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; arr&#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">9</span>&#125;;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt;::iterator it = <span class="built_in">lower_bound</span>(arr.<span class="built_in">begin</span>(), arr.<span class="built_in">end</span>(), <span class="number">7</span>);</span><br><span class="line"><span class="type">int</span> idx = it - arr.<span class="built_in">begin</span>();</span><br><span class="line"><span class="comment">// idx = 4</span></span><br></pre></td></tr></table></figure><p>我们通常写成一行：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; arr&#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">9</span>&#125;;</span><br><span class="line">idx = <span class="built_in">lower_bound</span>(arr.<span class="built_in">begin</span>(), arr.<span class="built_in">end</span>(), <span class="number">7</span>) - arr.<span class="built_in">begin</span>(); <span class="comment">// 4</span></span><br><span class="line">idx = <span class="built_in">lower_bound</span>(arr.<span class="built_in">begin</span>(), arr.<span class="built_in">end</span>(), <span class="number">8</span>) - arr.<span class="built_in">begin</span>(); <span class="comment">// 4</span></span><br><span class="line">idx = <span class="built_in">upper_bound</span>(arr.<span class="built_in">begin</span>(), arr.<span class="built_in">end</span>(), <span class="number">7</span>) - arr.<span class="built_in">begin</span>(); <span class="comment">// 4</span></span><br><span class="line">idx = <span class="built_in">upper_bound</span>(arr.<span class="built_in">begin</span>(), arr.<span class="built_in">end</span>(), <span class="number">8</span>) - arr.<span class="built_in">begin</span>(); <span class="comment">// 5</span></span><br></pre></td></tr></table></figure><h2 id="4-5-reverse"><a href="#4-5-reverse" class="headerlink" title="4.5 reverse()"></a>4.5 <code>reverse()</code></h2><p>反转一个可迭代对象的元素顺序</p><p><strong>用法示例</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt; <span class="keyword">class</span> BidirIt &gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">reverse</span><span class="params">( BidirIt first, BidirIt last )</span></span>;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">arr</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line"><span class="built_in">iota</span>(arr.<span class="built_in">begin</span>(), arr.<span class="built_in">end</span>(), <span class="number">1</span>);</span><br><span class="line"><span class="comment">// 1, 2, 3, 4, 5, 6, 7, 8, 9, 10</span></span><br><span class="line"><span class="built_in">reverse</span>(arr.<span class="built_in">begin</span>(), arr.<span class="built_in">end</span>());</span><br><span class="line"><span class="comment">// 10, 9, 8, 7, 6, 5, 4, 3, 2, 1</span></span><br></pre></td></tr></table></figure><h2 id="4-6-max-min"><a href="#4-6-max-min" class="headerlink" title="4.6 max() / min()"></a>4.6 <code>max()</code> / <code>min()</code></h2><p>返回最大值 / 最小值的<strong>数值</strong></p><p><strong>用法示例</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> mx = <span class="built_in">max</span>(<span class="number">1</span>, <span class="number">2</span>); <span class="comment">// 2</span></span><br><span class="line"><span class="type">int</span> mn = <span class="built_in">min</span>(<span class="number">1</span>, <span class="number">2</span>); <span class="comment">// 1</span></span><br></pre></td></tr></table></figure><p>在 C++11 之后，可以使用列表构造语法传入一个列表，这样就能一次性给多个元素找最大值而不用套娃了：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Before C++11</span></span><br><span class="line"><span class="type">int</span> mx = <span class="built_in">max</span>(<span class="built_in">max</span>(<span class="number">1</span>, <span class="number">2</span>), <span class="built_in">max</span>(<span class="number">3</span>, <span class="number">4</span>)); <span class="comment">// 4</span></span><br><span class="line"><span class="type">int</span> mn = <span class="built_in">min</span>(<span class="built_in">min</span>(<span class="number">1</span>, <span class="number">2</span>), <span class="built_in">min</span>(<span class="number">3</span>, <span class="number">4</span>)); <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// After C++11</span></span><br><span class="line"><span class="type">int</span> mx = <span class="built_in">max</span>(&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;); <span class="comment">// 4</span></span><br><span class="line"><span class="type">int</span> mn = <span class="built_in">min</span>(&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;); <span class="comment">// 1</span></span><br></pre></td></tr></table></figure><h2 id="4-7-unique"><a href="#4-7-unique" class="headerlink" title="4.7 unique()"></a>4.7 <code>unique()</code></h2><p>消除数组的重复<strong>相邻</strong>元素，数组长度不变，但是有效数据缩短，返回的是有效数据位置的结尾迭代器。</p><p>例如：$[1,1,4,5,1,4]\to[1,4,5,1,4,\underline?]$，下划线位置为返回的迭代器指向。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt; <span class="keyword">class</span> ForwardIt &gt;</span></span><br><span class="line"><span class="function">ForwardIt <span class="title">unique</span><span class="params">( ForwardIt first, ForwardIt last )</span></span>;</span><br></pre></td></tr></table></figure><p><strong>用法示例</strong></p><p>单独使用 unique 并不能达成去重效果，因为它只消除<strong>相邻</strong>的重复元素。但是如果序列有序，那么它就能去重了。</p><p>但是它去重后，序列尾部会产生一些无效数据：$[1,1,2,4,4,4,5]\to[1,2,4,5,\underline?,?,?]$，为了删掉这些无效数据，我们需要结合 erase.</p><p>最终，给 vector 去重的写法便是：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; arr&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">4</span>&#125;;</span><br><span class="line"><span class="built_in">sort</span>(arr.<span class="built_in">begin</span>(), arr.<span class="built_in">end</span>());</span><br><span class="line">arr.<span class="built_in">erase</span>(<span class="built_in">unique</span>(arr.<span class="built_in">begin</span>(), arr.<span class="built_in">end</span>()), arr.<span class="built_in">end</span>());</span><br></pre></td></tr></table></figure><h2 id="4-8-数学函数"><a href="#4-8-数学函数" class="headerlink" title="4.8 数学函数"></a>4.8 数学函数</h2><p>所有函数参数均支持 <code>int</code> / <code>long long</code> / <code>float</code> / <code>double</code> / <code>long double</code></p><div class="table-container"><table><thead><tr><th>公式</th><th>示例</th></tr></thead><tbody><tr><td>$f(x)=\lvert x\rvert$</td><td><code>abs(-1.0)</code></td></tr><tr><td>$f(x)=e^x$</td><td><code>exp(2)</code></td></tr><tr><td>$f(x)=\ln x$</td><td><code>log(3)</code></td></tr><tr><td>$f(x,y)=x^y$</td><td><code>pow(2, 3)</code></td></tr><tr><td>$f(x)=\sqrt x$</td><td><code>sqrt(2)</code></td></tr><tr><td>$f(x)=\lceil x\rceil$</td><td><code>ceil(2.1)</code></td></tr><tr><td>$f(x)=\lfloor x\rfloor$</td><td><code>floor(2.1)</code></td></tr><tr><td>$f(x)=\left<x\right>$</td><td><code>rount(2.1)</code></td></tr></tbody></table></div><p><strong>注意事项</strong></p><p>由于浮点误差，有些的数学函数的行为可能与预期不符，导致 WA。如果你的操作数都是整型，那么用下面的写法会更稳妥。</p><blockquote><p>原文地址：<a href="https://codeforces.com/blog/entry/107717">https://codeforces.com/blog/entry/107717</a></p></blockquote><ul><li>$\lfloor\frac{a}{b}\rfloor$<ul><li>别用：<code>floor(1.0 * a / b)</code></li><li>要用：<code>a / b</code></li></ul></li><li>$\lceil\frac{a}{b}\rceil$<ul><li>别用：<code>ceil(1.0 * a / b)</code></li><li>要用：<code>(a + b - 1) / b</code>  （$\lceil\frac{a}{b}\rceil=\lfloor\frac{a+b-1}{b}\rfloor$）</li></ul></li><li>$\lfloor\sqrt a\rfloor$<ul><li>别用：<code>(int) sqrt(a)</code></li><li>要用：二分查找 <a href="https://io.zouht.com/7.html">https://io.zouht.com/7.html</a></li></ul></li><li>$a^b$<ul><li>别用：<code>pow(a, b)</code></li><li>要用：快速幂 <a href="https://io.zouht.com/18.html">https://io.zouht.com/18.html</a></li></ul></li><li>$\lfloor\log_2 a\rfloor$<ul><li>别用：<code>log2(a)</code></li><li>要用：<code>__lg</code> （不规范，但是这是竞赛）/ <code>bit_width</code>（C++20 可用）</li></ul></li></ul><h2 id="4-9-gcd-lcm"><a href="#4-9-gcd-lcm" class="headerlink" title="4.9 gcd() / lcm()"></a>4.9 <code>gcd()</code> / <code>lcm()</code></h2><p>（C++17）返回最大公因数 / 最小公倍数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> x = <span class="built_in">gcd</span>(<span class="number">8</span>, <span class="number">12</span>); <span class="comment">// 4</span></span><br><span class="line"><span class="type">int</span> y = <span class="built_in">lcm</span>(<span class="number">8</span>, <span class="number">12</span>); <span class="comment">// 24</span></span><br></pre></td></tr></table></figure><p>如果不是 C++17，但是是 GNU 编译器（g++），那么可以用内置函数 <code>__gcd()</code>.</p><p>当然，<code>gcd</code> / <code>lcm</code> 函数也挺好写，直接写也行（欧几里得算法）：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">gcd</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!b)</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">gcd</span>(b, a % b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">lcm</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a / <span class="built_in">gcd</span>(a, b) * b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> leetcode刷题笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> STL </tag>
            
            <tag> C++ </tag>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>欢迎来到本站</title>
      <link href="/posts/9b94e219.html"/>
      <url>/posts/9b94e219.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
  
  
    
    
    <entry>
      <title></title>
      <link href="/manifest.json"/>
      <url>/manifest.json</url>
      
        <content type="html"><![CDATA[{"name":"SumikiruのBlog","short_name":"SumikiruのBlog","theme_color":"#d9f8ff","background_color":"#d9f8ff","display":"standalone","scope":"/","start_url":"/","icons":[{"src":"/images/siteicon/16.png","sizes":"16x16","type":"image/png"},{"src":"/images/siteicon/32.png","sizes":"32x32","type":"image/png"},{"src":"/images/siteicon/48.png","sizes":"48x48","type":"image/png"},{"src":"/images/siteicon/64.png","sizes":"64x64","type":"image/png"},{"src":"/images/siteicon/128.png","sizes":"128x128","type":"image/png"},{"src":"/images/siteicon/144.png","sizes":"144x144","type":"image/png"},{"src":"/images/siteicon/256.png","sizes":"256x256","type":"image/png"},{"src":"/images/siteicon/512.png","sizes":"512x512","type":"image/png"}],"splash_pages":null}]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>分类</title>
      <link href="/categories/index.html"/>
      <url>/categories/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/js/ali_font.js"/>
      <url>/js/ali_font.js</url>
      
        <content type="html"><![CDATA[window._iconfont_svg_string_4494647='<svg><symbol id="icon-plane" viewBox="0 0 1048 1024"><path d="M615 692.199l54.446 51.45-245.185 259.621V654.885h74.927V814.83z" fill="#333333" ></path><path d="M424.26 654.885v-29.271L968.955 61.315l53.897 52.05-534.178 553.409-12.313-11.889z" fill="#999999" ></path><path d="M1046.378 19.806L894.851 845.824 18.956 539.948 1046.353 19.806zM209.87 527.236L836.933 746.27l108.494-591.347L209.895 527.31z" fill="#333333" ></path></symbol><symbol id="icon-a-haotianqitaiyang" viewBox="0 0 1146 1024"><path d="M418.449468 418.449468m-230.528002 0a230.528002 230.528002 0 1 0 461.056005 0 230.528002 230.528002 0 1 0-461.056005 0Z" fill="#FFD500" ></path><path d="M418.449468 129.672928a19.768721 19.768721 0 0 1-19.768721-19.768721V19.768721a19.768721 19.768721 0 0 1 39.537443 0v90.130543a19.768721 19.768721 0 0 1-19.768722 19.773664zM200.276917 220.045638a19.739068 19.739068 0 0 1-13.981429-5.787293L122.561131 150.519045a19.768721 19.768721 0 0 1 27.957914-27.957914l63.734358 63.734357a19.768721 19.768721 0 0 1-13.976486 33.75015zM109.904207 438.21819H19.768721a19.768721 19.768721 0 0 1 0-39.537443h90.135486a19.768721 19.768721 0 0 1 0 39.537443zM136.542559 720.120157a19.768721 19.768721 0 0 1-13.981428-33.745208l63.734357-63.734357a19.768721 19.768721 0 0 1 27.957915 27.952972l-63.734358 63.734357a19.709415 19.709415 0 0 1-13.976486 5.792236zM418.449468 836.898936a19.768721 19.768721 0 0 1-19.768721-19.768721V726.99473a19.768721 19.768721 0 0 1 39.537443 0v90.130543a19.768721 19.768721 0 0 1-19.768722 19.773663zM700.346493 720.120157a19.729184 19.729184 0 0 1-13.976486-5.792236l-63.724473-63.734357a19.768721 19.768721 0 1 1 27.952972-27.952972l63.724473 63.734357a19.768721 19.768721 0 0 1-13.976486 33.745208zM817.125273 438.21819H726.99473a19.768721 19.768721 0 0 1 0-39.537443h90.130543a19.768721 19.768721 0 0 1 0 39.537443z" fill="#6E6E96" ></path><path d="M415.039364 184.516303c-127.315508 0-230.52306 103.207552-230.523061 230.528003s103.207552 230.532945 230.523061 230.532945 230.532945-103.212494 230.532944-230.532945-103.217437-230.528002-230.532944-230.528003z m-9.370374 421.864515c-114.609162 0-207.522153-92.917933-207.522153-207.522153s92.912991-207.522153 207.522153-207.522153 207.536979 92.917933 207.536979 207.522153-92.927817 207.522153-207.536979 207.522153z" fill="#E69900" opacity=".46" ></path><path d="M432.168961 642.251163c-116.027568 0-210.082202-94.054634-210.082203-210.087144 0-116.027568 94.059576-210.082202 210.082203-210.082203 116.022626 0 210.082202 94.054634 210.082202 210.082203 0 13.813394-1.368984 27.285778-3.919149 40.357844a230.809707 230.809707 0 0 0 7.23041-57.482499c0-127.32045-103.20261-230.532945-230.528002-230.532945-127.315508 0-230.52306 103.207552-230.523061 230.528003s103.207552 230.532945 230.523061 230.532944c19.847796 0 39.107473-2.51557 57.482499-7.23041-13.05724 2.545223-26.539508 3.914207-40.34796 3.914207z" fill="#FFE97D" ></path><path d="M636.62202 220.045638a19.768721 19.768721 0 0 1-13.976486-33.745207L686.365065 122.566073a19.768721 19.768721 0 0 1 27.962856 27.957914l-63.729415 63.734358a19.679762 19.679762 0 0 1-13.976486 5.787293zM418.449468 668.746192c-138.015328 0-250.296724-112.286338-250.296724-250.301666 0-138.010386 112.281395-250.301666 250.296724-250.301666 138.015328 0 250.301666 112.286338 250.301666 250.301666s-112.286338 250.301666-250.301666 250.301666z m0-461.056005c-116.215371 0-210.759281 94.54391-210.759281 210.764223 0 116.215371 94.54391 210.764223 210.759281 210.764224s210.764223-94.548852 210.764223-210.764224-94.548852-210.764223-210.764223-210.764223z" fill="#6E6E96" ></path><path d="M984.852989 529.480492c0.019769-1.354157 0.103786-2.703373 0.103786-4.072357 0-144.454989-117.109906-261.589606-261.589606-261.589606-124.365026 0-228.388038 86.829167-254.947315 203.143381a162.177648 162.177648 0 0 0-12.355451-0.528813c-85.924748 0-155.579837 69.664974-155.579838 155.574895 0 18.424448 3.217359 36.087801 9.093612 52.485956a208.016371 208.016371 0 0 0-38.351319 120.613911c0 113.907373 91.109095 206.464526 204.418463 208.945501v0.11367h401.898106c137.773162 0 249.461495-111.698218 249.461496-249.47138 0.004942-99.327941-58.085446-185.094539-142.151934-225.215158z" fill="#D9F8FF" ></path><path d="M997.588988 529.164192c0.948899 8.866272 1.477712 17.851155 1.477712 26.969479 0 1.309678-0.069191 2.574876-0.103786 3.874669 61.544972 29.425742 108.386957 84.738624 126.534644 151.86826-11.619066-79.055117-60.353906-146.016718-127.90857-182.712408zM724.523639 257.551845c-124.365026 0-228.383096 86.824224-254.942373 203.143381a162.286376 162.286376 0 0 0-12.355451-0.528814c-85.924748 0-155.579837 69.664974-155.579837 155.574896 0 18.419506 3.222302 36.082859 9.098554 52.481013a208.026255 208.026255 0 0 0-38.35132 120.623796c0 101.235622 72.002626 185.568988 167.579452 204.808896-69.215236-30.96276-117.470685-100.489353-117.470685-181.33354a197.919497 197.919497 0 0 1 36.354678-114.584451 147.87992 147.87992 0 0 1-8.624104-49.861658c0-81.615166 66.032472-147.776135 147.484546-147.776134 3.948802 0 7.838298 0.207572 11.712967 0.513986 25.180409-110.4775 123.776907-192.952605 241.677562-192.952605 101.991776 0 189.56227 61.727833 227.651653 149.916099-27.705863-114.747543-130.982606-200.024865-254.235642-200.024865z" fill="#FFFFFF" opacity=".63" ></path><path d="M877.543427 1023.940694H475.650264c-0.92913 0-1.838491-0.064248-2.728084-0.187803-59.192494-1.878029-114.544914-26.168845-156.088882-68.552984-42.156798-43.001911-65.37022-99.861696-65.37022-160.09699 0-44.202861 12.533369-86.755034 36.339853-123.683005a174.938358 174.938358 0 0 1-7.082145-49.416862c0-95.749802 77.137551-173.816483 172.536458-175.323848 34.708933-120.104867 143.545628-202.629394 270.114867-202.629394 152.441553 0 276.954845 121.864283 281.239715 273.287747 86.764918 46.58005 142.16676 138.395876 142.16676 237.363038 0 148.463098-120.772061 269.240101-269.235159 269.240101z m-399.698835-39.537443h399.698835c126.653256 0 229.697716-103.04446 229.697717-229.702658 0-88.030116-51.378907-169.432769-130.898589-207.37883a19.763779 19.763779 0 0 1-11.24346-18.20205l0.059306-2.026294c0.019769-0.553524 0.04448-1.126817 0.044479-1.695168 0-133.335084-108.480859-241.820885-241.820884-241.820885-113.521883 0-210.428155 77.216626-235.677755 187.773201a19.753895 19.753895 0 0 1-20.806579 15.305932 141.855403 141.855403 0 0 0-10.818433-0.474449c-74.883917 0-135.811116 60.922257-135.811116 135.806174 0 15.706249 2.67372 31.115967 7.937142 45.818954a19.768721 19.768721 0 0 1-2.476032 18.08838 187.951119 187.951119 0 0 0-34.718817 109.192533c0 102.080735 83.02863 186.947856 185.084654 189.181721 0.583177 0.034595 1.166355 0.074133 1.749532 0.133439z" fill="#6E6E96" ></path><path d="M989.612309 526.821599c0.029653-1.364042 0.103786-2.708315 0.103786-4.077299 0-119.412962-80.053437-220.065407-189.389293-251.418599 79.094654 41.761424 133.033611 124.790054 133.03361 220.445955 0 1.31462-0.084017 44.583409-0.103785 45.883202 80.068264 38.203054 135.400915 77.9283 135.400915 172.546343 0 131.239599-106.37549 237.634858-237.629916 237.634858H448.201394v-0.118613c-67.282843-1.467828-126.332014-36.29043-161.278172-88.588583 27.379679 81.32852 103.380529 140.288731 193.486361 142.25572v0.11367h401.893164c137.773162 0 249.466438-111.698218 249.466438-249.47138-0.004942-99.322999-58.100272-185.094539-142.156876-225.205274z" fill="#6E6E96" opacity=".15" ></path></symbol></svg>',function(a){var t=(t=document.getElementsByTagName("script"))[t.length-1],e=t.getAttribute("data-injectcss"),t=t.getAttribute("data-disable-injectsvg");if(!t){var n,i,c,l,o,d=function(t,e){e.parentNode.insertBefore(t,e)};if(e&&!a.__iconfont__svg__cssinject__){a.__iconfont__svg__cssinject__=!0;try{document.write("<style>.svgfont {display: inline-block;width: 1em;height: 1em;fill: currentColor;vertical-align: -0.1em;font-size:16px;}</style>")}catch(t){console&&console.log(t)}}n=function(){var t,e=document.createElement("div");e.innerHTML=a._iconfont_svg_string_4494647,(e=e.getElementsByTagName("svg")[0])&&(e.setAttribute("aria-hidden","true"),e.style.position="absolute",e.style.width=0,e.style.height=0,e.style.overflow="hidden",e=e,(t=document.body).firstChild?d(e,t.firstChild):t.appendChild(e))},document.addEventListener?~["complete","loaded","interactive"].indexOf(document.readyState)?setTimeout(n,0):(i=function(){document.removeEventListener("DOMContentLoaded",i,!1),n()},document.addEventListener("DOMContentLoaded",i,!1)):document.attachEvent&&(c=n,l=a.document,o=!1,h(),l.onreadystatechange=function(){"complete"==l.readyState&&(l.onreadystatechange=null,s())})}function s(){o||(o=!0,c())}function h(){try{l.documentElement.doScroll("left")}catch(t){return void setTimeout(h,50)}s()}}(window);]]></content>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/css/clock.min.css"/>
      <url>/css/clock.min.css</url>
      
        <content type="html"><![CDATA[@font-face {    font-family: UnidreamLED;    src: url(https://cdn.cbd.int/anzhiyu-blog@1.1.6/fonts/UnidreamLED.ttf);    font-display: swap}@font-face {    font-family: RedditMono;    src: url(https://fonts.gstatic.com/s/redditmono/v1/oPWL_kRmmu4oQ88oo13o4-rLRjs.woff2);    font-display: swap}.card-clock-location,.card-clock-windDir,span.card-clock-weather {    font-family: ZhuZiAYuanJWD}span.temp {    font-family: UnidreamLED}#hexo_electric_clock {    padding: 20px}.card-clock {    padding: 0 !important}.card-background {    height: 153px;    margin: 15px;    border-radius: 8px;    box-shadow: inset 0 0 4px 2px rgb(145 148 154 / 40%);    z-index: 2}.clock-row {    font-family: UnidreamLED;    font-weight: 400;    color: #000;    display: flex;    justify-content: space-between;    flex-wrap: nowrap;    white-space: nowrap}.card-clock-clockdate,.card-clock-ip {    text-align: left}.card-clock-location,.card-clock-weather {    text-align: center}.card-clock-dackorlight,.card-clock-humidity {    text-align: right}.card-clock-time {    flex: 1;    font-family: RedditMono;    font-size: 38px;    text-align: center;    line-height: 1.5}[data-theme=dark] .card-background {    background-color: #212121}[data-theme=dark] .clock-row {    color: #fff}@font-face {    font-family: qweather-icons;    src: url(fonts/qweather-icons.woff2?5bb5b475709c49961682eda055eb3dc5) format("woff2"), url(fonts/qweather-icons.woff?5bb5b475709c49961682eda055eb3dc5) format("woff"), url(fonts/qweather-icons.ttf?5bb5b475709c49961682eda055eb3dc5) format("truetype")}[class*=" qi-"]::before,[class^=qi-]::before {    display: inline-block;    font-family: qweather-icons !important;    font-style: normal;    font-weight: 400 !important;    font-variant: normal;    text-transform: none;    line-height: 1;    vertical-align: -.125em;    -webkit-font-smoothing: antialiased;    -moz-osx-font-smoothing: grayscale}@media screen and (min-width:900px) {    .card-clock-humidity {        display: block    }}@media screen and (max-width:1086px) {    .card-clock-humidity {        display: none    }}.qi-100::before {    content: "\f101"}.qi-101::before {    content: "\f102"}.qi-102::before {    content: "\f103"}.qi-103::before {    content: "\f104"}.qi-104::before {    content: "\f105"}.qi-150::before {    content: "\f106"}.qi-151::before {    content: "\f107"}.qi-152::before {    content: "\f108"}.qi-153::before {    content: "\f109"}.qi-300::before {    content: "\f10a"}.qi-301::before {    content: "\f10b"}.qi-302::before {    content: "\f10c"}.qi-303::before {    content: "\f10d"}.qi-304::before {    content: "\f10e"}.qi-305::before {    content: "\f10f"}.qi-306::before {    content: "\f110"}.qi-307::before {    content: "\f111"}.qi-308::before {    content: "\f112"}.qi-309::before {    content: "\f113"}.qi-310::before {    content: "\f114"}.qi-311::before {    content: "\f115"}.qi-312::before {    content: "\f116"}.qi-313::before {    content: "\f117"}.qi-314::before {    content: "\f118"}.qi-315::before {    content: "\f119"}.qi-316::before {    content: "\f11a"}.qi-317::before {    content: "\f11b"}.qi-318::before {    content: "\f11c"}.qi-350::before {    content: "\f11d"}.qi-351::before {    content: "\f11e"}.qi-399::before {    content: "\f11f"}.qi-400::before {    content: "\f120"}.qi-401::before {    content: "\f121"}.qi-402::before {    content: "\f122"}.qi-403::before {    content: "\f123"}.qi-404::before {    content: "\f124"}.qi-405::before {    content: "\f125"}.qi-406::before {    content: "\f126"}.qi-407::before {    content: "\f127"}.qi-408::before {    content: "\f128"}.qi-409::before {    content: "\f129"}.qi-410::before {    content: "\f12a"}.qi-456::before {    content: "\f12b"}.qi-457::before {    content: "\f12c"}.qi-499::before {    content: "\f12d"}.qi-500::before {    content: "\f12e"}.qi-501::before {    content: "\f12f"}.qi-502::before {    content: "\f130"}.qi-503::before {    content: "\f131"}.qi-504::before {    content: "\f132"}.qi-507::before {    content: "\f133"}.qi-508::before {    content: "\f134"}.qi-509::before {    content: "\f135"}.qi-510::before {    content: "\f136"}.qi-511::before {    content: "\f137"}.qi-512::before {    content: "\f138"}.qi-513::before {    content: "\f139"}.qi-514::before {    content: "\f13a"}.qi-515::before {    content: "\f13b"}.qi-800::before {    content: "\f13c"}.qi-801::before {    content: "\f13d"}.qi-802::before {    content: "\f13e"}.qi-803::before {    content: "\f13f"}.qi-804::before {    content: "\f140"}.qi-805::before {    content: "\f141"}.qi-806::before {    content: "\f142"}.qi-807::before {    content: "\f143"}.qi-900::before {    content: "\f144"}.qi-901::before {    content: "\f145"}.qi-999::before {    content: "\f146"}.qi-1001::before {    content: "\f147"}.qi-1002::before {    content: "\f148"}.qi-1003::before {    content: "\f149"}.qi-1004::before {    content: "\f14a"}.qi-1005::before {    content: "\f14b"}.qi-1006::before {    content: "\f14c"}.qi-1007::before {    content: "\f14d"}.qi-1008::before {    content: "\f14e"}.qi-1009::before {    content: "\f14f"}.qi-1010::before {    content: "\f150"}.qi-1011::before {    content: "\f151"}.qi-1012::before {    content: "\f152"}.qi-1013::before {    content: "\f153"}.qi-1014::before {    content: "\f154"}.qi-1015::before {    content: "\f155"}.qi-1016::before {    content: "\f156"}.qi-1017::before {    content: "\f157"}.qi-1018::before {    content: "\f158"}.qi-1019::before {    content: "\f159"}.qi-1020::before {    content: "\f15a"}.qi-1021::before {    content: "\f15b"}.qi-1022::before {    content: "\f15c"}.qi-1023::before {    content: "\f15d"}.qi-1024::before {    content: "\f15e"}.qi-1025::before {    content: "\f15f"}.qi-1026::before {    content: "\f160"}.qi-1027::before {    content: "\f161"}.qi-1028::before {    content: "\f162"}.qi-1029::before {    content: "\f163"}.qi-1030::before {    content: "\f164"}.qi-1031::before {    content: "\f165"}.qi-1032::before {    content: "\f166"}.qi-1033::before {    content: "\f167"}.qi-1034::before {    content: "\f168"}.qi-1035::before {    content: "\f169"}.qi-1036::before {    content: "\f16a"}.qi-1037::before {    content: "\f16b"}.qi-1038::before {    content: "\f16c"}.qi-1039::before {    content: "\f16d"}.qi-1040::before {    content: "\f16e"}.qi-1041::before {    content: "\f16f"}.qi-1042::before {    content: "\f170"}.qi-1043::before {    content: "\f171"}.qi-1044::before {    content: "\f172"}.qi-1045::before {    content: "\f173"}.qi-1046::before {    content: "\f174"}.qi-1047::before {    content: "\f175"}.qi-1048::before {    content: "\f176"}.qi-1049::before {    content: "\f177"}.qi-1050::before {    content: "\f178"}.qi-1051::before {    content: "\f179"}.qi-1052::before {    content: "\f17a"}.qi-1053::before {    content: "\f17b"}.qi-1054::before {    content: "\f17c"}.qi-1055::before {    content: "\f17d"}.qi-1056::before {    content: "\f17e"}.qi-1057::before {    content: "\f17f"}.qi-1058::before {    content: "\f180"}.qi-1059::before {    content: "\f181"}.qi-1061::before {    content: "\f182"}.qi-1064::before {    content: "\f183"}.qi-1101::before {    content: "\f184"}.qi-1302::before {    content: "\f185"}.qi-1402::before {    content: "\f186"}.qi-1601::before {    content: "\f187"}.qi-1602::before {    content: "\f188"}.qi-1603::before {    content: "\f189"}.qi-1604::before {    content: "\f18a"}.qi-1605::before {    content: "\f18b"}.qi-1606::before {    content: "\f18c"}.qi-1607::before {    content: "\f18d"}.qi-2001::before {    content: "\f18e"}.qi-2002::before {    content: "\f18f"}.qi-2003::before {    content: "\f190"}.qi-2004::before {    content: "\f191"}.qi-2005::before {    content: "\f192"}.qi-2006::before {    content: "\f193"}.qi-2007::before {    content: "\f194"}.qi-2008::before {    content: "\f195"}.qi-2009::before {    content: "\f196"}.qi-2010::before {    content: "\f197"}.qi-2011::before {    content: "\f198"}.qi-2012::before {    content: "\f199"}.qi-2013::before {    content: "\f19a"}.qi-2014::before {    content: "\f19b"}.qi-2015::before {    content: "\f19c"}.qi-2016::before {    content: "\f19d"}.qi-2017::before {    content: "\f19e"}.qi-2018::before {    content: "\f19f"}.qi-2019::before {    content: "\f1a0"}.qi-2020::before {    content: "\f1a1"}.qi-2021::before {    content: "\f1a2"}.qi-2022::before {    content: "\f1a3"}.qi-2023::before {    content: "\f1a4"}.qi-2024::before {    content: "\f1a5"}.qi-2025::before {    content: "\f1a6"}.qi-2026::before {    content: "\f1a7"}.qi-2027::before {    content: "\f1a8"}.qi-2028::before {    content: "\f1a9"}.qi-9998::before {    content: "\f1aa"}.qi-9999::before {    content: "\f1ab"}.qi-100-fill::before {    content: "\f1ac"}.qi-101-fill::before {    content: "\f1ad"}.qi-102-fill::before {    content: "\f1ae"}.qi-103-fill::before {    content: "\f1af"}.qi-104-fill::before {    content: "\f1b0"}.qi-150-fill::before {    content: "\f1b1"}.qi-151-fill::before {    content: "\f1b2"}.qi-152-fill::before {    content: "\f1b3"}.qi-153-fill::before {    content: "\f1b4"}.qi-300-fill::before {    content: "\f1b5"}.qi-301-fill::before {    content: "\f1b6"}.qi-302-fill::before {    content: "\f1b7"}.qi-303-fill::before {    content: "\f1b8"}.qi-304-fill::before {    content: "\f1b9"}.qi-305-fill::before {    content: "\f1ba"}.qi-306-fill::before {    content: "\f1bb"}.qi-307-fill::before {    content: "\f1bc"}.qi-308-fill::before {    content: "\f1bd"}.qi-309-fill::before {    content: "\f1be"}.qi-310-fill::before {    content: "\f1bf"}.qi-311-fill::before {    content: "\f1c0"}.qi-312-fill::before {    content: "\f1c1"}.qi-313-fill::before {    content: "\f1c2"}.qi-314-fill::before {    content: "\f1c3"}.qi-315-fill::before {    content: "\f1c4"}.qi-316-fill::before {    content: "\f1c5"}.qi-317-fill::before {    content: "\f1c6"}.qi-318-fill::before {    content: "\f1c7"}.qi-350-fill::before {    content: "\f1c8"}.qi-351-fill::before {    content: "\f1c9"}.qi-399-fill::before {    content: "\f1ca"}.qi-400-fill::before {    content: "\f1cb"}.qi-401-fill::before {    content: "\f1cc"}.qi-402-fill::before {    content: "\f1cd"}.qi-403-fill::before {    content: "\f1ce"}.qi-404-fill::before {    content: "\f1cf"}.qi-405-fill::before {    content: "\f1d0"}.qi-406-fill::before {    content: "\f1d1"}.qi-407-fill::before {    content: "\f1d2"}.qi-408-fill::before {    content: "\f1d3"}.qi-409-fill::before {    content: "\f1d4"}.qi-410-fill::before {    content: "\f1d5"}.qi-456-fill::before {    content: "\f1d6"}.qi-457-fill::before {    content: "\f1d7"}.qi-499-fill::before {    content: "\f1d8"}.qi-500-fill::before {    content: "\f1d9"}.qi-501-fill::before {    content: "\f1da"}.qi-502-fill::before {    content: "\f1db"}.qi-503-fill::before {    content: "\f1dc"}.qi-504-fill::before {    content: "\f1dd"}.qi-507-fill::before {    content: "\f1de"}.qi-508-fill::before {    content: "\f1df"}.qi-509-fill::before {    content: "\f1e0"}.qi-510-fill::before {    content: "\f1e1"}.qi-511-fill::before {    content: "\f1e2"}.qi-512-fill::before {    content: "\f1e3"}.qi-513-fill::before {    content: "\f1e4"}.qi-514-fill::before {    content: "\f1e5"}.qi-515-fill::before {    content: "\f1e6"}.qi-900-fill::before {    content: "\f1e7"}.qi-901-fill::before {    content: "\f1e8"}.qi-999-fill::before {    content: "\f1e9"}.qi-sunny::before {    content: "\f101"}.qi-cloudy::before {    content: "\f102"}.qi-few-clouds::before {    content: "\f103"}.qi-partly-cloudy::before {    content: "\f104"}.qi-overcast::before {    content: "\f105"}.qi-clear-night::before {    content: "\f106"}.qi-cloudy-night::before {    content: "\f107"}.qi-few-clouds-night::before {    content: "\f108"}.qi-partly-cloudy-night::before {    content: "\f109"}.qi-shower-rain::before {    content: "\f10a"}.qi-heavy-shower-rain::before {    content: "\f10b"}.qi-thundershower::before {    content: "\f10c"}.qi-heavy-thunderstorm::before {    content: "\f10d"}.qi-thundershower-with-hail::before {    content: "\f10e"}.qi-light-rain::before {    content: "\f10f"}.qi-moderate-rain::before {    content: "\f110"}.qi-heavy-rain::before {    content: "\f111"}.qi-extreme-rain::before {    content: "\f112"}.qi-drizzle-rain::before {    content: "\f113"}.qi-storm::before {    content: "\f114"}.qi-heavy-storm::before {    content: "\f115"}.qi-severe-storm::before {    content: "\f116"}.qi-freezing-rain::before {    content: "\f117"}.qi-light-to-moderate-rain::before {    content: "\f118"}.qi-moderate-to-heavy-rain::before {    content: "\f119"}.qi-heavy-rain-to-storm::before {    content: "\f11a"}.qi-storm-to-heavy-storm::before {    content: "\f11b"}.qi-heavy-to-severe-storm::before {    content: "\f11c"}.qi-shower-rain-night::before {    content: "\f11d"}.qi-heavy-shower-rain-night::before {    content: "\f11e"}.qi-rain::before {    content: "\f11f"}.qi-light-snow::before {    content: "\f120"}.qi-moderate-snow::before {    content: "\f121"}.qi-heavy-snow::before {    content: "\f122"}.qi-snowstorm::before {    content: "\f123"}.qi-sleet::before {    content: "\f124"}.qi-rain-and-snow::before {    content: "\f125"}.qi-shower-snow::before {    content: "\f126"}.qi-snow-flurry::before {    content: "\f127"}.qi-light-to-moderate-snow::before {    content: "\f128"}.qi-moderate-to-heavy-snow::before {    content: "\f129"}.qi-heavy-snow-to-snowstorm::before {    content: "\f12a"}.qi-shower-snow-night::before {    content: "\f12b"}.qi-snow-flurry-night::before {    content: "\f12c"}.qi-snow::before {    content: "\f12d"}.qi-mist::before {    content: "\f12e"}.qi-foggy::before {    content: "\f12f"}.qi-haze::before {    content: "\f130"}.qi-sand::before {    content: "\f131"}.qi-dust::before {    content: "\f132"}.qi-duststorm::before {    content: "\f133"}.qi-sandstorm::before {    content: "\f134"}.qi-dense-fog::before {    content: "\f135"}.qi-strong-fog::before {    content: "\f136"}.qi-moderate-haze::before {    content: "\f137"}.qi-heavy-haze::before {    content: "\f138"}.qi-severe-haze::before {    content: "\f139"}.qi-heavy-fog::before {    content: "\f13a"}.qi-extra-heavy-fog::before {    content: "\f13b"}.qi-new-moon::before {    content: "\f13c"}.qi-waxing-crescent::before {    content: "\f13d"}.qi-first-quarter::before {    content: "\f13e"}.qi-waxing-gibbous::before {    content: "\f13f"}.qi-full-moon::before {    content: "\f140"}.qi-waning-gibbous::before {    content: "\f141"}.qi-last-quarter::before {    content: "\f142"}.qi-waning-crescent::before {    content: "\f143"}.qi-hot::before {    content: "\f144"}.qi-cold::before {    content: "\f145"}.qi-unknown::before {    content: "\f146"}.qi-typhoon::before {    content: "\f147"}.qi-tornado::before {    content: "\f148"}.qi-rainstorm::before {    content: "\f149"}.qi-snow-storm::before {    content: "\f14a"}.qi-cold-wave::before {    content: "\f14b"}.qi-gale::before {    content: "\f14c"}.qi-sandstorm-warning::before {    content: "\f14d"}.qi-low-temperature-freeze::before {    content: "\f14e"}.qi-high-temperature::before {    content: "\f14f"}.qi-heat-wave::before {    content: "\f150"}.qi-dry-hot-air::before {    content: "\f151"}.qi-downburst::before {    content: "\f152"}.qi-avalanche::before {    content: "\f153"}.qi-lightning::before {    content: "\f154"}.qi-hail::before {    content: "\f155"}.qi-frost::before {    content: "\f156"}.qi-heavy-fog-warning::before {    content: "\f157"}.qi-low-level-wind-shearl::before {    content: "\f158"}.qi-haze-warning::before {    content: "\f159"}.qi-thunder-gust::before {    content: "\f15a"}.qi-road-icing::before {    content: "\f15b"}.qi-drought::before {    content: "\f15c"}.qi-gale-at-sea::before {    content: "\f15d"}.qi-heat-stroke::before {    content: "\f15e"}.qi-wildfire::before {    content: "\f15f"}.qi-grassland-fire::before {    content: "\f160"}.qi-freeze::before {    content: "\f161"}.qi-space-weather::before {    content: "\f162"}.qi-heavy-air-pollution::before {    content: "\f163"}.qi-low-temperature-rain-and-snow::before {    content: "\f164"}.qi-strong-convection::before {    content: "\f165"}.qi-ozone::before {    content: "\f166"}.qi-heavy-snow-warning::before {    content: "\f167"}.qi-cold-warning::before {    content: "\f168"}.qi-continuous-rain::before {    content: "\f169"}.qi-waterlogging::before {    content: "\f16a"}.qi-geological-hazard::before {    content: "\f16b"}.qi-heavy-rainfall::before {    content: "\f16c"}.qi-severely-falling-temperature::before {    content: "\f16d"}.qi-snow-disaster::before {    content: "\f16e"}.qi-wildfire-grassland::before {    content: "\f16f"}.qi-medical-meteorology::before {    content: "\f170"}.qi-thunderstorm::before {    content: "\f171"}.qi-school-closure::before {    content: "\f172"}.qi-factory-closure::before {    content: "\f173"}.qi-maritime-risk::before {    content: "\f174"}.qi-spring-dust::before {    content: "\f175"}.qi-falling-temperature::before {    content: "\f176"}.qi-typhoon-and-rainstorm::before {    content: "\f177"}.qi-severe-cold::before {    content: "\f178"}.qi-sand-dust::before {    content: "\f179"}.qi-sea-thunderstorms::before {    content: "\f17a"}.qi-sea-fog::before {    content: "\f17b"}.qi-sea-thunder::before {    content: "\f17c"}.qi-sea-typhoon::before {    content: "\f17d"}.qi-low-temperature::before {    content: "\f17e"}.qi-road-ice-and-snow::before {    content: "\f17f"}.qi-thunderstorm-and-gale::before {    content: "\f180"}.qi-continuous-low-temperature::before {    content: "\f181"}.qi-strong-dust::before {    content: "\f182"}.qi-short-lived-heavy-shower-rain::before {    content: "\f183"}.qi-flood::before {    content: "\f184"}.qi-mudflow::before {    content: "\f185"}.qi-storm-surge::before {    content: "\f186"}.qi-very-hot-weather::before {    content: "\f187"}.qi-strong-monsoon-signal::before {    content: "\f188"}.qi-landslip::before {    content: "\f189"}.qi-tropical-cyclone::before {    content: "\f18a"}.qi-fire-danger::before {    content: "\f18b"}.qi-flooding-in-the-northern-new-territories::before {    content: "\f18c"}.qi-cold-weather::before {    content: "\f18d"}.qi-wind::before {    content: "\f18e"}.qi-snow-ice::before {    content: "\f18f"}.qi-fog::before {    content: "\f190"}.qi-coastal-event::before {    content: "\f191"}.qi-forest-fire::before {    content: "\f192"}.qi-rain-warning::before {    content: "\f193"}.qi-rain-flood::before {    content: "\f194"}.qi-freezing-rain-icing::before {    content: "\f195"}.qi-ground-frost::before {    content: "\f196"}.qi-dust-raising-winds::before {    content: "\f197"}.qi-strong-surface-winds::before {    content: "\f198"}.qi-hot-day::before {    content: "\f199"}.qi-warm-night::before {    content: "\f19a"}.qi-cold-day::before {    content: "\f19b"}.qi-thunderstorm-and-lightning::before {    content: "\f19c"}.qi-hailstorm::before {    content: "\f19d"}.qi-sea-area-warning::before {    content: "\f19e"}.qi-fishermen-warning::before {    content: "\f19f"}.qi-low-humidity::before {    content: "\f1a0"}.qi-accumulated-rain::before {    content: "\f1a1"}.qi-hazardous-surf-warning::before {    content: "\f1a2"}.qi-marine-wind-warning::before {    content: "\f1a3"}.qi-road-weather-alert::before {    content: "\f1a4"}.qi-thunder-rain::before {    content: "\f1a5"}.qi-thunder-rain-and-fog::before {    content: "\f1a6"}.qi-damaging-winds::before {    content: "\f1a7"}.qi-veld-fire-conditions::before {    content: "\f1a8"}.qi-weather-advisory::before {    content: "\f1a9"}.qi-severe-weather-warning::before {    content: "\f1aa"}.qi-warning-default::before {    content: "\f1ab"}.qi-sunny-fill::before {    content: "\f1ac"}.qi-cloudy-fill::before {    content: "\f1ad"}.qi-few-clouds-fill::before {    content: "\f1ae"}.qi-partly-cloudy-fill::before {    content: "\f1af"}.qi-overcast-fill::before {    content: "\f1b0"}.qi-clear-night-fill::before {    content: "\f1b1"}.qi-cloudy-night-fill::before {    content: "\f1b2"}.qi-few-clouds-night-fill::before {    content: "\f1b3"}.qi-partly-cloudy-night-fill::before {    content: "\f1b4"}.qi-shower-rain-fill::before {    content: "\f1b5"}.qi-heavy-shower-rain-fill::before {    content: "\f1b6"}.qi-thundershower-fill::before {    content: "\f1b7"}.qi-heavy-thunderstorm-fill::before {    content: "\f1b8"}.qi-thundershower-with-hail-fill::before {    content: "\f1b9"}.qi-light-rain-fill::before {    content: "\f1ba"}.qi-moderate-rain-fill::before {    content: "\f1bb"}.qi-heavy-rain-fill::before {    content: "\f1bc"}.qi-extreme-rain-fill::before {    content: "\f1bd"}.qi-drizzle-rain-fill::before {    content: "\f1be"}.qi-storm-fill::before {    content: "\f1bf"}.qi-heavy-storm-fill::before {    content: "\f1c0"}.qi-severe-storm-fill::before {    content: "\f1c1"}.qi-freezing-rain-fill::before {    content: "\f1c2"}.qi-light-to-moderate-rain-fill::before {    content: "\f1c3"}.qi-moderate-to-heavy-rain-fill::before {    content: "\f1c4"}.qi-heavy-rain-to-storm-fill::before {    content: "\f1c5"}.qi-storm-to-heavy-storm-fill::before {    content: "\f1c6"}.qi-heavy-to-severe-storm-fill::before {    content: "\f1c7"}.qi-shower-rain-night-fill::before {    content: "\f1c8"}.qi-heavy-shower-rain-night-fill::before {    content: "\f1c9"}.qi-rain-fill::before {    content: "\f1ca"}.qi-light-snow-fill::before {    content: "\f1cb"}.qi-moderate-snow-fill::before {    content: "\f1cc"}.qi-heavy-snow-fill::before {    content: "\f1cd"}.qi-snowstorm-fill::before {    content: "\f1ce"}.qi-sleet-fill::before {    content: "\f1cf"}.qi-rain-and-snow-fill::before {    content: "\f1d0"}.qi-shower-snow-fill::before {    content: "\f1d1"}.qi-snow-flurry-fill::before {    content: "\f1d2"}.qi-light-to-moderate-snow-fill::before {    content: "\f1d3"}.qi-moderate-to-heavy-snow-fill::before {    content: "\f1d4"}.qi-heavy-snow-to-snowstorm-fill::before {    content: "\f1d5"}.qi-shower-snow-night-fill::before {    content: "\f1d6"}.qi-snow-flurry-night-fill::before {    content: "\f1d7"}.qi-snow-fill::before {    content: "\f1d8"}.qi-mist-fill::before {    content: "\f1d9"}.qi-foggy-fill::before {    content: "\f1da"}.qi-haze-fill::before {    content: "\f1db"}.qi-sand-fill::before {    content: "\f1dc"}.qi-dust-fill::before {    content: "\f1dd"}.qi-duststorm-fill::before {    content: "\f1de"}.qi-sandstorm-fill::before {    content: "\f1df"}.qi-dense-fog-fill::before {    content: "\f1e0"}.qi-strong-fog-fill::before {    content: "\f1e1"}.qi-moderate-haze-fill::before {    content: "\f1e2"}.qi-heavy-haze-fill::before {    content: "\f1e3"}.qi-severe-haze-fill::before {    content: "\f1e4"}.qi-heavy-fog-fill::before {    content: "\f1e5"}.qi-extra-heavy-fog-fill::before {    content: "\f1e6"}.qi-hot-fill::before {    content: "\f1e7"}.qi-cold-fill::before {    content: "\f1e8"}.qi-unknown-fill::before {    content: "\f1e9"}]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>标签</title>
      <link href="/tags/index.html"/>
      <url>/tags/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/css/custom.css"/>
      <url>/css/custom.css</url>
      
        <content type="html"><![CDATA[/* @font-face {  font-family: Candyhome;  src: url(https://npm.elemecdn.com/anzhiyu-blog@1.1.6/fonts/Candyhome.ttf);  font-display: swap;  font-weight: lighter;} */@font-face {    font-family: ZhuZiAYuanJWD;    src: url(https://npm.elemecdn.com/anzhiyu-blog@1.1.6/fonts/ZhuZiAWan.woff2);    font-display: swap;    font-weight: lighter;}div#menus {    font-family: "ZhuZiAYuanJWD";}h1#site-title {    font-family: ZhuZiAYuanJWD;    font-size: 3em !important;}a.article-title,a.blog-slider__title,a.categoryBar-list-link,h1.post-title {    font-family: ZhuZiAYuanJWD;}.iconfont {    font-family: "iconfont" !important;    font-size: 3em;    /* 可以定义图标大小 */    font-style: normal;    -webkit-font-smoothing: antialiased;    -moz-osx-font-smoothing: grayscale;}/* 时间轴生肖icon */svg.icon {    /* 这里定义svg.icon，避免和Butterfly自带的note标签冲突 */    width: 1em;    height: 1em;    /* width和height定义图标的默认宽度和高度*/    vertical-align: -0.15em;    fill: currentColor;    overflow: hidden;}.icon-zhongbiao::before {    color: #f7c768;}/* bilibli番剧插件 */#article-container .bangumi-tab.bangumi-active {    background: var(--anzhiyu-theme);    color: var(--anzhiyu-ahoverbg);    border-radius: 10px;}a.bangumi-tab:hover {    text-decoration: none !important;}.bangumi-button:hover {    background: var(--anzhiyu-theme) !important;    border-radius: 10px !important;    color: var(--anzhiyu-ahoverbg) !important;}a.bangumi-button.bangumi-nextpage:hover {    text-decoration: none !important;}.bangumi-button {    padding: 5px 10px !important;}a.bangumi-tab {    padding: 5px 10px !important;}svg.icon.faa-tada {    font-size: 1.1em;}.bangumi-info-item {    border-right: 1px solid #f2b94b;}.bangumi-info-item span {    color: #f2b94b;}.bangumi-info-item em {    color: #f2b94b;}/* 解决artitalk的图标问题 */#uploadSource>svg {    width: 1.19em;    height: 1.5em;}/*top-img黑色透明玻璃效果移除，不建议加，除非你执着于完全一图流或者背景图对比色明显 */#page-header:not(.not-top-img):before {    background-color: transparent !important;}/* 首页文章卡片 */#recent-posts>.recent-post-item {    background: rgba(255, 255, 255, 0.9);}/* 首页侧栏卡片 */#aside-content .card-widget {    background: rgba(255, 255, 255, 0.9);}/* 文章页面正文背景 */div#post {    background: rgba(255, 255, 255, 0.9);}/* 分页页面 */div#page {    background: rgba(255, 255, 255, 0.9);}/* 归档页面 */div#archive {    background: rgba(255, 255, 255, 0.9);}/* 标签页面 */div#tag {    background: rgba(255, 255, 255, 0.9);}/* 分类页面 */div#category {    background: rgba(255, 255, 255, 0.9);}/*夜间模式伪类遮罩层透明*/[data-theme="dark"] #recent-posts>.recent-post-item {    background: #121212;}[data-theme="dark"] .card-widget {    background: #121212 !important;}[data-theme="dark"] div#post {    background: #121212 !important;}[data-theme="dark"] div#tag {    background: #121212 !important;}[data-theme="dark"] div#archive {    background: #121212 !important;}[data-theme="dark"] div#page {    background: #121212 !important;}[data-theme="dark"] div#category {    background: #121212 !important;}[data-theme="dark"] div#category {    background: transparent !important;}/* 页脚透明 */#footer {    background: transparent !important;}/* 头图透明 */#page-header {    background: transparent !important;}#rightside>div>button {    border-radius: 5px;}/* 滚动条 */::-webkit-scrollbar {    width: 10px;    height: 10px;}::-webkit-scrollbar-thumb {    background-color: #3b70fc;    border-radius: 2em;}::-webkit-scrollbar-corner {    background-color: transparent;}::-moz-selection {    color: #fff;    background-color: #3b70fc;}/* 音乐播放器 *//* .aplayer .aplayer-lrc {    display: none !important;  } */.aplayer.aplayer-fixed.aplayer-narrow .aplayer-body {    left: -66px !important;    transition: all 0.3s;    /* 默认情况下缩进左侧66px，只留一点箭头部分 */}.aplayer.aplayer-fixed.aplayer-narrow .aplayer-body:hover {    left: 0 !important;    transition: all 0.3s;    /* 鼠标悬停是左侧缩进归零，完全显示按钮 */}.aplayer.aplayer-fixed {    z-index: 999999 !important;}/* 评论框  */.vwrap {    box-shadow: 2px 2px 5px #bbb;    background: rgba(255, 255, 255, 0.3);    border-radius: 8px;    padding: 30px;    margin: 30px 0px 30px 0px;}/* 设置评论框 */.vcard {    box-shadow: 2px 2px 5px #bbb;    background: rgba(255, 255, 255, 0.3);    border-radius: 8px;    padding: 30px;    margin: 30px 0px 0px 0px;}/* md网站下划线 */#article-container a:hover {    text-decoration: none !important;}#article-container #hpp_talk p img {    display: inline;}/* 404页面 */#error-wrap {    position: absolute;    top: 40%;    right: 0;    left: 0;    margin: 0 auto;    padding: 0 1rem;    max-width: 1000px;    transform: translate(0, -50%);}#error-wrap .error-content {    display: flex;    flex-direction: row;    justify-content: center;    align-items: center;    margin: 0 1rem;    height: 18rem;    border-radius: 8px;    background: var(--card-bg);    box-shadow: var(--card-box-shadow);    transition: all 0.3s;}#error-wrap .error-content .error-img {    box-flex: 1;    flex: 1;    height: 100%;    border-top-left-radius: 8px;    border-bottom-left-radius: 8px;    background-color: #3b70fc;    background-position: center;    background-size: cover;}#error-wrap .error-content .error-info {    box-flex: 1;    flex: 1;    padding: 0.5rem;    text-align: center;    font-size: 14px;    font-family: Titillium Web, "PingFang SC", "Hiragino Sans GB", "Microsoft JhengHei", "Microsoft YaHei", sans-serif;}#error-wrap .error-content .error-info .error_title {    margin-top: -4rem;    font-size: 9em;}#error-wrap .error-content .error-info .error_subtitle {    margin-top: -3.5rem;    word-break: break-word;    font-size: 1.6em;}#error-wrap .error-content .error-info a {    display: inline-block;    margin-top: 0.5rem;    padding: 0.3rem 1.5rem;    background: var(--btn-bg);    color: var(--btn-color);}#body-wrap.error .aside-list {    display: flex;    flex-direction: row;    flex-wrap: nowrap;    bottom: 0px;    position: absolute;    padding: 1rem;    width: 100%;    overflow: scroll;}#body-wrap.error .aside-list .aside-list-group {    display: flex;    flex-direction: row;    flex-wrap: nowrap;    max-width: 1200px;    margin: 0 auto;}#body-wrap.error .aside-list .aside-list-item {    padding: 0.5rem;}#body-wrap.error .aside-list .aside-list-item img {    width: 100%;    object-fit: cover;    border-radius: 12px;}#body-wrap.error .aside-list .aside-list-item .thumbnail {    overflow: hidden;    width: 230px;    height: 143px;    background: var(--anzhiyu-card-bg);    display: flex;}#body-wrap.error .aside-list .aside-list-item .content .title {    -webkit-line-clamp: 2;    overflow: hidden;    display: -webkit-box;    -webkit-box-orient: vertical;    line-height: 1.5;    justify-content: center;    align-items: flex-end;    align-content: center;    padding-top: 0.5rem;    color: white;}#body-wrap.error .aside-list .aside-list-item .content time {    display: none;}/* 代码框主题 */#article-container figure.highlight {    border-radius: 10px;}]]></content>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/js/runtime/runtime.min.js"/>
      <url>/js/runtime/runtime.min.js</url>
      
        <content type="html"><![CDATA[var now = new Date; function createtime() { var t = new Date("04/05/2024 00:00:00"); now.setTime(now.getTime() + 250); var e = (now - t) / 1e3 / 60 / 60 / 24, a = Math.floor(e), n = (now - t) / 1e3 / 60 / 60 - 24 * a, r = Math.floor(n); 1 == String(r).length && (r = "0" + r); var s = (now - t) / 1e3 / 60 - 1440 * a - 60 * r, i = Math.floor(s); 1 == String(i).length && (i = "0" + i); var o = (now - t) / 1e3 - 86400 * a - 3600 * r - 60 * i, l = Math.round(o); 1 == String(l).length && (l = "0" + l); let g = ""; g = r < 18 && r >= 9 ? `<img class='boardsign' src='https://img.shields.io/badge/simukiru-%E6%91%B8%E9%B1%BC%E4%B8%AD-blue?style=social&logo=Youtube%20Gaming' title='玩得舒心之后，学的才舒心~'><span class='textTip'> <br> 本站居然运行了 ${a} 天</span><span id='runtime'> ${r} 小时 ${i} 分 ${l} 秒 </span> <i class='fas fa-heartbeat' style='color:red'></i>` : `<img class='boardsign' src='https://img.shields.io/badge/simukiru-%E6%91%B8%E9%B1%BC%E4%B8%AD~-blue?style=social&logo=Youtube%20Gaming' title='养精蓄锐不失为一种选择~'><span class='textTip'> <br> 本站居然运行了 ${a} 天</span><span id='runtime'> ${r} 小时 ${i} 分 ${l} 秒 </span> <i class='fas fa-heartbeat' style='color:red'></i>`, document.getElementById("workboard") && (document.getElementById("workboard").innerHTML = g) } setInterval((() => { createtime() }), 250);]]></content>
      
    </entry>
    
    
  
</search>
