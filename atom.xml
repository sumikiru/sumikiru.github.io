<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>SumikiruのBlog</title>
  
  <subtitle>寄美好于未来，收嫌心于现今</subtitle>
  <link href="https://sumikiru.top/atom.xml" rel="self"/>
  
  <link href="https://sumikiru.top/"/>
  <updated>2025-02-06T14:42:00.323Z</updated>
  <id>https://sumikiru.top/</id>
  
  <author>
    <name>Sumikiru</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>GAS中文文档（更新中）</title>
    <link href="https://sumikiru.top/posts/d0ae354a.html"/>
    <id>https://sumikiru.top/posts/d0ae354a.html</id>
    <published>2025-02-06T12:54:30.000Z</published>
    <updated>2025-02-06T14:42:00.323Z</updated>
    
    <content type="html"><![CDATA[<p><strong>更新时间：2025/2/26(更新中)</strong><br>翻译此文时间: 2024.2.6<br>原文地址: <a href="https://github.com/BillEliot/GASDocumentation">tranek/GASDocumentation</a><br>翻译地址(UE4.24): <a href="https://github.com/BillEliot/GASDocumentation_Chinese">BillEliot/GASDocumentation_Chinese</a><br>更新翻译地址(UE5.3): <a href="https://github.com/sumikiru/GASDocumentation_Chinese">sumikiru/GASDocumentation_Chinese</a></p><h1 id="GASDocumentation"><a href="#GASDocumentation" class="headerlink" title="GASDocumentation"></a>GASDocumentation</h1><p>我使用一个简单的多人游戏模板项目来阐述对Unreal Engine 5中GameplayAbilitySystem(GAS)插件的理解. 这不是官方文档, 并且这个项目和我自己都不来自Epic Games. 我不能保证该文档的准确性.  </p><p>该文档的目的是阐明GAS中的主要概念和相关类, 并结合我的经验提供一些附加说明. 在社区用户中, 已经形成了大量有关GAS的”部落知识”, 而我致力于将我了解的全部在这里分享.  </p><p>样例项目和文档目前基于<code>Unreal Engine 5.3</code>. 该文档拥有可用于旧版本Unreal Engine的分支, 但是它们不再受支持, 并且可能存在bug和过时信息.<br><a href="https://github.com/tranek/GASShooter">GASShooter</a>是该样例项目的姐妹项目, 其演示了基于多人FPS/TPS的高阶GAS技术.  </p><p>最好的文档永远是该插件的代码.  </p><hr><p><span id="table-of-contents"></span></p><h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><ul><li><a href="#gasdocumentation">GASDocumentation</a><ul><li><a href="#table-of-contents">目录</a></li><li><a href="#intro">1. 步入GameplayAbilitySystem插件</a></li><li><a href="#sp">2. 样例项目</a></li><li><a href="#setup">3. 使用GAS创建一个项目</a></li><li><a href="#concepts">4. GAS概念</a><ul><li><a href="#concepts-asc">4.1 Ability System Component</a><ul><li><a href="#concepts-asc-rm">4.1.1 同步模式</a></li><li><a href="#concepts-asc-setup">4.1.2 设置和初始化</a></li></ul></li><li><a href="#concepts-gt">4.2 Gameplay Tags</a><ul><li><a href="#concepts-gt-change">4.2.1 响应Gameplay Tags的变化</a></li></ul></li><li><a href="#concepts-a">4.3 Attribute</a><ul><li><a href="#concepts-a-definition">4.3.1 Attribute定义</a></li><li><a href="#concepts-a-value">4.3.2 BaseValue vs. CurrentValue</a></li><li><a href="#concepts-a-meta">4.3.3 元(Meta)Attribute</a></li><li><a href="#concepts-a-changes">4.3.4 响应Attribute变化</a></li><li><a href="#concepts-a-derived">4.3.5 自动推导Attribute</a></li></ul></li><li><a href="#concepts-as">4.4 AttributeSet</a><ul><li><a href="#concepts-as-definition">4.4.1 定义AttributeSet</a></li><li><a href="#concepts-as-design">4.4.2 设计AttributeSet</a><ul><li><a href="#concepts-as-design-subcomponents">4.4.2.1 使用单独Attribute的子组件</a></li><li><a href="#concepts-as-design-addremoveruntime">4.4.2.2 运行时添加和移除AttributeSet</a></li><li><a href="#concepts-as-design-itemattributes">4.4.2.3 Item Attribute(武器弹药)</a><ul><li><a href="#concepts-as-design-itemattributes-plainfloats">4.4.2.3.1 在物品中使用普通浮点数</a></li><li><a href="#concepts-as-design-itemattributes-attributeset">4.4.2.3.2 在物品中使用AttributeSet</a></li><li><a href="#concepts-as-design-itemattributes-asc">4.4.2.3.3 在物品中使用单独的ASC</a></li></ul></li></ul></li><li><a href="#concepts-as-attributes">4.4.3 定义Attribute</a></li><li><a href="#concepts-as-init">4.4.4 初始化Attribute</a></li><li><a href="#concepts-as-preattributechange">4.4.5 PreAttributeChange()</a></li><li><a href="#concepts-as-postgameplayeffectexecute">4.4.6 PostGameplayEffectExecute()</a></li><li><a href="#concepts-as-onattributeaggregatorcreated">4.4.7 OnAttributeAggregatorCreated()</a></li></ul></li><li><a href="#concepts-ge">4.5 Gameplay Effects</a><ul><li><a href="#concepts-ge-definition">4.5.1 定义GameplayEffect</a></li><li><a href="#concepts-ge-applying">4.5.2 应用GameplayEffect</a></li><li><a href="#concepts-ga-removing">4.5.3 移除GameplayEffect</a></li><li><a href="#concepts-ge-mods">4.5.4 GameplayEffectModifier</a><ul><li><a href="#concepts-ge-mods-multiplydivide">4.5.4.1 Multiply和Divide Modifier</a></li><li><a href="#concepts-ge-mods-gameplaytags">4.5.4.2 Modifier的GameplayTag</a></li></ul></li><li><a href="#concepts-ge-stacking">4.5.5 GameplayEffect堆栈</a></li><li><a href="#concepts-ge-ga">4.5.6 授予Ability</a></li><li><a href="#concepts-ge-tags">4.5.7 GameplayEffect标签</a></li><li><a href="#concepts-ge-immunity">4.5.8 免疫</a></li><li><a href="#concepts-ge-spec">4.5.9 GameplayEffectSpec</a><ul><li><a href="#concepts-ge-spec-setbycaller">4.5.9.1 SetByCaller</a></li></ul></li><li><a href="#concepts-ge-context">4.5.10 GameplayEffectContext</a></li><li><a href="#concepts-ge-mmc">4.5.11 Modifier Magnitude Calculation</a></li><li><a href="#concepts-ge-ec">4.5.12 Gameplay Effect Execution Calculation</a><ul><li><a href="#concepts-ge-ec-senddata">4.5.12.1 发送数据到Execution Calculation</a><ul><li><a href="#concepts-ge-ec-senddata-setbycaller">4.5.12.1.1 SetByCaller</a></li><li><a href="#concepts-ge-ec-senddata-backingdataattribute">4.5.12.1.2 Backing数据Attribute计算Modifier</a></li><li><a href="#concepts-ge-ec-senddata-backingdatatempvariable">4.5.12.1.3 Backing数据临时变量计算Modifier</a></li><li><a href="#concepts-ge-ec-senddata-effectcontext">4.5.12.1.4 GameplayEffectContext</a></li></ul></li></ul></li><li><a href="#concepts-ge-car">4.5.13 自定义应用需求</a></li><li><a href="#concepts-ge-cost">4.5.14 花费(Cost)GameplayEffect</a></li><li><a href="#concepts-ge-cooldown">4.5.15 冷却(Cooldown)GameplayEffect</a><ul><li><a href="#concepts-ge-cooldown-tr">4.5.15.1 获取Cooldown GameplayEffect的剩余时间</a></li><li><a href="#concepts-ge-cooldown-listen">4.5.15.2 监听冷却开始和结束</a></li><li><a href="#concepts-ge-cooldown-prediction">4.5.15.3 预测冷却时间</a></li></ul></li><li><a href="#concepts-ge-duration">4.5.16 修改已激活GameplayEffect的持续时间</a></li><li><a href="#concepts-ge-dynamic">4.5.17 运行时创建动态GameplayEffect</a></li><li><a href="#concepts-ge-containers">4.5.18 GameplayEffect Containers</a></li></ul></li><li><a href="#concepts-ga">4.6 Gameplay Abilities</a><ul><li><a href="#concepts-ga-definition">4.6.1 GameplayAbility定义</a><ul><li><a href="#concepts-ga-definition-reppolicy">4.6.1.1 Replication Policy</a></li><li><a href="#concepts-ga-definition-remotecancel">4.6.1.2 Server Respects Remote Ability Cancellation</a></li><li><a href="#concepts-ga-definition-repinputdirectly">4.6.1.3 Replicate Input Directly</a></li></ul></li><li><a href="#concepts-ga-input">4.6.2 绑定输入到ASC</a><ul><li><a href="#concepts-ga-input-noactivate">4.6.2.1 绑定输入时不激活Ability</a></li></ul></li><li><a href="#concepts-ga-granting">4.6.3 授予Ability</a></li><li><a href="#concepts-ga-activating">4.6.4 激活Ability</a><ul><li><a href="#concepts-ga-activating-passive">4.6.4.1 被动Ability</a></li></ul></li><li><a href="#concepts-ga-cancelabilities">4.6.5 取消Ability</a></li><li><a href="#concepts-ga-definition-activeability">4.6.6 获取激活的Ability</a></li><li><a href="#concepts-ga-instancing">4.6.7 实例化策略</a></li><li><a href="#concepts-ga-net">4.6.8 网络执行策略(Net Execution Policy)</a></li><li><a href="#concepts-ga-tags">4.6.9 Ability标签</a></li><li><a href="#concepts-ga-spec">4.6.10 Gameplay Ability Spec</a></li><li><a href="#concepts-ga-data">4.6.11 传递数据到Ability</a></li><li><a href="#concepts-ga-commit">4.6.12 Ability花费(Cost)和冷却(Cooldown)</a></li><li><a href="#concepts-ga-leveling">4.6.13 升级Ability</a></li><li><a href="#concepts-ga-sets">4.6.14 Ability集合</a></li><li><a href="#concepts-ga-batching">4.6.15 Ability批处理</a></li><li><a href="#concepts-ga-netsecuritypolicy">4.6.16 网络安全策略(Net Security Policy)</a></li></ul></li><li><a href="#concepts-at">4.7 Ability Tasks</a><ul><li><a href="#concepts-at-definition">4.7.1 AbilityTask定义</a></li><li><a href="#concepts-at-custom">4.7.2 自定义AbilityTask</a></li><li><a href="#concepts-at-using">4.7.3 使用AbilityTask</a></li><li><a href="#concepts-at-rms">4.7.4 Root Motion Source Ability Task</a></li></ul></li><li><a href="#concepts-gc">4.8 Gameplay Cues</a><ul><li><a href="#concepts-gc-definition">4.8.1 GameplayCue定义</a></li><li><a href="#concepts-gc-trigger">4.8.2 触发GameplayCue</a></li><li><a href="#concepts-gc-local">4.8.3 客户端GameplayCue</a></li><li><a href="#concepts-gc-parameters">4.8.4 GameplayCue参数</a></li><li><a href="#concepts-gc-manager">4.8.5 Gameplay Cue Manager</a></li><li><a href="#concepts-gc-prevention">4.8.6 阻止GameplayCue响应</a></li><li><a href="#concepts-gc-batching">4.8.7 GameplayCue批处理</a><ul><li><a href="#concepts-gc-batching-manualrpc">4.8.7.1 手动RPC</a></li><li><a href="#concepts-gc-batching-gcsonge">4.8.7.2 GameplayEffect中的多个GameplayCue</a></li></ul></li></ul></li><li><a href="#concepts-asg">4.9 Ability System Globals</a><ul><li><a href="#concepts-asg-initglobaldata">4.9.1 InitGlobalData()</a></li></ul></li><li><a href="#concepts-p">4.10 预测(Prediction)</a><ul><li><a href="#concepts-p-key">4.10.1 Prediction Key</a></li><li><a href="#concepts-p-windows">4.10.2 在Ability中创建新的预测窗口(Prediction Window)</a></li><li><a href="#concepts-p-spawn">4.10.3 预测性地生成Actor</a></li><li><a href="#concepts-p-future">4.10.4 GAS中预测的未来</a></li><li><a href="#concepts-p-npp">4.10.5 网络预测插件(Network Prediction plugin)</a></li></ul></li><li><a href="#concepts-targeting">4.11 Targeting</a><ul><li><a href="#concepts-targeting-data">4.11.1 Target Data</a></li><li><a href="#concepts-targeting-actors">4.11.2 Target Actor</a></li><li><a href="#concepts-target-data-filters">4.11.3 TargetData过滤器</a></li><li><a href="#concepts-targeting-reticles">4.11.4 Gameplay Ability World Reticles</a></li><li><a href="#concepts-targeting-containers">4.11.5 Gameplay Effect Containers Targeting</a></li></ul></li></ul></li><li><a href="#cae">5. 常用的Abilty和Effect</a><ul><li><a href="#cae-stun">5.1 眩晕(Stun)</a></li><li><a href="#cae-sprint">5.2 奔跑(Sprint)</a></li><li><a href="#cae-ads">5.3 瞄准(Aim Down Sight)</a></li><li><a href="#cae-ls">5.4 生命偷取(Lifesteal)</a></li><li><a href="#cae-random">5.5 在客户端和服务端中生成随机数</a></li><li><a href="#cae-crit">5.6 暴击(Critical Hits)</a></li><li><a href="#cae-nonstackingge">5.7 非堆栈GameplayEffect, 但是只有其最高级(Greatest Magnitude)才能实际影响Target</a></li><li><a href="#cae-paused">5.8 游戏暂停时生成TargetData</a></li><li><a href="#cae-onebuttoninteractionsystem">5.9 按钮交互系统(Button Interaction System)</a></li></ul></li><li><a href="#debugging">6. 调试GAS</a><ul><li><a href="#debugging-sd">6.1 showdebug abilitysystem</a></li><li><a href="#debugging-gd">6.2 Gameplay Debugger</a></li><li><a href="#debugging-log">6.3 GAS日志(Logging)</a></li></ul></li><li><a href="#optimizations">7. 优化</a><ul><li><a href="#optimizations-abilitybatching">7.1 Ability批处理</a></li><li><a href="#optimizations-gameplaycuebatching">7.2 GameplayCue批处理</a></li><li><a href="#optimizations-ascreplicationmode">7.3 AbilitySystemComponent同步模式(Replication Mode)</a></li><li><a href="#optimizations-attributeproxyreplication">7.4 Attribute代理同步</a></li><li><a href="#optimizations-asclazyloading">7.5 ASC懒加载</a></li></ul></li><li><a href="#qol">8. Quality of Life Suggestions</a><ul><li><a href="#qol-gameplayeffectcontainers">8.1 Gameplay Effect Containers</a></li><li><a href="#qol-asynctasksascdelegates">8.2 将蓝图AsyncTask绑定到ASC委托</a></li></ul></li><li><a href="#troubleshooting">9. 疑难解答</a><ul><li><a href="#troubleshooting-notlocal">9.1 LogAbilitySystem: Warning: Can’t activate LocalOnly or LocalPredicted ability %s when not local!</a></li><li><a href="#troubleshooting-scriptstructcache">9.2 ScriptStructCache错误</a></li><li><a href="#troubleshooting-replicatinganimmontages">9.3 动画蒙太奇不能同步到客户端</a></li><li><a href="#troubleshooting-duplicatingblueprintactors">9.4 复制的蓝图Actor会将AttributeSet设置为nullptr</a></li></ul></li><li><a href="#acronyms">10. ASC常用术语缩略</a></li><li><a href="#resources">11. 其他资源</a></li><li><a href="#changelog">12. GAS更新日志</a><ul><li><a href="#changelog-4.26">4.26</a></li><li><a href="#changelog-4.25.1">4.25.1</a></li><li><a href="#changelog-4.25">4.25</a></li><li><a href="#changelog-4.24">4.24</a></li></ul></li></ul></li></ul><hr><p><span id="intro"></span></p><h1 id="1-步入GameplayAbilitySystem插件"><a href="#1-步入GameplayAbilitySystem插件" class="headerlink" title="1. 步入GameplayAbilitySystem插件"></a>1. 步入GameplayAbilitySystem插件</h1><p>摘自<a href="https://docs.unrealengine.com/en-US/Gameplay/GameplayAbilitySystem/index.html">官方文档</a>:  </p><blockquote><p>Gameplay技能系统 是一个高度灵活的框架，可用于构建你可能会在RPG或MOBA游戏中看到的技能和属性类型。你可以构建可供游戏中的角色使用的动作或被动技能，使这些动作导致各种属性累积或损耗的状态效果，实现约束这些动作使用的”冷却”计时器或资源消耗，更改技能等级及每个技能等级的技能效果，激活粒子或音效，等等。简单来说，此系统可帮助你在任何现代RPG或MOBA游戏中设计、实现及高效关联各种游戏中的技能，既包括跳跃等简单技能，也包括你喜欢的角色的复杂技能集。</p></blockquote><p>GameplayAbilitySystem插件由Epic Games开发, 随Unreal Engine 4 (UE4)发布. 它已经由3A商业游戏的严格测试, 例如帕拉贡(Paragon)和堡垒之夜(Fortnite)等等.  </p><p>该插件对于单人和多人游戏提供了开箱即用的解决方案:  </p><ul><li>执行基于等级的角色能力(Ability)或技能(Skill), 该能力或技能可选花费和冷却时间. (<a href="#concepts-ga">GameplayAbility</a>)</li><li>管理属于Actor的数值Attribute. (<a href="#concepts-a">Attribute</a>)</li><li>为Actor应用状态效果. (<a href="#concepts-ge">GameplayEffect</a>)</li><li>为Actor应用GameplayTag. (<a href="#concepts-gt">GameplayTag</a>)</li><li>生成视觉或声音效果. (<a href="#concepts-gc">GameplayCue</a>)</li><li>为以上提到的所有应用同步(Replication).</li></ul><p>在多人游戏中, GAS提供客户端预测(<a href="#concepts-p">client-side prediction</a>)支持:  </p><ul><li>能力激活.</li><li>播放蒙太奇.</li><li>对<code>Attribute</code>的修改.</li><li>应用<code>GameplayTag</code>.</li><li>生成<code>GameplayCue</code>.</li><li>通过连接于<code>CharacterMovementComponent</code>的<code>RootMotionSource</code>函数形成的移动.</li></ul><p><strong>GAS必须由C++创建</strong>, 但是<code>GameplayAbility</code>和<code>GameplayEffect</code>可由设计师在蓝图中创建.  </p><p>GAS中的现存问题:</p><ul><li><code>GameplayEffect</code>延迟调节(Latency Reconciliation).(不能预测能力冷却时间, 导致高延迟玩家相比低延迟玩家, 对于短冷却时间的能力有更低的激活速率.)</li><li>不能预测性地移除<code>GameplayEffect</code>. 然而我们可以反向预测性地添加<code>GameplayEffect</code>, 从而高效的移除它. 但是这不总是合适或者可行的, 因此这仍然是个问题.</li><li>缺乏样例模板项目, 多人联机样例和文档. 希望这篇文档会有所帮助.</li></ul><p><strong><a href="#table-of-contents">⬆ 返回目录</a></strong></p><p><span id="sp"></span></p><h1 id="2-样例项目"><a href="#2-样例项目" class="headerlink" title="2. 样例项目"></a>2. 样例项目</h1><p>该文档包含一个支持多人联机的第三人称射击游戏模板项目, 其目标受众为初识<code>GameplayAbilitySystem</code>插件, 但并不是Unreal Engine 4新手. 用户应该了解C++, 蓝图, UMG, Replication和其他UE4的中间件. 该项目提供了一个样例, 其向你展示了如何使用<code>GameplayAbilitySystem</code>插件建立一个基础的支持多人联机的第三人称射击游戏, 其中<code>AbilitySystemComponent(ASC)</code>分别位于<code>PlayerState</code>类代表玩家/AI控制的人物和位于<code>Character</code>类代表AI控制的小兵.<br>我在保证展现GAS基础和带有完整注释的代码所表示的一些普遍技能的同时, 尽力使这个样例足够简单. 由于该文档专注于初学者, 因此该样例不包含像<a href="#concepts-p-spawn">Predicting Projectiles</a>这样的高阶技术.<br>概念说明:  </p><ul><li><code>ASC</code>位于<code>PlayerState</code>还是<code>Character</code>.</li><li>网络同步的<code>Attribute</code>.</li><li>网络同步的蒙太奇(Animation Montages).</li><li><code>GameplayTag</code>.</li><li>在<code>GameplayAbility</code>内部和外部应用和移除<code>GameplayEffect</code>.</li><li>应用被护甲防御后的伤害值来修改角色生命值.</li><li><code>GameplayEffectExecutionCalculations</code>.</li><li>眩晕效果.</li><li>死亡和重生.</li><li>在服务端上使用能力(Ability)生成抛射物(Projectile).</li><li>在瞄准和奔跑时, 预测性的修改本地玩家速度.</li><li>不断消耗耐力来奔跑.</li><li>消耗魔法值来使用能力(Ability).</li><li>被动能力(Ability).</li><li>堆栈<code>GameplayEffect</code>.</li><li>锁定Actor.</li><li>在蓝图中创建<code>GameplayAbility</code>.</li><li>在C++中创建<code>GameplayAbility</code>.</li><li>实例化每个Actor的<code>GameplayAbility</code>.</li><li>非实例化的<code>GameplayAbility</code>(Jump).</li><li>静态<code>GameplayCue</code>(子弹撞击粒子效果).</li><li>Actor <code>GameplayCue</code>(奔跑和眩晕粒子效果).</li></ul><p>角色类有如下能力:  </p><div class="table-container"><table><thead><tr><th style="text-align:center">能力</th><th style="text-align:center">输入绑定</th><th style="text-align:center">是否可预测</th><th style="text-align:center">C++/Blueprint</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center">跳跃</td><td style="text-align:center">空格键</td><td style="text-align:center">Yes</td><td style="text-align:center">C++</td><td style="text-align:center">使角色跳跃.</td></tr><tr><td style="text-align:center">枪</td><td style="text-align:center">鼠标左键</td><td style="text-align:center">No</td><td style="text-align:center">C++</td><td style="text-align:center">从角色的枪中发射投掷物, 发射动画是可预测的, 但是投掷物不能预测.</td></tr><tr><td style="text-align:center">瞄准</td><td style="text-align:center">鼠标右键</td><td style="text-align:center">Yes</td><td style="text-align:center">Blueprint</td><td style="text-align:center">当按住鼠标右键时, 角色会走的更慢并且摄像机会拉近(zoom in)以获得更高的射击精度.</td></tr><tr><td style="text-align:center">奔跑</td><td style="text-align:center">左Shift</td><td style="text-align:center">Yes</td><td style="text-align:center">Blueprint</td><td style="text-align:center">当按住左Shift时, 角色在消耗体力的同时跑得更快.</td></tr><tr><td style="text-align:center">向前猛冲</td><td style="text-align:center">Q</td><td style="text-align:center">Yes</td><td style="text-align:center">Blueprint</td><td style="text-align:center">角色消耗体力的同时向前猛冲.</td></tr><tr><td style="text-align:center">被动护盾叠加</td><td style="text-align:center">被动</td><td style="text-align:center">No</td><td style="text-align:center">Blueprint</td><td style="text-align:center">每过4s角色获得一个最大层数为4的护盾, 每次受到伤害时移除一层护盾.</td></tr><tr><td style="text-align:center">陨石坠落</td><td style="text-align:center">R</td><td style="text-align:center">No</td><td style="text-align:center">Blueprint</td><td style="text-align:center">角色锁定一个敌人召唤一个陨石, 对其造成伤害和眩晕效果. 定位是可以预测的而陨石生成是不可预测的.</td></tr></tbody></table></div><p><code>GameplayAbility</code>无论是由蓝图还是C++创建都没关系. 这里我们使用蓝图和C++混合创建, 意在展示每种方式的使用方法.<br>AI控制的小兵没有预先定义的<code>GameplayAbility</code>. 红方小兵有较多的生命回复, 蓝方小兵有较多的初始生命.<br>对于<code>GameplayAbility</code>的命名, 我使用<code>_BP</code>后缀表示由蓝图创建的<code>GameplayAbility</code>逻辑, 没有后缀则表示由C++创建.  </p><p><strong>蓝图资源命名前缀</strong>  </p><div class="table-container"><table><thead><tr><th style="text-align:center">Prefix</th><th style="text-align:center">Asset Type</th></tr></thead><tbody><tr><td style="text-align:center">GA_</td><td style="text-align:center">GameplayAbility</td></tr><tr><td style="text-align:center">GC_</td><td style="text-align:center">GameplayCue</td></tr><tr><td style="text-align:center">GE_</td><td style="text-align:center">GameplayEffect</td></tr></tbody></table></div><p><strong><a href="#table-of-contents">⬆ 返回目录</a></strong></p><p><span id="setup"></span></p><h1 id="3-使用GAS创建一个项目"><a href="#3-使用GAS创建一个项目" class="headerlink" title="3. 使用GAS创建一个项目"></a>3. 使用GAS创建一个项目</h1><p>使用GAS建立一个项目的基本步骤:  </p><ol><li>在编辑器中启用GameplayAbilitySystem插件.</li><li>编辑<code>YourProjectName.Build.cs</code>, 添加<code>&quot;GameplayAbilities&quot;</code>, <code>&quot;GameplayTags&quot;</code>, <code>&quot;GameplayTasks&quot;</code>到你的<code>PrivateDependencyModuleNames</code>.</li><li>刷新/重新生成Visual Studio项目文件.</li><li>从4.24开始, 需要强制调用<code>UAbilitySystemGlobals::InitGlobalData()</code>来使用<a href="#concepts-targeting-data"><code>TargetData</code></a>, 样例项目在<code>UEngineSubsystem::Initialize()</code>中调用该函数. 参阅<a href="#concepts-asg-initglobaldata"><code>InitGlobalData()</code></a>获取更多信息.</li></ol><p>这就是你启用GAS所需做的全部了. 从这里开始, 添加一个<a href="#concepts-asc"><code>ASC</code></a>和<a href="#concepts-as"><code>AttributeSet</code></a>到你的<code>Character</code>或<code>PlayerState</code>, 并开始着手<a href="#concepts-ga"><code>GameplayAbility</code></a>和<a href="#concepts-ge"><code>GameplayEffect</code></a>!</p><p><strong><a href="#table-of-contents">⬆ 返回目录</a></strong></p><p><span id="concepts"></span></p><h1 id="4-GAS概念"><a href="#4-GAS概念" class="headerlink" title="4. GAS概念"></a>4. GAS概念</h1><ul><li>4.1 <a href="#concepts-asc">Ability System Component</a>  </li><li>4.2 <a href="#concepts-gt">Gameplay Tags</a>  </li><li>4.3 <a href="#concepts-a">Attributes</a>  </li><li>4.4 <a href="#concepts-as">Attribute Set</a>  </li><li>4.5 <a href="#concepts-ge">Gameplay Effects</a>  </li><li>4.6 <a href="#concepts-ga">Gameplay Abilities</a>  </li><li>4.7 <a href="#concepts-at">Ability Tasks</a>  </li><li>4.8 <a href="#concepts-gc">Gameplay Cues</a>  </li><li>4.9 <a href="#concepts-asg">Ability System Globals</a>  </li><li>4.10 <a href="#concepts-p">Prediction</a></li></ul><p><span id="concepts-asc"></span></p><h2 id="4-1-Ability-System-Component"><a href="#4-1-Ability-System-Component" class="headerlink" title="4.1 Ability System Component"></a>4.1 Ability System Component</h2><p><code>AbilitySystemComponent(ASC)</code>是GAS的核心, 它是一个处理所有与该系统交互的<code>UActorComponent</code>(<a href="https://docs.unrealengine.com/en-US/API/Plugins/GameplayAbilities/UAbilitySystemComponent/index.html">UAbilitySystemComponent</a>), 所有期望使用<a href="#concepts-ga">GameplayAbility</a>, 包含<a href="#concepts-a">Attribute</a>, 或者接受<a href="#concepts-ge">GameplayEffect</a>的Actor都必须附加<code>ASC</code>. 这些对象都存于<code>ASC</code>并由其管理和同步(除了由<a href="#concepts-as">AttributeSet</a>同步的<code>Attribute</code>). 开发者最好但不强求继承该组件.  </p><p><code>ASC</code>附加的<code>Actor</code>被引用作为该<code>ASC</code>的<code>OwnerActor</code>, 该<code>ASC</code>的物理代表<code>Actor</code>被称为<code>AvatarActor</code>. <code>OwnerActor</code>和<code>AvatarActor</code>可以是同一个 <code>Actor</code>, 比如MOBA游戏中的一个简单AI小兵; 它们也可以是不同的<code>Actor</code>, 比如MOBA游戏中玩家控制的英雄, 其中<code>OwnerActor</code>是<code>PlayerState</code>, <code>AvatarActor</code>是英雄的<code>Character</code>类. 绝大多数Actor的<code>ASC</code>都附加在其自身, 如果你的Actor会重生并且重生时需要持久化<code>Attribute</code>或<code>GameplayEffect</code>(比如MOBA中的英雄), 那么<code>ASC</code>理想的位置就是<code>PlayerState</code>.  </p><p><strong>Note:</strong> 如果<code>ASC</code>位于PlayerState, 那么你需要提高PlayerState的<code>NetUpdateFrequency</code>, 其默认是一个很低的值, 因此在客户端上发生<code>Attribute</code>和<code>GameplayTag</code>改变时会造成延迟或卡顿. 确保启用<a href="https://docs.unrealengine.com/en-US/Gameplay/Networking/Actors/Properties/index.html#adaptivenetworkupdatefrequency">Adaptive Network Update Frequency</a>, Fortnite就启用了该项.  </p><p>OwnerActor需要继承并实现<code>IAbilitySystemInterface</code>, 如果AvatarActor和OwnerActor是不同的Actor, 那么AvatarActor也应该继承并实现<code>IAbilitySystemInterface</code>. 该接口有一个必须重写的函数, <code>UAbilitySystemComponent* GetAbilitySystemComponent() const</code>, 其返回一个指向<code>ASC</code>的指针, <code>ASC</code>通过寻找该接口函数来和系统内部进行交互.  </p><p><code>ASC</code>在<code>FActiveGameplayEffectContainer ActiveGameplayEffect</code>中保存其当前活跃的<code>GameplayEffect</code>.  </p><p><code>ASC</code>在<code>FGameplayAbilitySpecContainer ActivatableAbility</code>中保存其授予的<code>GameplayAbility</code>. 当你想遍历<code>ActivatableAbility.Items</code>时, 确保在循环体之上添加<code>ABILITYLIST_SCOPE_LOCK();</code>来锁定列表以防其改变(比如移除一个Ability). 每个域中的<code>ABILITYLIST_SCOPE_LOCK();</code>会增加<code>AbilityScopeLockCount</code>, 之后出域时会减量. 不要尝试在<code>ABILITYLIST_SCOPE_LOCK();</code>域中移除某个Ability(Ability删除函数会在内部检查<code>AbilityScopeLockCount</code>以防在列表锁定时移除Ability).  </p><p><strong><a href="#table-of-contents">⬆ 返回目录</a></strong></p><p><span id="concepts-asc-rm"></span></p><h3 id="4-1-1-同步模式"><a href="#4-1-1-同步模式" class="headerlink" title="4.1.1 同步模式"></a>4.1.1 同步模式</h3><p><code>ASC</code>定义了三种不同的同步模式用于同步<code>GameplayEffect</code>, <code>GameplayTag</code>和<code>GameplayCue</code> - <code>Full</code>, <code>Mixed</code>和<code>Minimal</code>. <code>Attribute</code>由其<code>AttributeSet</code>同步.  </p><div class="table-container"><table><thead><tr><th style="text-align:center">同步模式</th><th style="text-align:center">何时使用</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center"><code>Full</code></td><td style="text-align:center">单人</td><td style="text-align:center">所有<code>GameplayEffect</code>都同步到客户端.</td></tr><tr><td style="text-align:center"><code>Mixed</code></td><td style="text-align:center">多人, 玩家控制的Actor</td><td style="text-align:center"><code>GameplayEffect</code>只同步到其所属客户端, 只有<code>GameplayTag</code>和<code>GameplayCue</code>同步到所有客户端.</td></tr><tr><td style="text-align:center"><code>Minimal</code></td><td style="text-align:center">多人, AI控制的Actor</td><td style="text-align:center"><code>GameplayEffect</code>从不同步到任何客户端, 只有<code>GameplayTag</code>和<code>GameplayCue</code>同步到所有客户端.</td></tr></tbody></table></div><p><strong>Note:</strong> <code>Mixed</code>同步模式需要<code>OwnerActor</code>的<code>Owner</code>是<code>Controller</code>. <code>PlayerState</code>的<code>Owner</code>默认是<code>Controller</code>但是<code>Character</code>不是. 如果<code>OwnerActor</code>不是<code>PlayerState</code>时使用<code>Mixed</code>同步模式, 那么需要在<code>OwnerActor</code>中调用<code>SetOwner()</code>设置<code>Controller</code>.  </p><p>从4.24开始, 需要使用<code>PossessedBy()</code>设置新的<code>Controller</code>为<code>Pawn</code>的Owner.  </p><p><strong><a href="#table-of-contents">⬆ 返回目录</a></strong></p><p><span id="concepts-asc-setup"></span></p><h3 id="4-1-2-设置和初始化"><a href="#4-1-2-设置和初始化" class="headerlink" title="4.1.2 设置和初始化"></a>4.1.2 设置和初始化</h3><p><code>ASC</code>一般在<code>OwnerActor</code>的构建函数中创建并且需要明确标记为Replicated. <strong>这必须在C++中完成.</strong>  </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">AGDPlayerState::<span class="built_in">AGDPlayerState</span>()</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// Create Ability system component, and set it to be explicitly replicated</span></span><br><span class="line">AbilitySystemComponent = <span class="built_in">CreateDefaultSubobject</span>&lt;UGDAbilitySystemComponent&gt;(<span class="built_in">TEXT</span>(<span class="string">&quot;AbilitySystemComponent&quot;</span>));</span><br><span class="line">AbilitySystemComponent-&gt;<span class="built_in">SetIsReplicated</span>(<span class="literal">true</span>);</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>OwnerActor</code>和<code>AvatarActor</code>的<code>ASC</code>在服务端和客户端上均需初始化, 你应该在<code>Pawn</code>的<code>Controller</code>设置之后初始化(Possess之后), 单人游戏只需参考服务端的做法.  </p><p>对于玩家控制的Character且<code>ASC</code>位于<code>Pawn</code>, 我一般在服务端<code>Pawn</code>的<code>PossessedBy()</code>函数中初始化, 在客户端<code>PlayerController</code>的<code>AcknowledgePossession()</code>函数中初始化.  </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">APACharacterBase::PossessedBy</span><span class="params">(AController * NewController)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Super::<span class="built_in">PossessedBy</span>(NewController);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (AbilitySystemComponent)</span><br><span class="line">&#123;</span><br><span class="line">AbilitySystemComponent-&gt;<span class="built_in">InitAbilityActorInfo</span>(<span class="keyword">this</span>, <span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ASC MixedMode replication requires that the ASC Owner&#x27;s Owner be the Controller.</span></span><br><span class="line"><span class="built_in">SetOwner</span>(NewController);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">APAPlayerControllerBase::AcknowledgePossession</span><span class="params">(APawn* P)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Super::<span class="built_in">AcknowledgePossession</span>(P);</span><br><span class="line"></span><br><span class="line">APACharacterBase* CharacterBase = <span class="built_in">Cast</span>&lt;APACharacterBase&gt;(P);</span><br><span class="line"><span class="keyword">if</span> (CharacterBase)</span><br><span class="line">&#123;</span><br><span class="line">CharacterBase-&gt;<span class="built_in">GetAbilitySystemComponent</span>()-&gt;<span class="built_in">InitAbilityActorInfo</span>(CharacterBase, CharacterBase);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于玩家控制的Character且<code>ASC</code>位于<code>PlayerState</code>, 我一般在服务端<code>Pawn</code>的<code>PossessedBy()</code>函数中初始化, 在客户端PlayerController的<code>OnRep_PlayerState()</code>函数中初始化, 这确保了<code>PlayerState</code>存在于客户端上.  </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">AGDHeroCharacter::PossessedBy</span><span class="params">(AController * NewController)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Super::<span class="built_in">PossessedBy</span>(NewController);</span><br><span class="line"></span><br><span class="line">AGDPlayerState* PS = <span class="built_in">GetPlayerState</span>&lt;AGDPlayerState&gt;();</span><br><span class="line"><span class="keyword">if</span> (PS)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// Set the ASC on the Server. Clients do this in OnRep_PlayerState()</span></span><br><span class="line">AbilitySystemComponent = <span class="built_in">Cast</span>&lt;UGDAbilitySystemComponent&gt;(PS-&gt;<span class="built_in">GetAbilitySystemComponent</span>());</span><br><span class="line"></span><br><span class="line"><span class="comment">// AI won&#x27;t have PlayerControllers so we can init again here just to be sure. No harm in initing twice for heroes that have PlayerControllers.</span></span><br><span class="line">PS-&gt;<span class="built_in">GetAbilitySystemComponent</span>()-&gt;<span class="built_in">InitAbilityActorInfo</span>(PS, <span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">AGDHeroCharacter::OnRep_PlayerState</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Super::<span class="built_in">OnRep_PlayerState</span>();</span><br><span class="line"></span><br><span class="line">AGDPlayerState* PS = <span class="built_in">GetPlayerState</span>&lt;AGDPlayerState&gt;();</span><br><span class="line"><span class="keyword">if</span> (PS)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// Set the ASC for clients. Server does this in PossessedBy.</span></span><br><span class="line">AbilitySystemComponent = <span class="built_in">Cast</span>&lt;UGDAbilitySystemComponent&gt;(PS-&gt;<span class="built_in">GetAbilitySystemComponent</span>());</span><br><span class="line"></span><br><span class="line"><span class="comment">// Init ASC Actor Info for clients. Server will init its `ASC` when it possesses a new Actor.</span></span><br><span class="line">AbilitySystemComponent-&gt;<span class="built_in">InitAbilityActorInfo</span>(PS, <span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果你遇到了错误消息<code>LogAbilitySystem: Warning: Can&#39;t activate LocalOnly or LocalPredicted Ability %s when not local!</code>, 那么就表明<code>ASC</code>没有在客户端中初始化.  </p><p><strong><a href="#table-of-contents">⬆ 返回目录</a></strong></p><p><span id="concepts-gt"></span></p><h2 id="4-2-Gameplay-Tags"><a href="#4-2-Gameplay-Tags" class="headerlink" title="4.2 Gameplay Tags"></a>4.2 Gameplay Tags</h2><p><code>FGameplayTag</code>是由<code>GameplayTagManager</code>注册的形似<code>Parent.Child.Grandchild...</code>的层级Name, 这些标签对于分类和描述对象的状态非常有用, 例如, 如果某个Character处于眩晕状态, 我们可以给一个<code>State.Debuff.Stun</code>的<code>GameplayTag</code>.  </p><p>你会发现自己使用<code>GameplayTag</code>替换了过去使用布尔值或枚举值来编程, 并且需要对对象有无特定的<code>GameplayTag</code>做布尔逻辑判断.  </p><p>当给某个对象设置标签时, 如果它有<code>ASC</code>的话, 我们一般添加标签到<code>ASC</code>以与其交互. UAbilitySystemComponent执行<code>IGameplayTagAssetInterface</code>接口的函数来访问其拥有的<code>GameplayTag</code>.  </p><p>多个<code>GameplayTag</code>可被保存于一个<code>FGameplayTagContainer</code>中, 相比<code>TArray&lt;FGameplayTag&gt;</code>, 最好使用<code>GameplayTagContainer</code>, 因为<code>GameplayTagContainer</code>做了一些很有效率的优化. 因为标签是标准的<code>FName</code>, 所以当在项目设置(Project Setting)中启用<code>Fast Replication</code>后, 它们可以高效地打包进<code>FGameplayTagContainer</code>以用于同步. <code>Fast Replication</code>要求服务端和客户端有相同的<code>GameplayTag</code>列表, 这通常不是问题, 因此你应该启用该选项. <code>GameplayTagContainer</code>也可以返回<code>TArray&lt;FGameplayTag&gt;</code>以用于遍历.  </p><p>保存于<code>FGameplayTagCountContainer</code>中的<code>GameplayTag</code>有保存该<code>GameplayTag</code>实例数的<code>TagMap</code>. FGameplayTagCountContainer可能存有<code>TagMapCount</code>为0的<code>GameplayTag</code>, 你可能在Debug时遇到这种情况. 任何<code>HasTag()</code>或<code>HasMatchingTag()</code>或其他相似的函数会检查<code>TagMapCount</code>, 如果<code>GameplayTag</code>不存在或者其<code>TagMapCount</code>为0就会返回false.  </p><p><code>GameplayTag</code>必须在<code>DefaultGameplayTag.ini</code>中提前定义, UE4编辑器在项目设置中提供了一个界面供开发者管理<code>GameplayTag</code>而无需手动编辑DefaultGameplayTag.ini, 该<code>GameplayTag</code>编辑器可以创建, 重命名, 搜索引用和删除<code>GameplayTag</code>.  </p><p><img src="https://pic1.imgdb.cn/item/67a4c479d0e0a243d4fc5376.png" alt="GameplayTag Editor in Project Settings">  </p><p>搜索<code>GameplayTag</code>会弹出一个类似Reference Viewer的窗口来显示所有引用该<code>GameplayTag</code>的资源, 但这不会显示任何引用该<code>GameplayTag</code>的C++类.  </p><p>重命名<code>GameplayTag</code>会创建重定向, 因此仍引用原来<code>GameplayTag</code>的资源会重定向到新的<code>GameplayTag</code>. 如果可以的话, 我更倾向于创建新的<code>GameplayTag</code>, 手动更新所有引用到新的<code>GameplayTag</code>, 之后删除旧的<code>GameplayTag</code>以避免创建新的重定向.  </p><p>除了<code>Fast Replication</code>, <code>GameplayTag</code>编辑器可以选择填充普遍需要同步的<code>GameplayTag</code>以对其深度优化.  </p><p>如果<code>GameplayTag</code>由<code>GameplayEffect</code>添加, 那么其就是可同步的. <code>ASC</code>允许你添加不可同步的<code>LooseGameplayTag</code>且必须手动管理. 样例项目对<code>State.Dead</code>使用了<code>LooseGameplayTag</code>, 因此当生命值降为0时, 其所属客户端会立即响应. 重生时需要手动将<code>TagMapCount</code>设置回0, 当使用<code>LooseGameplayTag</code>时只能手动调整<code>TagMapCount</code>, 相比纯手动调整<code>TagMapCount</code>, 最好使用<code>UAbilitySystemComponent::AddLooseGameplayTag()</code>和<code>UAbilitySystemComponent::RemoveLooseGameplayTag()</code>.  </p><p>C++中获取<code>GameplayTag</code>引用:  </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">FGameplayTag::<span class="built_in">RequestGameplayTag</span>(<span class="built_in">FName</span>(<span class="string">&quot;Your.GameplayTag.Name&quot;</span>))</span><br></pre></td></tr></table></figure><p>对于像获取父或子<code>GameplayTag</code>的高阶操作, 请查看<code>GameplayTagManager</code>提供的函数. 为了访问<code>GameplayTagManager</code>, 请引用<code>GameplayTagManager.h</code>并使用<code>UGameplayTagManager::Get().FunctionName</code>调用函数. 相比使用常量字符串进行操作和比较, <code>GameplayTagManager</code>实际上使用关系节点(父, 子等等)保存<code>GameplayTag</code>以获得更快的处理速度.  </p><p><code>GameplayTag</code>和<code>GameplayTagContainer</code>有可选UPROPERTY宏<code>Meta = (Categories = &quot;GameplayCue&quot;)</code>用于在蓝图中过滤标签而只显示父标签为<code>GameplayCue</code>的<code>GameplayTag</code>, 当你知道<code>GameplayTag</code>或<code>GameplayTagContainer</code>变量应该只用于<code>GameplayCue</code>时, 这将是非常有用的.  </p><p>作为选择, 有一单独的<code>FGameplayCueTag</code>结构体可以包裹<code>FGameplayTag</code>并且可以在蓝图中自动过滤<code>GameplayTag</code>而只显示父标签为<code>GameplayCue</code>的标签.  </p><p>如果你想过滤函数中的<code>GameplayTag</code>参数, 使用UFUNCTION宏<code>Meta = (GameplayTagFilter = &quot;GameplayCue&quot;)</code>. <code>GameplayTagContainer</code>参数不能过滤, 如果你想编辑引擎来允许过滤<code>GameplayTagContainer</code>参数, 查看<code>SGameplayTagGraphPin::ParseDefaultValueData()</code>是如何从<code>Engine\Plugins\Editor\GameplayTagEditor\Source\GameplayTagEditor\Private\SGameplayTagGraphPin.cpp</code>中调用<code>FilterString = UGameplayTagManager::Get().GetCategoriesMetaFromField(PinStructType);</code>的, 还有是如何在<code>SGameplayTagGraphPin::GetListContent()</code>中将<code>FilterString</code>传递给<code>SGameplayTagWidget</code>的, <code>Engine\Plugins\Editor\GameplayTagEditor\Source\GameplayTagEditor\Private\S</code>GameplayTagContainer<code>GraphPin.cpp</code>中这些函数的<code>GameplayTagContainer</code>版本并没有检查Meta域属性和传递过滤器.  </p><p>样例项目广泛地使用了<code>GameplayTag</code>.  </p><p><strong><a href="#table-of-contents">⬆ 返回目录</a></strong></p><p><span id="concepts-gt-change"></span></p><h3 id="4-2-1-响应Gameplay-Tags的变化"><a href="#4-2-1-响应Gameplay-Tags的变化" class="headerlink" title="4.2.1 响应Gameplay Tags的变化"></a>4.2.1 响应Gameplay Tags的变化</h3><p><code>ASC</code>提供了一个委托(Delegate)用于在<code>GameplayTag</code>添加或移除时触发, 其中<code>EGameplayTagEventType</code>参数可以明确是该<code>GameplayTag</code>添加/移除还是其<code>TagMapCount</code>发生变化时触发.  </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">AbilitySystemComponent-&gt;<span class="built_in">RegisterGameplayTagEvent</span>(FGameplayTag::<span class="built_in">RequestGameplayTag</span>(<span class="built_in">FName</span>(<span class="string">&quot;State.Debuff.Stun&quot;</span>)), EGameplayTagEventType::NewOrRemoved).<span class="built_in">AddUObject</span>(<span class="keyword">this</span>, &amp;AGDPlayerState::StunTagChanged);</span><br></pre></td></tr></table></figure><p>回调函数拥有变化的<code>GameplayTag</code>参数和新的<code>TagCount</code>参数.  </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">StunTagChanged</span><span class="params">(<span class="type">const</span> FGameplayTag CallbackTag, int32 NewCount)</span></span>;</span><br></pre></td></tr></table></figure><p><strong><a href="#table-of-contents">⬆ 返回目录</a></strong></p><p><span id="concepts-a"></span></p><h2 id="4-3-Attribute"><a href="#4-3-Attribute" class="headerlink" title="4.3 Attribute"></a>4.3 Attribute</h2><p><span id="concepts-a-definition"></span></p><h3 id="4-3-1-Attribute定义"><a href="#4-3-1-Attribute定义" class="headerlink" title="4.3.1 Attribute定义"></a>4.3.1 Attribute定义</h3><p><code>Attribute</code>是由<a href="https://docs.unrealengine.com/en-US/API/Plugins/GameplayAbilities/FGameplayAttributeData/index.html">FGameplayAttributeData</a>结构体定义的浮点值, 其可以表示从角色生命值到角色等级再到一瓶药水的剂量的任何事物, 如果某项数值是属于某个Actor且游戏相关的, 你就应该考虑使用<code>Attribute</code>. <code>Attribute</code>一般应该只能由<a href="#concepts-ge">GameplayEffect</a>修改, 这样<code>ASC</code>才能<a href="#concepts-p">预测(Predict)</a>其改变.  </p><p><code>Attribute</code>也可以由<code>AttributeSet</code>定义并存于其中. <a href="#concepts-as">AttributeSet</a>用于同步那些标记为replication的<code>Attribute</code>. 参阅<a href="#concepts-as">AttributeSet</a>部分来了解如何定义<code>Attribute</code>.  </p><p><strong>Tip</strong>: 如果你不想某个<code>Attribute</code>显示在编辑器的<code>Attribute</code>列表, 可以使用<code>Meta = (HideInDetailsView)</code>属性宏.  </p><p><strong><a href="#table-of-contents">⬆ 返回目录</a></strong></p><p><span id="concepts-a-value"></span></p><h3 id="4-3-2-BaseValue-vs-CurrentValue"><a href="#4-3-2-BaseValue-vs-CurrentValue" class="headerlink" title="4.3.2 BaseValue vs. CurrentValue"></a>4.3.2 BaseValue vs. CurrentValue</h3><p>一个<code>Attribute</code>是由两个值 —— 一个<code>BaseValue</code>和一个<code>CurrentValue</code>组成的, <code>BaseValue</code>是<code>Attribute</code>的永久值而<code>CurrentValue</code>是<code>BaseValue</code>加上<code>GameplayEffect</code>给的临时修改值后得到的. 例如, 你的Character可能有一个<code>BaseValue</code>为600u/s的移动速度<code>Attribute</code>, 因为还没有<code>GameplayEffect</code>修改移动速度, 所以<code>CurrentValue</code>也是600u/s, 如果Character获得了一个临时50u/s的移动速度加成, 那么<code>BaseValue</code>仍然是600u/s而<code>CurrentValue</code>是600+50=650u/s, 当该移动速度加成消失后, <code>CurrentValue</code>就会变回<code>BaseValue</code>的600u/s.  </p><p>初识GAS的新手经常将<code>BaseValue</code>误认为<code>Attribute</code>的最大值并以这样的认识去编程, 这是错误的, 可以修改或引用的Ability/UI中的<code>Attribute</code>最大值应该是另外单独的<code>Attribute</code>. 对于硬编码的最大值和最小值, 有一种方法是使用可以设置最大值和最小值的<code>FAttributeMetaData</code>定义一个DataTable, 但是Epic在该结构体上的注释称之为”work in progress”, 详见<code>AttributeSet.h</code>. 为了避免这种疑惑, 我建议引用在Ability或UI中的最大值应该单独定义<code>Attribute</code>, 只用于限制(Clamp)<code>Attribute</code>大小的硬编码最大值和最小值应该在<code>AttributeSet</code>中定义为硬编码浮点值. 关于限制(Clamp)<code>Attribute</code>值的问题在<a href="#concepts-as-preattributechange">PreAttributeChange()</a>中讨论了CurrentValue的修改, 在<a href="#concepts-as-postgameplayeffectexecute">PostGameplayEffectExecute()</a>中讨论了<code>GameplayEffect</code>对<code>BaseValue</code>的修改.  </p><p><code>即刻(Instant)GameplayEffect</code>可以永久性的修改<code>BaseValue</code>, 而<code>持续(Duration)</code>和<code>无限(Infinite)GameplayEffect</code>可以修改CurrentValue. 周期性(Periodic)<code>GameplayEffect</code>被视为<code>即刻(Instant)GameplayEffect</code>并且可以修改<code>BaseValue</code>.  </p><p><strong><a href="#table-of-contents">⬆ 返回目录</a></strong></p><p><span id="concepts-a-meta"></span></p><h3 id="4-3-3-元-Meta-Attribute"><a href="#4-3-3-元-Meta-Attribute" class="headerlink" title="4.3.3 元(Meta)Attribute"></a>4.3.3 元(Meta)Attribute</h3><p>一些<code>Attribute</code>被视为占位符, 其是用于预计和<code>Attribute</code>交互的临时值, 这些<code>Attribute</code>被叫做<code>Meta Attribute</code>. 例如, 我们通常定义伤害值为<code>Meta Attribute</code>, 使用伤害值<code>Meta Attribute</code>作为占位符, 而不是使用<code>GameplayEffect</code>直接修改生命值<code>Attribute</code>, 使用这种方法, 伤害值就可以在<a href="#concepts-ge-ec">GameplayEffectExecutionCalculation</a>中由buff和debuff修改, 并且可以在<code>AttributeSet</code>中进一步操作, 例如, 在最终将生命值减去伤害值之前, 要将伤害值减去当前的护盾值. 伤害值<code>Meta Attribute</code>在<code>GameplayEffect</code>之间不是持久化的, 并且可以被任何一方重写. <code>Meta Attribute</code>一般是不可同步的.  </p><p><code>Meta Attribute</code>对于在”我们应该造成多少伤害?”和”我们该如何处理伤害值?”这种问题之中的伤害值和治疗值做了很好的解构, 这种解构意味着<code>GameplayEffect</code>和<code>ExecutionCalculation</code>无需了解目标是如何处理伤害值的. 继续看伤害值的例子, <code>GameplayEffect</code>确定造成多少伤害, 之后<code>AttributeSet</code>决定如何使用该伤害值, 不是所有的Character都有相同的<code>Attribute</code>, 特别是使用了<code>AttributeSet</code>子类的话, <code>AttributeSet</code>基类可能只有一个生命值<code>Attribute</code>, 但是它的子类可能增加了一个护盾值<code>Attribute</code>, 拥有护盾值<code>Attribute</code>的子类<code>AttributeSet</code>可能会以不同于<code>AttributeSet</code>基类的方式分配收到的伤害.  </p><p>尽管<code>Meta Attribute</code>是一个很好的设计模式, 但其并不是强制使用的. 如果你只有一个用于所有伤害实例的<code>Execution Calculation</code>和一个所有Character共用的<code>AttributeSet</code>类, 那么你就可以在<code>Exeuction Calculation</code>中分配伤害到生命, 护盾等等, 并直接修改那些<code>Attribute</code>, 这种方式你只会丢失灵活性, 但总体上并无大碍.  </p><p><strong><a href="#table-of-contents">⬆ 返回目录</a></strong></p><p><span id="concepts-a-changes"></span></p><h3 id="4-3-4-响应Attribute变化"><a href="#4-3-4-响应Attribute变化" class="headerlink" title="4.3.4 响应Attribute变化"></a>4.3.4 响应Attribute变化</h3><p>为了监听<code>Attribute</code>何时变化以便更新UI和其他游戏逻辑, 可以使用<code>UAbilitySystemComponent::GetGameplayAttributeValueChangeDelegate(FGameplayAttribute</code>Attribute<code>)</code>, 该函数返回一个委托(Delegate), 你可以将其绑定一个当<code>Attribute</code>变化时需要自动调用的函数. 该委托提供一个<code>FOnAttributeChangeData</code>参数, 其中有<code>NewValue</code>, <code>OldValue</code>和<code>FGameplayEffectModCallbackData</code>. <strong>Note</strong>: <code>FGameplayEffectModCallbackData</code>只能在服务端上设置.  </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">AbilitySystemComponent-&gt;<span class="built_in">GetGameplayAttributeValueChangeDelegate</span>(AttributeSetBase-&gt;<span class="built_in">GetHealthAttribute</span>()).<span class="built_in">AddUObject</span>(<span class="keyword">this</span>, &amp;AGDPlayerState::HealthChanged);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">HealthChanged</span><span class="params">(<span class="type">const</span> FOnAttributeChangeData&amp; Data)</span></span>;</span><br></pre></td></tr></table></figure><p>样例项目将其绑定到了<code>GDPlayerState</code>用于更新HUD, 当生命值下降为0时, 也可以响应玩家死亡.  </p><p>样例项目中有一个将上述逻辑包裹进<code>ASyncTask</code>的自定义蓝图节点, 其在<code>UI_HUD(UMG Widget)</code>中用于更新生命值, 魔法值和耐力值. 该AsyncTask会一直响应直到手动调用<code>EndTask()</code>, 就像在UMG Widget的<code>Destruct</code>事件中调用那样. 参阅<code>AsyncTaskAttributeChanged.h/cpp</code>.  </p><p><img src="https://pic1.imgdb.cn/item/67a4c4a4d0e0a243d4fc5382.png" alt="Listen for Attribute Change BP Node"> </p><p><strong><a href="#table-of-contents">⬆ 返回目录</a></strong></p><p><span id="concepts-a-derived"></span></p><h3 id="4-3-5-自动推导Attribute"><a href="#4-3-5-自动推导Attribute" class="headerlink" title="4.3.5 自动推导Attribute"></a>4.3.5 自动推导Attribute</h3><p>为了使一个<code>Attribute</code>的部分或全部值继承自一个或更多<code>Attribute</code>, 可以使用基于一个或多个<code>Attribute</code>或<a href="#concepts-ge-mmc">MMC</a> <a href="#concepts-ge-mods">Modifiers</a>的<code>无限(Infinite)GameplayEffect</code>. 当自动推导<code>Attribute</code>依赖的某个<code>Attribute</code>更新时它也会自动更新.  </p><p>在自动推导<code>Attribute</code>上的所有<code>Modifier</code>形成的最终公式和<code>Modifier Aggregators</code>的公式是一样的. 如果你需要计算式要按一定的顺序进行, 在<code>MMC</code>中做就是了.  </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">((CurrentValue + Additive) * Multiplicitive) / Division</span><br></pre></td></tr></table></figure><p><strong>Note</strong>: 如果在PIE中打开多个窗口, 你需要在编辑器首选项中禁用<code>Run Under One Process</code>, 否则当自动推导<code>Attribute</code>所依赖的<code>Attribute</code>更新时, 除了第一个窗口外其不会更新.  </p><p>在这个例子中, 我们有一个<code>无限(Infinite)GameplayEffect</code>, 其从TestAttrB和TestAttrC <code>Attribute</code>以<code>TestAttrA = (TestAttrA + TestAttrB) * ( 2 * TestAttrC)</code>公式继承得到TestAttrA, 每次TestAttrB和TestAttrC更新时, TestAttrA都会自动重新计算.  </p><p><img src="https://pic1.imgdb.cn/item/67a4c4c9d0e0a243d4fc5389.png" alt="Derived Attribute Example">  </p><p><strong><a href="#table-of-contents">⬆ 返回目录</a></strong></p><p><span id="concepts-as"></span></p><h2 id="4-4-AttributeSet"><a href="#4-4-AttributeSet" class="headerlink" title="4.4 AttributeSet"></a>4.4 AttributeSet</h2><p><span id="concepts-as-definition"></span></p><h3 id="4-4-1-定义AttributeSet"><a href="#4-4-1-定义AttributeSet" class="headerlink" title="4.4.1 定义AttributeSet"></a>4.4.1 定义AttributeSet</h3><p><code>AttributeSet</code>用于定义, 保存以及管理对<code>Attribute</code>的修改. 开发者应该继承<a href="https://docs.unrealengine.com/en-US/API/Plugins/GameplayAbilities/UAttributeSet/index.html">UAttributeSet</a>. 在OwnerActor的构造函数中创建<code>AttributeSet</code>会自动注册到其<code>ASC</code>. <strong>这必须在C++中完成.</strong>  </p><p><strong><a href="#table-of-contents">⬆ 返回目录</a></strong></p><p><span id="concepts-as-design"></span></p><h3 id="4-4-2-设计AttributeSet"><a href="#4-4-2-设计AttributeSet" class="headerlink" title="4.4.2 设计AttributeSet"></a>4.4.2 设计AttributeSet</h3><p>一个<code>ASC</code>可能有一个或多个<code>AttributeSet</code>, <code>AttributeSet</code>消耗的内存微不足道, 使用多少<code>AttributeSet</code>是留给开发人员决定的.  </p><p>有种方案是设置一个单一且巨大的<code>AttributeSet</code>, 共享于游戏中的所有Actor, 并且只使用需要的<code>Attribute</code>, 忽略不用的<code>Attribute</code>.  </p><p>作为选择, 你可以使用多个<code>AttributeSet</code>来表示按需添加到Actor的<code>Attribute</code>分组, 例如, 你可以有一个生命相关的<code>AttributeSet</code>, 一个魔法相关的<code>AttributeSet</code>等等. 在MOBA游戏中, 英雄可能需要魔法, 但是小兵并不需要, 因此英雄就需要魔法<code>AttributeSet</code>而小兵则不需要.  </p><p>另外, 继承<code>AttributeSet</code>的另一种意义是可以选择一个Actor可以有哪些<code>Attribute</code>. <code>Attribute</code>在内部被引用为<code>AttributeSetClassName.AttributeName</code>, 当你继承<code>AttributeSet</code>时, 所有父类的<code>Attribute</code>仍将保留父类名作为前缀.  </p><p>尽管可以拥有多个<code>AttributeSet</code>, 但是不应该在同一<code>ASC</code>中拥有多个同一类的<code>AttributeSet</code>, 如果在同一<code>ASC</code>中有多个同一类的<code>AttributeSet</code>, <code>ASC</code>就不知道该使用哪个<code>AttributeSet</code>而随机选择一个.  </p><p><strong><a href="#table-of-contents">⬆ 返回目录</a></strong></p><p><span id="concepts-as-design-subcomponents"></span></p><h4 id="4-4-2-1-使用单独Attribute的子组件"><a href="#4-4-2-1-使用单独Attribute的子组件" class="headerlink" title="4.4.2.1 使用单独Attribute的子组件"></a>4.4.2.1 使用单独Attribute的子组件</h4><p>假设你在某个Pawn上有多个可被损害的组件, 像可被独立损害的护甲片, 如果可以明确可被损害组件的最大数量, 我建议把多个生命值<code>Attribute</code>放到一个<code>AttributeSet</code>中 —— DamageableCompHealth0, DamageableCompHealth1, 等等, 以表示这些可被损害组件在逻辑上的”slot”, 在可被损害组件的类实例中, 指定可以被<code>GameplayAbility</code>和<a href="#concepts-ge-ec">Execution</a>读取的带slot编号的<code>Attribute</code>来表明该应用伤害值到哪个<code>Attribute</code>. 如果Pawn当前拥有0个或少于最大数量的可损害组件也无妨, 因为<code>AttributeSet</code>拥有一个<code>Attribute</code>, 并不意味着必须要使用它, 未使用的<code>Attribute</code>只占用很少的内存.  </p><p>如果每个子组件都需要很多<code>Attribute</code>且子组件的数量可以是无限的, 或者子组件可以分离被其他玩家使用(比如武器), 或者出于其他原因上述方法不适用于你, 那么我建议就不要使用<code>Attribute</code>, 而是在组件中保存普通的浮点数. 参阅<a href="#concepts-as-design-itemattributes">Item Attribute</a>.  </p><p><strong><a href="#table-of-contents">⬆ 返回目录</a></strong></p><p><span id="concepts-as-design-addremoveruntime"></span></p><h4 id="4-4-2-2-运行时添加和移除AttributeSet"><a href="#4-4-2-2-运行时添加和移除AttributeSet" class="headerlink" title="4.4.2.2 运行时添加和移除AttributeSet"></a>4.4.2.2 运行时添加和移除AttributeSet</h4><p><code>AttributeSet</code>可以在运行时从<code>ASC</code>上添加和移除, 然而移除<code>AttributeSet</code>是很危险的, 例如, 如果某个<code>AttributeSet</code>在客户端上移除早于服务端, 而某个<code>Attribute</code>的变化又同步到了客户端, 那么<code>Attribute</code>就会因为找不到<code>AttributeSet</code>而使游戏崩溃.  </p><p>武器添加到Inventory:  </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">AbilitySystemComponent-&gt;SpawnedAttribute.<span class="built_in">AddUnique</span>(WeaponAttributeSetPointer);</span><br><span class="line">AbilitySystemComponent-&gt;<span class="built_in">ForceReplication</span>();</span><br></pre></td></tr></table></figure><p>武器从Inventory移除:  </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">AbilitySystemComponent-&gt;SpawnedAttribute.<span class="built_in">Remove</span>(WeaponAttributeSetPointer);</span><br><span class="line">AbilitySystemComponent-&gt;<span class="built_in">ForceReplication</span>();</span><br></pre></td></tr></table></figure><p><strong><a href="#table-of-contents">⬆ 返回目录</a></strong></p><p><span id="concepts-as-design-itemattributes"></span></p><h4 id="4-4-2-3-Item-Attribute-武器弹药"><a href="#4-4-2-3-Item-Attribute-武器弹药" class="headerlink" title="4.4.2.3 Item Attribute(武器弹药)"></a>4.4.2.3 Item Attribute(武器弹药)</h4><p>有几种方法可以实现带有<code>Attribute</code>(武器弹药, 盔甲耐久等等)的可装备物品, 所有这些方法都直接在物品中存储数据, 这对于在生命周期中可以被多个玩家装备的物品来说是必须的.  </p><ol><li>在物品中使用普通的浮点数(推荐).</li><li>在物品中使用单独的<code>AttributeSet</code>.</li><li>在物品中使用单独的<code>ASC</code>.</li></ol><p><strong><a href="#table-of-contents">⬆ 返回目录</a></strong></p><p><span id="concepts-as-design-itemattributes-plainfloats"></span></p><h5 id="4-4-2-3-1-在物品中使用普通浮点数"><a href="#4-4-2-3-1-在物品中使用普通浮点数" class="headerlink" title="4.4.2.3.1 在物品中使用普通浮点数"></a>4.4.2.3.1 在物品中使用普通浮点数</h5><p>在物品类实例中存储普通浮点数而不是<code>Attribute</code>, Fortnite和<a href="https://github.com/tranek/GASShooter">GASShooter</a>就是这样处理枪械子弹的, 对于枪械, 在其实例中存储可同步的浮点数(COND_OwnerOnly), 比如最大弹匣量, 当前弹匣中弹药量, 剩余弹药量等等, 如果枪械需要共享剩余弹药量, 那么就将剩余弹药量移到Character中共享的弹药<code>AttributeSet</code>里作为一个<code>Attribute</code>(换弹Ability可以使用一个<code>Cost GE</code>从剩余弹药量中填充枪械的弹匣弹药量浮点). 因为没有为当前弹匣弹药量使用<code>Attribute</code>, 所以需要重写<code>UGameplayAbility</code>中的一些函数来检查和应用枪械中浮点数的花销(cost). 当授予Ability时将枪械在<a href="https://github.com/tranek/GASDocumentation#concepts-ga-spec">GameplayAbilitySpec</a>中转换为<code>SourceObject</code>, 这意味着可以在Ability中访问授予Ability的枪械.  </p><p>为了防止在全自动射击过程中枪械会反向同步弹药量并扰乱本地弹药量(译者注: 通俗解释就是因为存在同步延迟且在连续射击这一高同步过程中, 所以客户端的弹药量会来不及和服务端同步, 造成弹药量减少后又突然变多的现象.), 如果玩家拥有<code>IsFiring</code>的<code>GameplayTag</code>, 就在PreReplication()中禁用同步, 本质上是要在其中做自己的本地预测.  </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">AGSWeapon::PreReplication</span><span class="params">(IRepChangedPropertyTracker&amp; ChangedPropertyTracker)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Super::<span class="built_in">PreReplication</span>(ChangedPropertyTracker);</span><br><span class="line"></span><br><span class="line"><span class="built_in">DOREPLIFETIME_ACTIVE_OVERRIDE</span>(AGSWeapon, PrimaryClipAmmo, (<span class="built_in">IsValid</span>(AbilitySystemComponent) &amp;&amp; !AbilitySystemComponent-&gt;<span class="built_in">HasMatchingGameplayTag</span>(WeaponIsFiringTag)));</span><br><span class="line"><span class="built_in">DOREPLIFETIME_ACTIVE_OVERRIDE</span>(AGSWeapon, SecondaryClipAmmo, (<span class="built_in">IsValid</span>(AbilitySystemComponent) &amp;&amp; !AbilitySystemComponent-&gt;<span class="built_in">HasMatchingGameplayTag</span>(WeaponIsFiringTag)));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>好处:  </p><ol><li>避免了使用<code>AttributeSet</code>的局限(见下).</li></ol><p>局限:  </p><ol><li>不能使用现有的<code>GameplayEffect</code>工作流(弹药使用的Cost GEs等等).</li><li>要求重写UGameplayAbility中的关键函数来检查和应用枪械中浮点数的花销(Cost).</li></ol><p><strong><a href="#table-of-contents">⬆ 返回目录</a></strong></p><p><span id="concepts-as-design-itemattributes-attributeset"></span></p><h5 id="4-4-2-3-2-在物品中使用AttributeSet"><a href="#4-4-2-3-2-在物品中使用AttributeSet" class="headerlink" title="4.4.2.3.2 在物品中使用AttributeSet"></a>4.4.2.3.2 在物品中使用AttributeSet</h5><p>在物品中使用单独的<code>AttributeSet</code>可以实现<a href="#concepts-as-design-addremoveruntime">将其添加到玩家的Inventory</a>, 但还是有一定的局限性. 较早版本的<a href="https://github.com/tranek/GASShooter">GASShooter</a>中的武器弹药是使用的这种方法, 武器类在其自身存储诸如最大弹匣量, 当前弹匣弹药量, 剩余弹药量等等到一个<code>AttributeSet</code>, 如果枪械需要共享剩余弹药量, 那么就将剩余弹药量移到Character中共享的弹药<code>AttributeSet</code>里. 当服务端上某个武器添加到玩家的Inventory后, 该武器会将它的<code>AttributeSet</code>添加到玩家的<code>ASC::SpawnedAttribute</code>, 之后服务端会将其同步下发到客户端, 如果该武器从Inventory中移除, 它也会将其<code>AttributeSet</code>从<code>ASC::SpawnedAttribute</code>中移除.  </p><p>当<code>AttributeSet</code>存于除了OwnerActor之外的对象上时(对于某个武器来说), 会得到一些关于<code>AttributeSet</code>的编译错误, 解决办法是在BeginPlay()中构建<code>AttributeSet</code>而不是在构造函数中, 并在武器类中实现<code>IAbilitySystemInterface</code>(当你添加武器到玩家Inventory时设置<code>ASC</code>的指针).  </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">AGSWeapon::BeginPlay</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (!AttributeSet)</span><br><span class="line">&#123;</span><br><span class="line">AttributeSet = <span class="built_in">NewObject</span>&lt;UGSWeaponAttributeSet&gt;(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>你可以查看<a href="https://github.com/tranek/GASShooter/tree/df5949d0dd992bd3d76d4a728f370f2e2c827735">较早版本的GASShooter</a>来实际地体会这种方案.  </p><p>好处:  </p><ol><li>可以使用已有的<code>GameplayAbility</code>和<code>GameplayEffect</code>工作流(弹药使用的Cost GEs等等).</li><li>对于很小的物品集可以快速设置</li></ol><p>局限:  </p><ol><li>必须为每个武器类型创建新的<code>AttributeSet</code>类, <code>ASC</code>实际上只能有一个该类的<code>AttributeSet</code>实例, 因为对<code>Attribute</code>的修改会在<code>ASC</code>的SpawnedAttribute数组中寻找其第一个<code>AttributeSet</code>类实例, 其他相同的<code>AttributeSet</code>类实例则会被忽略.  </li><li>和第1条同样的原因(每个<code>AttributeSet</code>类一个<code>AttributeSet</code>实例), 在玩家的Inventory中每种武器类型只能有一个.</li><li>移除<code>AttributeSet</code>是很危险的. 在GASShooter中, 如果玩家因为火箭弹而自杀, 玩家会立即从其Inventory中移除火箭弹发射器(包括其在<code>ASC</code>中的<code>AttributeSet</code>), 当服务端同步火箭弹发射器的弹药<code>Attribute</code>改变时, 由于<code>AttributeSet</code>在客户端<code>ASC</code>上不复存在而使游戏崩溃.</li></ol><p><strong><a href="#table-of-contents">⬆ 返回目录</a></strong></p><p><span id="concepts-as-design-itemattributes-asc"></span></p><h5 id="4-4-2-3-3-在物品中使用单独的ASC"><a href="#4-4-2-3-3-在物品中使用单独的ASC" class="headerlink" title="4.4.2.3.3 在物品中使用单独的ASC"></a>4.4.2.3.3 在物品中使用单独的ASC</h5><p>在每个物品上都创建一个<code>AbilitySystemComponent</code>是种很极端的方案. 我还没有亲自做过这种方案, 在其他地方也没见过. 这种方案应该会花费相当的开发成本才能正常使用.  </p><blockquote><p>Is it viable to have several AbilitySystemComponents which have the same owner but different avatars (e.g. on pawn and weapon/items/projectiles with Owner set to PlayerState)?</p><p>The first problem I see there would be implementing the IGameplayTagAssetInterface and IAbilitySystemInterface on the owning Actor. The former may be possible: just aggregate the tags from all all ASCs (but watch out -HasAlMatchingGameplayTag may be met only via cross ASC aggregation. It wouldn’t be enough to just forward that calls to each ASC and OR the results together). But the later is even trickier: which ASC is the authoritative one? If someone wants to apply a GE -which one should receive it? Maybe you can work these out but this side of the problem will be the hardest: owners will multiple ASCs beneath them.</p><p>Separate ASCs on the pawn and the weapon can make sense on its own though. E.g, distinguishing between tags the describe the weapon vs those that describe the owning pawn. Maybe it does make sense that tags granted to the weapon also “apply” to the owner and nothing else (E.g, Attribute and GEs are independent but the owner will aggregate the owned tags like I describe above). This could work out, I am sure. But having multiple ASCs with the same owner may get dicey.</p></blockquote><p><em><a href="https://epicgames.ent.box.com/s/m1egifkxv3he3u3xezb9hzbgroxyhx89">community questions #6</a>中来自Epic的Dave Ratti的回答.</em>  </p><p>好处: </p><ol><li>可以使用已有的<code>GameplayAbility</code>和<code>GameplayEffect</code>工作流(弹药使用的Cost GEs等等).</li><li>可以复用<code>AttributeSet</code>类(每个武器的<code>ASC</code>中各一个).</li></ol><p>局限:  </p><ol><li>未知的开发成本.</li><li>甚至方案可行么?</li></ol><p><strong><a href="#table-of-contents">⬆ 返回目录</a></strong></p><p><span id="concepts-as-attributes"></span></p><h3 id="4-4-3-定义Attribute"><a href="#4-4-3-定义Attribute" class="headerlink" title="4.4.3 定义Attribute"></a>4.4.3 定义Attribute</h3><p><strong>Attribute只能使用C++在AttributeSet头文件中定义.</strong> 建议把下面这个宏块加到每个<code>AttributeSet</code>头文件的顶部, 其会自动为每个<code>Attribute</code>生成getter和setter函数.  </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Uses macros from AttributeSet.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ATTRIBUTE_ACCESSORS(ClassName, PropertyName) \</span></span><br><span class="line"><span class="meta">GAMEPLAYATTRIBUTE_PROPERTY_GETTER(ClassName, PropertyName) \</span></span><br><span class="line"><span class="meta">GAMEPLAYATTRIBUTE_VALUE_GETTER(PropertyName) \</span></span><br><span class="line"><span class="meta">GAMEPLAYATTRIBUTE_VALUE_SETTER(PropertyName) \</span></span><br><span class="line"><span class="meta">GAMEPLAYATTRIBUTE_VALUE_INITTER(PropertyName)</span></span><br></pre></td></tr></table></figure><p>一个可同步的生命值<code>Attribute</code>可能像下面这样定义:  </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">UPROPERTY</span>(BlueprintReadOnly, Category = <span class="string">&quot;Health&quot;</span>, ReplicatedUsing = OnRep_Health)</span><br><span class="line">FGameplayAttributeData Health;</span><br><span class="line"><span class="built_in">ATTRIBUTE_ACCESSORS</span>(UGDAttributeSetBase, Health)</span><br></pre></td></tr></table></figure><p>同样在头文件中定义OnRep函数:  </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">UFUNCTION</span>()</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">OnRep_Health</span><span class="params">(<span class="type">const</span> FGameplayAttributeData&amp; OldHealth)</span></span>;</span><br></pre></td></tr></table></figure><p><code>AttributeSet</code>的.cpp文件应该用预测系统(Prediction System)使用的<code>GAMEPLAYATTRIBUTE_REPNOTIFY</code>宏填充OnRep函数:  </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">UGDAttributeSetBase::OnRep_Health</span><span class="params">(<span class="type">const</span> FGameplayAttributeData&amp; OldHealth)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">GAMEPLAYATTRIBUTE_REPNOTIFY</span>(UGDAttributeSetBase, Health, OldHealth);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后, <code>Attribute</code>需要添加到<code>GetLifetimeReplicatedProps</code>:  </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">UGDAttributeSetBase::GetLifetimeReplicatedProps</span><span class="params">(TArray&lt;FLifetimeProperty&gt;&amp; OutLifetimeProps)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Super::<span class="built_in">GetLifetimeReplicatedProps</span>(OutLifetimeProps);</span><br><span class="line"></span><br><span class="line"><span class="built_in">DOREPLIFETIME_CONDITION_NOTIFY</span>(UGDAttributeSetBase, Health, COND_None, REPNOTIFY_Always);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>REPTNOTIFY_Always</code>用于设置OnRep函数在客户端值已经与服务端同步的值相同的情况下触发(因为有预测), 默认设置下, 客户端值与服务端同步的值相同时, OnRep函数是不会触发的.  </p><p>如果<code>Attribute</code>无需像<code>Meta Attribute</code>那样同步, 那么<code>OnRep</code>和<code>GetLifetimeReplicatedProps</code>步骤可以跳过.  </p><p><strong><a href="#table-of-contents">⬆ 返回目录</a></strong></p><p><span id="concepts-as-init"></span></p><h3 id="4-4-4-初始化Attribute"><a href="#4-4-4-初始化Attribute" class="headerlink" title="4.4.4 初始化Attribute"></a>4.4.4 初始化Attribute</h3><p>有多种方法可以初始化<code>Attribute</code>(将BaseValue和CurrentValue设置为某初始值). Epic建议使用<code>即刻(Instant)GameplayEffect</code>, 这也是样例项目使用的方法.  </p><p>查看样例项目的GE_HeroAttribute蓝图来了解如何创建<code>即刻(Instant)GameplayEffect</code>以初始化<code>Attribute</code>, 该<code>GameplayEffect</code>应用是写在C++中的.  </p><p>如果在定义<code>Attribute</code>时使用了ATTRIBUTE_ACCESSORS宏, 那么在<code>AttributeSet</code>中会自动为每个<code>Attribute</code>生成一个初始化函数.  </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// InitHealth(float InitialValue) is an automatically generated function for an Attribute &#x27;Health&#x27; defined with the `ATTRIBUTE_ACCESSORS` macro</span></span><br><span class="line">AttributeSet-&gt;<span class="built_in">InitHealth</span>(<span class="number">100.0f</span>);</span><br></pre></td></tr></table></figure><p>查看<code>AttributeSet.h</code>获取更多初始化<code>Attribute</code>的方法.  </p><p><strong>Note</strong>: 4.24之前, FAttributeSetInitterDiscreteLevels不能和FGameplayAttributeData协同使用, 它在<code>Attribute</code>是原生浮点数时创建, 并且会和FGameplayAttributeData不是Plain Old Data(POD)时冲突. 该问题在4.24中修复(<a href="https://issues.unrealengine.com/issue/UE-76557">https://issues.unrealengine.com/issue/UE-76557.</a>).  </p><p><strong><a href="#table-of-contents">⬆ 返回目录</a></strong></p><p><span id="concepts-as-preattributechange"></span></p><h3 id="4-4-5-PreAttributeChange"><a href="#4-4-5-PreAttributeChange" class="headerlink" title="4.4.5 PreAttributeChange()"></a>4.4.5 PreAttributeChange()</h3><p><code>PreAttributeChange(const FGameplayAttribute&amp; Attribute, float&amp; NewValue)</code>是<code>AttributeSet</code>中的主要函数之一, 其在修改发生前响应<code>Attribute</code>的CurrentValue变化, 其是通过引用参数NewValue限制(Clamp)CurrentValue即将进行的修改的理想位置.  </p><p>例如像样例项目那样限制移动速度<code>Modifier</code>:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (Attribute == <span class="built_in">GetMoveSpeedAttribute</span>())</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// Cannot slow less than 150 units/s and cannot boost more than 1000 units/s</span></span><br><span class="line">NewValue = FMath::<span class="built_in">Clamp</span>&lt;<span class="type">float</span>&gt;(NewValue, <span class="number">150</span>, <span class="number">1000</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><code>GetMoveSpeedAttribute()</code>函数是由我们在<code>AttributeSet.h</code>中添加的宏块创建的(<a href="#concepts-as-attributes">定义Attribute</a>).  </p><p><code>PreAttributeChange()</code>可以被<code>Attribute</code>的任何修改触发, 无论是使用<code>Attribute</code>的setter(由<code>AttributeSet.h</code>中的宏块定义(<a href="#concepts-as-attributes">定义Attribute</a>))还是使用<a href="#concepts-ge">GameplayEffect</a>.  </p><p><strong>Note</strong>: 在这里做的任何限制都不会永久性地修改<code>ASC</code>中的<code>Modifier</code>, 只会修改查询<code>Modifier</code>的返回值, 这意味着像<a href="#concepts-ge-ec">GameplayEffectExecutionCalculations</a>和<a href="#concepts-ge-mmc">ModifierMagnitudeCalculations</a>这种自所有<code>Modifier</code>重新计算CurrentValue的函数需要再次执行限制(Clamp)操作.  </p><p><strong>Note</strong>: Epic对于PreAttributeChange()的注释说明不要将该函数用于游戏逻辑事件, 而主要在其中做限制操作. 对于修改<code>Attribute</code>的游戏逻辑事件的建议位置是<code>UAbilitySystemComponent::GetGameplayAttributeValueChangeDelegate(FGameplayAttribute Attribute)</code>(<a href="#concepts-a-changes">响应Attribute变化</a>).  </p><p><strong><a href="#table-of-contents">⬆ 返回目录</a></strong></p><p><span id="concepts-as-postgameplayeffectexecute"></span></p><h3 id="4-4-6-PostGameplayEffectExecute"><a href="#4-4-6-PostGameplayEffectExecute" class="headerlink" title="4.4.6 PostGameplayEffectExecute()"></a>4.4.6 PostGameplayEffectExecute()</h3><p><code>PostGameplayEffectExecute(const FGameplayEffectModCallbackData &amp; Data)</code>仅在<code>即刻(Instant)GameplayEffect</code>对<code>Attribute</code>的BaseValue修改之后触发, 当<a href="#concepts-ge">GameplayEffect</a>对其修改时, 这就是一个处理更多<code>Attribute</code>操作的有效位置.  </p><p>例如, 在样例项目中, 我们在这里从生命值<code>Attribute</code>中减去了最终的伤害值<code>Meta Attribute</code>, 如果有护盾值<code>Attribute</code>的话, 我们也会在减除生命值之前从护盾值中减除伤害值. 样例项目也在这里应用了被击打反应动画, 显示浮动的伤害数值和为击杀者分配经验值和赏金. 通过设计, 伤害值<code>Meta Attribute</code>总是会传递给<code>即刻(Instant)GameplayEffect</code>而不是Attribute Setter.  </p><p>其他只会由<code>即刻(Instant)GameplayEffect</code>修改BaseValue的<code>Attribute</code>, 像魔法值和耐力值, 也可以在这里被限制为其相应的最大值<code>Attribute</code>.  </p><p><strong>Note</strong>: 当PostGameplayEffectExecute()被调用时, 对<code>Attribute</code>的修改已经发生, 但是还没有被同步回客户端, 因此在这里限制值不会造成对客户端的二次同步, 客户端只会接收到限制后的值.  </p><p><strong><a href="#table-of-contents">⬆ 返回目录</a></strong></p><p><span id="concepts-as-onattributeaggregatorcreated"></span></p><h3 id="4-4-7-OnAttributeAggregatorCreated"><a href="#4-4-7-OnAttributeAggregatorCreated" class="headerlink" title="4.4.7 OnAttributeAggregatorCreated()"></a>4.4.7 OnAttributeAggregatorCreated()</h3><p><code>OnAttributeAggregatorCreated(const FGameplayAttribute&amp; Attribute, FAggregator* NewAggregator)</code>会在Aggregator为集合中的某个<code>Attribute</code>创建时触发, 它允许<a href="https://docs.unrealengine.com/en-US/API/Plugins/GameplayAbilities/FAggregatorEvaluateMetaData/index.html">FAggregatorEvaluateMetaData</a>的自定义设置, <code>AggregatorEvaluateMetaData</code>是Aggregator基于所有应用的<code>Modifier(Modifier)</code>评估<code>Attribute</code>的CurrentValue的. 默认情况下, AggregatorEvaluateMetaData只由Aggregator用于确定哪些<a href="#concepts-ge-mods">Modifier</a>是满足条件的, 以MostNegativeMod_AllPositiveMods为例, 其允许所有正(Positive)<code>Modifier</code>但是限制负(Negative)<code>Modifier</code>(仅最负的那一个), 这在Paragon中只允许将最负移动速度减速效果应用到玩家, 而不用管应用所有正移动速度buff时有多少负移动效果. 不满足条件的<code>Modifier</code>仍存于<code>ASC</code>中, 只是不被总合进最终的CurrentValue, 一旦条件改变, 它们之后就可能满足条件, 就像如果最负<code>Modifier</code>过期后, 下一个最负<code>Modifier</code>(如果存在的话)就是满足条件的.  </p><p>为了在只允许最负<code>Modifier</code>和所有正<code>Modifier</code>的例子中使用<code>AggregatorEvaluateMetaData</code>:  </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">OnAttributeAggregatorCreated</span><span class="params">(<span class="type">const</span> FGameplayAttribute&amp; Attribute, FAggregator* NewAggregator)</span> <span class="type">const</span> <span class="keyword">override</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">UGSAttributeSetBase::OnAttributeAggregatorCreated</span><span class="params">(<span class="type">const</span> FGameplayAttribute&amp; Attribute, FAggregator* NewAggregator)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Super::<span class="built_in">OnAttributeAggregatorCreated</span>(Attribute, NewAggregator);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!NewAggregator)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (Attribute == <span class="built_in">GetMoveSpeedAttribute</span>())</span><br><span class="line">&#123;</span><br><span class="line">NewAggregator-&gt;EvaluationMetaData = &amp;FAggregatorEvaluateMetaDataLibrary::MostNegativeMod_AllPositiveMods;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>你的自定义<code>AggregatorEvaluateMetaData</code>应该作为静态变量添加到<code>FAggregatorEvaluateMetaDataLibrary</code>.  </p><p><strong><a href="#table-of-contents">⬆ 返回目录</a></strong></p><p><span id="concepts-ge"></span></p><h2 id="4-5-Gameplay-Effects"><a href="#4-5-Gameplay-Effects" class="headerlink" title="4.5 Gameplay Effects"></a>4.5 Gameplay Effects</h2><p><span id="concepts-ge-definition"></span></p><h3 id="4-5-1-定义GameplayEffect"><a href="#4-5-1-定义GameplayEffect" class="headerlink" title="4.5.1 定义GameplayEffect"></a>4.5.1 定义GameplayEffect</h3><p><a href="https://docs.unrealengine.com/en-US/API/Plugins/GameplayAbilities/UGameplayEffect/index.html">GameplayEffect(GE)</a>是Ability修改其自身和其他<a href="#concepts-a">Attribute</a>和<a href="#concepts-gt">GameplayTag</a>的容器, 其可以立即修改<code>Attribute</code>(像伤害或治疗)或应用长期的状态buff/debuff(像移动速度加速或眩晕). UGameplayEffect只是一个定义单一游戏效果的数据类, 不应该在其中添加额外的逻辑. 设计师一般会创建很多UGameplayEffect的子类蓝图.  </p><p><code>GameplayEffect</code>通过<a href="#concepts-ge-mods">Modifier</a>和<a href="#concepts-ge-ec">Execution(GameplayEffectExecutionCalculation)</a>修改<code>Attribute</code>.  </p><p><code>GameplayEffect</code>有三种持续类型: <code>即刻(Instant)</code>, <code>持续(Duration)</code>和<code>无限(Infinite)</code>.  </p><p>额外地, <code>GameplayEffect</code>可以添加/执行<a href="#concepts-gc">GameplayCue</a>, <code>即刻(Instant)GameplayEffect</code>可以调用<code>GameplayCue GameplayTag</code>的Execute而<code>持续(Duration)</code>或<code>无限(Infinite)</code>可以调用<code>GameplayCue GameplayTag</code>的Add和Remove.  </p><div class="table-container"><table><thead><tr><th style="text-align:center">类型</th><th style="text-align:center">GameplayCue事件</th><th style="text-align:center">何时使用</th></tr></thead><tbody><tr><td style="text-align:center">即刻(Instant)</td><td style="text-align:center">Execute</td><td style="text-align:center">对<code>Attribute</code>中BaseValue立即进行的永久性修改. 其不会应用<code>GameplayTag</code>, 哪怕是一帧.</td></tr><tr><td style="text-align:center">持续(Duration)</td><td style="text-align:center">Add &amp; Remove</td><td style="text-align:center">对<code>Attribute</code>中CurrentValue的临时修改和当<code>GameplayEffect</code>过期或手动移除时, 应用将要被移除的<code>GameplayTag</code>. 持续时间是在UGameplayEffect类/蓝图中明确的.</td></tr><tr><td style="text-align:center">无限(Infinite)</td><td style="text-align:center">Add &amp; Remove</td><td style="text-align:center">对<code>Attribute</code>中CurrentValue的临时修改和当<code>GameplayEffect</code>移除时, 应用将要被移除的<code>GameplayTag</code>. 该类型自身永不过期且必须由某个Ability或<code>ASC</code>手动移除.</td></tr></tbody></table></div><p><code>持续(Duration)</code>和<code>无限(Infinite)GameplayEffect</code>可以选择应用周期性的Effect, 其每过X秒(由周期定义)就应用一次<code>Modifier</code>和Execution, 当周期性的Effect修改<code>Attribute</code>的BaseValue和执行<code>GameplayCue</code>时就被视为<code>即刻(Instant)GameplayEffect</code>, 这种类型的Effect对于像随时间推移的持续伤害(damage over time, DOT)很有用. <strong>Note</strong>: 周期性的Effect不能被<a href="#concepts-p">预测</a>.  </p><p>如果<code>持续(Duration)</code>和<code>无限(Infinite)GameplayEffect</code>的Ongoing Tag Requirements未满足/满足的话(<a href="#concepts-ge-tags">Gameplay Effect Tags</a>), 那么它们在应用后就可以被暂时的关闭和打开, 关闭<code>GameplayEffect</code>会移除其<code>Modifier</code>和已应用<code>GameplayTag</code>效果, 但是不会移除该<code>GameplayEffect</code>, 重新打开<code>GameplayEffect</code>会重新应用其<code>Modifier</code>和<code>GameplayTag</code>.  </p><p>如果你需要手动重新计算某个<code>持续(Duration)</code>或<code>无限(Infinite)GameplayEffect</code>的<code>Modifier</code>(假设有一个使用非<code>Attribute</code>数据的<code>MMC</code>), 可以使用和<code>UAbilitySystemComponent::ActiveGameplayEffect.GetActiveGameplayEffect(ActiveHandle).Spec.GetLevel()</code>相同的Level调用<code>UAbilitySystemComponent::ActiveGameplayEffect.SetActiveGameplayEffectLevel(FActiveGameplayEffectHandle ActiveHandle, int32 NewLevel)</code>. 当<code>Backing Attribute</code>更新时, 基于<code>Backing Attribute</code>的<code>Modifier</code>会自动更新. SetActiveGameplayEffectLevel()更新<code>Modifier</code>的关键函数是:  </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">MarkItemDirty</span>(Effect);</span><br><span class="line">Effect.Spec.<span class="built_in">CalculateModifierMagnitudes</span>();</span><br><span class="line"><span class="comment">// Private function otherwise we&#x27;d call these three functions without needing to set the level to what it already is</span></span><br><span class="line"><span class="built_in">UpdateAllAggregatorModMagnitudes</span>(Effect);</span><br></pre></td></tr></table></figure><p><code>GameplayEffect</code>一般是不实例化的, 当Ability或<code>ASC</code>想要应用<code>GameplayEffect</code>时, 其会从<code>GameplayEffect</code>的<code>ClassDefaultObject</code>创建一个<code>GameplayEffectSpec</code>, 之后成功应用的<code>GameplayEffectSpec</code>会被添加到一个名为<code>FActiveGameplayEffect</code>的新结构体, 其是<code>ASC</code>在名为<code>ActiveGameplayEffect</code>的特殊结构体容器中追踪的内容.  </p><p><strong><a href="#table-of-contents">⬆ 返回目录</a></strong></p><p><span id="concepts-ge-applying"></span></p><h3 id="4-5-2-应用GameplayEffect"><a href="#4-5-2-应用GameplayEffect" class="headerlink" title="4.5.2 应用GameplayEffect"></a>4.5.2 应用GameplayEffect</h3><p><code>GameplayEffect</code>可以被<a href="#concepts-ga">GameplayAbility</a>和<code>ASC</code>中的多个函数应用, 其通常是<code>ApplyGameplayEffectTo</code>的形式, 不同的函数本质上都是最终在目标上调用<code>UAbilitySystemComponent::ApplyGameplayEffectSpecToSelf()</code>的方便函数.  </p><p>为了在<code>GameplayAbility</code>之外应用<code>GameplayEffect</code>, 例如对于某个投掷物, 你就需要获取到目标的<code>ASC</code>并使用它的函数之一来<code>ApplyGameplayEffectToSelf</code>.  </p><p>你可以绑定<code>持续(Duration)</code>或<code>无限(Infinite)GameplayEffect</code>的委托来监听其应用到<code>ASC</code>:  </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">AbilitySystemComponent-&gt;OnActiveGameplayEffectAddedDelegateToSelf.<span class="built_in">AddUObject</span>(<span class="keyword">this</span>, &amp;APACharacterBase::OnActiveGameplayEffectAddedCallback);</span><br></pre></td></tr></table></figure><p>回调函数:  </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">OnActiveGameplayEffectAddedCallback</span><span class="params">(UAbilitySystemComponent* Target, <span class="type">const</span> FGameplayEffectSpec&amp; SpecApplied, FActiveGameplayEffectHandle ActiveHandle)</span></span>;</span><br></pre></td></tr></table></figure><p>服务端总是会调用该函数而不管同步模式是什么, <code>Autonomous Proxy</code>只会在<code>Full</code>和<code>Mixed</code>同步模式下对于同步的<code>GameplayEffect</code>调用该函数, <code>Simulated Proxy</code>只会在<code>Full</code>同步模式下调用该函数.  </p><p><strong><a href="#table-of-contents">⬆ 返回目录</a></strong></p><p><span id="concepts-ga-removing"></span></p><h3 id="4-5-3-移除GameplayEffect"><a href="#4-5-3-移除GameplayEffect" class="headerlink" title="4.5.3 移除GameplayEffect"></a>4.5.3 移除GameplayEffect</h3><p><code>GameplayEffect</code>可以被<a href="#concepts-ga">GameplayAbility</a>和<code>ASC</code>中的多个函数移除, 其通常是<code>RemoveActiveGameplayEffect</code>的形式, 不同的函数本质上都是最终在目标上调用<code>FActiveGameplayEffectContainer::RemoveActiveEffects()</code>的方便函数.  </p><p>为了在<code>GameplayAbility</code>之外移除<code>GameplayEffect</code>, 你就需要获取到该目标的<code>ASC</code>并使用它的函数之一来<code>RemoveActiveGameplayEffect</code>.  </p><p>你可以绑定<code>持续(Duration)</code>或<code>无限(Infinite)GameplayEffect</code>的委托来监听其应用到<code>ASC</code>:  </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">AbilitySystemComponent-&gt;<span class="built_in">OnAnyGameplayEffectRemovedDelegate</span>().<span class="built_in">AddUObject</span>(<span class="keyword">this</span>, &amp;APACharacterBase::OnRemoveGameplayEffectCallback);</span><br></pre></td></tr></table></figure><p>回调函数:  </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">OnRemoveGameplayEffectCallback</span><span class="params">(<span class="type">const</span> FActiveGameplayEffect&amp; EffectRemoved)</span></span>;</span><br></pre></td></tr></table></figure><p>服务端总是会调用该函数而不管同步模式是什么, <code>Autonomous Proxy</code>只会在Full和Mixed同步模式下对于可同步的<code>GameplayEffect</code>调用该函数, <code>Simulated Proxy</code>只会在Full同步模式下调用该函数.  </p><p><strong><a href="#table-of-contents">⬆ 返回目录</a></strong></p><p><span id="concepts-ge-mods"></span></p><h3 id="4-5-4-GameplayEffectModifier"><a href="#4-5-4-GameplayEffectModifier" class="headerlink" title="4.5.4 GameplayEffectModifier"></a>4.5.4 GameplayEffectModifier</h3><p><code>Modifier</code>可以修改<code>Attribute</code>并且是唯一可以<a href="#concepts-p">预测性</a>修改<code>Attribute</code>的方法. 一个<code>GameplayEffect</code>可以有0个或多个<code>Modifier</code>, 每个<code>Modifier</code>通过某个指定的操作只能修改一个<code>Attribute</code>.  </p><div class="table-container"><table><thead><tr><th style="text-align:center">操作</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center">Add</td><td style="text-align:center">将<code>Modifier</code>指定的<code>Attribute</code>加上计算结果. 使用负数以实现减法操作.</td></tr><tr><td style="text-align:center">Multiply</td><td style="text-align:center">将<code>Modifier</code>指定的<code>Attribute</code>乘以计算结果.</td></tr><tr><td style="text-align:center">Divide</td><td style="text-align:center">将<code>Modifier</code>指定的<code>Attribute</code>除以计算结果.</td></tr><tr><td style="text-align:center">Override</td><td style="text-align:center">使用计算结果覆盖<code>Modifier</code>指定的<code>Attribute</code>.</td></tr></tbody></table></div><p><code>Attribute</code>的CurrentValue是其所有<code>Modifier</code>与其BaseValue计算并总合后的结果, 像下面这样的<code>Modifier</code>总合公式被定义在<code>GameplayEffectAggregator.cpp</code>中的<code>FAggregatorModChannel::EvaluateWithBase</code>:  </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">((InlineBaseValue + Additive) * Multiplicitive) / Division</span><br></pre></td></tr></table></figure><p>Override<code>Modifier</code>会优先覆盖最后应用的<code>Modifier</code>得出的最终值.  </p><p><strong>Note</strong>: 对于基于百分比的修改, 确保使用<code>Multiply</code>操作以使其在加法操作之后.  </p><p><strong>Note</strong>: <a href="#concepts-p">预测(Prediction)</a>对于百分比修改有些问题.  </p><p>有四种类型的<code>Modifier</code>: <code>ScalableFloat</code>, <code>AttributeBased</code>, <code>CustomCalculationClass</code>, 和 <code>SetByCaller</code>, 它们全都生成一些浮点数, 用于之后基于各自的操作修改指定<code>Modifier</code>的<code>Attribute</code>.  </p><div class="table-container"><table><thead><tr><th style="text-align:center">Modifier类型</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center">Scalable Float</td><td style="text-align:center">FScalableFloat结构体可以指向某个横向为变量, 纵向为等级的Data Table, <code>Scalable Float</code>会以Ability的当前等级自动读取指定Data Table的某行值(或者在<a href="#concepts-ge-spec">GameplayEffectSpec</a>中重写的不同等级), 该值还可以进一步被系数处理, 如果没有指定Data Table/Row, 那么就会将其视为1, 因此该系数就可以在所有等级都硬编码为一个值.<img src="https://pic1.imgdb.cn/item/67a4c4f1d0e0a243d4fc538f.png" alt="ScalableFloat"></td></tr><tr><td style="text-align:center">Attribute Based</td><td style="text-align:center"><code>Attribute Based Modifier</code>将Source(<code>GameplayEffectSpec</code>的创建者)或Target(<code>GameplayEffectSpec</code>的接收者)上的CurrentValue或BaseValue视为<code>Backing Attribute</code>, 可以使用系数和Pre与Post系数和来修改它. <code>Snapshotting</code>意味着当<code>GameplayEffectSpec</code>创建时捕获该<code>Attribute</code>, 而<code>No Snapshotting</code>意味着当<code>GameplayEffectSpec</code>应用时捕获该<code>Attribute</code>.</td></tr><tr><td style="text-align:center">Custom Calculation Class</td><td style="text-align:center"><code>Custom Calculation Class</code>为复杂的<code>Modifier</code>提供了最大的灵活性, 该<code>Modifier</code>使用了<a href="#concepts-ge-mmc">ModifierMagnitudeCalculation</a>类, 且可以使用系数和Pre与Post系数和来处理浮点值结果.</td></tr><tr><td style="text-align:center">Set By Caller</td><td style="text-align:center"><code>SetByCaller</code>Modifier是运行时由Ability或<code>GameplayEffectSpec</code>的创建者于<code>GameplayEffect</code>之外设置的值, 例如, 如果你想让伤害值随玩家蓄力技能的长短而变化, 那么就需要使用<code>SetByCaller</code>. <code>SetByCaller</code>本质上是存于<code>GameplayEffectSpec</code>中的<code>TMap&lt;FGameplayTag, float&gt;</code>, <code>Modifier</code>只是告知<code>Aggregator</code>去寻找与提供的<code>GameplayTag</code>相关联的<code>SetByCaller</code>值. <code>Modifier</code>使用的<code>SetByCaller</code>只能使用该概念的<code>GameplayTag</code>形式, <code>FName</code>形式在此处不适用. 如果<code>Modifier</code>被设置为<code>SetByCaller</code>, 但是带有正确<code>GameplayTag</code>的<code>SetByCaller</code>在<code>GameplayEffectSpec</code>中不存在, 那么游戏会抛出一个运行时错误并返回0, 这可能在<code>Divide</code>操作中造成问题. 参阅<a href="#concepts-ge-spec-setbycaller">SetByCallers</a>获取更多关于如何使用<code>SetByCaller</code>的信息.</td></tr></tbody></table></div><p><strong><a href="#table-of-contents">⬆ 返回目录</a></strong></p><p><span id="concepts-ge-mods-multiplydivide"></span></p><h4 id="4-5-4-1-Multiply和Divide-Modifier"><a href="#4-5-4-1-Multiply和Divide-Modifier" class="headerlink" title="4.5.4.1 Multiply和Divide Modifier"></a>4.5.4.1 Multiply和Divide Modifier</h4><p>默认情况下, 所有的<code>Multiply</code>和<code>Divide</code>Modifier在对<code>Attribute</code>的BaseValue乘除前都会先加到一起.  </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">float</span> <span class="title">FAggregatorModChannel::EvaluateWithBase</span><span class="params">(<span class="type">float</span> InlineBaseValue, <span class="type">const</span> FAggregatorEvaluateParameters&amp; Parameters)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">...</span><br><span class="line"><span class="type">float</span> Additive = <span class="built_in">SumMods</span>(Mods[EGameplayModOp::Additive], GameplayEffectUtilities::<span class="built_in">GetModifierBiasByModifierOp</span>(EGameplayModOp::Additive), Parameters);</span><br><span class="line"><span class="type">float</span> Multiplicitive = <span class="built_in">SumMods</span>(Mods[EGameplayModOp::Multiplicitive], GameplayEffectUtilities::<span class="built_in">GetModifierBiasByModifierOp</span>(EGameplayModOp::Multiplicitive), Parameters);</span><br><span class="line"><span class="type">float</span> Division = <span class="built_in">SumMods</span>(Mods[EGameplayModOp::Division], GameplayEffectUtilities::<span class="built_in">GetModifierBiasByModifierOp</span>(EGameplayModOp::Division), Parameters);</span><br><span class="line">...</span><br><span class="line"><span class="keyword">return</span> ((InlineBaseValue + Additive) * Multiplicitive) / Division;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">float</span> <span class="title">FAggregatorModChannel::SumMods</span><span class="params">(<span class="type">const</span> TArray&lt;FAggregatorMod&gt;&amp; InMods, <span class="type">float</span> Bias, <span class="type">const</span> FAggregatorEvaluateParameters&amp; Parameters)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">float</span> Sum = Bias;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">const</span> FAggregatorMod&amp; Mod : InMods)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (Mod.<span class="built_in">Qualifies</span>())</span><br><span class="line">&#123;</span><br><span class="line">Sum += (Mod.EvaluatedMagnitude - Bias);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> Sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><em>摘自GameplayEffectAggregator.cpp</em>  </p><p>在该公式中<code>Multiply</code>和<code>Divide</code>Modifier都有一个值为1的<code>Bias</code>值(加法的<code>Bias</code>值为0), 因此它看起来像:  </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> + (Mod1.Magnitude - <span class="number">1</span>) + (Mod2.Magnitude - <span class="number">1</span>) + ...</span><br></pre></td></tr></table></figure><p>该公式会导致一些意料之外的结果, 首先, 它在对BaseValue乘除之前将所有的<code>Modifier</code>都加到了一起, 大部分人都期望将其乘或除在一起, 例如, 你有两个值为1.5的<code>Multiply</code>Modifier, 大部分人都期望将BaseValue乘上<code>1.5 x 1.5 = 2.25</code>, 然而, 这里是将两个1.5加在一起再乘以BaseValue(50%增量 + 另一个50%增量 = 100%增量).拿<code>GameplayPrediction.h</code>中的一个例子来说, 给基值速度500加上10%的加速buff就是550, 再加上另一个10%的加速buff就是600.  </p><p>其次, 该公式还有一些对于可以使用哪些值而未说明的的规则, 因为这是考虑Paragon的情况而设计的.  </p><p><em>译者注: 说实话, 我没有搞懂下文中原文档作者的逻辑, 可能是没有充分了解项目的原因? 比如在样例项目中, 删除BP_DamageVolume的GameplayEffect中的Executions, 并按照下文例4添加两个Multiply Multipliers, Attribute均为GDAttributeSetBase.XP, Modifier Magnitude均为Scalable Float/5.0, 回到游戏, 击杀一个小兵使XP增加到1, 然后进入BP_DamageVolume, 会发现XP依次变为25, 625…, 进行调试也会发现是Modifier依次相乘的, 并不是作者所说的乘法分配律逻辑. 还有就是为什么符合公式规则的<code>1 + (0.5 - 1) + (1.1 - 1) = 0.6</code>是正确的而不符合公式规则的<code>1 + (0.5 - 1) + (0.5 - 1) = 0</code>和<code>1 + (5 - 1) + (5 - 1) = 9</code>就是错误预期? 这个正确和错误预期是以什么为评判标准的? 是否符合公式规则么? 如果各位明白其中道理, 还请不吝赐教, 在此感谢!</em>  </p><p>对于<code>Multiply</code>和<code>Divide</code>中乘法加法公式的规则:  </p><ul><li>(最多不超过1个值 &lt; 1) AND (任意数量值位于[1, 2))</li><li>OR (一个值 &gt;= 2)</li></ul><p>公式中的Bias基本上都会减去<code>[1, 2)</code>区间中的整数位, 第一个Modifier的<code>Bias</code>会从最开始的<code>Sum</code>值减值(在循环体前设置Bias), 这就是为什么某个值它本身能起作用的原因以及某个小于1的值与<code>[1, 2)</code>区间中的值起作用的原因.  </p><p><code>Multiply</code>的一些例子:<br>Multipliers: 0.5<br><code>1 + (0.5 - 1) = 0.5</code>, 正确.  </p><p>Multipliers: 0.5, 0.5<br><code>1 + (0.5 - 1) + (0.5 - 1) = 0</code>, 错误预期<code>1</code>? 多个小于1的值在<code>Modifier</code>相加中不起作用. Paragon这样设计只是为了使用<a href="#cae-nonstackingge">Multiply Modifier的最负值</a>, 因此最多只会有一个小于1的值乘到BaseValue.  </p><p>Multipliers: 1.1, 0.5<br><code>1 + (0.5 - 1) + (1.1 - 1) = 0.6</code>, 正确.  </p><p>Multipliers: 5, 5<br><code>1 + (5 - 1) + (5 - 1) = 9</code>, 错误预期<code>10</code>. 它总会是<code>Modifier值的和 - Modifier个数 + 1</code>.  </p><p>很多游戏会想要它们的<code>Modify</code>和<code>Divide</code>Modifier在应用到BaseValue之前先乘或除到一起, 为了实现这种需求, 你需要修改<code>FAggregatorModChannel::EvaluateWithBase()</code>的引擎代码.  </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">float</span> <span class="title">FAggregatorModChannel::EvaluateWithBase</span><span class="params">(<span class="type">float</span> InlineBaseValue, <span class="type">const</span> FAggregatorEvaluateParameters&amp; Parameters)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">...</span><br><span class="line"><span class="type">float</span> Multiplicitive = <span class="built_in">MultiplyMods</span>(Mods[EGameplayModOp::Multiplicitive], Parameters);</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> ((InlineBaseValue + Additive) * Multiplicitive) / Division;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">float</span> <span class="title">FAggregatorModChannel::MultiplyMods</span><span class="params">(<span class="type">const</span> TArray&lt;FAggregatorMod&gt;&amp; InMods, <span class="type">const</span> FAggregatorEvaluateParameters&amp; Parameters)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">float</span> Multiplier = <span class="number">1.0f</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">const</span> FAggregatorMod&amp; Mod : InMods)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (Mod.<span class="built_in">Qualifies</span>())</span><br><span class="line">&#123;</span><br><span class="line">Multiplier *= Mod.EvaluatedMagnitude;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> Multiplier;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong><a href="#table-of-contents">⬆ 返回目录</a></strong></p><p><span id="concepts-ge-mods-gameplaytags"></span></p><h4 id="4-5-4-2-Modifier的GameplayTag"><a href="#4-5-4-2-Modifier的GameplayTag" class="headerlink" title="4.5.4.2 Modifier的GameplayTag"></a>4.5.4.2 Modifier的GameplayTag</h4><p>每个<a href="#concepts-ge-mods">Modifier</a>都可以设置<code>SourceTag</code>和<code>TargetTag</code>, 它们的作用就像<code>GameplayEffect</code>的<a href="#concepts-ge-tags">Application Tag requirements</a>, 因此只有当Effect应用后才会考虑标签, 对于周期性(Periodic)的<code>无限(Infinite)</code>Effect, 这些标签只会在第一次应用Effect时才会被考虑, 而不是在每次周期执行时.  </p><p><code>Attribute Based Modifier</code>也可以设置<code>SourceTagFilter</code>和<code>TargetTagFilter</code>. 当确定<code>Attribute Based Modifier</code>的源(Source)<code>Attribute</code>的Magnitude时, 这些过滤器就会用来将某些<code>Modifier</code>排除在该Attribute之外, 源(Source)或目标(Target)中没有过滤器所有标签的<code>Modifier</code>也会被排除在外.  </p><p>这更详尽的意思是: 源(Source)<code>ASC</code>和目标(Target)<code>ASC</code>的标签都被<code>GameplayEffect</code>所捕获, 当<code>GameplayEffectSpec</code>创建时, 源(Source)<code>ASC</code>的标签被捕获, 当执行Effect时, 目标(Target)<code>ASC</code>的标签被捕获. 当确定<code>无限(Infinite)</code>或<code>持续(Duration)</code>Effect的<code>Modifier</code>是否满足条件可以被应用(也就是聚合器条件(Aggregator Qualify))并且过滤器已经设置时, 被捕获的标签就会和过滤器进行比对.  </p><p><strong><a href="#table-of-contents">⬆ 返回目录</a></strong></p><p><span id="concepts-ge-stacking"></span></p><h3 id="4-5-5-GameplayEffect堆栈"><a href="#4-5-5-GameplayEffect堆栈" class="headerlink" title="4.5.5 GameplayEffect堆栈"></a>4.5.5 GameplayEffect堆栈</h3><p><code>GameplayEffect</code>默认会应用新的<code>GameplayEffectSpec</code>实例, 而不明确或不关心之前已经应用过的尚且存在的<code>GameplayEffectSpec</code>实例. <code>GameplayEffect</code>可以设置到堆栈中, 新的<code>GameplayEffectSpec</code>实例不会添加到堆栈中, 而是修改当前已经存在的<code>GameplayEffectSpec</code>堆栈数. 堆栈只适用于<code>持续(Duration)</code>和<code>无限(Infinite)GameplayEffect</code>.  </p><p>有两种类型的堆栈: Aggregate by Source和Aggregate by Target.  </p><div class="table-container"><table><thead><tr><th style="text-align:center">堆栈类型</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center">Aggregate by Source</td><td style="text-align:center">目标(Target)上的每个源(Source)<code>ASC</code>都有一个单独的堆栈实例, 每个源(Source)可以应用堆栈中的X个<code>GameplayEffect</code>.</td></tr><tr><td style="text-align:center">Aggregate by Target</td><td style="text-align:center">目标(Target)上只有一个堆栈实例而不管源(Source)如何, 每个源(Source)都可以在共享堆栈限制(Shared Stack Limit)内应用堆栈.</td></tr></tbody></table></div><p>堆栈对过期, 持续刷新和周期性刷新也有一些处理策略, 这些在<code>GameplayEffect</code>蓝图中都有很友好的悬浮提示帮助.  </p><p>样例项目包含一个用于监听<code>GameplayEffect</code>堆栈变化的自定义蓝图节点, HUD UMG Widget使用它来更新玩家拥有的被动护盾堆栈(层数). 该<code>AsyncTask</code>将会一直响应直到手动调用<code>EndTask()</code>, 就像在UMG Widget的<code>Destruct</code>事件中调用那样. 参阅<code>AsyncTaskAttributeChanged.h/cpp</code>.  </p><p><img src="https://pic1.imgdb.cn/item/67a4c515d0e0a243d4fc5395.png" alt="Listen for GameplayEffect Stack Change BP Node"></p><p><strong><a href="#table-of-contents">⬆ 返回目录</a></strong></p><p><span id="concepts-ge-ga"></span></p><h3 id="4-5-6-授予Ability"><a href="#4-5-6-授予Ability" class="headerlink" title="4.5.6 授予Ability"></a>4.5.6 授予Ability</h3><p><code>GameplayEffect</code>可以授予(Grant)新的<a href="#concepts-ga">GameplayAbility</a>到<code>ASC</code>. 只有<code>持续(Duration)</code>和<code>无限(Infinite)GameplayEffect</code>可以授予Ability.  </p><p>一个普遍用法是当想要强制另一个玩家做某些事的时候, 像击退或拉取时移动他们, 就会对它们应用一个<code>GameplayEffect</code>来授予其一个自动激活的Ability(查看<a href="#concepts-ga-activating-passive">被动Ability</a>来了解如何在Ability被授予时自动激活它), 从而使其做出相应的动作.  </p><p>设计师可以决定一个<code>GameplayEffect</code>能够授予哪些Ability, 授予的Ability等级, 将其<a href="#concepts-ga-input">绑定</a>在什么输入键上以及该Ability的移除策略.  </p><div class="table-container"><table><thead><tr><th style="text-align:center">移除策略</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center">立即取消Ability</td><td style="text-align:center">当授予Ability的<code>GameplayEffect</code>从目标移除时, 授予的Ability就会立即取消并移除.</td></tr><tr><td style="text-align:center">结束时移除Ability</td><td style="text-align:center">允许授予的Ability完成, 之后将其从目标移除.</td></tr><tr><td style="text-align:center">无</td><td style="text-align:center">授予的Ability不受从目标移除的授予<code>GameplayEffect</code>的影响, 目标将会一直拥有该Ability直到之后被手动移除.</td></tr></tbody></table></div><p><strong><a href="#table-of-contents">⬆ 返回目录</a></strong></p><p><span id="concepts-ge-tags"></span></p><h3 id="4-5-7-GameplayEffect标签"><a href="#4-5-7-GameplayEffect标签" class="headerlink" title="4.5.7 GameplayEffect标签"></a>4.5.7 GameplayEffect标签</h3><p><code>GameplayEffect</code>可以带有多个<a href="#concepts-gt">GameplayTagContainer</a>, 设计师可以编辑每个类别的<code>Added</code>和<code>Removed</code>GameplayTagContainer, 结果会在编译后显示在<code>Combined GameplayTagContainer</code>中. <code>Added</code>标签是该<code>GameplayEffect</code>新增的之前其父类没有的标签, <code>Removed</code>标签是其父类拥有但该类没有的标签.  </p><div class="table-container"><table><thead><tr><th style="text-align:center">分类</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center">Gameplay Effect Asset Tags</td><td style="text-align:center"><code>GameplayEffect</code>拥有的标签, 它们自身没有任何功能且只用于描述<code>GameplayEffect</code>.</td></tr><tr><td style="text-align:center">Granted Tags</td><td style="text-align:center">存于<code>GameplayEffect</code>中且又用于<code>GameplayEffect</code>所应用<code>ASC</code>的标签. 当<code>GameplayEffect</code>移除时它们也会从<code>ASC</code>中移除. 该标签只作用于<code>持续(Duration)</code>和<code>无限(Infinite)GameplayEffect</code>.</td></tr><tr><td style="text-align:center">Ongoing Tag Requirements</td><td style="text-align:center">一旦<code>GameplayEffect</code>应用后, 这些标签将决定<code>GameplayEffect</code>是开启还是关闭. <code>GameplayEffect</code>可以是关闭但仍然是应用的. 如果某个<code>GameplayEffect</code>由于不符合<code>Ongoing Tag Requirements</code>而关闭, 但是之后又满足需求了, 那么该<code>GameplayEffect</code>会重新打开并重新应用它的<code>Modifier</code>. 该标签只作用于<code>持续(Duration)</code>和<code>无限(Infinite)GameplayEffect</code>.</td></tr><tr><td style="text-align:center">Application Tag Requirements</td><td style="text-align:center">位于目标上决定某个<code>GameplayEffect</code>是否可以应用到该目标的标签, 如果不满足这些需求, 那么<code>GameplayEffect</code>就不可应用.</td></tr><tr><td style="text-align:center">Remove Gameplay Effects with Tags</td><td style="text-align:center">当<code>GameplayEffect</code>成功应用后, 如果位于目标上的该<code>GameplayEffect</code>在其<code>Asset Tags</code>或<code>Granted Tags</code>中有任意一个本标签的话, 其就会自目标上移除.</td></tr></tbody></table></div><p><strong><a href="#table-of-contents">⬆ 返回目录</a></strong></p><p><span id="concepts-ge-immunity"></span></p><h3 id="4-5-8-免疫"><a href="#4-5-8-免疫" class="headerlink" title="4.5.8 免疫"></a>4.5.8 免疫</h3><p><code>GameplayEffect</code>可以基于<a href="#concepts-gt">GameplayTag</a>实现免疫, 有效阻止其他<code>GameplayEffect</code>应用. 尽管免疫可以由<code>Application Tag Requirements</code>等方式有效地实现, 但是使用该系统可以在<code>GameplayEffect</code>被免疫阻止时提供<code>UAbilitySystemComponent::OnImmunityBlockGameplayEffectDelegate</code>委托(Delegate).  </p><p><code>GrantedApplicationImmunityTags</code>会检查源(Source)<code>ASC</code>(包括源Ability的AbilityTag, 如果有的话)是否包含特定的标签, 这是一种基于确定Character或源(Source)的标签对其所有<code>GameplayEffect</code>提供免疫的方法.  </p><p><code>Granted Application Immunity Query</code>会检查传入的<code>GameplayEffectSpec</code>是否与其查询条件相匹配, 从而阻止或允许其应用.  </p><p><code>GameplayEffect</code>蓝图中的查询条件都有友好的悬浮提示帮助.  </p><p><strong><a href="#table-of-contents">⬆ 返回目录</a></strong></p><p><span id="concepts-ge-spec"></span></p><h3 id="4-5-9-GameplayEffectSpec"><a href="#4-5-9-GameplayEffectSpec" class="headerlink" title="4.5.9 GameplayEffectSpec"></a>4.5.9 GameplayEffectSpec</h3><p><a href="https://docs.unrealengine.com/en-US/API/Plugins/GameplayAbilities/FGameplayEffectSpec/index.html">GameplayEffectSpec(GESpec)</a>可以看作是<code>GameplayEffect</code>的实例, 它保存了一个其所代表的<code>GameplayEffect</code>类引用, 创建时的等级和创建者, 它在应用之前可以在运行时(Runtime)自由的创建和修改, 不像<code>GameplayEffect</code>应该由设计师在运行前创建. 当应用<code>GameplayEffect</code>时, <code>GameplayEffectSpec</code>会自<code>GameplayEffect</code>创建并且会实际应用到目标(Target).  </p><p><code>GameplayEffectSpec</code>是由<code>UAbilitySystemComponent::MakeOutgoingSpec()(BlueprintCallable)</code>自<code>GameplayEffect</code>创建的. <code>GameplayEffectSpec</code>不必立即应用. 通常是将<code>GameplayEffectSpec</code>传递给创建自Ability的投掷物, 该投掷物可以应用到它之后击中的目标. 当<code>GameplayEffectSpec</code>成功应用后, 就会返回一个名为<code>FActiveGameplayEffect</code>的新结构体.  </p><p><code>GameplayEffectSpec</code>的重要内容:  </p><ul><li>创建该<code>GameplayEffectSpec</code>的<code>GameplayEffect</code>类.</li><li>该<code>GameplayEffectSpec</code>的等级. 通常和创建<code>GameplayEffectSpec</code>的Ability的等级一样, 但是可以是不同的.</li><li><code>GameplayEffectSpec</code>的持续时间. 默认是<code>GameplayEffect</code>的持续时间, 但是可以是不同的.</li><li>对于周期性Effect中<code>GameplayEffectSpec</code>的周期, 默认是<code>GameplayEffect</code>的周期, 但是可以是不同的.</li><li>该<code>GameplayEffectSpec</code>的当前堆栈数. 堆栈限制取决于<code>GameplayEffect</code>.</li><li><a href="#concepts-ge-context">GameplayEffectContextHandle</a>表明该<code>GameplayEffectSpec</code>由谁创建.</li><li><code>Attribute</code>在<code>GameplayEffectSpec</code>创建时由Snapshot捕获.</li><li>除了<code>GameplayEffect</code>授予的<code>GameplayTags</code>, <code>GameplayEffectSpec</code>还会授予目标(Target)<code>DynamicGrantedTags</code>.</li><li>除了<code>GameplayEffect</code>拥有的<code>AssetTags</code>, <code>GameplayEffectSpec</code>还会拥有<code>DynamicAssetTags</code>.</li><li><code>SetByCaller TMaps</code>.</li></ul><p><strong><a href="#table-of-contents">⬆ 返回目录</a></strong></p><p><span id="concepts-ge-spec-setbycaller"></span></p><h4 id="4-5-9-1-SetByCaller"><a href="#4-5-9-1-SetByCaller" class="headerlink" title="4.5.9.1 SetByCaller"></a>4.5.9.1 SetByCaller</h4><p><code>SetByCaller</code>允许<code>GameplayEffectSpec</code>拥有和<code>GameplayTag</code>或<code>FName</code>相关联的浮点值, 它们存储在<code>GameplayEffectSpec</code>上其各自的<code>TMaps: TMap&lt;FGameplayTag, float&gt;</code>和<code>TMap&lt;FName, float&gt;</code>中, 可以作为<code>GameplayEffect</code>的<code>Modifier</code>或者传递浮点值的通用方法使用. 其普遍用法是经由<code>SetByCaller</code>传递某个Ability内部生成的数值数据到<a href="#concepts-ge-ec">GameplayEffectExecutionCalculations</a>或<a href="#concepts-ge-mmc">ModifierMagnitudeCalculations</a>.  </p><div class="table-container"><table><thead><tr><th style="text-align:center">SetByCaller使用</th><th style="text-align:center">说明</th></tr></thead><tbody><tr><td style="text-align:center"><code>Modifier</code></td><td style="text-align:center">必须提前在<code>GameplayEffect</code>类中定义. 只能使用<code>GameplayTag</code>形式. 如果在<code>GameplayEffect</code>类中定义而<code>GameplayEffectSpec</code>中没有相应的标签/浮点值对, 那么游戏在<code>GameplayEffectSpec</code>应用时会抛出运行时错误并返回0, 这对于<code>Divide</code>操作是个潜在问题, 参阅<a href="#concepts-ge-mods">Modifier</a>.</td></tr><tr><td style="text-align:center">其他</td><td style="text-align:center">无需提前定义. 读取<code>GameplayEffectSpec</code>中不存在的<code>SetByCaller</code>会返回一个由开发者定义的可带有警告信息的默认值.</td></tr></tbody></table></div><p>为了在蓝图中指定<code>SetByCaller</code>值, 请使用相应形式(<code>GameplayTag</code>或<code>FName</code>)的蓝图节点.  </p><p><img src="https://pic1.imgdb.cn/item/67a4c59dd0e0a243d4fc53a3.png" alt="Assigning SetByCaller"></p><p>为了在蓝图中读取<code>SetByCaller</code>值, 需要在蓝图中创建自定义节点.  </p><p>为了在C++中指定<code>SetByCaller</code>值, 需要使用相应形式的函数(<code>GameplayTag</code>或<code>FName</code>).  </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">FGameplayEffectSpec::SetSetByCallerMagnitude</span><span class="params">(FName DataName, <span class="type">float</span> Magnitude)</span></span>;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">FGameplayEffectSpec::SetSetByCallerMagnitude</span><span class="params">(FGameplayTag DataTag, <span class="type">float</span> Magnitude)</span></span>;</span><br></pre></td></tr></table></figure><p>为了在C++中读取<code>SetByCaller</code>的值, 需要使用相应形式的函数(<code>GameplayTag</code>或<code>FName</code>).  </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">float</span> <span class="title">GetSetByCallerMagnitude</span><span class="params">(FName DataName, <span class="type">bool</span> WarnIfNotFound = <span class="literal">true</span>, <span class="type">float</span> DefaultIfNotFound = <span class="number">0.f</span>)</span> <span class="type">const</span></span>;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">float</span> <span class="title">GetSetByCallerMagnitude</span><span class="params">(FGameplayTag DataTag, <span class="type">bool</span> WarnIfNotFound = <span class="literal">true</span>, <span class="type">float</span> DefaultIfNotFound = <span class="number">0.f</span>)</span> <span class="type">const</span></span>;</span><br></pre></td></tr></table></figure><p>我建议使用<code>GameplayTag</code>形式而不是<code>FName</code>形式, 这可以避免蓝图中的拼写错误, 并且当<code>GameplayEffectSpec</code>同步时, <code>GameplayTag</code>比<code>FName</code>在网络传输中更有效率, 因为<code>TMap</code>也会同步.  </p><p><strong><a href="#table-of-contents">⬆ 返回目录</a></strong></p><p><span id="concepts-ge-context"></span></p><h3 id="4-5-10-GameplayEffectContext"><a href="#4-5-10-GameplayEffectContext" class="headerlink" title="4.5.10 GameplayEffectContext"></a>4.5.10 GameplayEffectContext</h3><p><a href="https://docs.unrealengine.com/en-US/API/Plugins/GameplayAbilities/FGameplayEffectContext/index.html">GameplayEffectContext</a>结构体存有关于<code>GameplayEffectSpec</code>创建者(Instigator)和<a href="#concepts-targeting-data">TargetData</a>的信息, 这也是一个很好的可继承结构体以在<a href="#concepts-ge-mmc">ModifierMagnitudeCalculation</a>/<a href="#concepts-ge-ec">GameplayEffectExecutionCalculation</a>, <a href="#concepts-as">AttributeSet</a>和<a href="#concepts-gc">GameplayCue</a>之间传递任意数据.  </p><p>继承<code>GameplayEffectContext</code>:  </p><ol><li>继承<code>FGameplayEffectContext</code>.</li><li>重写<code>FGameplayEffectContext::GetScriptStruct()</code>.</li><li>重写<code>FGameplayEffectContext::Duplicate()</code>.</li><li>如果新数据需要同步的话, 重写<code>FGameplayEffectContext::NetSerialize()</code>.</li><li>对子结构体实现<code>TStructOpsTypeTraits</code>, 就像父结构体<code>FGameplayEffectContext</code>有的那样.</li><li>在<a href="#concepts-asg">AbilitySystemGlobals</a>类中重写<code>AllocGameplayEffectContext()</code>以返回一个新的子结构体对象.</li></ol><p>GASShooter使用了一个子结构体<code>GameplayEffectContext</code>来添加可以在<code>GameplayCue</code>中访问的<code>TargetData</code>, 特别是对于霰弹枪, 因为它可以击打多个敌人.  </p><p><strong><a href="#table-of-contents">⬆ 返回目录</a></strong></p><p><span id="concepts-ge-mmc"></span></p><h3 id="4-5-11-Modifier-Magnitude-Calculation"><a href="#4-5-11-Modifier-Magnitude-Calculation" class="headerlink" title="4.5.11 Modifier Magnitude Calculation"></a>4.5.11 Modifier Magnitude Calculation</h3><p><a href="https://docs.unrealengine.com/en-US/API/Plugins/GameplayAbilities/UGameplayModMagnitudeCalculation/index.html">ModifierMagnitudeCalculations</a>(<code>ModMagcCalc</code>或<code>MMC</code>)是在<code>GameplayEffect</code>中作为<a href="#concepts-ge-mods">Modifier</a>使用的强有力的类, 它的功能类似<a href="#concepts-ge-ec">GameplayEffectExecutionCalculation</a>但是要逊色一些, 最重要的是它是可预测的. 它唯一要做的就是自<code>CalculateBaseMagnitude_Implementation()</code>返回浮点值, 你可以在C++和蓝图中继承并重写该函数.  </p><p><code>MMC</code>可以用于各种持续时间的<code>GameplayEffect</code> - <code>即刻(Instant)</code>, <code>持续(Duration)</code>, <code>无限(Infinite)</code>和<code>周期性(Periodic)</code>.  </p><p><code>MMC</code>的优势在于能够完全访问<code>GameplayEffectSpec</code>来读取<code>GameplayTag</code>和<code>SetByCaller</code>，从而能够捕获<code>GameplayEffect</code>的<code>源(Source)</code>或<code>目标(Target)</code>上任意数量的<code>Attribute</code>值. <code>Attribute</code>可以被Snapshot也可以不被Snapshot, <code>Snapshotted Attribute</code>在<code>GameplayEffectSpec</code>创建时被捕获而非<code>Snapshotted Attribute</code>在<code>GameplayEffectSpec</code>应用时被捕获并且该<code>Attribute</code>被<code>无限(Infinite)</code>或<code>持续(Duration)</code>GameplayEffect修改时会自动更新. 捕获<code>Attribute</code>会自<code>ASC</code>现有的<code>Modifier</code>重新计算它们的<code>CurrentValue</code>, 该重新计算<strong>不会</strong>执行<code>AbilitySet</code>中的<a href="#concepts-as-preattributechange">PreAttributeChange()</a>, 因此所有的限制操作(Clamp)必须在这里重新处理.  </p><div class="table-container"><table><thead><tr><th style="text-align:center">Snapshot</th><th style="text-align:center">源(Source)或目标(Target)</th><th style="text-align:center">在GameplayEffectSpec中捕获</th><th style="text-align:center">Attribute被无限(Infinite)或持续(Duration)GameplayEffect修改时自动更新</th></tr></thead><tbody><tr><td style="text-align:center">是</td><td style="text-align:center">Source</td><td style="text-align:center">创建</td><td style="text-align:center">否</td></tr><tr><td style="text-align:center">是</td><td style="text-align:center">Target</td><td style="text-align:center">应用</td><td style="text-align:center">否</td></tr><tr><td style="text-align:center">否</td><td style="text-align:center">Source</td><td style="text-align:center">应用</td><td style="text-align:center">是</td></tr><tr><td style="text-align:center">否</td><td style="text-align:center">Target</td><td style="text-align:center">应用</td><td style="text-align:center">是</td></tr></tbody></table></div><p><code>MMC</code>的结果浮点值可以进一步由系数和前后系数之和在<code>GameplayEffect</code>的<code>Modifier</code>中修改.  </p><p>举一个<code>MMC</code>的例子, 该<code>MMC</code>会捕获目标的魔法值<code>Attribute</code>并因为毒药Effect而将其减少, 其减少量的变化取决于目标所拥有的魔法值和可能拥有的某个标签:  </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">UPAMMC_PoisonMana::<span class="built_in">UPAMMC_PoisonMana</span>()</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//ManaDef defined in header FGameplayEffectAttributeCaptureDefinition ManaDef;</span></span><br><span class="line">ManaDef.AttributeToCapture = UPAAttributeSetBase::<span class="built_in">GetManaAttribute</span>();</span><br><span class="line">ManaDef.AttributeSource = EGameplayEffectAttributeCaptureSource::Target;</span><br><span class="line">ManaDef.bSnapshot = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//MaxManaDef defined in header FGameplayEffectAttributeCaptureDefinition MaxManaDef;</span></span><br><span class="line">MaxManaDef.AttributeToCapture = UPAAttributeSetBase::<span class="built_in">GetMaxManaAttribute</span>();</span><br><span class="line">MaxManaDef.AttributeSource = EGameplayEffectAttributeCaptureSource::Target;</span><br><span class="line">MaxManaDef.bSnapshot = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">RelevantAttributesToCapture.<span class="built_in">Add</span>(ManaDef);</span><br><span class="line">RelevantAttributesToCapture.<span class="built_in">Add</span>(MaxManaDef);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">float</span> <span class="title">UPAMMC_PoisonMana::CalculateBaseMagnitude_Implementation</span><span class="params">(<span class="type">const</span> FGameplayEffectSpec &amp; Spec)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// Gather the tags from the source and target as that can affect which buffs should be used</span></span><br><span class="line"><span class="type">const</span> FGameplayTagContainer* SourceTags = Spec.CapturedSourceTags.<span class="built_in">GetAggregatedTags</span>();</span><br><span class="line"><span class="type">const</span> FGameplayTagContainer* TargetTags = Spec.CapturedTargetTags.<span class="built_in">GetAggregatedTags</span>();</span><br><span class="line"></span><br><span class="line">FAggregatorEvaluateParameters EvaluationParameters;</span><br><span class="line">EvaluationParameters.SourceTags = SourceTags;</span><br><span class="line">EvaluationParameters.TargetTags = TargetTags;</span><br><span class="line"></span><br><span class="line"><span class="type">float</span> Mana = <span class="number">0.f</span>;</span><br><span class="line"><span class="built_in">GetCapturedAttributeMagnitude</span>(ManaDef, Spec, EvaluationParameters, Mana);</span><br><span class="line">Mana = FMath::<span class="built_in">Max</span>&lt;<span class="type">float</span>&gt;(Mana, <span class="number">0.0f</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">float</span> MaxMana = <span class="number">0.f</span>;</span><br><span class="line"><span class="built_in">GetCapturedAttributeMagnitude</span>(MaxManaDef, Spec, EvaluationParameters, MaxMana);</span><br><span class="line">MaxMana = FMath::<span class="built_in">Max</span>&lt;<span class="type">float</span>&gt;(MaxMana, <span class="number">1.0f</span>); <span class="comment">// Avoid divide by zero</span></span><br><span class="line"></span><br><span class="line"><span class="type">float</span> Reduction = <span class="number">-20.0f</span>;</span><br><span class="line"><span class="keyword">if</span> (Mana / MaxMana &gt; <span class="number">0.5f</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// Double the effect if the target has more than half their mana</span></span><br><span class="line">Reduction *= <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (TargetTags-&gt;<span class="built_in">HasTagExact</span>(FGameplayTag::<span class="built_in">RequestGameplayTag</span>(<span class="built_in">FName</span>(<span class="string">&quot;Status.WeakToPoisonMana&quot;</span>))))</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// Double the effect if the target is weak to PoisonMana</span></span><br><span class="line">Reduction *= <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> Reduction;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果你没有在<code>MMC</code>的构造函数中将<code>FGameplayEffectAttributeCaptureDefinition</code>添加到<code>RelevantAttributesToCapture</code>中并且尝试捕获<code>Attribute</code>, 那么将会得到一个关于捕获时缺失Spec的错误. 如果不需要捕获<code>Attribute</code>, 那么就不必添加什么到<code>RelevantAttributesToCapture</code>.  </p><p><strong><a href="#table-of-contents">⬆ 返回目录</a></strong></p><p><span id="concepts-ge-ec"></span></p><h3 id="4-5-12-Gameplay-Effect-Execution-Calculation"><a href="#4-5-12-Gameplay-Effect-Execution-Calculation" class="headerlink" title="4.5.12 Gameplay Effect Execution Calculation"></a>4.5.12 Gameplay Effect Execution Calculation</h3><p><a href="https://docs.unrealengine.com/en-US/API/Plugins/GameplayAbilities/UGameplayEffectExecutionCalculat-/index.html">GameplayEffectExecutionCalculation</a>(ExecutionCalculation, Execution(你会在插件代码里经常看到这个词)或ExecCalc)是<code>GameplayEffect</code>对<code>ASC</code>进行修改最强有力的方式. 像<a href="#concepts-ge-mmc">ModifierMagnitudeCalculation</a>一样, 它也可以捕获<code>Attribute</code>并选择性地为其创建Snapshot, 和<code>MMC</code>不同的是, 它可以修改多个<code>Attribute</code>并且基本上可以处理程序员想要做的任何事. 这种强有力和灵活性的负面就是它是不可<a href="#concepts-p">预测</a>的且必须在C++中实现.  </p><p><code>ExecutionCalculation</code>只能由<code>即刻(Instant)</code>和<code>周期性(Periodic)</code>GameplayEffect使用, 插件中所有和”Execute”相关的一般都引用到这两种类型的<code>GameplayEffect</code>.  </p><p>当<code>GameplayEffectSpec</code>创建时, Snapshot会捕获<code>Attribute</code>, 而当<code>GameplayEffectSpec</code>应用时, 非Snapshot会捕获<code>Attribute</code>. 捕获<code>Attribute</code>会自<code>ASC</code>现有的<code>Modifier</code>重新计算它们的<code>CurrentValue</code>, 该重新计算<strong>不会</strong>执行<code>AbilitySet</code>中的<a href="#concepts-as-preattributechange">PreAttributeChange()</a>, 因此所有的限制操作(Clamp)必须在这里重新处理.  </p><div class="table-container"><table><thead><tr><th style="text-align:center">快照</th><th style="text-align:center">Source或Target</th><th style="text-align:center">在GameplayEffectSpec中捕获</th></tr></thead><tbody><tr><td style="text-align:center">是</td><td style="text-align:center">Source</td><td style="text-align:center">创建</td></tr><tr><td style="text-align:center">是</td><td style="text-align:center">Target</td><td style="text-align:center">应用</td></tr><tr><td style="text-align:center">否</td><td style="text-align:center">Source</td><td style="text-align:center">应用</td></tr><tr><td style="text-align:center">否</td><td style="text-align:center">Target</td><td style="text-align:center">应用</td></tr></tbody></table></div><p>为了设置<code>Attribute</code>捕获, 我们采用Epic的ActionRPG样例项目使用的方式, 定义一个保存和声明如何捕获<code>Attribute</code>的结构体, 并在该结构体的构造函数中创建一个它的副本(Copy). 每个<code>ExecCalc</code>都需要有一个这样的结构体. <strong>Note</strong>: 每个结构体需要一个独一无二的名字, 因为它们共享同一个命名空间, 多个结构体使用相同名字在捕获<code>Attribute</code>时会造成错误(大多是捕获到错误的<code>Attribute</code>值).  </p><p>对于<code>Local Predicted</code>, <code>Server Only</code>和<code>Server Initiated</code>的<a href="#concepts-ga">GameplayAbility</a>, <code>ExecCalc</code>只在服务端调用.  </p><p><code>ExecCalc</code>最普遍的应用场景是计算一个来自很多<code>源(Source)</code>和<code>目标(Target)</code>中<code>Attribute</code>伤害值的复杂公式. 样例项目中有一个简单的<code>ExecCalc</code>用于计算伤害值, 其从<code>GameplayEffectSpec</code>的<a href="#concepts-ge-spec-setbycaller">SetByCaller</a>中读取伤害值, 之后基于从<code>目标(Target)</code>捕获的护盾<code>Attribute</code>来减少该伤害值. 参阅<code>GDDamageExecCalculation.cpp/.h</code>.  </p><p><strong><a href="#table-of-contents">⬆ 返回目录</a></strong></p><p><span id="concepts-ge-ec-senddata"></span></p><h4 id="4-5-12-1-发送数据到Execution-Calculation"><a href="#4-5-12-1-发送数据到Execution-Calculation" class="headerlink" title="4.5.12.1 发送数据到Execution Calculation"></a>4.5.12.1 发送数据到Execution Calculation</h4><p>除了捕获<code>Attribute</code>, 还有几种方法可以发送数据到<code>ExecutionCalculation</code>.  </p><p><strong><a href="#table-of-contents">⬆ 返回目录</a></strong></p><p><span id="concepts-ge-ec-senddata-setbycaller"></span></p><h5 id="4-5-12-1-1-SetByCaller"><a href="#4-5-12-1-1-SetByCaller" class="headerlink" title="4.5.12.1.1 SetByCaller"></a>4.5.12.1.1 SetByCaller</h5><p>任何<a href="#concepts-ge-spec-setbycaller">设置在<code>GameplayEffectSpec</code>中的<code>SetByCaller</code></a>都可以直接在<code>ExecutionCalculation</code>中读取.  </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> FGameplayEffectSpec&amp; Spec = ExecutionParams.<span class="built_in">GetOwningSpec</span>();</span><br><span class="line"><span class="type">float</span> Damage = FMath::<span class="built_in">Max</span>&lt;<span class="type">float</span>&gt;(Spec.<span class="built_in">GetSetByCallerMagnitude</span>(FGameplayTag::<span class="built_in">RequestGameplayTag</span>(<span class="built_in">FName</span>(<span class="string">&quot;Data.Damage&quot;</span>)), <span class="literal">false</span>, <span class="number">-1.0f</span>), <span class="number">0.0f</span>);</span><br></pre></td></tr></table></figure><p><strong><a href="#table-of-contents">⬆ 返回目录</a></strong></p><p><span id="concepts-ge-ec-senddata-backingdataattribute"></span></p><h5 id="4-5-12-1-2-Backing数据Attribute计算Modifier"><a href="#4-5-12-1-2-Backing数据Attribute计算Modifier" class="headerlink" title="4.5.12.1.2 Backing数据Attribute计算Modifier"></a>4.5.12.1.2 Backing数据Attribute计算Modifier</h5><p>如果你想硬编码值到<code>GameplayEffect</code>, 可以使用<code>CalculationModifier</code>传递, 其使用捕获的<code>Attribute</code>之一作为Backing数据.  </p><p>在这个截图例子中, 我们给捕获的伤害值<code>Attribute</code>增加了50, 你也可以将其设为<code>Override</code>来直接传入硬编码值.  </p><p><img src="https://pic1.imgdb.cn/item/67a4c5c1d0e0a243d4fc53a8.png" alt="Backing Data Attribute Calculation Modifier"></p><p>当<code>ExecutionCalculation</code>捕获该<code>Attribute</code>时会读取这个值.  </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">float</span> Damage = <span class="number">0.0f</span>;</span><br><span class="line"><span class="comment">// Capture optional damage value set on the damage GE as a CalculationModifier under the ExecutionCalculation</span></span><br><span class="line">ExecutionParams.<span class="built_in">AttemptCalculateCapturedAttributeMagnitude</span>(<span class="built_in">DamageStatics</span>().DamageDef, EvaluationParameters, Damage);</span><br></pre></td></tr></table></figure><p><strong><a href="#table-of-contents">⬆ 返回目录</a></strong></p><p><span id="concepts-ge-ec-senddata-backingdatatempvariable"></span></p><h5 id="4-5-12-1-3-Backing数据临时变量计算Modifier"><a href="#4-5-12-1-3-Backing数据临时变量计算Modifier" class="headerlink" title="4.5.12.1.3 Backing数据临时变量计算Modifier"></a>4.5.12.1.3 Backing数据临时变量计算Modifier</h5><p>如果你想硬编码值到<code>GameplayEffect</code>, 可以在C++中使用<code>CalculationModifier</code>传递, 其使用一个<code>临时变量</code>或<code>暂时聚合器(Transient Aggregator)</code>, 该<code>临时变量</code>与<code>GameplayTag</code>相关联.  </p><p>在这个截图例子中, 我们使用<code>Data.Damage GameplayTag</code>增加50到一个临时变量.  </p><p><img src="https://pic1.imgdb.cn/item/67a4c60ad0e0a243d4fc53b0.png" alt="Backing Data Temporary Variable Calculation Modifier"></p><p>添加Backing临时变量到你的<code>ExecutionCalculation</code>构造函数:  </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ValidTransientAggregatorIdentifiers.<span class="built_in">AddTag</span>(FGameplayTag::<span class="built_in">RequestGameplayTag</span>(<span class="string">&quot;Data.Damage&quot;</span>));</span><br></pre></td></tr></table></figure><p><code>ExecutionCalculation</code>会使用和<code>Attribute</code>捕获函数相似的特殊捕获函数来读取这个值.  </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">float</span> Damage = <span class="number">0.0f</span>;</span><br><span class="line">ExecutionParams.<span class="built_in">AttemptCalculateTransientAggregatorMagnitude</span>(FGameplayTag::<span class="built_in">RequestGameplayTag</span>(<span class="string">&quot;Data.Damage&quot;</span>), EvaluationParameters, Damage);</span><br></pre></td></tr></table></figure><p><strong><a href="#table-of-contents">⬆ 返回目录</a></strong></p><p><span id="concepts-ge-ec-senddata-effectcontext"></span></p><h5 id="4-5-12-1-4-GameplayEffectContext"><a href="#4-5-12-1-4-GameplayEffectContext" class="headerlink" title="4.5.12.1.4 GameplayEffectContext"></a>4.5.12.1.4 GameplayEffectContext</h5><p>你可以通过<a href="#concepts-ge-context"><code>GameplayEffectSpec</code>中的自定义<code>GameplayEffectContext</code></a>发送数据到<code>ExecutionCalculation</code>.  </p><p>在<code>ExecutionCalculation</code>中, 你可以自<code>FGameplayEffectCustomExecutionParameters</code>访问<code>EffectContext</code>.  </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> FGameplayEffectSpec&amp; Spec = ExecutionParams.<span class="built_in">GetOwningSpec</span>();</span><br><span class="line">FGSGameplayEffectContext* ContextHandle = <span class="built_in">static_cast</span>&lt;FGSGameplayEffectContext*&gt;(Spec.<span class="built_in">GetContext</span>().<span class="built_in">Get</span>());</span><br></pre></td></tr></table></figure><p>如果你需要修改<code>GameplayEffectSpec</code>中的什么或者<code>EffectContext</code>:  </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">FGameplayEffectSpec* MutableSpec = ExecutionParams.<span class="built_in">GetOwningSpecForPreExecuteMod</span>();</span><br><span class="line">FGSGameplayEffectContext* ContextHandle = <span class="built_in">static_cast</span>&lt;FGSGameplayEffectContext*&gt;(MutableSpec-&gt;<span class="built_in">GetContext</span>().<span class="built_in">Get</span>());</span><br></pre></td></tr></table></figure><p>在<code>ExecutionCalculation</code>中修改<code>GameplayEffectSpec</code>时要小心. 参看<code>GetOwningSpecForPreExecuteMod()</code>的注释.  </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** Non const access. Be careful with this, especially when modifying a spec after attribute capture. */</span></span><br><span class="line"><span class="function">FGameplayEffectSpec* <span class="title">GetOwningSpecForPreExecuteMod</span><span class="params">()</span> <span class="type">const</span></span>;</span><br></pre></td></tr></table></figure><p><strong><a href="#table-of-contents">⬆ 返回目录</a></strong></p><p><span id="concepts-ge-car"></span></p><h3 id="4-5-13-自定义应用需求"><a href="#4-5-13-自定义应用需求" class="headerlink" title="4.5.13 自定义应用需求"></a>4.5.13 自定义应用需求</h3><p><a href="https://docs.unrealengine.com/en-US/API/Plugins/GameplayAbilities/UGameplayEffectCustomApplication-/index.html">CustomApplicationRequirement(CAR)</a>类为设计师提供对于<code>GameplayEffect</code>是否可以应用的高阶控制, 而不是对<code>GameplayEffect</code>进行简单的<code>GameplayTag</code>检查. 这可以通过在蓝图中重写<code>CanApplyGameplayEffect()</code>和在C++中重写<code>CanApplyGameplayEffect_Implementation()</code>实现.  </p><p><code>CAR</code>的应用场景:  </p><ul><li>目标需要有一定数量的<code>Attribute</code>.</li><li>目标需要有一定数量的<code>GameplayEffect</code>堆栈.</li></ul><p><code>CAR</code>还有很多高阶功能, 像检查<code>GameplayEffect</code>实例是否已经位于目标上, 修改当前实例的<a href="#concepts-ge-duration">持续时间</a>而不是应用一个新实例(对于<code>CanApplyGameplayEffect()</code>返回false).</p><p><strong><a href="#table-of-contents">⬆ 返回目录</a></strong></p><p><span id="concepts-ge-cost"></span></p><h3 id="4-5-14-花费-Cost-GameplayEffect"><a href="#4-5-14-花费-Cost-GameplayEffect" class="headerlink" title="4.5.14 花费(Cost)GameplayEffect"></a>4.5.14 花费(Cost)GameplayEffect</h3><p><a href="#concepts-ga">GameplayAbility</a>有一个特别设计用来作为Ability花费(Cost)的可选<code>GameplayEffect</code>. 花费(Cost)是指<code>ASC</code>激活<code>GameplayAbility</code>所必需的<code>Attribute</code>量. 如果某个<code>GA</code>不能提供<code>Cost GE</code>, 那么它就不能被激活. 该<code>Cost GE</code>应该是某个带有一个或多个自<code>Attribute</code>中减值Modifier的<code>即刻(Instant)GameplayEffect</code>. 默认情况下, <code>Cost GE</code>是可以被预测的, 建议保留该功能, 也就是不要使用<code>ExecutionCalculations</code>, <code>MMC</code>对于复杂的花费计算是完美适配并且鼓励使用的.  </p><p>开始的时候, 你通常会为每个有花费的<code>GA</code>都设置一个独一无二的<code>Cost GE</code>, 一个更高阶的技巧是对多个<code>GA</code>复用一个<code>Cost GE</code>, 只需修改自<code>GA</code>的<code>Cost GE</code>创建的<code>GameplayEffectSpec</code>中指定的数据(花费值是在<code>GA</code>上定义的), <strong>这只作用于<code>实例化(Instanced)</code>的Ability.</strong>  </p><p>复用<code>Cost GE</code>的两种技巧:  </p><ol><li>使用<code>MMC</code>. 这是最简单的方式. 创建一个从<code>GameplayAbility</code>实例读取花费值的<a href="#concepts-ge-mmc">MMC</a>, 你可以从<code>GameplayEffectSpec</code>中获取到该实例.  </li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">float</span> <span class="title">UPGMMC_HeroAbilityCost::CalculateBaseMagnitude_Implementation</span><span class="params">(<span class="type">const</span> FGameplayEffectSpec &amp; Spec)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">const</span> UPGGameplayAbility* Ability = <span class="built_in">Cast</span>&lt;UPGGameplayAbility&gt;(Spec.<span class="built_in">GetContext</span>().<span class="built_in">GetAbilityInstance_NotReplicated</span>());</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!Ability)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0.0f</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> Ability-&gt;Cost.<span class="built_in">GetValueAtLevel</span>(Ability-&gt;<span class="built_in">GetAbilityLevel</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个例子中, 花费值是一个我添加到<code>GameplayAbility</code>子类上的<code>FScalableFloat</code>.  </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">UPROPERTY</span>(BlueprintReadOnly, EditAnywhere, Category = <span class="string">&quot;Cost&quot;</span>)</span><br><span class="line">FScalableFloat Cost;</span><br></pre></td></tr></table></figure><p><img src="https://pic1.imgdb.cn/item/67a4c62ed0e0a243d4fc53b3.png" alt="Cost GE With MMC"></p><ol><li><strong>重写<code>UGameplayAbility::GetCostGameplayEffect()</code>.</strong> 重写该函数并在<a href="#concepts-ge-dynamic">运行时</a>创建一个用来读取<code>GameplayAbility</code>中花费值的<code>GameplayEffect</code>.  </li></ol><p><strong><a href="#table-of-contents">⬆ 返回目录</a></strong></p><p><span id="concepts-ge-cooldown"></span></p><h3 id="4-5-15-冷却-Cooldown-GameplayEffect"><a href="#4-5-15-冷却-Cooldown-GameplayEffect" class="headerlink" title="4.5.15 冷却(Cooldown)GameplayEffect"></a>4.5.15 冷却(Cooldown)GameplayEffect</h3><p><a href="#concepts-ga">GameplayAbility</a>有一个特别设计用来作为Ability冷却(Cooldown)的可选<code>GameplayEffect</code>. 冷却时间决定了激活Ability之后多久可以再次激活. 如果某个<code>GA</code>在冷却中, 那么它就不能被激活. 该<code>Cooldown GE</code>应该是一个不带有<code>Modifier</code>的<code>持续(Duration)GameplayEffect</code>, 并且在<code>GameplayEffect</code>的<code>GrantedTags</code>中每个<code>GameplayAbility</code>或Ability插槽(Slot)(如果你的游戏有分配到插槽的可交换Ability且共享同一个冷却)都有一个独一无二的<code>GameplayTag</code>(<code>Cooldown Tag</code>). <code>GA</code>实际上会检查<code>Cooldown Tag</code>的存在而不是<code>Cooldown GE</code>的存在, 默认情况下, <code>Cooldown GE</code>是可以被预测的, 建议保留该功能, 也就是不要使用<code>ExecutionCalculations</code>, <code>MMC</code>对于复杂的冷却计算是完美适配并且鼓励使用的.  </p><p>开始的时候, 你通常会为每个有冷却的<code>GA</code>都设置一个独一无二的<code>Cooldown GE</code>, 一个更高阶的技巧是对多个<code>GA</code>复用一个<code>Cooldown GE</code>, 只需修改自<code>GA</code>的<code>Cooldown GE</code>创建的<code>GameplayEffectSpec</code>中指定的数据(冷却时间和<code>Cooldown Tag</code>是在<code>GA</code>上定义的), <strong>这只作用于<code>实例化(Instanced)</code>的Ability.</strong>  </p><p>复用<code>Cooldown GE</code>的两种技巧:  </p><ol><li>使用<a href="#concepts-ge-spec-setbycaller">SetByCaller</a>. 这是最简单的方式. 使用<code>GameplayTag</code>设置<code>SetByCaller</code>为共享<code>Cooldown GE</code>的持续时间. 在<code>GameplayAbility</code>子类中, 为持续时间定义一个浮点/<code>FScalableFloat</code>变量, 为独一无二的<code>Cooldown Tag</code>定义一个<code>FGameplayTagContainer</code>, 除此之外还要定义一个临时<code>FGameplayTagContainer</code>, 其用来作为<code>Cooldown Tag</code>与<code>Cooldown GE</code>标签并集的返回指针.  </li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">UPROPERTY</span>(BlueprintReadOnly, EditAnywhere, Category = <span class="string">&quot;Cooldown&quot;</span>)</span><br><span class="line">FScalableFloat CooldownDuration;</span><br><span class="line"></span><br><span class="line"><span class="built_in">UPROPERTY</span>(BlueprintReadOnly, EditAnywhere, Category = <span class="string">&quot;Cooldown&quot;</span>)</span><br><span class="line">FGameplayTagContainer CooldownTags;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Temp container that we will return the pointer to in GetCooldownTags().</span></span><br><span class="line"><span class="comment">// This will be a union of our CooldownTags and the Cooldown GE&#x27;s cooldown tags.</span></span><br><span class="line"><span class="built_in">UPROPERTY</span>()</span><br><span class="line">FGameplayTagContainer TempCooldownTags;</span><br></pre></td></tr></table></figure><p>之后重写<code>UGameplayAbility::GetCooldownTags()</code>以返回<code>Cooldown Tag</code>和所有现有<code>Cooldown GE</code>标签的并集.  </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">const</span> FGameplayTagContainer * <span class="title">UPGGameplayAbility::GetCooldownTags</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">FGameplayTagContainer* MutableTags = <span class="built_in">const_cast</span>&lt;FGameplayTagContainer*&gt;(&amp;TempCooldownTags);</span><br><span class="line"><span class="type">const</span> FGameplayTagContainer* ParentTags = Super::<span class="built_in">GetCooldownTags</span>();</span><br><span class="line"><span class="keyword">if</span> (ParentTags)</span><br><span class="line">&#123;</span><br><span class="line">MutableTags-&gt;<span class="built_in">AppendTags</span>(*ParentTags);</span><br><span class="line">&#125;</span><br><span class="line">MutableTags-&gt;<span class="built_in">AppendTags</span>(CooldownTags);</span><br><span class="line"><span class="keyword">return</span> MutableTags;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后, 重写<code>UGameplayAbility::ApplyCooldown()</code>以注入我们自己的<code>Cooldown Tag</code>, 并将<code>SetByCaller</code>添加到<code>Cooldown GameplayEffectSpec</code>.  </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">UPGGameplayAbility::ApplyCooldown</span><span class="params">(<span class="type">const</span> FGameplayAbilitySpecHandle Handle, <span class="type">const</span> FGameplayAbilityActorInfo * ActorInfo, <span class="type">const</span> FGameplayAbilityActivationInfo ActivationInfo)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">UGameplayEffect* CooldownGE = <span class="built_in">GetCooldownGameplayEffect</span>();</span><br><span class="line"><span class="keyword">if</span> (CooldownGE)</span><br><span class="line">&#123;</span><br><span class="line">FGameplayEffectSpecHandle SpecHandle = <span class="built_in">MakeOutgoingGameplayEffectSpec</span>(CooldownGE-&gt;<span class="built_in">GetClass</span>(), <span class="built_in">GetAbilityLevel</span>());</span><br><span class="line">SpecHandle.Data.<span class="built_in">Get</span>()-&gt;DynamicGrantedTags.<span class="built_in">AppendTags</span>(CooldownTags);</span><br><span class="line">SpecHandle.Data.<span class="built_in">Get</span>()-&gt;<span class="built_in">SetSetByCallerMagnitude</span>(FGameplayTag::<span class="built_in">RequestGameplayTag</span>(<span class="built_in">FName</span>(  OurSetByCallerTag  )), CooldownDuration.<span class="built_in">GetValueAtLevel</span>(<span class="built_in">GetAbilityLevel</span>()));</span><br><span class="line"><span class="built_in">ApplyGameplayEffectSpecToOwner</span>(Handle, ActorInfo, ActivationInfo, SpecHandle);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面图片中, 冷却时间<code>Modifier</code>被设置为<code>SetByCaller</code>, 其<code>Data Tag</code>为<code>Data.Cooldown</code>. <code>Data.Cooldown</code>就是上面代码中的<code>OurSetByCallerTag</code>.  </p><p><img src="https://pic1.imgdb.cn/item/67a4c64dd0e0a243d4fc53b9.png" alt="Cooldown GE with SetByCaller">  </p><ol><li>使用<a href="#concepts-ge-mmc">MMC</a>. 它的设置与上文所提的一致, 除了不需要在<code>Cooldown GE</code>和<code>ApplyCost</code>中设置<code>SetByCaller</code>作为持续时间, 相反, 我们需要将持续时间设置为<code>Custom Calculation类</code>并将其指向新创建的<code>MMC</code>.  </li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">UPROPERTY</span>(BlueprintReadOnly, EditAnywhere, Category = <span class="string">&quot;Cooldown&quot;</span>)</span><br><span class="line">FScalableFloat CooldownDuration;</span><br><span class="line"></span><br><span class="line"><span class="built_in">UPROPERTY</span>(BlueprintReadOnly, EditAnywhere, Category = <span class="string">&quot;Cooldown&quot;</span>)</span><br><span class="line">FGameplayTagContainer CooldownTags;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Temp container that we will return the pointer to in GetCooldownTags().</span></span><br><span class="line"><span class="comment">// This will be a union of our CooldownTags and the Cooldown GE&#x27;s cooldown tags.</span></span><br><span class="line"><span class="built_in">UPROPERTY</span>()</span><br><span class="line">FGameplayTagContainer TempCooldownTags;</span><br></pre></td></tr></table></figure><p>之后重写<code>UGameplayAbility::GetCooldownTags()</code>以返回<code>Cooldown Tag</code>和所有现有<code>Cooldown GE</code>标签的并集.  </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">const</span> FGameplayTagContainer * <span class="title">UPGGameplayAbility::GetCooldownTags</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">FGameplayTagContainer* MutableTags = <span class="built_in">const_cast</span>&lt;FGameplayTagContainer*&gt;(&amp;TempCooldownTags);</span><br><span class="line"><span class="type">const</span> FGameplayTagContainer* ParentTags = Super::<span class="built_in">GetCooldownTags</span>();</span><br><span class="line"><span class="keyword">if</span> (ParentTags)</span><br><span class="line">&#123;</span><br><span class="line">MutableTags-&gt;<span class="built_in">AppendTags</span>(*ParentTags);</span><br><span class="line">&#125;</span><br><span class="line">MutableTags-&gt;<span class="built_in">AppendTags</span>(CooldownTags);</span><br><span class="line"><span class="keyword">return</span> MutableTags;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后, 重写<code>UGameplayAbility::ApplyCooldown()</code>以将我们的<code>Cooldown Tag</code>注入<code>Cooldown GameplayEffectSpec</code>.  </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">UPGGameplayAbility::ApplyCooldown</span><span class="params">(<span class="type">const</span> FGameplayAbilitySpecHandle Handle, <span class="type">const</span> FGameplayAbilityActorInfo * ActorInfo, <span class="type">const</span> FGameplayAbilityActivationInfo ActivationInfo)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">UGameplayEffect* CooldownGE = <span class="built_in">GetCooldownGameplayEffect</span>();</span><br><span class="line"><span class="keyword">if</span> (CooldownGE)</span><br><span class="line">&#123;</span><br><span class="line">FGameplayEffectSpecHandle SpecHandle = <span class="built_in">MakeOutgoingGameplayEffectSpec</span>(CooldownGE-&gt;<span class="built_in">GetClass</span>(), <span class="built_in">GetAbilityLevel</span>());</span><br><span class="line">SpecHandle.Data.<span class="built_in">Get</span>()-&gt;DynamicGrantedTags.<span class="built_in">AppendTags</span>(CooldownTags);</span><br><span class="line"><span class="built_in">ApplyGameplayEffectSpecToOwner</span>(Handle, ActorInfo, ActivationInfo, SpecHandle);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">float</span> <span class="title">UPGMMC_HeroAbilityCooldown::CalculateBaseMagnitude_Implementation</span><span class="params">(<span class="type">const</span> FGameplayEffectSpec &amp; Spec)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">const</span> UPGGameplayAbility* Ability = <span class="built_in">Cast</span>&lt;UPGGameplayAbility&gt;(Spec.<span class="built_in">GetContext</span>().<span class="built_in">GetAbilityInstance_NotReplicated</span>());</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!Ability)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0.0f</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> Ability-&gt;CooldownDuration.<span class="built_in">GetValueAtLevel</span>(Ability-&gt;<span class="built_in">GetAbilityLevel</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://pic1.imgdb.cn/item/67a4c678d0e0a243d4fc53bd.png" alt="Cooldown GE with MMC">  </p><p><strong><a href="#table-of-contents">⬆ 返回目录</a></strong></p><p><span id="concepts-ge-cooldown-tr"></span></p><h4 id="4-5-15-1-获取Cooldown-GameplayEffect的剩余时间"><a href="#4-5-15-1-获取Cooldown-GameplayEffect的剩余时间" class="headerlink" title="4.5.15.1 获取Cooldown GameplayEffect的剩余时间"></a>4.5.15.1 获取Cooldown GameplayEffect的剩余时间</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">APGPlayerState::GetCooldownRemainingForTag</span><span class="params">(FGameplayTagContainer CooldownTags, <span class="type">float</span> &amp; TimeRemaining, <span class="type">float</span> &amp; CooldownDuration)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (AbilitySystemComponent &amp;&amp; CooldownTags.<span class="built_in">Num</span>() &gt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">TimeRemaining = <span class="number">0.f</span>;</span><br><span class="line">CooldownDuration = <span class="number">0.f</span>;</span><br><span class="line"></span><br><span class="line">FGameplayEffectQuery <span class="type">const</span> Query = FGameplayEffectQuery::<span class="built_in">MakeQuery_MatchAnyOwningTags</span>(CooldownTags);</span><br><span class="line">TArray&lt; TPair&lt;<span class="type">float</span>, <span class="type">float</span>&gt; &gt; DurationAndTimeRemaining = AbilitySystemComponent-&gt;<span class="built_in">GetActiveEffectsTimeRemainingAndDuration</span>(Query);</span><br><span class="line"><span class="keyword">if</span> (DurationAndTimeRemaining.<span class="built_in">Num</span>() &gt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">int32 BestIdx = <span class="number">0</span>;</span><br><span class="line"><span class="type">float</span> LongestTime = DurationAndTimeRemaining[<span class="number">0</span>].Key;</span><br><span class="line"><span class="keyword">for</span> (int32 Idx = <span class="number">1</span>; Idx &lt; DurationAndTimeRemaining.<span class="built_in">Num</span>(); ++Idx)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (DurationAndTimeRemaining[Idx].Key &gt; LongestTime)</span><br><span class="line">&#123;</span><br><span class="line">LongestTime = DurationAndTimeRemaining[Idx].Key;</span><br><span class="line">BestIdx = Idx;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">TimeRemaining = DurationAndTimeRemaining[BestIdx].Key;</span><br><span class="line">CooldownDuration = DurationAndTimeRemaining[BestIdx].Value;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Note:</strong> 在客户端上查询剩余冷却时间要求其可以接收同步的<code>GameplayEffect</code>, 这依赖于它们<code>ASC</code>的<a href="#concepts-asc-rm">同步模式</a>.  </p><p><strong><a href="#table-of-contents">⬆ 返回目录</a></strong></p><p> <span id="concepts-ge-cooldown-listen"></span></p><h4 id="4-5-15-2-监听冷却开始和结束"><a href="#4-5-15-2-监听冷却开始和结束" class="headerlink" title="4.5.15.2 监听冷却开始和结束"></a>4.5.15.2 监听冷却开始和结束</h4><p>为了监听某个冷却何时开始, 你可以通过绑定<code>AbilitySystemComponent-&gt;OnActiveGameplayEffectAddedDelegateToSelf</code>或者<code>AbilitySystemComponent-&gt;RegisterGameplayTagEvent(CooldownTag, EGameplayTagEventType::NewOrRemoved)</code>分别在<code>Cooldown GE</code>应用和<code>Cooldown Tag</code>添加时作出响应. 我建议监听<code>Cooldown GE</code>何时应用, 因为这时还可以访问应用它的<code>GameplayEffectSpec</code>. 由此你可以确定当前<code>Cooldown GE</code>是客户端预测的还是由服务端校正的.  </p><p>为了监听某个冷却何时结束, 你可以通过绑定<code>AbilitySystemComponent-&gt;OnAnyGameplayEffectRemovedDelegate()</code>或者<code>AbilitySystemComponent-&gt;RegisterGameplayTagEvent(CooldownTag, EGameplayTagEventType::NewOrRemoved)</code>分别在<code>Cooldown GE</code>移除和<code>Cooldown Tag</code>移除时作出响应. 我建议监听<code>Cooldown Tag</code>何时移除, 因为当服务端校正的<code>Cooldown GE</code>到来时, 会移除客户端预测的<code>Cooldown GE</code>, 这会响应<code>OnAnyGameplayEffectRemovedDelegate()</code>, 即使仍处于冷却过程中. 预测的<code>Cooldown GE</code>在移除时和服务端校正的<code>Cooldown GE</code>在应用时<code>Cooldown Tag</code>都不会改变.  </p><p><strong>Note:</strong> 在客户端上监听某个<code>GameplayEffect</code>添加或移除要求其可以接收同步的<code>GameplayEffect</code>, 这依赖于它们<code>ASC</code>的<a href="#concepts-asc-rm">同步模式</a>.  </p><p>样例项目包含一个用于监听冷却开始和结束的自定义蓝图节点, HUD UMG Widget使用它来更新陨石技能的剩余冷却时间, 该<code>AsyncTask</code>会一直响应直到手动调用<code>EndTask()</code>, 就像在UMG Widget的<code>Destruct</code>事件中调用那样. 参阅<code>AsyncTaskAttributeChanged.h/cpp</code>.  </p><p><img src="https://pic1.imgdb.cn/item/67a4c694d0e0a243d4fc53ca.png" alt="Listen for Cooldown Change BP Node">  </p><p><strong><a href="#table-of-contents">⬆ 返回目录</a></strong></p><p><span id="concepts-ge-cooldown-prediction"></span></p><h4 id="4-5-15-3-预测冷却时间"><a href="#4-5-15-3-预测冷却时间" class="headerlink" title="4.5.15.3 预测冷却时间"></a>4.5.15.3 预测冷却时间</h4><p>目前冷却时间不是真正可预测的. 我们可以在客户端预测的<code>Cooldown GE</code>应用时启动UI的冷却时间计时器, 但是<code>GameplayAbility</code>的实际冷却时间是由服务端的冷却时间剩余决定的. 取决于玩家的延迟情况, 可能客户端预测的冷却已经结束, 但是服务端上的<code>GameplayAbility</code>仍处于冷却过程, 这会阻止<code>GameplayAbility</code>的立刻再激活直到服务端冷却结束.  </p><p>样例项目通过在客户端预测的冷却开始时灰化陨石技能的图标, 之后在服务端校正的<code>Cooldown GE</code>到来时启动冷却计时器处理该问题.  </p><p>在实际游戏中导致的结果就是高延迟的玩家相比低延迟的玩家对冷却时间短的技能有更低的触发率, 从而处于劣势, Fortnite通过使其武器使用无需冷却<code>GameplayEffect</code>的自定义Bookkeeping而避免该现象.  </p><p>Epic希望在未来的<a href="#concepts-p-future">GAS迭代版本</a>中实现真正的冷却预测(玩家可以激活一个在客户端冷却完成但服务端仍处于冷却过程的<code>GameplayAbility</code>).  </p><p><strong><a href="#table-of-contents">⬆ 返回目录</a></strong></p><p><span id="concepts-ge-duration"></span></p><h3 id="4-5-16-修改已激活GameplayEffect的持续时间"><a href="#4-5-16-修改已激活GameplayEffect的持续时间" class="headerlink" title="4.5.16 修改已激活GameplayEffect的持续时间"></a>4.5.16 修改已激活GameplayEffect的持续时间</h3><p>为了修改<code>Cooldown GE</code>或其他任何<code>持续(Duration)</code>GameplayEffect的剩余时间, 我们需要修改<code>GameplayEffectSpec</code>的持续时间, 更新它的<code>StartServerWorldTime</code>, <code>CachedStartServerWorldTime</code>, <code>StartWorldTime</code>, 并且使用<code>CheckDuration()</code>重新检查持续时间. 在服务端上完成这些操作并将<code>FActiveGameplayEffect</code>标记为dirty, 其会将这些修改同步到客户端. <strong>Note:</strong> 该操作包含一个<code>const_cast</code>, 这可能不是<code>Epic</code>希望的修改持续时间的方法, 但是迄今为止它看起来运行得很好.  </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">UPAAbilitySystemComponent::SetGameplayEffectDurationHandle</span><span class="params">(FActiveGameplayEffectHandle Handle, <span class="type">float</span> NewDuration)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (!Handle.<span class="built_in">IsValid</span>())</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> FActiveGameplayEffect* ActiveGameplayEffect = <span class="built_in">GetActiveGameplayEffect</span>(Handle);</span><br><span class="line"><span class="keyword">if</span> (!ActiveGameplayEffect)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">FActiveGameplayEffect* AGE = <span class="built_in">const_cast</span>&lt;FActiveGameplayEffect*&gt;(ActiveGameplayEffect);</span><br><span class="line"><span class="keyword">if</span> (NewDuration &gt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">AGE-&gt;Spec.Duration = NewDuration;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">AGE-&gt;Spec.Duration = <span class="number">0.01f</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">AGE-&gt;StartServerWorldTime = ActiveGameplayEffects.<span class="built_in">GetServerWorldTime</span>();</span><br><span class="line">AGE-&gt;CachedStartServerWorldTime = AGE-&gt;StartServerWorldTime;</span><br><span class="line">AGE-&gt;StartWorldTime = ActiveGameplayEffects.<span class="built_in">GetWorldTime</span>();</span><br><span class="line">ActiveGameplayEffects.<span class="built_in">MarkItemDirty</span>(*AGE);</span><br><span class="line">ActiveGameplayEffects.<span class="built_in">CheckDuration</span>(Handle);</span><br><span class="line"></span><br><span class="line">AGE-&gt;EventSet.OnTimeChanged.<span class="built_in">Broadcast</span>(AGE-&gt;Handle, AGE-&gt;StartWorldTime, AGE-&gt;<span class="built_in">GetDuration</span>());</span><br><span class="line"><span class="built_in">OnGameplayEffectDurationChange</span>(*AGE);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong><a href="#table-of-contents">⬆ 返回目录</a></strong></p><p><span id="concepts-ge-dynamic"></span></p><h3 id="4-5-17-运行时创建动态GameplayEffect"><a href="#4-5-17-运行时创建动态GameplayEffect" class="headerlink" title="4.5.17 运行时创建动态GameplayEffect"></a>4.5.17 运行时创建动态GameplayEffect</h3><p>在运行时创建动态<code>GameplayEffect</code>是一个高阶技术, 你不必经常使用它.  </p><p>只有<code>即刻(Instant)GameplayEffect</code>可以在运行时由C++创建, <code>持续(Duration)</code>和<code>无限(Infinite)</code>GameplayEffect不能在运行时动态创建, 因为它们在同步时会寻找并不存在的<code>GameplayEffect</code>类定义. 为了实现该功能, 你应该创建一个原型<code>GameplayEffect</code>类, 就像平时在编辑器中做的那样, 之后根据运行时所需来定制化<code>GameplayEffectSpec</code>.  </p><p>运行时创建的<code>即刻(Instant)GameplayEffect</code>也可以在客户端<a href="#concepts-p">预测</a>的<code>GameplayAbility</code>中调用. 然而, 目前还不明确动态创建是否有副作用.  </p><p>样例项目会在角色<code>AttributeSet</code>中的值受到致命一击时创建该<code>GameplayEffect</code>来将金币和经验点数返还给击杀者.  </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Create a dynamic instant Gameplay Effect to give the bounties</span></span><br><span class="line">UGameplayEffect* GEBounty = <span class="built_in">NewObject</span>&lt;UGameplayEffect&gt;(<span class="built_in">GetTransientPackage</span>(), <span class="built_in">FName</span>(<span class="built_in">TEXT</span>(<span class="string">&quot;Bounty&quot;</span>)));</span><br><span class="line">GEBounty-&gt;DurationPolicy = EGameplayEffectDurationType::Instant;</span><br><span class="line"></span><br><span class="line">int32 Idx = GEBounty-&gt;Modifiers.<span class="built_in">Num</span>();</span><br><span class="line">GEBounty-&gt;Modifiers.<span class="built_in">SetNum</span>(Idx + <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">FGameplayModifierInfo&amp; InfoXP = GEBounty-&gt;Modifiers[Idx];</span><br><span class="line">InfoXP.ModifierMagnitude = <span class="built_in">FScalableFloat</span>(<span class="built_in">GetXPBounty</span>());</span><br><span class="line">InfoXP.ModifierOp = EGameplayModOp::Additive;</span><br><span class="line">InfoXP.Attribute = UGDAttributeSetBase::<span class="built_in">GetXPAttribute</span>();</span><br><span class="line"></span><br><span class="line">FGameplayModifierInfo&amp; InfoGold = GEBounty-&gt;Modifiers[Idx + <span class="number">1</span>];</span><br><span class="line">InfoGold.ModifierMagnitude = <span class="built_in">FScalableFloat</span>(<span class="built_in">GetGoldBounty</span>());</span><br><span class="line">InfoGold.ModifierOp = EGameplayModOp::Additive;</span><br><span class="line">InfoGold.Attribute = UGDAttributeSetBase::<span class="built_in">GetGoldAttribute</span>();</span><br><span class="line"></span><br><span class="line">Source-&gt;<span class="built_in">ApplyGameplayEffectToSelf</span>(GEBounty, <span class="number">1.0f</span>, Source-&gt;<span class="built_in">MakeEffectContext</span>());</span><br></pre></td></tr></table></figure><p>第二个样例展示了在一个客户端预测的<code>GameplayAbility</code>中创建运行时<code>GameplayEffect</code>, 使用风险自负(查看代码中的注释)!</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">UGameplayAbilityRuntimeGE::<span class="built_in">UGameplayAbilityRuntimeGE</span>()</span><br><span class="line">&#123;</span><br><span class="line">NetExecutionPolicy = EGameplayAbilityNetExecutionPolicy::LocalPredicted;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">UGameplayAbilityRuntimeGE::ActivateAbility</span><span class="params">(<span class="type">const</span> FGameplayAbilitySpecHandle Handle, <span class="type">const</span> FGameplayAbilityActorInfo* ActorInfo, <span class="type">const</span> FGameplayAbilityActivationInfo ActivationInfo, <span class="type">const</span> FGameplayEventData* TriggerEventData)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">HasAuthorityOrPredictionKey</span>(ActorInfo, &amp;ActivationInfo))</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (!<span class="built_in">CommitAbility</span>(Handle, ActorInfo, ActivationInfo))</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">EndAbility</span>(Handle, ActorInfo, ActivationInfo, <span class="literal">true</span>, <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Create the GE at runtime.</span></span><br><span class="line">UGameplayEffect* GameplayEffect = <span class="built_in">NewObject</span>&lt;UGameplayEffect&gt;(<span class="built_in">GetTransientPackage</span>(), <span class="built_in">TEXT</span>(<span class="string">&quot;RuntimeInstantGE&quot;</span>));</span><br><span class="line">GameplayEffect-&gt;DurationPolicy = EGameplayEffectDurationType::Instant; <span class="comment">// Only instant works with runtime GE.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Add a simple scalable float modifier, which overrides MyAttribute with 42.</span></span><br><span class="line"><span class="comment">// In real world applications, consume information passed via TriggerEventData.</span></span><br><span class="line"><span class="type">const</span> int32 Idx = GameplayEffect-&gt;Modifiers.<span class="built_in">Num</span>();</span><br><span class="line">GameplayEffect-&gt;Modifiers.<span class="built_in">SetNum</span>(Idx + <span class="number">1</span>);</span><br><span class="line">FGameplayModifierInfo&amp; ModifierInfo = GameplayEffect-&gt;Modifiers[Idx];</span><br><span class="line">ModifierInfo.Attribute.<span class="built_in">SetUProperty</span>(UMyAttributeSet::<span class="built_in">GetMyModifiedAttribute</span>());</span><br><span class="line">ModifierInfo.ModifierMagnitude = <span class="built_in">FScalableFloat</span>(<span class="number">42.f</span>);</span><br><span class="line">ModifierInfo.ModifierOp = EGameplayModOp::Override;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Apply the GE.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Create the GESpec here to avoid the behavior of ASC to create GESpecs from the GE class default object.</span></span><br><span class="line"><span class="comment">// Since we have a dynamic GE here, this would create a GESpec with the base GameplayEffect class, so we</span></span><br><span class="line"><span class="comment">// would lose our modifiers. Attention: It is unknown, if this &quot;hack&quot; done here can have drawbacks!</span></span><br><span class="line"><span class="comment">// The spec prevents the GE object being collected by the GarbageCollector, since the GE is a UPROPERTY on the spec.</span></span><br><span class="line">FGameplayEffectSpec* GESpec = <span class="keyword">new</span> <span class="built_in">FGameplayEffectSpec</span>(GameplayEffect, &#123;&#125;, <span class="number">0.f</span>); <span class="comment">// &quot;new&quot;, since lifetime is managed by a shared ptr within the handle</span></span><br><span class="line"><span class="built_in">ApplyGameplayEffectSpecToOwner</span>(Handle, ActorInfo, ActivationInfo, <span class="built_in">FGameplayEffectSpecHandle</span>(GESpec));</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">EndAbility</span>(Handle, ActorInfo, ActivationInfo, <span class="literal">false</span>, <span class="literal">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong><a href="#table-of-contents">⬆ 返回目录</a></strong></p><p><span id="concepts-ge-containers"></span></p><h3 id="4-5-18-GameplayEffect-Containers"><a href="#4-5-18-GameplayEffect-Containers" class="headerlink" title="4.5.18 GameplayEffect Containers"></a>4.5.18 GameplayEffect Containers</h3><p>Epic的<a href="https://www.unrealengine.com/marketplace/en-US/slug/action-rpg">Action RPG</a>样例项目实现了一个名为<code>FGameplayEffectContainer</code>的结构体, 它不属于原生GAS, 但是对于包含<code>GameplayEffect</code>和<a href="#concepts-targeting-data">TargetData</a>极其好用, 它会使一些过程自动化, 比如从<code>GameplayEffect</code>中创建<code>GameplayEffectSpec</code>并在其<code>GameplayEffectContext</code>中设置默认值. 在<code>GameplayAbility</code>中创建<code>GameplayEffectContainer</code>并将其传递给已生成的投掷物是非常简单和显而易见的, 然而我没有选择在样例项目中实现<code>GameplayEffectContainer</code>, 因为我想向你展示的是没有它的原生GAS, 但是我高度建议你研究一下它并将其纳入到你的项目中.  </p><p>为了访问<code>GameplayEffectContainer</code>中的<code>GESpec</code>以求做一些诸如添加<code>SetByCaller</code>的操作, 请使用<code>FGameplayEffectContainer</code>结构体中的<code>GESpec</code>数组索引访问<code>GESpec</code>引用, 这要求你需要提前知道想要访问的<code>GESpec</code>的索引.  </p><p><img src="https://pic1.imgdb.cn/item/67a4c6b4d0e0a243d4fc53d7.png" alt="SetByCaller with a GameplayEffectContainer">  </p><p><code>GameplayEffectContainer</code>还包含一个可选的用于<a href="#concepts-targeting-containers">定位(Target)</a>的高效方法.</p><p><strong><a href="#table-of-contents">⬆ 返回目录</a></strong></p><p><span id="concepts-ga"></span></p><h2 id="4-6-Gameplay-Abilities"><a href="#4-6-Gameplay-Abilities" class="headerlink" title="4.6 Gameplay Abilities"></a>4.6 Gameplay Abilities</h2><p><span id="concepts-ga-definition"></span></p><h3 id="4-6-1-GameplayAbility定义"><a href="#4-6-1-GameplayAbility定义" class="headerlink" title="4.6.1 GameplayAbility定义"></a>4.6.1 GameplayAbility定义</h3><p><a href="https://docs.unrealengine.com/en-US/API/Plugins/GameplayAbilities/Abilities/UGameplayAbility/index.html">GameplayAbility(GA)</a>是Actor在游戏中可以触发的一切行为和技能. 多个<code>GameplayAbility</code>可以在同一时刻激活, 例如奔跑和射击. 其可由蓝图或C++完成.  </p><p><code>GameplayAbility</code>示例:  </p><ul><li>跳跃</li><li>奔跑</li><li>射击</li><li>每X秒被动地阻挡一次攻击</li><li>使用药剂</li><li>开门</li><li>收集资源</li><li>建造</li></ul><p>不应该使用<code>GameplayAbility</code>的场景:  </p><ul><li>基础移动输入</li><li>一些与UI的交互 - 不要使用<code>GameplayAbility</code>从商店中购买物品</li></ul><p>这些不是规定, 只是我的建议而已, 你的设计和实现可能是多样的.  </p><p><code>GameplayAbility</code>自带有根据等级修改Attribute变化量或者<code>GameplayAbility</code>作用的默认功能.  </p><p><code>GameplayAbility</code>运行在所属(Owning)客户端还是服务端取决于<a href="#concepts-ga-net">网络执行策略(Net Execution Policy)</a>而不是Simulated Proxy. <code>网络执行策略(Net Execution Policy)</code>决定某个<code>GameplayAbility</code>是否是客户端可<a href="#concepts-p">预测</a>的, 其对于<a href="#concepts-ga-commit">可选的Cost和<code>Cooldown GameplayEffect</code></a>包含有默认行为. <code>GameplayAbility</code>使用<a href="#concepts-at">AbilityTask</a>用于随时间推移而发生的行为, 例如等待某个事件, 等待某个Attribute改变, 等待玩家选择一个目标或者使用<code>Root Motion Source</code>移动某个<code>Character</code>. <strong>Simulated Client不会运行<code>GameplayAbility</code>,</strong> 而是当服务端执行<code>Ability</code>时, 任何需要在Simulated Proxy上展现的视觉效果(像动画蒙太奇)将会被同步(Replicate)或者通过<code>AbilityTask</code>进行RPC或者对于像声音和粒子这样的装饰效果使用<a href="#concepts-gc">GameplayCue</a>.  </p><p>所有的<code>GameplayAbility</code>都会有它们各自由你的游戏逻辑重写的<code>ActivateAbility()</code>函数, 附加的逻辑可以添加到<code>EndAbility()</code>, 其会在<code>GameplayAbility</code>完成或取消时执行.  </p><p>一个简单的<code>GameplayAbility</code>流程图: <img src="https://pic1.imgdb.cn/item/67a4c6d4d0e0a243d4fc53db.png" alt="Simple GameplayAbility Flowchart">  </p><p>一个更复杂<code>GameplayAbility</code>流程图: <img src="https://pic1.imgdb.cn/item/67a4c6ead0e0a243d4fc53e3.png" alt="Complex GameplayAbility Flowchart">  </p><p>复杂的Ability可以使用多个相互交互(激活, 取消等等)的<code>GameplayAbility</code>实现.  </p><p><strong><a href="#table-of-contents">⬆ 返回目录</a></strong></p><p><span id="concepts-ga-definition-reppolicy"></span></p><h4 id="4-6-1-1-Replication-Policy"><a href="#4-6-1-1-Replication-Policy" class="headerlink" title="4.6.1.1 Replication Policy"></a>4.6.1.1 Replication Policy</h4><p>不要使用该选项. 这个名字会误导你并且你并不需要它. <a href="#concepts-ga-spec">GameplayAbilitySpec</a>默认会从服务端向所属(Owning)客户端同步, 上文提到过, <strong><code>GameplayAbility</code>不会运行在Simulated Proxy上,</strong> 其使用<code>AbilityTask</code>和<code>GameplayCue</code>来同步或者RPC视觉变化到Simulated Proxy. Epic的Dave Ratti已经表明要在未来<a href="https://epicgames.ent.box.com/s/m1egifkxv3he3u3xezb9hzbgroxyhx89">移除该选项</a>的意愿.  </p><p><strong><a href="#table-of-contents">⬆ 返回目录</a></strong></p><p><span id="concepts-ga-definition-remotecancel"></span></p><h4 id="4-6-1-2-Server-Respects-Remote-Ability-Cancellation"><a href="#4-6-1-2-Server-Respects-Remote-Ability-Cancellation" class="headerlink" title="4.6.1.2 Server Respects Remote Ability Cancellation"></a>4.6.1.2 Server Respects Remote Ability Cancellation</h4><p>这个选项往往会引起麻烦. 它的意思是如果客户端的<code>GameplayAbility</code>由于玩家取消或者自然完成时, 就会强制它的服务端版本结束而不管其是否完成. 最重要的是之后的问题, 特别是对于高延迟玩家所使用的客户端预测的<code>GameplayAbility</code>. 一般情况下禁用该选项.  </p><p><strong><a href="#table-of-contents">⬆ 返回目录</a></strong></p><p><span id="concepts-ga-definition-repinputdirectly"></span></p><h4 id="4-6-1-3-Replicate-Input-Directly"><a href="#4-6-1-3-Replicate-Input-Directly" class="headerlink" title="4.6.1.3 Replicate Input Directly"></a>4.6.1.3 Replicate Input Directly</h4><p>设置该选项就会一直向服务端同步输入的按下(Press)和抬起(Release)事件. Epic不建议使用该选项而是依靠创建在已有输入相关的<a href="#concepts-at">AbilityTask</a>中的<code>Generic Replicated Event</code>(如果你的<a href="#concepts-ga-input">输入绑定在ASC</a>).  </p><p>Epic的注释:  </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** Direct Input state replication. These will be called if bReplicateInputDirectly is true on the ability and is generally not a good thing to use. (Instead, prefer to use Generic Replicated Events). */</span></span><br><span class="line">UAbilitySystemComponent::<span class="built_in">ServerSetInputPressed</span>()</span><br></pre></td></tr></table></figure><p><strong><a href="#table-of-contents">⬆ 返回目录</a></strong></p><p><span id="concepts-ga-input"></span></p><h3 id="4-6-2-绑定输入到ASC"><a href="#4-6-2-绑定输入到ASC" class="headerlink" title="4.6.2 绑定输入到ASC"></a>4.6.2 绑定输入到ASC</h3><p><code>ASC</code>允许你直接绑定输入事件并当你授予<code>GameplayAbility</code>时分配这些输入到<code>GameplayAbility</code>, 如果<code>GameplayTag</code>合乎要求, 当按下按键时, 分配到<code>GameplayAbility</code>的输入事件会自动激活各自的<code>GameplayAbility</code>. 分配的输入事件要求使用响应输入的内建<code>AbilityTask</code>.  </p><p>除了分配的输入事件可以激活<code>GameplayAbility</code>, <code>ASC</code>也接受一般的<code>Confirm</code>和<code>Cancel</code>输入, 这些特殊输入被<code>AbilityTask</code>用来确定像<a href="#concepts-targeting-actors">Target Actor</a>的对象或取消它们.  </p><p>为了绑定输入到<code>ASC</code>, 你必须首先创建一个枚举来将输入事件名称转换为byte, 枚举名必须准确匹配项目设置中用于输入事件的名称, <code>DisplayName</code>就无所谓了.  </p><p>样例项目中:  </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">UENUM</span>(BlueprintType)</span><br><span class="line"><span class="keyword">enum class</span> <span class="title class_">EGDAbilityInputID</span> : uint8</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 0 None</span></span><br><span class="line"><span class="function">None<span class="title">UMETA</span><span class="params">(DisplayName = <span class="string">&quot;None&quot;</span>)</span>,</span></span><br><span class="line"><span class="function"><span class="comment">// 1 Confirm</span></span></span><br><span class="line"><span class="function">Confirm<span class="title">UMETA</span><span class="params">(DisplayName = <span class="string">&quot;Confirm&quot;</span>)</span>,</span></span><br><span class="line"><span class="function"><span class="comment">// 2 Cancel</span></span></span><br><span class="line"><span class="function">Cancel<span class="title">UMETA</span><span class="params">(DisplayName = <span class="string">&quot;Cancel&quot;</span>)</span>,</span></span><br><span class="line"><span class="function"><span class="comment">// 3 LMB</span></span></span><br><span class="line"><span class="function">Ability1<span class="title">UMETA</span><span class="params">(DisplayName = <span class="string">&quot;Ability1&quot;</span>)</span>,</span></span><br><span class="line"><span class="function"><span class="comment">// 4 RMB</span></span></span><br><span class="line"><span class="function">Ability2<span class="title">UMETA</span><span class="params">(DisplayName = <span class="string">&quot;Ability2&quot;</span>)</span>,</span></span><br><span class="line"><span class="function"><span class="comment">// 5 Q</span></span></span><br><span class="line"><span class="function">Ability3<span class="title">UMETA</span><span class="params">(DisplayName = <span class="string">&quot;Ability3&quot;</span>)</span>,</span></span><br><span class="line"><span class="function"><span class="comment">// 6 E</span></span></span><br><span class="line"><span class="function">Ability4<span class="title">UMETA</span><span class="params">(DisplayName = <span class="string">&quot;Ability4&quot;</span>)</span>,</span></span><br><span class="line"><span class="function"><span class="comment">// 7 R</span></span></span><br><span class="line"><span class="function">Ability5<span class="title">UMETA</span><span class="params">(DisplayName = <span class="string">&quot;Ability5&quot;</span>)</span>,</span></span><br><span class="line"><span class="function"><span class="comment">// 8 Sprint</span></span></span><br><span class="line"><span class="function">Sprint<span class="title">UMETA</span><span class="params">(DisplayName = <span class="string">&quot;Sprint&quot;</span>)</span>,</span></span><br><span class="line"><span class="function"><span class="comment">// 9 Jump</span></span></span><br><span class="line"><span class="function">Jump<span class="title">UMETA</span><span class="params">(DisplayName = <span class="string">&quot;Jump&quot;</span>)</span></span></span><br><span class="line"><span class="function">&#125;</span>;</span><br></pre></td></tr></table></figure><p>如果你的<code>ASC</code>位于<code>Character</code>, 那么就在<code>SetupPlayerInputComponent()</code>中包含用于绑定到<code>ASC</code>的函数.  </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Bind to AbilitySystemComponent</span></span><br><span class="line">AbilitySystemComponent-&gt;<span class="built_in">BindAbilityActivationToInputComponent</span>(PlayerInputComponent, <span class="built_in">FGameplayAbilityInputBinds</span>(<span class="built_in">FString</span>(<span class="string">&quot;ConfirmTarget&quot;</span>), <span class="built_in">FString</span>(<span class="string">&quot;CancelTarget&quot;</span>), <span class="built_in">FString</span>(<span class="string">&quot;EGDAbilityInputID&quot;</span>), <span class="built_in">static_cast</span>&lt;int32&gt;(EGDAbilityInputID::Confirm), <span class="built_in">static_cast</span>&lt;int32&gt;(EGDAbilityInputID::Cancel)));</span><br></pre></td></tr></table></figure><p>如果你的<code>ASC</code>位于<code>PlayerState</code>, <code>SetupPlayerInputComponent()</code>中有一个潜在的竞争情况就是<code>PlayerState</code>还没有同步到客户端, 因此, 我建议尝试在<code>SetupPlayerInputComponent()</code>和<code>OnRep_PlayerState()</code>中绑定输入, 只有<code>OnRep_PlayerState()</code>自身是不充分的, 因为可能有种情况是当<code>PlayerState</code>在<code>PlayerController</code>告知客户端调用用于创建<code>InputComponent</code>的<code>ClientRestart()</code>前同步时, Actor的<code>InputComponent</code>可能为NULL. 样例项目演示了尝试使用一个布尔值控制流程从而在两个位置绑定, 这样实际上只绑定了一次.  </p><p><strong>Note:</strong> 样例项目枚举中的<code>Confirm</code>和<code>Cancel</code>没有匹配项目设置中的输入事件名称(<code>ConfirmTarget</code>和<code>CancelTarget</code>), 但是我们在<code>BindAbilityActivationToInputComponent()</code>中提供了它们之间的映射, 这是特殊的, 因为我们提供了映射并且它们无需匹配, 但是它们是可以匹配的. 枚举中的其他输入都必须匹配项目设置中的输入事件名称.  </p><p>对于只能用一次输入激活的<code>GameplayAbility</code>(它们总是像MOBA游戏一样存在于相同的”槽”中), 我倾向在<code>UGameplayAbility</code>子类中添加一个变量, 这样我就可以定义他们的输入, 之后在授予Ability的时候可以从<code>ClassDefaultObject</code>中读取这个值.  </p><p><strong><a href="#table-of-contents">⬆ 返回目录</a></strong></p><p><span id="concepts-ga-input-noactivate"></span></p><h4 id="4-6-2-1-绑定输入时不激活Ability"><a href="#4-6-2-1-绑定输入时不激活Ability" class="headerlink" title="4.6.2.1 绑定输入时不激活Ability"></a>4.6.2.1 绑定输入时不激活Ability</h4><p>如果你不想你的<code>GameplayAbility</code>在按键按下时自动激活, 但是仍想将它们绑定到输入以与<code>AbilityTask</code>一起使用, 你可以在<code>UGameplayAbility</code>子类中添加一个新的布尔变量, <code>bActivateOnInput</code>, 其默认值为<code>true</code>并重写<code>UAbilitySystemComponent::AbilityLocalInputPressed()</code>.  </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">UGSAbilitySystemComponent::AbilityLocalInputPressed</span><span class="params">(int32 InputID)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// Consume the input if this InputID is overloaded with GenericConfirm/Cancel and the GenericConfim/Cancel callback is bound</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">IsGenericConfirmInputBound</span>(InputID))</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">LocalInputConfirm</span>();</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">IsGenericCancelInputBound</span>(InputID))</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">LocalInputCancel</span>();</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ---------------------------------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">ABILITYLIST_SCOPE_LOCK</span>();</span><br><span class="line"><span class="keyword">for</span> (FGameplayAbilitySpec&amp; Spec : ActivatableAbilities.Items)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (Spec.InputID == InputID)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (Spec.Ability)</span><br><span class="line">&#123;</span><br><span class="line">Spec.InputPressed = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">if</span> (Spec.<span class="built_in">IsActive</span>())</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (Spec.Ability-&gt;bReplicateInputDirectly &amp;&amp; <span class="built_in">IsOwnerActorAuthoritative</span>() == <span class="literal">false</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">ServerSetInputPressed</span>(Spec.Handle);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">AbilitySpecInputPressed</span>(Spec);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Invoke the InputPressed event. This is not replicated here. If someone is listening, they may replicate the InputPressed event to the server.</span></span><br><span class="line"><span class="built_in">InvokeReplicatedEvent</span>(EAbilityGenericReplicatedEvent::InputPressed, Spec.Handle, Spec.ActivationInfo.<span class="built_in">GetActivationPredictionKey</span>());</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">UGSGameplayAbility* GA = <span class="built_in">Cast</span>&lt;UGSGameplayAbility&gt;(Spec.Ability);</span><br><span class="line"><span class="keyword">if</span> (GA &amp;&amp; GA-&gt;bActivateOnInput)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// Ability is not active, so try to activate it</span></span><br><span class="line"><span class="built_in">TryActivateAbility</span>(Spec.Handle);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong><a href="#table-of-contents">⬆ 返回目录</a></strong></p><p><span id="concepts-ga-granting"></span></p><h3 id="4-6-3-授予Ability"><a href="#4-6-3-授予Ability" class="headerlink" title="4.6.3 授予Ability"></a>4.6.3 授予Ability</h3><p>向<code>ASC</code>授予<code>GameplayAbility</code>会将其添加到<code>ASC</code>的<code>ActivatableAbilities</code>列表, 从而允许其在满足<a href="#concepts-ga-tags"><code>GameplayTag</code>需求</a>时激活该<code>GameplayAbility</code>.  </p><p>我们在服务端授予<code>GameplayAbility</code>, 之后其会自动同步<a href="#concepts-ga-spec">GameplayAbilitySpec</a>到所属(Owning)客户端, 其他客户端/Simulated proxy不会接受到<code>GameplayAbilitySpec</code>.  </p><p>样例项目在游戏开始时将<code>TArray&lt;TSubclassOf&lt;UGDGameplayAbility&gt;&gt;</code>保存在它读取和授予的<code>Character</code>类中.  </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">AGDCharacterBase::AddCharacterAbilities</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// Grant abilities, but only on the server</span></span><br><span class="line"><span class="keyword">if</span> (Role != ROLE_Authority || !AbilitySystemComponent.<span class="built_in">IsValid</span>() || AbilitySystemComponent-&gt;CharacterAbilitiesGiven)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (TSubclassOf&lt;UGDGameplayAbility&gt;&amp; StartupAbility : CharacterAbilities)</span><br><span class="line">&#123;</span><br><span class="line">AbilitySystemComponent-&gt;<span class="built_in">GiveAbility</span>(</span><br><span class="line"><span class="built_in">FGameplayAbilitySpec</span>(StartupAbility, <span class="built_in">GetAbilityLevel</span>(StartupAbility.<span class="built_in">GetDefaultObject</span>()-&gt;AbilityID), <span class="built_in">static_cast</span>&lt;int32&gt;(StartupAbility.<span class="built_in">GetDefaultObject</span>()-&gt;AbilityInputID), <span class="keyword">this</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">AbilitySystemComponent-&gt;CharacterAbilitiesGiven = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当授予这些<code>GameplayAbility</code>时, 我们就在使用<code>UGameplayAbility</code>类, Ability等级, 其绑定的输入和<code>SourceObject</code>或将该<code>GameplayAbility</code>设置到该<code>ASC</code>的源(Source)创建<code>GameplayAbilitySpec</code>.  </p><p><strong><a href="#table-of-contents">⬆ 返回目录</a></strong></p><p><span id="concepts-ga-activating"></span></p><h3 id="4-6-4-激活Ability"><a href="#4-6-4-激活Ability" class="headerlink" title="4.6.4 激活Ability"></a>4.6.4 激活Ability</h3><p>如果某个<code>GameplayAbility</code>被分配给了一个输入事件, 那么当输入按键按下并且它的<code>GameplayTag</code>需求满足时, 它将会自动激活, 这可能并非总是激活<code>GameplayAbility</code>的期望方式. <code>ASC</code>提供了另外四种激活<code>GameplayAbility</code>的方法: 通过<code>GameplayTag</code>, <code>GameplayAbility</code>类, <code>GameplayAbilitySpecHandle</code>和Event, 通过Event激活<code>GameplayAbility</code>允许你<a href="#concepts-ga-data">传递一个该事件的数据负载(Payload)</a>.  </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">UFUNCTION</span>(BlueprintCallable, Category = <span class="string">&quot;Abilities&quot;</span>)</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">TryActivateAbilitiesByTag</span><span class="params">(<span class="type">const</span> FGameplayTagContainer&amp; GameplayTagContainer, <span class="type">bool</span> bAllowRemoteActivation = <span class="literal">true</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">UFUNCTION</span>(BlueprintCallable, Category = <span class="string">&quot;Abilities&quot;</span>)</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">TryActivateAbilityByClass</span><span class="params">(TSubclassOf&lt;UGameplayAbility&gt; InAbilityToActivate, <span class="type">bool</span> bAllowRemoteActivation = <span class="literal">true</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">TryActivateAbility</span><span class="params">(FGameplayAbilitySpecHandle AbilityToActivate, <span class="type">bool</span> bAllowRemoteActivation = <span class="literal">true</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">TriggerAbilityFromGameplayEvent</span><span class="params">(FGameplayAbilitySpecHandle AbilityToTrigger, FGameplayAbilityActorInfo* ActorInfo, FGameplayTag Tag, <span class="type">const</span> FGameplayEventData* Payload, UAbilitySystemComponent&amp; Component)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">FGameplayAbilitySpecHandle <span class="title">GiveAbilityAndActivateOnce</span><span class="params">(<span class="type">const</span> FGameplayAbilitySpec&amp; AbilitySpec)</span></span>;</span><br></pre></td></tr></table></figure><p>想要通过Event激活<code>GameplayAbility</code>, <code>GameplayAbility</code>必须设置它的<code>Trigger</code>, 分配一个<code>GameplayTag</code>并为<code>GameplayEvent</code>选择一个选项. 想要发送Event, 就得使用<code>UAbilitySystemBlueprintLibrary::SendGameplayEventToActor(AActor* Actor, FGameplayTag EventTag, FGameplayEventData Payload)</code>函数. 通过Event激活<code>GameplayAbility</code>允许你传递一个数据负载(Payload).  </p><p><code>GameplayAbility Trigger</code>也允许你在某个<code>GameplayTag</code>添加或移除时激活该<code>GameplayAbility</code>.  </p><p><strong>Note:</strong> 当从蓝图中的Event激活<code>GameplayAbility</code>时, 你必须使用<code>ActivateAbilityFromEvent</code>节点, 并且标准的<code>ActivateAbility</code>节点不能出现在图表中, 如果<code>ActivateAbility</code>节点存在, 它就会一直被调用而不调用<code>ActivateAbilityFromEvent</code>节点.  </p><p><strong>Note:</strong> 不要忘记应该在<code>GameplayAbility</code>终止时调用<code>EndAbility()</code>, 除非你的<code>GameplayAbility</code>是像被动技能那样一直运行的<code>GameplayAbility</code>.  </p><p>对于<strong>客户端预测</strong><code>GameplayAbility</code>的激活序列:  </p><ol><li><strong>所属(Owning)客户端</strong>调用<code>TryActivateAbility()</code></li><li>调用<code>InternalTryActivateAbility()</code></li><li>调用<code>CanActivateAbility()</code>并返回是否满足<code>GameplayTag</code>需求, <code>ASC</code>是否满足技能花费, <code>GameplayAbility</code>是否不在冷却期和当前是否没有其他实例被激活</li><li>调用<code>CallServerTryActivateAbility()</code>并传入其生成的<code>Prediction Key</code></li><li>调用<code>CallActivateAbility()</code></li><li>调用<code>PreActivate()</code>, Epic称之为”boilerplate init stuff”</li><li>调用<code>ActivateAbility()</code>最终激活Ability</li></ol><p><strong>服务端</strong>接收到<code>CallServerTryActivateAbility()</code>  </p><ol><li>调用<code>ServerTryActivateAbility()</code></li><li>调用<code>InternalServerTryActivateAbility()</code></li><li>调用<code>InternalTryActivateAbility()</code></li><li>调用<code>CanActivateAbility()</code>并返回是否满足<code>GameplayTag</code>需求, <code>ASC</code>是否满足技能花费, <code>GameplayAbility</code>是否不在冷却期和当前是否没有其他实例被激活</li><li>如果成功则调用<code>ClientActivateAbilitySucceed()</code>告知客户端更新它的<code>ActivationInfo</code>(即该激活已由服务端确认)并广播<code>OnConfirmDelegate</code>代理. 这和输入确认(Input Confirmation)不一样.</li><li>调用<code>CallActivateAbility()</code></li><li>调用<code>PreActivate()</code>, Epic称之为”boilerplate init stuff”</li><li>调用<code>ActivateAbility()</code>最终激活Ability</li></ol><p>如果服务端在任意时刻激活失败, 就会调用<code>ClientActivateAbilityFailed()</code>, 立即终止客户端的<code>GameplayAbility</code>并撤销所有预测的修改.  </p><p><strong><a href="#table-of-contents">⬆ 返回目录</a></strong></p><p><span id="concepts-ga-activating-passive"></span></p><h4 id="4-6-4-1-被动Ability"><a href="#4-6-4-1-被动Ability" class="headerlink" title="4.6.4.1 被动Ability"></a>4.6.4.1 被动Ability</h4><p>为了实现自动激活和持续运行的被动<code>GameplayAbility</code>, 需要重写<code>UGameplayAbility::OnAvatarSet()</code>, 该函数在授予<code>GameplayAbility</code>并设置<code>AvatarActor</code>且调用<code>TryActivateAbility()</code>时自动调用.  </p><p>我建议添加一个<code>布尔值</code>到你的自定义<code>UGameplayAbility</code>类来表明其在授予时是否应该被激活. 样例项目中的被动护甲叠层Ability是这样做的.  </p><p>被动<code>GameplayAbility</code>一般有一个<code>仅服务器(Server Only)</code>的<a href="#concepts-ga-net">网络执行策略(Net Execution Policy)</a>.  </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">UGDGameplayAbility::OnAvatarSet</span><span class="params">(<span class="type">const</span> FGameplayAbilityActorInfo * ActorInfo, <span class="type">const</span> FGameplayAbilitySpec &amp; Spec)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Super::<span class="built_in">OnAvatarSet</span>(ActorInfo, Spec);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (ActivateAbilityOnGranted)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">bool</span> ActivatedAbility = ActorInfo-&gt;AbilitySystemComponent-&gt;<span class="built_in">TryActivateAbility</span>(Spec.Handle, <span class="literal">false</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Epic描述该函数为初始化被动Ability的正确位置和应该做一些类似<code>BeginPlay</code>的事情.  </p><p><strong><a href="#table-of-contents">⬆ 返回目录</a></strong></p><p><span id="concepts-ga-cancelabilities"></span></p><h3 id="4-6-5-取消Ability"><a href="#4-6-5-取消Ability" class="headerlink" title="4.6.5 取消Ability"></a>4.6.5 取消Ability</h3><p>为了从内部取消<code>GameplayAbility</code>, 可以调用<code>CancelAbility()</code>, 其会调用<code>EndAbility()</code>并设置它的<code>WasCancelled</code>参数为<code>true</code>.  </p><p>为了从外部取消<code>GameplayAbility</code>, <code>ASC</code>提供了一些函数:  </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** Cancels the specified ability CDO. */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">CancelAbility</span><span class="params">(UGameplayAbility* Ability)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Cancels the ability indicated by passed in spec handle. If handle is not found among reactivated abilities nothing happens. */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">CancelAbilityHandle</span><span class="params">(<span class="type">const</span> FGameplayAbilitySpecHandle&amp; AbilityHandle)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Cancel all abilities with the specified tags. Will not cancel the Ignore instance */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">CancelAbilities</span><span class="params">(<span class="type">const</span> FGameplayTagContainer* WithTags=<span class="literal">nullptr</span>, <span class="type">const</span> FGameplayTagContainer* WithoutTags=<span class="literal">nullptr</span>, UGameplayAbility* Ignore=<span class="literal">nullptr</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Cancels all abilities regardless of tags. Will not cancel the ignore instance */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">CancelAllAbilities</span><span class="params">(UGameplayAbility* Ignore=<span class="literal">nullptr</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Cancels all abilities and kills any remaining instanced abilities */</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">DestroyActiveState</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><p><strong>Note:</strong> 我发现如果存在一个<code>非实例(Non-Instanced)GameplayAbility</code>时, <code>CancelAllAbilities</code>似乎不能正常运行, 它似乎会命中这个<code>非实例(Non-Instanced)GameplayAbility</code>并放弃继续处理. <code>CancelAbility</code>可以更好地处理<code>非实例(Non-Instanced)GameplayAbility</code>, 样例项目就是这样使用的(跳跃是一个非实例(Non-Instanced)GameplayAbility), 因人而异.  </p><p><strong><a href="#table-of-contents">⬆ 返回目录</a></strong></p><p><span id="concepts-ga-definition-activeability"></span></p><h3 id="4-6-6-获取激活的Ability"><a href="#4-6-6-获取激活的Ability" class="headerlink" title="4.6.6 获取激活的Ability"></a>4.6.6 获取激活的Ability</h3><p>初学者经常会问”我怎样才能获取激活的Ability?”, 也许是用来设置变量或取消它. 多个<code>GameplayAbility</code>可以在同一时刻激活, 因此没有”一个激活的Ability”, 相反, 你必须搜索<code>ASC</code>的<code>ActivatableAbility</code>列表(<code>ASC</code>拥有的已授予<code>GameplayAbility</code>)并找到一个与你正在寻找的<a href="#concepts-ga-tags">资源或授予的GameplayTag</a>相匹配的Ability.  </p><p><code>UAbilitySystemComponent::GetActivatableAbilities()</code>会返回一个用于遍历的<code>TArray&lt;FGameplayAbilitySpec&gt;</code>.  </p><p><code>ASC</code>还有另一个有用的函数, 它将一个<code>GameplayTagContainer</code>作为参数来协助搜索, 而无需手动遍历<code>GameplayAbilitySpec</code>列表. <code>bOnlyAbilitiesThatSatisfyTagRequirements</code>参数只会返回那些<code>GameplayTag</code>满足需求且可以立刻激活的<code>GameplayAbilitySpecs</code>, 例如, 你可能有两个基本的攻击<code>GameplayAbility</code>, 一个使用武器, 另一个使用拳头, 正确的激活取决于武器是否装备并设置了<code>GameplayTag</code>需求. 详见Epic关于函数的注释.  </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">UAbilitySystemComponent::<span class="built_in">GetActivatableGameplayAbilitySpecsByAllMatchingTags</span>(<span class="type">const</span> FGameplayTagContainer&amp; GameplayTagContainer, TArray &lt; <span class="keyword">struct</span> FGameplayAbilitySpec* &gt;&amp; MatchingGameplayAbilities, <span class="type">bool</span> bOnlyAbilitiesThatSatisfyTagRequirements = <span class="literal">true</span>)</span><br></pre></td></tr></table></figure><p>一旦你获取到了寻找的<code>FGameplayAbilitySpec</code>, 那么就可以调用它的<code>IsActive()</code>.  </p><p><strong><a href="#table-of-contents">⬆ 返回目录</a></strong></p><p><span id="concepts-ga-instancing"></span></p><h3 id="4-6-7-实例化策略"><a href="#4-6-7-实例化策略" class="headerlink" title="4.6.7 实例化策略"></a>4.6.7 实例化策略</h3><p><code>GameplayAbility</code>的实例化策略决定了当<code>GameplayAbility</code>激活时是否和如何实例化.  </p><div class="table-container"><table><thead><tr><th style="text-align:center">实例化策略</th><th style="text-align:center">描述</th><th style="text-align:center">何时使用的例子</th></tr></thead><tbody><tr><td style="text-align:center">按Actor实例化(Instanced Per Actor)</td><td style="text-align:center">每个<code>ASC</code>只能有一个在激活之间复用的<code>GameplayAbility</code>实例.</td><td style="text-align:center">这可能是你使用最频繁的实例化策略. 你可以对任一<code>Ability</code>使用并在激活之间提供持久化. 设计者可以在激活之间手动重设任意变量.</td></tr><tr><td style="text-align:center">按操作实例化(Instanced Per Execution)</td><td style="text-align:center">每有一个<code>GameplayAbility</code>激活, 就有一个新的<code>GameplayAbility</code>实例创建.</td><td style="text-align:center">这些<code>GameplayAbility</code>的好处是每次激活时变量都会重置, 其性能要比<code>Instanced Per Actor</code>差, 因为每次激活时都会生成新的<code>GameplayAbility</code>. 样例项目没有使用该方式.</td></tr><tr><td style="text-align:center">非实例化(Non-Instanced)</td><td style="text-align:center"><code>GameplayAbility</code>操作其<code>ClassDefaultObject</code>, 没有实例创建.</td><td style="text-align:center">它是三种方式中性能最好的, 但是使用它是最受限制的. <code>非实例化(Non-Instanced)GameplayAbility</code>不能存储状态, 这意味着没有动态变量和不能绑定到<code>AbilityTask</code>委托. 使用它的最佳场景就是需要频繁使用的简单Ability, 像MOBA或RTS游戏中小兵的基础攻击. 样例项目中的跳跃<code>GameplayAbility</code>就是<code>非实例化(Non-Instanced)</code>的.</td></tr></tbody></table></div><p><strong><a href="#table-of-contents">⬆ 返回目录</a></strong></p><p><span id="concepts-ga-net"></span></p><h3 id="4-6-8-网络执行策略-Net-Execution-Policy"><a href="#4-6-8-网络执行策略-Net-Execution-Policy" class="headerlink" title="4.6.8 网络执行策略(Net Execution Policy)"></a>4.6.8 网络执行策略(Net Execution Policy)</h3><p><code>GameplayAbility</code>的<code>网络执行策略(Net Execution Policy)</code>决定了谁该以什么顺序运行该<code>GameplayAbility</code>.  </p><div class="table-container"><table><thead><tr><th style="text-align:center">网络执行策略(Net Execution Policy)</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center">Local Only</td><td style="text-align:center"><code>GameplayAbility</code>只运行在所属(Owning)客户端. 这对那些只需做本地视觉变化的Ability很有用. 单人游戏应该使用<code>Server Only</code>.</td></tr><tr><td style="text-align:center">Local Predicted</td><td style="text-align:center"><code>Local Predicted GameplayAbility</code>首先在所属(Owning)客户端激活, 之后在服务端激活. 服务端版本会纠正客户端预测的所有不正确的地方. 参见Prediction.</td></tr><tr><td style="text-align:center">Server Only</td><td style="text-align:center"><code>GameplayAbility</code>只运行在服务端. 被动<code>GameplayAbility</code>一般是<code>Server Only</code>. 单人游戏应该使用该项.</td></tr><tr><td style="text-align:center">Server Initiated</td><td style="text-align:center"><code>Server Initiated GameplayAbility</code>首先在服务端激活, 之后在所属(Owning)客户端激活. 我个人使用的不多(如果有的话).</td></tr></tbody></table></div><p><strong><a href="#table-of-contents">⬆ 返回目录</a></strong></p><p><span id="concepts-ga-tags"></span></p><h3 id="4-6-9-Ability标签"><a href="#4-6-9-Ability标签" class="headerlink" title="4.6.9 Ability标签"></a>4.6.9 Ability标签</h3><p><code>GameplayAbility</code>自带有内建逻辑的<code>GameplayTagContainer</code>. 这些<code>GameplayTag</code>都不进行同步.  </p><div class="table-container"><table><thead><tr><th style="text-align:center">GameplayTagContainer</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center">Ability Tags</td><td style="text-align:center"><code>GameplayAbility</code>拥有的<code>GameplayTag</code>, 这只是用来描述<code>GameplayAbility</code>的<code>GameplayTag</code>.</td></tr><tr><td style="text-align:center">Cancel Abilities with Tag</td><td style="text-align:center">当该<code>GameplayAbility</code>激活时, 其他<code>Ability Tags</code>中拥有这些<code>GameplayTag</code>的<code>GameplayAbility</code>将会被取消.</td></tr><tr><td style="text-align:center">Block Abilities with Tag</td><td style="text-align:center">当该<code>GameplayAbility</code>激活时, 其他<code>Ability Tags</code>中拥有这些<code>GameplayTag</code>的<code>GameplayAbility</code>将会阻塞激活.</td></tr><tr><td style="text-align:center">Activation Owned Tags</td><td style="text-align:center">当该<code>GameplayAbility</code>激活时, 这些<code>GameplayTag</code>会交给该<code>GameplayAbility</code>的拥有者.</td></tr><tr><td style="text-align:center">Activation Required Tags</td><td style="text-align:center">该<code>GameplayAbility</code>只有在其拥有者拥有所有这些<code>GameplayTag</code>时才会激活.</td></tr><tr><td style="text-align:center">Activation Blocked Tags</td><td style="text-align:center">该<code>GameplayAbility</code>在其拥有者拥有任意这些标签时不能被激活.</td></tr><tr><td style="text-align:center">Source Required Tags</td><td style="text-align:center">该<code>GameplayAbility</code>只有在<code>Source</code>拥有所有这些<code>GameplayTag</code>时才会激活. <code>Source GameplayTag</code>只有在该<code>GameplayAbility</code>由Event触发时设置.</td></tr><tr><td style="text-align:center">Source Blocked Tags</td><td style="text-align:center">该<code>GameplayAbility</code>在<code>Source</code>拥有任意这些标签时不能被激活. <code>Source GameplayTag</code>只有在该<code>GameplayAbility</code>由Event触发时设置.</td></tr><tr><td style="text-align:center">Target Required Tags</td><td style="text-align:center">该<code>GameplayAbility</code>只有在<code>Target</code>拥有所有这些<code>GameplayTag</code>时才会激活. <code>Target GameplayTag</code>只有在该<code>GameplayAbility</code>由Event触发时设置.</td></tr><tr><td style="text-align:center">Target Blocked Tags</td><td style="text-align:center">该<code>GameplayAbility</code>在<code>Target</code>拥有任意这些标签时不能被激活. <code>Target GameplayTag</code>只有在该<code>GameplayAbility</code>由Event触发时设置.</td></tr></tbody></table></div><p><strong><a href="#table-of-contents">⬆ 返回目录</a></strong></p><p><span id="concepts-ga-spec"></span></p><h3 id="4-6-10-Gameplay-Ability-Spec"><a href="#4-6-10-Gameplay-Ability-Spec" class="headerlink" title="4.6.10 Gameplay Ability Spec"></a>4.6.10 Gameplay Ability Spec</h3><p><code>GameplayAbilitySpec</code>会在<code>GameplayAbility</code>授予后存在于<code>ASC</code>中并定义可激活<code>GameplayAbility</code> - <code>GameplayAbility</code>类, 等级, 输入绑定和必须与<code>GameplayAbility</code>类分开保存的运行时状态.  </p><p>当<code>GameplayAbility</code>在服务端授予时, 服务端会同步<code>GameplayAbilitySpec</code>到所属(Owning)客户端, 因此可以激活它.  </p><p>激活<code>GameplayAbilitySpec</code>会根据它的<code>实例化策略(Instancing Policy)</code>创建一个<code>GameplayAbility</code>实例(<code>Non-Instanced GameplayAbility</code>除外).  </p><p><strong><a href="#table-of-contents">⬆ 返回目录</a></strong></p><p><span id="concepts-ga-data"></span></p><h3 id="4-6-11-传递数据到Ability"><a href="#4-6-11-传递数据到Ability" class="headerlink" title="4.6.11 传递数据到Ability"></a>4.6.11 传递数据到Ability</h3><p><code>GameplayAbility</code>的一般范式是<code>Activate-&gt;Generate Data-&gt;Apply-&gt;End</code>. 有时你需要调整现有数据, GAS提供了一些选项来获取外部数据到你的<code>GameplayAbility</code>.  </p><div class="table-container"><table><thead><tr><th style="text-align:center">方法</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center">通过Event激活<code>GameplayAbility</code></td><td style="text-align:center">使用含有数据负载(Payload)的Event激活<code>GameplayAbility</code>. 对于客户端预测的<code>GameplayAbility</code>, Event的负载(Payload)是由客户端同步到服务端的. 对于那些不适合任意现有变量的数据可以使用两个<code>Optional Object</code>或<a href="#concepts-targeting-data">TargetData</a>变量. 该方法的缺点是不能使用输入绑定激活Ability. 为了通过Event激活<code>GameplayAbility</code>, 该<code>GameplayAbility</code>必须设置其Trigger, 分配一个<code>GameplayTag</code>并选择一个<code>GameplayEvent</code>选项. 想要发送事件, 就得使用<code>UAbilitySystemBlueprintLibrary::SendGameplayEventToActor(AActor* Actor, FGameplayTag EventTag, FGameplayEventData Payload)</code>函数.</td></tr><tr><td style="text-align:center">使用<code>WaitGameplayEvent AbilityTask</code></td><td style="text-align:center">在<code>GameplayAbility</code>激活后, 使用<code>WaitGameplayEvent AbilityTask</code>来告知其监听带有负载(Payload)的事件. Event负载(Payload)及其发送过程与通过Event激活<code>GameplayAbility</code>是一样的. 该方法的缺点是Event不能通过<code>AbilityTask</code>同步且只能用于<code>Local Only</code>和<code>Server Only</code>的<code>GameplayAbility</code>. 你可以编写自己的<code>AbilityTask</code>以支持同步Event负载(Payload).</td></tr><tr><td style="text-align:center">使用<code>TargetData</code></td><td style="text-align:center">自定义<code>TargetData</code>结构体是一种在客户端和服务端之间传递任意数据的好方法.</td></tr><tr><td style="text-align:center">保存数据在<code>OwnerActor</code>或者<code>AvatarActor</code></td><td style="text-align:center">使用保存于<code>OwnerActor</code>, <code>AvatarActor</code>或者其他任意你可以获取到引用的对象中的可同步变量. 这种方法最灵活且可以用于由输入绑定激活的<code>GameplayAbility</code>, 然而, 它不能保证在使用时数据同步, 你必须提前做好准备 - 这意味着如果你设置了一个可同步的变量, 之后立即激活该<code>GameplayAbility</code>, 那么因为存在潜在的丢包情况, 不能保证接收者上发生的顺序.</td></tr></tbody></table></div><p><strong><a href="#table-of-contents">⬆ 返回目录</a></strong></p><p><span id="concepts-ga-commit"></span></p><h3 id="4-6-12-Ability花费-Cost-和冷却-Cooldown"><a href="#4-6-12-Ability花费-Cost-和冷却-Cooldown" class="headerlink" title="4.6.12 Ability花费(Cost)和冷却(Cooldown)"></a>4.6.12 Ability花费(Cost)和冷却(Cooldown)</h3><p><code>GameplayAbility</code>默认带有对可选Cost和Cooldown的功能. Cost是<code>ASC</code>为了激活使用<code>即刻(Instant)GameplayEffect</code>(<a href="#concepts-ge-cost">Cost GE</a>)实现的GameplayAbility所必须具有的预先定义的大量Attribute. Cooldown是用于阻止<code>GameplayAbility</code>再次激活(直到冷却完成)的计时器, 其由<code>持续(Duration)GameplayEffect</code>(<a href="#concepts-ge-cooldown">Cooldown GE</a>)实现.  </p><p>在<code>GameplayAbility</code>调用<code>UGameplayAbility::Activate()</code>之前, 其会调用<code>UGameplayAbility::CanActivateAbility()</code>, 该函数会检查所属<code>ASC</code>是否满足Cost(<code>UGameplayAbility::CheckCost()</code>)并确保该<code>GameplayAbility</code>不在冷却期(<code>UGameplayAbility::CheckCooldown()</code>).  </p><p>在<code>GameplayAbility</code>调用<code>Activate()</code>之后, 其可以选择性使用<code>UGameplayAbility::CommitAbility()</code>随时提交Cost和Cooldown, <code>UGameplayAbility::CommitAbility()</code>会调用<code>UGameplayAbility::CommitCost()</code>和<code>UGameplayAbility::CommitCooldown()</code>, 如果它们不需要同时提交, 设计师可以选择分别调用<code>CommitCost()</code>或<code>CommitCooldown()</code>. 提交Cost和Cooldown会多次调用<code>CheckCost()</code>和<code>CheckCooldown()</code>. 所属(Owning)<code>ASC</code>的Attribute在<code>GameplayAbility</code>激活后可能改变, 从而导致提交时无法满足Cost. 如果<a href="#concepts-p-key">prediction key</a>在提交时有效的话, 提交Cost和Cooldown是可以<a href="#concepts-p">客户端预测</a>的.  </p><p>详见<a href="#concepts-ge-cost">CostGE</a>和<a href="#concepts-ge-cooldown">CooldownGE</a>.  </p><p><strong><a href="#table-of-contents">⬆ 返回目录</a></strong></p><p><span id="concepts-ga-leveling"></span></p><h3 id="4-6-13-升级Ability"><a href="#4-6-13-升级Ability" class="headerlink" title="4.6.13 升级Ability"></a>4.6.13 升级Ability</h3><p>有两个常见的方法用于升级Ability:  </p><div class="table-container"><table><thead><tr><th style="text-align:center">升级方法</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center">升级时取消授予和重新授予</td><td style="text-align:center">自<code>ASC</code>取消授予(移除)<code>GameplayAbility</code>, 并在下一等级于服务端上重新授予. 如果此时<code>GameplayAbility</code>是激活的, 那么就会终止它.</td></tr><tr><td style="text-align:center">增加<code>GameplayAbilitySpec</code>的等级</td><td style="text-align:center">在服务端上找到<code>GameplayAbilitySpec</code>, 增加它的等级, 并将其标记为Dirty以同步到所属(Owning)客户端. 该方法不会在<code>GameplayAbility</code>激活时将其终止.</td></tr></tbody></table></div><p>两种方法的主要区别在于你是否想要在升级时取消激活的<code>GameplayAbility</code>. 基于你的<code>GameplayAbility</code>, 你很可能需要同时使用两种方法. 我建议在<code>UGameplayAbility</code>子类中增加一个布尔值以明确使用哪种方法.  </p><p><strong><a href="#table-of-contents">⬆ 返回目录</a></strong></p><p><span id="concepts-ga-sets"></span></p><h3 id="4-6-14-Ability集合"><a href="#4-6-14-Ability集合" class="headerlink" title="4.6.14 Ability集合"></a>4.6.14 Ability集合</h3><p><code>GameplayAbilitySet</code>是很方便的<code>UDataAsset</code>类, 其用于保存输入绑定和初始<code>GameplayAbility</code>列表, 该<code>GameplayAbility</code>列表用于拥有授予<code>GameplayAbility</code>逻辑的Character. 子类也可以包含额外的逻辑和属性. Paragon中的每个英雄都拥有一个<code>GameplayAbilitySet</code>以包含其授予的所有<code>GameplayAbility</code>.  </p><p><strong><a href="#table-of-contents">⬆ 返回目录</a></strong></p><p><span id="concepts-ga-batching"></span></p><h3 id="4-6-15-Ability批处理"><a href="#4-6-15-Ability批处理" class="headerlink" title="4.6.15 Ability批处理"></a>4.6.15 Ability批处理</h3><p>一般<code>GameplayAbility</code>的生命周期最少涉及2到3个自客户端到服务端的RPC.  </p><ol><li>CallServerTryActivateAbility()</li><li>ServerSetReplicatedTargetData() (可选)</li><li>ServerEndAbility()</li></ol><p>如果<code>GameplayAbility</code>在一帧同一原子(Atomic)组中执行这些操作, 我们就可以优化该工作流, 将所有2个或3个RPC批处理(整合)为1个RPC. <code>GAS</code>称这种RPC优化为<code>Ability批处理</code>. 常见的使用<code>Ability批处理</code>时机的例子是枪支命中判断. 枪支命中判断时, 会在一帧同一原子(Atomic)组中做射线检测, 发送<a href="#concepts-targeting-data">TargetData</a>到服务端并结束Ability. GASShooter样例项目对其枪支命中判断使用了该技术.  </p><p>半自动枪支是最好的案例, 其将<code>CallServerTryActivateAbility()</code>, <code>ServerSetReplicatedTargetData()</code>(子弹命中结果)和<code>ServerEndAbility()</code>批处理成一个而不是三个<code>RPC</code>.  </p><p>全自动/爆炸开火枪支会对第一发子弹将<code>CallServerTryActivateAbility()</code>和<code>ServerSetReplicatedTargetData()</code>批处理成一个而不是两个RPC, 接下来的每一发子弹都是它自己的<code>ServerSetReplicatedTargetData()</code>RPC, 最后, 当停止射击时, <code>ServerEndAbility()</code>会作为单独的RPC发送. 这是最坏的情况, 我们只保存了第一发子弹的一个RPC而不是两个. 这种情况也可以通过<a href="#concepts-ga-data">GameplayEvent</a>激活Ability来实现, 该<code>GameplayEvent</code>会自客户端向服务端发送带有<code>EventPayload</code>的子弹<code>TargetData</code>. 后者的缺点是<code>TargetData</code>必须在Ability外部生成, 尽管批处理方法在Ability内部生成<code>TargetData</code>.  </p><p>Ability批处理在<a href="#concepts-asc">ASC</a>中是默认禁止的. 为了启用Ability批处理, 需要重写<code>ShouldDoServerAbilityRPCBatch()</code>以返回true:  </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">bool</span> <span class="title">ShouldDoServerAbilityRPCBatch</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123; <span class="keyword">return</span> <span class="literal">true</span>; &#125;</span><br></pre></td></tr></table></figure><p>现在Ability批处理已经启用, 在激活你想使用批处理的Ability之前, 必须提前创建一个<code>FScopedServerAbilityRPCBatcher</code>结构体, 这个特殊的结构体会在其域内尝试批处理所有跟随它的Ability, 一旦出了<code>FScopedServerAbilityRPCBatcher</code>域, 所有已激活的Ability将不再尝试批处理. <code>FScopedServerAbilityRPCBatcher</code>通过在每个可以批处理的函数中设置特殊代码来运行, 其会拦截RPC的发送并将消息打包进一个批处理结构体, 当出了<code>FScopedServerAbilityRPCBatcher</code>后, 它会在<code>UAbilitySystemComponent::EndServerAbilityRPCBatch()</code>中自动将该批处理结构体RPC到服务端, 服务端在<code>UAbilitySystemComponent::ServerAbilityRPCBatch_Internal(FServerAbilityRPCBatch&amp; BatchInfo)</code>中接收该批处理结构体, <code>BatchInfo</code>参数会包含几个flag, 其包括该Ability是否应该结束, 激活时输入是否按下和是否包含<code>TargetData</code>. 这是个可以设置断点以确认批处理是否正确运行的好函数. 作为选择, 可以使用<code>AbilitySystem.ServerRPCBatching.Log 1</code>来启用特别的Ability批处理日志.  </p><p>这个方法只能在C++中完成, 并且只能通过<code>FGameplayAbilitySpecHandle</code>来激活Ability.  </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">UGSAbilitySystemComponent::BatchRPCTryActivateAbility</span><span class="params">(FGameplayAbilitySpecHandle InAbilityHandle, <span class="type">bool</span> EndAbilityImmediately)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">bool</span> AbilityActivated = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">if</span> (InAbilityHandle.<span class="built_in">IsValid</span>())</span><br><span class="line">&#123;</span><br><span class="line"><span class="function">FScopedServerAbilityRPCBatcher <span class="title">GSAbilityRPCBatcher</span><span class="params">(<span class="keyword">this</span>, InAbilityHandle)</span></span>;</span><br><span class="line">AbilityActivated = <span class="built_in">TryActivateAbility</span>(InAbilityHandle, <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (EndAbilityImmediately)</span><br><span class="line">&#123;</span><br><span class="line">FGameplayAbilitySpec* AbilitySpec = <span class="built_in">FindAbilitySpecFromHandle</span>(InAbilityHandle);</span><br><span class="line"><span class="keyword">if</span> (AbilitySpec)</span><br><span class="line">&#123;</span><br><span class="line">UGSGameplayAbility* GSAbility = <span class="built_in">Cast</span>&lt;UGSGameplayAbility&gt;(AbilitySpec-&gt;<span class="built_in">GetPrimaryInstance</span>());</span><br><span class="line">GSAbility-&gt;<span class="built_in">ExternalEndAbility</span>();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> AbilityActivated;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> AbilityActivated;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>GASShooter对半自动和全自动枪支使用了相同的批处理<code>GameplayAbility</code>, 并没有直接调用<code>EndAbility()</code>(它通过一个只能由客户端调用的Ability在该Ability外处理, 该只能由客户端调用的Ability用于管理玩家输入和基于当前开火模式对批处理Ability的调用). 因为所有的RPC必须在<code>FScopedServerAbilityRPCBatcher</code>域中, 所以我提供了<code>EndAbilityImmediately</code>参数以使仅客户端的控制/管理可以明确该Ability是否可以批处理<code>EndAbility()</code>(半自动)或不批处理<code>EndAbility()</code>(全自动)以及之后<code>EndAbility()</code>是否可以在其自己的RPC中调用.  </p><p>GASShooter暴露了一个蓝图节点以允许上文提到的仅客户端调用的Ability所使用的批处理Ability来触发批处理Ability. (译者注: 此处相当拗口, 但原文翻译确实如此, 配合项目浏览也许会更容易明白些.)  </p><p><img src="https://pic1.imgdb.cn/item/67a4c705d0e0a243d4fc53e8.png" alt="Activate Batched Ability">  </p><p><strong><a href="#table-of-contents">⬆ 返回目录</a></strong></p><p><span id="concepts-ga-netsecuritypolicy"></span></p><h3 id="4-6-16-网络安全策略-Net-Security-Policy"><a href="#4-6-16-网络安全策略-Net-Security-Policy" class="headerlink" title="4.6.16 网络安全策略(Net Security Policy)"></a>4.6.16 网络安全策略(Net Security Policy)</h3><p><code>GameplayAbility</code>的网络安全策略决定了Ability应该在网络的何处执行. 它为尝试执行限制Ability的客户端提供了保护.  </p><div class="table-container"><table><thead><tr><th style="text-align:center">网络安全策略</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center">ClientOrServer</td><td style="text-align:center">没有安全需求. 客户端或服务端可以自由地触发该Ability的执行和终止.</td></tr><tr><td style="text-align:center">ServerOnlyExecution</td><td style="text-align:center">客户端对该Ability请求的执行会被服务端忽略, 但客户端仍可以请求服务端取消或结束该Ability.</td></tr><tr><td style="text-align:center">ServerOnlyTermination</td><td style="text-align:center">客户端对该Ability请求的取消或结束会被服务端忽略, 但客户端仍可以请求执行该Ability.</td></tr><tr><td style="text-align:center">ServerOnly</td><td style="text-align:center">服务端控制该Ability的执行和终止, 客户端的任何请求都会被忽略.</td></tr></tbody></table></div><p><span id="concepts-at"></span></p><h2 id="4-7-Ability-Tasks"><a href="#4-7-Ability-Tasks" class="headerlink" title="4.7 Ability Tasks"></a>4.7 Ability Tasks</h2><p><span id="concepts-at-definition"></span></p><h3 id="4-7-1-AbilityTask定义"><a href="#4-7-1-AbilityTask定义" class="headerlink" title="4.7.1 AbilityTask定义"></a>4.7.1 AbilityTask定义</h3><p><code>GameplayAbility</code>只能在一帧中执行, 这本身并不能提供太多灵活性, 为了实现随时间推移而触发或响应一段时间后触发的委托操作, 我们需要使用<code>AbilityTask</code>.  </p><p>GAS自带很多<code>AbilityTask</code>:  </p><ul><li>使用<code>RootMotionSource</code>移动Character的Task</li><li>播放动画蒙太奇的Task</li><li>响应<code>Attribute</code>变化的Task</li><li>响应<code>GameplayEffect</code>变化的Task</li><li>响应玩家输入的Task</li><li>更多</li></ul><p><code>UAbilityTask</code>的构造函数中强制硬编码允许最多1000个同时运行的<code>AbilityTask</code>, 当设计那些同时拥有数百个Character的游戏(像RTS)的<code>GameplayAbility</code>时要注意这一点.  </p><p><strong><a href="#table-of-contents">⬆ 返回目录</a></strong></p><p><span id="concepts-at-custom"></span></p><h3 id="4-7-2-自定义AbilityTask"><a href="#4-7-2-自定义AbilityTask" class="headerlink" title="4.7.2 自定义AbilityTask"></a>4.7.2 自定义AbilityTask</h3><p>通常你需要创建自己的自定义<code>AbilityTask</code>(C++中). 样例项目带有两个自定义<code>AbilityTask</code>:  </p><ol><li><code>PlayMontageAndWaitForEvent</code>是默认<code>PlayMontageAndWait</code>和<code>WaitGameplayEvent</code>AbilityTask的结合体, 其允许动画蒙太奇自<code>AnimNotify</code>发送GameplayEvent回到启动它的<code>GameplayAbility</code>, 可以使用该Task在动画蒙太奇的某个特定时刻来触发操作.</li><li><code>WaitReceiveDamage</code>可以监听<code>OwnerActor</code>接收伤害. 当英雄接收到一个伤害实例时, 被动护甲层<code>GameplayAbility</code>就会移除一层护甲.  </li></ol><p><code>AbilityTask</code>的组成:  </p><ul><li>创建新的<code>AbilityTask</code>实例的静态函数</li><li>当<code>AbilityTask</code>完成目的时分发的委托(Delegate)</li><li>进行主要工作的<code>Activate()</code>函数, 绑定到外部的委托等等</li><li>进行清理工作的<code>OnDestroy()</code>函数, 包括其绑定到外部的委托</li><li>所有绑定到外部委托的回调函数</li><li>成员变量和所有内部辅助函数</li></ul><p><strong>Note:</strong> <code>AbilityTask</code>只能声明一种类型的输出委托, 所有的输出委托都必须是该种类型, 不管它们是否使用参数. 对于未使用的委托参数会传递默认值.  </p><p><code>AbilityTask</code>只能运行在那些运行所属<code>GameplayAbility</code>的客户端或服务端, 然而, 可以通过设置<code>bSimulatedTask = true</code>使<code>AbilityTask</code>运行在Simulated Client上, 在<code>AbilityTask</code>的构造函数中, 重写<code>virtual void InitSimulatedTask(UGameplayTasksComponent&amp; InGameplayTasksComponent);</code>并将所有成员变量设置为同步的, 这只在极少的情况下有用, 比如在移动<code>AbilityTask</code>中, 不想同步每次移动变化, 但是又需要模拟整个移动<code>AbilityTask</code>, 所有的<code>RootMotionSource AbilityTask</code>都是这样做的, 查看<code>AbilityTask_MoveToLocation.h/.cpp</code>以作为参考范例.  </p><p>如果你在<code>AbilityTask</code>的构造函数中设置了<code>bTickingTask = true;</code>并重写了<code>virtual void TickTask(float DeltaTime);</code>, <code>AbilityTask</code>就可以使用<code>Tick</code>, 这在你需要根据帧率平滑线性插值的时候很有用. 查看<code>AbilityTask_MoveToLocation.h/.cpp</code>以作为参考范例.  </p><p><strong><a href="#table-of-contents">⬆ 返回目录</a></strong></p><p><span id="concepts-at-using"></span></p><h3 id="4-7-3-使用AbilityTask"><a href="#4-7-3-使用AbilityTask" class="headerlink" title="4.7.3 使用AbilityTask"></a>4.7.3 使用AbilityTask</h3><p>在C++中创建并激活<code>AbilityTask</code>(GDGA_FireGun.cpp):  </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">UGDAT_PlayMontageAndWaitForEvent* Task = UGDAT_PlayMontageAndWaitForEvent::<span class="built_in">PlayMontageAndWaitForEvent</span>(<span class="keyword">this</span>, NAME_None, MontageToPlay, <span class="built_in">FGameplayTagContainer</span>(), <span class="number">1.0f</span>, NAME_None, <span class="literal">false</span>, <span class="number">1.0f</span>);</span><br><span class="line">Task-&gt;OnBlendOut.<span class="built_in">AddDynamic</span>(<span class="keyword">this</span>, &amp;UGDGA_FireGun::OnCompleted);</span><br><span class="line">Task-&gt;OnCompleted.<span class="built_in">AddDynamic</span>(<span class="keyword">this</span>, &amp;UGDGA_FireGun::OnCompleted);</span><br><span class="line">Task-&gt;OnInterrupted.<span class="built_in">AddDynamic</span>(<span class="keyword">this</span>, &amp;UGDGA_FireGun::OnCancelled);</span><br><span class="line">Task-&gt;OnCancelled.<span class="built_in">AddDynamic</span>(<span class="keyword">this</span>, &amp;UGDGA_FireGun::OnCancelled);</span><br><span class="line">Task-&gt;EventReceived.<span class="built_in">AddDynamic</span>(<span class="keyword">this</span>, &amp;UGDGA_FireGun::EventReceived);</span><br><span class="line">Task-&gt;<span class="built_in">ReadyForActivation</span>();</span><br></pre></td></tr></table></figure><p>在蓝图中, 我们只需使用为<code>AbilityTask</code>创建的蓝图节点, 不必调用<code>ReadyForActivate()</code>, 其由<code>Engine/Source/Editor/GameplayTasksEditor/Private/K2Node_LatentGameplayTaskCall.cpp</code>自动调用. <code>K2Node_LatentGameplayTaskCall</code>也会自动调用<code>BeginSpawningActor()</code>和<code>FinishSpawningActor()</code>(如果它们存在于你的<code>AbilityTask</code>类中, 查看<code>AbilityTask_WaitTargetData</code>), 再强调一遍, <code>K2Node_LatentGameplayTaskCall</code>只会对蓝图做这些自动操作, 在C++中, 我们必须手动调用<code>ReadyForActivation()</code>, <code>BeginSpawningActor()</code>和<code>FinishSpawningActor()</code>.  </p><p><img src="https://pic1.imgdb.cn/item/67a4c72dd0e0a243d4fc53fc.png" alt="Blueprint WaitTargetData AbilityTask">  </p><p>如果想要手动取消<code>AbilityTask</code>, 只需在蓝图(Async Task Proxy)或C++中对<code>AbilityTask</code>对象调用<code>EndTask()</code>.  </p><p><strong><a href="#table-of-contents">⬆ 返回目录</a></strong></p><p><span id="concepts-at-rms"></span></p><h3 id="4-7-4-Root-Motion-Source-Ability-Task"><a href="#4-7-4-Root-Motion-Source-Ability-Task" class="headerlink" title="4.7.4 Root Motion Source Ability Task"></a>4.7.4 Root Motion Source Ability Task</h3><p>GAS自带的<code>AbilityTask</code>可以使用挂载在<code>CharacterMovementComponent</code>中的<code>Root Motion Source</code>随时间推移而移动<code>Character</code>, 像击退, 复杂跳跃, 吸引和猛冲.  </p><p><strong>Note:</strong> <code>RootMotionSource AbilityTask</code>预测支持的引擎版本是4.19和4.25+, 该预测在引擎版本4.20-4.24中存在bug, 然而, <code>AbilityTask</code>仍然可以使用较小的网络修正在多人游戏中执行功能, 并且在单人游戏中完美运行. 可以将4.25中对预测的修复自定义到4.20~4.24引擎中.  </p><p><strong><a href="#table-of-contents">⬆ 返回目录</a></strong></p><p><span id="concepts-gc"></span></p><h2 id="4-8-Gameplay-Cues"><a href="#4-8-Gameplay-Cues" class="headerlink" title="4.8 Gameplay Cues"></a>4.8 Gameplay Cues</h2><p><span id="concepts-gc-definition"></span></p><h3 id="4-8-1-GameplayCue定义"><a href="#4-8-1-GameplayCue定义" class="headerlink" title="4.8.1 GameplayCue定义"></a>4.8.1 GameplayCue定义</h3><p><code>GameplayCue(GC)</code>执行非游戏逻辑相关的功能, 像音效, 粒子效果, 镜头抖动等等. <code>GameplayCue</code>一般是可同步(除非在客户端明确<code>执行(Executed)</code>, <code>添加(Added)</code>和<code>移除(Removed)</code>)和可预测的.  </p><p>我们可以在<code>ASC</code>中通过发送一个<strong>强制带有”GameplayCue”父名</strong>的相应<code>GameplayTag</code>和<code>GameplayCueManager</code>的事件类型(Execute, Add或Remove)来触发<code>GameplayCue</code>. <code>GameplayCueNotify</code>对象和其他实现<code>IGameplayCueInterface</code>的<code>Actor</code>可以基于<code>GameplayCue</code>的<code>GameplayTag(GameplayCueTag)</code>来订阅(Subscribe)这些事件.  </p><p><strong>Note:</strong> 再次强调, <code>GameplayCue</code>的<code>GameplayTag</code>需要以<code>GameplayCue</code>为开头, 举例来说, 一个有效的<code>GameplayCue</code>的<code>GameplayTag</code>可能是<code>GameplayCue.A.B.C</code>.  </p><p>有两个<code>GameplayCueNotify</code>类, <code>Static</code>和<code>Actor</code>. 它们各自响应不同的事件, 并且不同的<code>GameplayEffect</code>类型可以触发它们. 根据你的逻辑重写相关的事件.  </p><div class="table-container"><table><thead><tr><th style="text-align:center">GameplayCue类</th><th style="text-align:center">事件</th><th style="text-align:center">GameplayEffect类型</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center"><a href="https://docs.unrealengine.com/en-US/API/Plugins/GameplayAbilities/UGameplayCueNotify_Static/index.html">GameplayCueNotify_Static</a></td><td style="text-align:center">Execute</td><td style="text-align:center">Instant或Periodic</td><td style="text-align:center"><code>Static GameplayCueNotify</code>直接操作<code>ClassDefaultObject</code>(意味着没有实例)并且对于一次性效果(像击打伤害)是极好的.</td></tr><tr><td style="text-align:center"><a href="https://docs.unrealengine.com/en-US/BlueprintAPI/GameplayCueNotify/index.html">GameplayCueNotify_Actor</a></td><td style="text-align:center">Add或Remove</td><td style="text-align:center">Duration或Infinite</td><td style="text-align:center"><code>Actor GameplayCueNotify</code>会在添加(Added)时生成一个新的实例, 因为其是实例化的, 所以可以随时间推移执行操作直到被移除(Removed). 这对循环的声音和粒子效果是很好的, 其会在<code>持续(Duration)</code>或<code>无限(Infinite)</code>GameplayEffect被移除或手动调用移除时移除. 其也自带选项来管理允许同时添加(Added)多少个, 因此多个相同效果的应用只启用一次声音或粒子效果.</td></tr></tbody></table></div><p><code>GameplayCueNotify</code>技术上可以响应任何事件, 但是这是我们一般使用它的方式.  </p><p><strong>Note:</strong> 当使用<code>GameplayCueNotify_Actor</code>时, 要勾选<code>Auto Destroy on Remove</code>, 否则之后对<code>GameplayCueTag</code>的<code>添加(Add)</code>调用将无法进行.  </p><p>当使用除<code>Full</code>之外的<code>ASC</code><a href="#concepts-asc-rm">同步模式</a>时, <code>Add</code>和<code>Remove</code>GC事件会在服务端玩家中触发两次(Listen Server) - 一次是应用<code>GE</code>, 再一次是从”Minimal”<code>NetMultiCast</code>到客户端. 然而, <code>WhileActive</code>事件仍会触发一次. 所有的事件在客户端中只触发一次.  </p><p>样例项目包含了一个<code>GameplayCueNotify_Actor</code>用于眩晕和奔跑效果. 其还含有一个<code>GameplayCueNotify_Static</code>用于枪支弹药伤害. 这些<code>GC</code>可以通过<a href="#concepts-gc-local">客户端触发</a>来进行优化, 而不是通过<code>GE</code>同步. 我选择了在样例项目中展示使用它们的基本方法.  </p><p><strong><a href="#table-of-contents">⬆ 返回目录</a></strong></p><p><span id="concepts-gc-trigger"></span></p><h3 id="4-8-2-触发GameplayCue"><a href="#4-8-2-触发GameplayCue" class="headerlink" title="4.8.2 触发GameplayCue"></a>4.8.2 触发GameplayCue</h3><h4 id="GameplayEffect"><a href="#GameplayEffect" class="headerlink" title="GameplayEffect"></a>GameplayEffect</h4><p>在成功应用(未被Tag或Immunity阻塞)的<code>GameplayEffect</code>中填写所有应该触发的<code>GameplayCue</code>的<code>GameplayTag</code>.  </p><p><img src="https://pic1.imgdb.cn/item/67a4c754d0e0a243d4fc5405.png" alt="GameplayCue Triggered from a GameplayEffect">  </p><h4 id="手动调用"><a href="#手动调用" class="headerlink" title="手动调用"></a>手动调用</h4><p><code>UGameplayAbility</code>提供了蓝图节点来<code>Execute</code>, <code>Add</code>或<code>Remove</code> GameplayCue.  </p><p><img src="https://pic1.imgdb.cn/item/67a4c76fd0e0a243d4fc5407.png" alt="GameplayCue Triggered from a GameplayAbility">  </p><p>在C++中, 你可以在<code>ASC</code>中直接调用函数(或者在你的<code>ASC</code>子类中暴露它们到蓝图):  </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** GameplayCues can also come on their own. These take an optional effect context to pass through hit result, etc */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ExecuteGameplayCue</span><span class="params">(<span class="type">const</span> FGameplayTag GameplayCueTag, FGameplayEffectContextHandle EffectContext = FGameplayEffectContextHandle())</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ExecuteGameplayCue</span><span class="params">(<span class="type">const</span> FGameplayTag GameplayCueTag, <span class="type">const</span> FGameplayCueParameters&amp; GameplayCueParameters)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Add a persistent gameplay cue */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">AddGameplayCue</span><span class="params">(<span class="type">const</span> FGameplayTag GameplayCueTag, FGameplayEffectContextHandle EffectContext = FGameplayEffectContextHandle())</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">AddGameplayCue</span><span class="params">(<span class="type">const</span> FGameplayTag GameplayCueTag, <span class="type">const</span> FGameplayCueParameters&amp; GameplayCueParameters)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Remove a persistent gameplay cue */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">RemoveGameplayCue</span><span class="params">(<span class="type">const</span> FGameplayTag GameplayCueTag)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Removes any GameplayCue added on its own, i.e. not as part of a GameplayEffect. */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">RemoveAllGameplayCues</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><p><strong><a href="#table-of-contents">⬆ 返回目录</a></strong></p><p><span id="concepts-gc-local"></span></p><h3 id="4-8-3-客户端GameplayCue"><a href="#4-8-3-客户端GameplayCue" class="headerlink" title="4.8.3 客户端GameplayCue"></a>4.8.3 客户端GameplayCue</h3><p>从<code>GameplayAbility</code>和<code>ASC</code>中暴露的用于触发<code>GameplayCue</code>的函数默认是可同步的. 每个<code>GameplayCue</code>事件都是一个多播(Multicast)RPC. 这会导致大量RPC. GAS也强制在每次网络更新中最多能有两个相同的<code>GameplayCue</code>RPC. 我们可以通过使用客户端<code>GameplayCue</code>来避免这个问题. 客户端<code>GameplayCue</code>只能在单独的客户端上<code>Execute</code>, <code>Add</code>或<code>Remove</code>.  </p><p>可以使用客户端<code>GameplayCue</code>的场景:  </p><ul><li>抛射物伤害</li><li>近战碰撞伤害</li><li>动画蒙太奇触发的<code>GameplayCue</code></li></ul><p>你应该添加到<code>ASC</code>子类中的客户端<code>GameplayCue</code>函数:  </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">UFUNCTION</span>(BlueprintCallable, Category = <span class="string">&quot;GameplayCue&quot;</span>, Meta = (AutoCreateRefTerm = <span class="string">&quot;GameplayCueParameters&quot;</span>, GameplayTagFilter = <span class="string">&quot;GameplayCue&quot;</span>))</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ExecuteGameplayCueLocal</span><span class="params">(<span class="type">const</span> FGameplayTag GameplayCueTag, <span class="type">const</span> FGameplayCueParameters&amp; GameplayCueParameters)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">UFUNCTION</span>(BlueprintCallable, Category = <span class="string">&quot;GameplayCue&quot;</span>, Meta = (AutoCreateRefTerm = <span class="string">&quot;GameplayCueParameters&quot;</span>, GameplayTagFilter = <span class="string">&quot;GameplayCue&quot;</span>))</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">AddGameplayCueLocal</span><span class="params">(<span class="type">const</span> FGameplayTag GameplayCueTag, <span class="type">const</span> FGameplayCueParameters&amp; GameplayCueParameters)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">UFUNCTION</span>(BlueprintCallable, Category = <span class="string">&quot;GameplayCue&quot;</span>, Meta = (AutoCreateRefTerm = <span class="string">&quot;GameplayCueParameters&quot;</span>, GameplayTagFilter = <span class="string">&quot;GameplayCue&quot;</span>))</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">RemoveGameplayCueLocal</span><span class="params">(<span class="type">const</span> FGameplayTag GameplayCueTag, <span class="type">const</span> FGameplayCueParameters&amp; GameplayCueParameters)</span></span>;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">UPAAbilitySystemComponent::ExecuteGameplayCueLocal</span><span class="params">(<span class="type">const</span> FGameplayTag GameplayCueTag, <span class="type">const</span> FGameplayCueParameters &amp; GameplayCueParameters)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">UAbilitySystemGlobals::<span class="built_in">Get</span>().<span class="built_in">GetGameplayCueManager</span>()-&gt;<span class="built_in">HandleGameplayCue</span>(<span class="built_in">GetOwner</span>(), GameplayCueTag, EGameplayCueEvent::Type::Executed, GameplayCueParameters);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">UPAAbilitySystemComponent::AddGameplayCueLocal</span><span class="params">(<span class="type">const</span> FGameplayTag GameplayCueTag, <span class="type">const</span> FGameplayCueParameters &amp; GameplayCueParameters)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">UAbilitySystemGlobals::<span class="built_in">Get</span>().<span class="built_in">GetGameplayCueManager</span>()-&gt;<span class="built_in">HandleGameplayCue</span>(<span class="built_in">GetOwner</span>(), GameplayCueTag, EGameplayCueEvent::Type::OnActive, GameplayCueParameters);</span><br><span class="line">UAbilitySystemGlobals::<span class="built_in">Get</span>().<span class="built_in">GetGameplayCueManager</span>()-&gt;<span class="built_in">HandleGameplayCue</span>(<span class="built_in">GetOwner</span>(), GameplayCueTag, EGameplayCueEvent::Type::WhileActive, GameplayCueParameters);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">UPAAbilitySystemComponent::RemoveGameplayCueLocal</span><span class="params">(<span class="type">const</span> FGameplayTag GameplayCueTag, <span class="type">const</span> FGameplayCueParameters &amp; GameplayCueParameters)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">UAbilitySystemGlobals::<span class="built_in">Get</span>().<span class="built_in">GetGameplayCueManager</span>()-&gt;<span class="built_in">HandleGameplayCue</span>(<span class="built_in">GetOwner</span>(), GameplayCueTag, EGameplayCueEvent::Type::Removed, GameplayCueParameters);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果某个<code>GameplayCue</code>是客户端添加的, 那么它也应该自客户端移除. 如果它是通过同步添加的, 那么它也应该通过同步移除.  </p><p><strong><a href="#table-of-contents">⬆ 返回目录</a></strong></p><p><span id="concepts-gc-parameters"></span></p><h3 id="4-8-4-GameplayCue参数"><a href="#4-8-4-GameplayCue参数" class="headerlink" title="4.8.4 GameplayCue参数"></a>4.8.4 GameplayCue参数</h3><p><code>GameplayCue</code>接受一个包含额外<code>GameplayCue</code>信息的<code>FGameplayCueParameters</code>结构体作为参数. 如果你在<code>GameplayAbility</code>或<code>ASC</code>中使用函数手动触发<code>GameplayCue</code>, 那么就必须手动填充传递给<code>GameplayCue</code>的<code>GameplayCueParameters</code>结构体. 如果<code>GameplayCue</code>由<code>GameplayEffect</code>触发, 那么下列的变量会自动填充到<code>FGameplayCueParameters</code>结构体中:  </p><ul><li>AggregatedSourceTags</li><li>AggregatedTargetTags</li><li>GameplayEffectLevel</li><li>AbilityLevel</li><li><a href="#concepts-ge-context">EffectContext</a></li><li>Magnitude(如果<code>GameplayEffect</code>具有在<code>GameplayCue</code>标签容器(TagContainer)上方的下拉列表中选择的<code>Magnitude Attribute</code>和影响该<code>Attribute</code>的相应<code>Modifier</code>)</li></ul><p>当手动触发<code>GameplayCue</code>时, <code>GameplayCueParameters</code>中的<code>SourceObject</code>变量似乎是一个传递任意数据到<code>GameplayCue</code>的好地方.  </p><p><strong>Note:</strong> 参数结构体中的某些变量, 像<code>Instigator</code>, 可能已经存在于<code>EffectContext</code>中. <code>EffectContext</code>也可以包含<code>FHitResult</code>用于存储<code>GameplayCue</code>在世界中生成的位置. 子类化<code>EffectContext</code>似乎是一个传递更多数据到<code>GameplayCue</code>的好方法, 特别是对于那些由<code>GameplayEffect</code>触发的<code>GameplayCue</code>.  </p><p>查看<a href="#concepts-asg">UAbilitySystemGlobals</a>中用于填充<code>GameplayCueParameters</code>结构体的三个函数以获得更多信息. 它们是虚函数, 因此你可以重写它们以自动填充更多信息.  </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** Initialize GameplayCue Parameters */</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">InitGameplayCueParameters</span><span class="params">(FGameplayCueParameters&amp; CueParameters, <span class="type">const</span> FGameplayEffectSpecForRPC &amp;Spec)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">InitGameplayCueParameters_GESpec</span><span class="params">(FGameplayCueParameters&amp; CueParameters, <span class="type">const</span> FGameplayEffectSpec &amp;Spec)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">InitGameplayCueParameters</span><span class="params">(FGameplayCueParameters&amp; CueParameters, <span class="type">const</span> FGameplayEffectContextHandle&amp; EffectContext)</span></span>;</span><br></pre></td></tr></table></figure><p><strong><a href="#table-of-contents">⬆ 返回目录</a></strong></p><p><span id="concepts-gc-manager"></span></p><h3 id="4-8-5-Gameplay-Cue-Manager"><a href="#4-8-5-Gameplay-Cue-Manager" class="headerlink" title="4.8.5 Gameplay Cue Manager"></a>4.8.5 Gameplay Cue Manager</h3><p>默认情况下, 游戏开始时<code>GameplayCueManager</code>会扫描游戏的全部目录以寻找<code>GameplayCueNotify</code>并将其加载进内存. 我们可以设置<code>DefaultGame.ini</code>来修改<code>GameplayCueManager</code>的扫描路径.  </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[/Script/GameplayAbilities.AbilitySystemGlobals]</span><br><span class="line">GameplayCueNotifyPaths=<span class="string">&quot;/Game/GASDocumentation/Characters&quot;</span></span><br></pre></td></tr></table></figure><p>我们确实想要<code>GameplayCueManager</code>扫描并找到所有的<code>GameplayCueNotify</code>, 然而, 我们不想要它异步加载每一个, 因为这会将每个<code>GameplayCueNotify</code>和它们所引用的音效和粒子特效放入内存而不管它们是否在关卡中使用. 在像Paragon这样的大型游戏中, 内存中会放入数百兆的无用资源并造成卡顿和启动时无响应.  </p><p>在启动时异步加载每个<code>GameplayCue</code>的一种可选方法是只异步加载那些会在游戏中触发的<code>GameplayCue</code>, 这会在异步加载每个<code>GameplayCue</code>时减少不必要的内存占用和潜在的游戏无响应几率, 从而避免特定<code>GameplayCue</code>在游戏中第一次触发时可能出现的延迟效果. SSD不存在这种潜在的延迟, 我还没有在HDD上测试过, 如果在UE编辑器中使用该选项并且编辑器需要编译粒子系统的话, 就可能会在GameplayCue首次加载时有轻微的卡顿或无响应, 这在构建版本中不是问题, 因为粒子系统肯定是编译好的.  </p><p>首先我们必须继承<code>UGameplayCueManager</code>并告知<code>AbilitySystemGlobals</code>类在<code>DefaultGame.ini</code>中使用我们的<code>UGameplayCueManager</code>子类.  </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[/Script/GameplayAbilities.AbilitySystemGlobals]</span><br><span class="line">GlobalGameplayCueManagerClass=<span class="string">&quot;/Script/ParagonAssets.PBGameplayCueManager&quot;</span></span><br></pre></td></tr></table></figure><p>在我们的<code>UGameplayCueManager</code>子类中, 重写<code>ShouldAsyncLoadRuntimeObjectLibraries()</code>.  </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">bool</span> <span class="title">ShouldAsyncLoadRuntimeObjectLibraries</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">override</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong><a href="#table-of-contents">⬆ 返回目录</a></strong></p><p><span id="concepts-gc-prevention"></span></p><h3 id="4-8-6-阻止GameplayCue响应"><a href="#4-8-6-阻止GameplayCue响应" class="headerlink" title="4.8.6 阻止GameplayCue响应"></a>4.8.6 阻止GameplayCue响应</h3><p>有时我们不想响应<code>GameplayCue</code>, 例如我们阻止了一次攻击, 可能就不想播放附加在伤害<code>GameplayEffect</code>上的击打效果或者自定义的效果. 我们可以在<a href="#concepts-ge-ec">GameplayEffectExecutionCalculations</a>中调用<code>OutExecutionOutput.MarkGameplayCuesHandledManually()</code>, 之后手动发送我们的<code>GameplayCue</code>事件到<code>Target</code>或<code>Source</code>的<code>ASC</code>中.  </p><p>如果你想某个特别指定<code>ASC</code>中的<code>GameplayCue</code>永不触发, 可以设置<code>AbilitySystemComponent-&gt;bSuppressGameplayCues = true;</code>.  </p><p><strong><a href="#table-of-contents">⬆ 返回目录</a></strong></p><p><span id="concepts-gc-batching"></span></p><h3 id="4-8-7-GameplayCue批处理"><a href="#4-8-7-GameplayCue批处理" class="headerlink" title="4.8.7 GameplayCue批处理"></a>4.8.7 GameplayCue批处理</h3><p>每次<code>GameplayCue</code>触发都是一次不可靠的多播(NetMulticast)RPC. 在同一时刻触发多个<code>GameplayCue</code>的情况下, 有一些优化方法来将它们压缩成一个RPC或者通过发送更少的数据来节省带宽.  </p><p><strong><a href="#table-of-contents">⬆ 返回目录</a></strong></p><p><span id="concepts-gc-batching-manualrpc"></span></p><h4 id="4-8-7-1-手动RPC"><a href="#4-8-7-1-手动RPC" class="headerlink" title="4.8.7.1 手动RPC"></a>4.8.7.1 手动RPC</h4><p>假设你有一个可以发射8枚弹丸的霰弹枪, 就会有8个轨迹和碰撞<code>GameplayCue</code>. GASShooter采用将它们联合成一个RPC的延迟(Lazy)方法, 其将所有的轨迹信息保存到<a href="#concepts-ge-ec">EffectContext</a>作为<a href="#concepts-targeting-data">TargetData</a>. 尽管其将RPC数量从8降为1, 然而还是在这一个RPC中通过网络发送大量数据(~500 bytes). 一个进一步优化的方法是使用一个自定义结构体发送RPC, 在该自定义RPC中你需要高效编码命中位置(Hit Location)或者给一个随机种子以在接收端重现/近似计算碰撞位置, 客户端之后需要解包该自定义结构体并重现<a href="#concepts-gc-local">客户端执行的<code>GameplayCue</code></a>.  </p><p>运行机制:  </p><ol><li>声明一个<code>FScopedGameplayCueSendContext</code>. 其会阻塞<code>UGameplayCueManager::FlushPendingCues()</code>直到其出域, 意味着所有<code>GameplayCue</code>都将会排队等候直到该<code>FScopedGameplayCueSendContext</code>出域.</li><li>重写<code>UGameplayCueManager::FlushPendingCues()</code>以将那些可以基于一些自定义<code>GameplayTag</code>批处理的<code>GameplayCue</code>合并进自定义的结构体并将其RPC到客户端.</li><li>客户端接收自定义结构体并将其解包进客户端执行的<code>GameplayCue</code>.</li></ol><p>该方法也可以在你的<code>GameplayCue</code>需要特别指定的参数时使用, 这些需要特别指定的参数不能由<code>GameplayCueParameter</code>提供, 并且你不想将它们添加到<code>EffectContext</code>, 像伤害数值, 暴击标识, 破盾标识, 处决标识等等.  </p><p><a href="https://forums.unrealengine.com/development-discussion/c-gameplay-programming/1711546-fscopedgameplaycuesendcontext-gameplaycuemanager">https://forums.unrealengine.com/development-discussion/c-gameplay-programming/1711546-fscopedgameplaycuesendcontext-gameplaycuemanager</a>  </p><p><strong><a href="#table-of-contents">⬆ 返回目录</a></strong></p><p><span id="concepts-gc-batching-gcsonge"></span></p><h4 id="4-8-7-2-GameplayEffect中的多个GameplayCue"><a href="#4-8-7-2-GameplayEffect中的多个GameplayCue" class="headerlink" title="4.8.7.2 GameplayEffect中的多个GameplayCue"></a>4.8.7.2 GameplayEffect中的多个GameplayCue</h4><p>一个<code>GameplayEffect</code>中的所有<code>GameplayCue</code>已经由一个RPC发送了. 默认情况下, <code>UGameplayCueManager::InvokeGameplayCueAddedAndWhileActive_FromSpec()</code>会在不可靠的多播(NetMulticast)RPC中发送整个<code>GameplayEffectSpec</code>(除了转换为<code>FGameplayEffectSpecForRPC</code>)而不管<code>ASC</code>的同步模式, 取决于<code>GameplayEffectSpec</code>的内容, 这可能会使用大量带宽, 我们可以通过设置<code>AbilitySystem.AlwaysConvertGESpecToGCParams 1</code>来将其优化, 这会将<code>GameplayEffectSpec</code>转换为<code>FGameplayCueParameter</code>结构体并且RPC它而不是整个<code>FGameplayEffectSpecForRPC</code>, 这会节省带宽但是只有较少的信息, 取决于<code>GESpec</code>如何转换为<code>GameplayCueParameters</code>和你的<code>GameplayCue</code>需要知道什么.  </p><p><strong><a href="#table-of-contents">⬆ 返回目录</a></strong></p><p><span id="concepts-asg"></span></p><h2 id="4-9-Ability-System-Globals"><a href="#4-9-Ability-System-Globals" class="headerlink" title="4.9 Ability System Globals"></a>4.9 Ability System Globals</h2><p><a href="https://docs.unrealengine.com/en-US/API/Plugins/GameplayAbilities/UAbilitySystemGlobals/index.html">AbilitySystemGlobals</a>类保存有关GAS的全局信息. 大多数变量可以在<code>DefaultGame.ini</code>中设置. 一般你不需要和该类互动, 但是应该知道它的存在. 如果你需要继承像<a href="#concepts-gc-manager">GameplayCueManager</a>或<a href="#concepts-ge-context">GameplayEffectContext</a>这样的对象, 就必须通过<code>AbilitySystemGlobals</code>来做.  </p><p>想要继承<code>AbilitySystemGlobals</code>, 需要在<code>DefaultGame.ini</code>中设置类名:  </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[/Script/GameplayAbilities.AbilitySystemGlobals]</span><br><span class="line">AbilitySystemGlobalsClassName=<span class="string">&quot;/Script/ParagonAssets.PAAbilitySystemGlobals&quot;</span></span><br></pre></td></tr></table></figure><p><strong><a href="#table-of-contents">⬆ 返回目录</a></strong></p><p><span id="concepts-asg-initglobaldata"></span></p><h3 id="4-9-1-InitGlobalData"><a href="#4-9-1-InitGlobalData" class="headerlink" title="4.9.1 InitGlobalData()"></a>4.9.1 InitGlobalData()</h3><p>从UE 4.24开始, 必须调用<code>UAbilitySystemGlobals::InitGlobalData()</code>来使用<a href="#concepts-targeting-data">TargetData</a>, 否则你会遇到关于<code>ScriptStructCache</code>的错误, 并且客户端会从服务端断开连接, 该函数只需要在项目中调用一次. Fortnite从AssetManager类的起始加载函数中调用该函数, Paragon是从UEngine::Init()中调用的. 我发现将其放到<code>UEngineSubsystem::Initialize()</code>是个好位置, 这也是样例项目中使用的. 我觉得你应该复制这段模板代码到你自己的项目中以避免出现<code>TargetData</code>的使用问题.  </p><p>如果你在使用<code>AbilitySystemGlobals GlobalAttributeSetDefaultsTableNames</code>时发生崩溃, 可能之后需要像Fortnite一样在<code>AssetManager</code>或<code>GameInstance</code>中调用<code>UAbilitySystemGlobals::InitGlobalData()</code>而不是在<code>UEngineSubsystem::Initialize()</code>中. 该崩溃可能是由于<code>Subsystem</code>的加载顺序引发的, <code>GlobalAttributeDefaultsTables</code>需要加载<code>EditorSubsystem</code>来绑定<code>UAbilitySystemGlobals::InitGlobalData()</code>中的委托.  </p><p><strong><a href="#table-of-contents">⬆ 返回目录</a></strong></p><p><span id="concepts-p"></span></p><h2 id="4-10-预测-Prediction"><a href="#4-10-预测-Prediction" class="headerlink" title="4.10 预测(Prediction)"></a>4.10 预测(Prediction)</h2><p>GAS带有开箱即用的客户端预测功能, 然而, 它不能预测所有. GAS中客户端预测的意思是客户端无需等待服务端的许可而激活<code>GameplayAbility</code>和应用<code>GameplayEffect</code>. 它可以”预测”许可其可以这样做的服务端和其应用<code>GameplayEffect</code>的目标. 服务端在客户端激活之后运行<code>GameplayAbility</code>(网络延迟)并告知客户端它的预测是否正确, 如果客户端的预测出错, 那么它就会”回滚”其”错误预测”的修改以匹配服务端.  </p><p>GAS相关预测的最佳源码是插件源码中的<code>GameplayPrediction.h</code>.  </p><p>Epic的理念是只能预测”不受伤害(get away with)”的事情. 例如, Paragon和Fortnite不能预测伤害值, 它们很可能对伤害值使用了<a href="#concepts-ge-ec">ExecutionCalculations</a>, 而这无论如何是不能预测的. 这并不是说你不能试着预测像伤害值这样的事情, 无论如何, 如果你这样做了并且效果很好, 那就是极好的.  </p><blockquote><p>… we are also not all in on a “predict everything: seamlessly and automatically” solution. We still feel player prediction is best kept to a minimum (meaning: predict the minimum amount of stuff you can get away with).</p></blockquote><p><em>来自Epic的Dave Ratti在新的<a href="#concepts-p-npp">网络预测插件</a>中的注释.</em>  </p><p><strong>什么是可预测的:</strong>  </p><ul><li>Ability激活</li><li>触发事件</li><li>GameplayEffect应用<ul><li>Attribute修改(例外: 执行(Execution)目前无法预测, 只能是Attribute Modifiy)</li><li>GameplayTag修改</li></ul></li><li>GameplayCue事件(可预测GameplayEffect中的和它们自己)</li><li>蒙太奇</li><li>移动(内建在UE4 UCharacterMovement中)</li></ul><p><strong>什么是不可预测的:</strong>  </p><ul><li>GameplayEffect移除</li><li>GameplayEffect周期效果(dots ticking)</li></ul><p><em>源自<code>GameplayPrediction.h</code></em>  </p><p>尽管我们可以预测<code>GameplayEffect</code>的应用, 但是不能预测<code>GameplayEffect</code>的移除. 绕过这条限制的一个方法是当想要移除<code>GameplayEffect</code>时, 可以预测性地执行相反的效果, 假设我们要降低40%移动速度, 可以通过应用增加40%移动速度的buff来预测性地将其移除, 之后同时移除这两个<code>GameplayEffect</code>. 这并不是对每个场景都适用, 因此仍然需要对预测性地移除<code>GameplayEffect</code>的支持. 来自Epic的Dave Ratti已经表达过在<a href="https://epicgames.ent.box.com/s/m1egifkxv3he3u3xezb9hzbgroxyhx89">GAS的迭代版本中</a>增加它的期望.  </p><p>因为我们不能预测<code>GameplayEffect</code>的移除, 所以就不能完全预测<code>GameplayAbility</code>的冷却时间, 并且也没有相反的<code>GameplayEffect</code>这种变通方案可供使用. 服务端同步的<code>Cooldown GE</code>将会存于客户端上, 并且任何对其绕过的尝试(例如使用<code>Minimal</code>同步模式)都会被服务端拒绝. 这意味着高延迟的客户端会花费较长事件来告知服务端开始冷却和接收到服务端<code>Cooldown GE</code>的移除. 这意味着高延迟的玩家会比低延迟的玩家有更低的触发率, 从而劣势于低延迟玩家. Fortnite通过使用自定义Bookkeeping而不是<code>Cooldown GE</code>的方法避免了该问题.  </p><p>关于预测伤害值, 我个人不建议使用, 尽管它是大多数刚接触GAS的人最先做的事情之一, 我特别不建议尝试预测死亡, 虽然你可以预测伤害值, 但是这样做很棘手. 如果你错误预测地应用了伤害, 那么玩家将会看到敌人的生命值会跳动, 如果你尝试预测死亡, 那么这将会是特别尴尬和令人沮丧的, 假设你错误预测了某个<code>Character</code>的死亡, 那么它就会开启布娃娃模拟, 只有当服务端纠正后才会停止布娃娃模拟并继续向你射击.</p><p><strong>Note:</strong> 修改<code>Attribute</code>的<code>即刻(Instant)GameplayEffect</code>(像<code>Cost GE</code>)在你自身可以无缝预测, 预测修改其他Character的<code>即刻(Instant)Attribute</code>会显示短暂的异常或者<code>Attribute</code>中的暂时性问题. 预测的<code>即刻(Instant)GameplayEffect</code>实际上被视为<code>无限(Infinite)GameplayEffect</code>, 因此如果错误预测的话还可以回滚. 当服务端的<code>GameplayEffect</code>被应用时, 其实是存在两个相同的<code>GameplayEffect</code>的, 会在短时间内造成<code>Modifier</code>应用两次或者不应用, 其最终会纠正自身, 但是有时候这个异常现象对玩家来说是显著的.  </p><p>GAS的预测实现尝试解决的问题:  </p><blockquote><ol><li>“我能这样做吗?”(Can I do this?) 预测的基本协议.</li><li>“撤销”(Undo) 当预测错误时如何消除其副作用.</li><li>“重现”(Redo) 如何避免已经在客户端预测但还是从服务端同步的重播副作用.</li><li>“完整”(Completeness) 如何确认我们真的预测了所有副作用.</li><li>“依赖”(Dependencies) 如何管理依赖预测和预测事件链.</li><li>“重写”(Override) 如何预测地重写由服务端同步/拥有的状态.</li></ol></blockquote><p>源自<code>GameplayPrediction.h</code>  </p><p><strong><a href="#table-of-contents">⬆ 返回目录</a></strong></p><p><span id="concepts-p-key"></span></p><h3 id="4-10-1-Prediction-Key"><a href="#4-10-1-Prediction-Key" class="headerlink" title="4.10.1 Prediction Key"></a>4.10.1 Prediction Key</h3><p>GAS的预测建立在<code>Prediction Key</code>的概念上, 其是一个由客户端激活<code>GameplayAbility</code>时生成的整型标识符.  </p><ul><li>客户端激活<code>GameplayAbility</code>时生成<code>Prediction Key</code>, 这是<code>Activation Prediction Key</code>.  </li><li>客户端使用<code>CallServerTryActivateAbility()</code>将该<code>Prediction Key</code>发送到服务端.</li><li>客户端在<code>Prediction Key</code>有效时将其添加到应用的所有<code>GameplayEffect</code>.</li><li>客户端的<code>Prediction Key</code>出域. 之后该<code>GameplayAbility</code>中的预测效果(Effect)需要一个新的<a href="#concepts-p-windows">Scoped Prediction Window</a>.</li><li>服务端从客户端接收<code>Prediction Key</code>.</li><li>服务端将<code>Prediction Key</code>添加到其应用的所有<code>GameplayEffect</code>.</li><li>服务端同步该<code>Prediction Key</code>回客户端.</li><li>客户端使用<code>Prediction Key</code>从服务端接收同步的<code>GameplayEffect</code>, 该<code>Prediction Key</code>用于应用<code>GameplayEffect</code>. 如果任何同步的<code>GameplayEffect</code>与客户端使用相同<code>Prediction Key</code>应用的<code>GameplayEffect</code>相匹配, 那么其就是正确预测的. 目标上暂时会有<code>GameplayEffect</code>的两份拷贝直到客户端移除它预测的那一个.</li><li>客户端从服务端上接收回<code>Prediction Key</code>, 这是同步的<code>Prediction Key</code>, 该<code>Prediction Key</code>现在被标记为陈旧(Stale).</li><li>客户端移除所有由同步的陈旧(Stale)<code>Prediction Key</code>创建的<code>GameplayEffect</code>. 由服务端同步的<code>GameplayEffect</code>会持续存在. 任何客户端添加的和没有从服务端接收到一个匹配的同步版本的都被视为错误预测.</li></ul><p>在源于<code>Activation Prediction Key</code>激活的<code>GameplayAbility</code>中的一个<code>instruction &quot;window&quot;</code>原子(Atomic)组期间, <code>Prediction Key</code>是保证有效的, 你可以理解为<code>Prediction Key</code>只在一帧期间是有效的. 任何潜在行为<code>AbilityTask</code>的回调函数将不再拥有一个有效的<code>Prediction Key</code>, 除非该<code>AbilityTask</code>有内建的可以生成新<a href="#concepts-p-windows">Scoped Prediction Window</a>的同步点(Sync Point).  </p><p><strong><a href="#table-of-contents">⬆ 返回目录</a></strong></p><p><span id="concepts-p-windows"></span></p><h3 id="4-10-2-在Ability中创建新的预测窗口-Prediction-Window"><a href="#4-10-2-在Ability中创建新的预测窗口-Prediction-Window" class="headerlink" title="4.10.2 在Ability中创建新的预测窗口(Prediction Window)"></a>4.10.2 在Ability中创建新的预测窗口(Prediction Window)</h3><p>为了在<code>AbilityTask</code>的回调函数中预测更多的行为, 我们需要使用新的<code>Scoped Prediction Key</code>创建<code>Scoped Prediction Window</code>, 有时这被视为客户端和服务端间的同步点(Sync Point). 一些<code>AbilityTask</code>, 像所有输入相关的<code>AbilityTask</code>, 带有创建新<code>Scoped Prediction Window</code>的内建功能, 意味着<code>AbilityTask</code>回调函数中的原子(Atomic)代码有一个有效的<code>Scoped Prediction Key</code>可供使用. 像<code>WaitDelay</code>的其他Task没有创建新<code>Scoped Prediction Window</code>以用于回调函数的内建代码, 如果你需要在<code>WaitDelay</code>这样的<code>AbilityTask</code>后预测行为, 就必须使用<code>OnlyServerWait</code>选项的<code>WaitNetSync AbilityTask</code>手动来做, 当客户端触发<code>OnlyServerWait</code>选项的<code>WaitNetSync</code>时, 它会生成一个新的基于<code>GameplayAbility</code>的<code>Activation Prediction Key</code>的<code>Scoped Prediction Key</code>, RPC其到服务端, 并将其添加到所有新应用的<code>GameplayEffect</code>. 当服务端触发<code>OnlyServerWait</code>选项的<code>WaitNetSync</code>时, 它会在继续前等待直到接收到客户端新的<code>Scoped Prediction Key</code>, 该<code>Scoped Prediction Key</code>会执行和<code>Activation Prediction Key</code>同样的操作 —— 应用到<code>GameplayEffect</code>并同步回客户端标记为陈旧(Stale). <code>Scoped Prediction Key</code>直到出域前都有效, 也就表示<code>Scoped Prediction Window</code>已经关闭了. 所以只有原子(Atomic)操作, nothing latent, 可以使用新的<code>Scoped Prediction Key</code>.  </p><p>你可以根据需求创建任意数量的<code>Scoped Prediction Window</code>.  </p><p>如果你想添加同步点(Sync Point)功能到自己的自定义<code>AbilityTask</code>, 请查看那些输入<code>AbilityTask</code>是如何从根本上注入<code>WaitNetSync AbilityTask</code>代码到自身的.  </p><p><strong>Note:</strong> 当使用<code>WaitNetSync</code>时, 会阻塞服务端<code>GameplayAbility</code>继续执行直到其接收到客户端的消息. 这可能会被破解游戏的恶意用户滥用以故意延迟发送新的<code>Scoped Prediction Key</code>, 尽管Epic很少使用<code>WaitNetSync</code>, 但如果你对此担忧的话, 其建议创建一个带有延迟的新<code>AbilityTask</code>, 它会自动继续运行而无需等待客户端消息.  </p><p>样例项目在奔跑<code>GameplayAbility</code>中使用了<code>WaitNetSync</code>以在每次应用耐力花费时创建新的<code>Scoped Prediction Window</code>, 这样我们就可以进行预测. 理想上当应用花费和冷却时间时我们就想要一个有效的<code>Prediction Key</code>.  </p><p>如果你有一个在所属(Owning)客户端执行两次的预测<code>GameplayEffect</code>, 那么你的<code>Prediction Key</code>就是陈旧(Stall)的, 并且正在经历”redo”问题. 你通常可以在应用<code>GameplayEffect</code>之前将<code>OnlyServerWait</code>选项的<code>WaitNetSync AbilityTask</code>放到正确的位置以创建新的<code>Scoped Prediction Key</code>来解决这个问题.  </p><p><strong><a href="#table-of-contents">⬆ 返回目录</a></strong></p><p><span id="concepts-p-spawn"></span></p><h3 id="4-10-3-预测性地生成Actor"><a href="#4-10-3-预测性地生成Actor" class="headerlink" title="4.10.3 预测性地生成Actor"></a>4.10.3 预测性地生成Actor</h3><p>在客户端预测性地生成Actor是一项高级技术. GAS对此没有提供开箱即用的功能(<code>SpawnActor AbilityTask</code>只在服务端生成Actor). 其关键是在客户端和服务端都生成同步的Actor.  </p><p>如果Actor只是用于场景装饰或者不服务于任何游戏逻辑, 简单的解决方案就是重写Actor的<code>IsNetRelevantFor()</code>函数以限制服务端同步到所属(Owning)客户端, 所属(Owning)客户端会拥有其本地生成的版本, 而服务端和其他客户端会拥有服务端同步的版本.  </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">APAReplicatedActorExceptOwner::IsNetRelevantFor</span><span class="params">(<span class="type">const</span> AActor * RealViewer, <span class="type">const</span> AActor * ViewTarget, <span class="type">const</span> FVector &amp; SrcLocation)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> !<span class="built_in">IsOwnedBy</span>(ViewTarget);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果生成的Actor影响了游戏逻辑, 像投掷物就需要预测伤害值, 那么你需要本文档范围之外的高级知识, 在Epic Games的Github上查看UnrealTournament是如何生成投掷物的, 它有一个只在所属(Owning)客户端生成且与服务端同步的投掷物.  </p><p><strong><a href="#table-of-contents">⬆ 返回目录</a></strong></p><p><span id="concepts-p-future"></span></p><h3 id="4-10-4-GAS中预测的未来"><a href="#4-10-4-GAS中预测的未来" class="headerlink" title="4.10.4 GAS中预测的未来"></a>4.10.4 GAS中预测的未来</h3><p><code>GameplayPrediction.h</code>说明了在未来可能会增加预测<code>GameplayEffect</code>移除和周期<code>GameplayEffect</code>的功能.  </p><p>来自Epic的Dave Ratti已经<a href="https://epicgames.ent.box.com/s/m1egifkxv3he3u3xezb9hzbgroxyhx89">表达过对其修复的兴趣</a>, 包括预测冷却时间时的延迟问题和高延迟玩家对低延迟玩家的劣势.  </p><p>来自Epic之手的新<a href="#concepts-p-npp">网络预测插件(Network Prediction plugin)</a>期望能与GAS充分交互, 就像在次之前的<code>CharacterMovementComponent</code>.  </p><p><strong><a href="#table-of-contents">⬆ 返回目录</a></strong></p><p><span id="concepts-p-npp"></span></p><h3 id="4-10-5-网络预测插件-Network-Prediction-plugin"><a href="#4-10-5-网络预测插件-Network-Prediction-plugin" class="headerlink" title="4.10.5 网络预测插件(Network Prediction plugin)"></a>4.10.5 网络预测插件(Network Prediction plugin)</h3><p>Epic最近发起了一项倡议, 将使用新的网络预测插件替换<code>CharacterMovementComponent</code>, 该插件仍处于起步阶段, 但是在Unreal Engine Github上已经可以访问了, 现在说未来哪个引擎版本将首次搭载其试验版还为时尚早.  </p><p><strong><a href="#table-of-contents">⬆ 返回目录</a></strong></p><p><span id="concepts-targeting"></span></p><h2 id="4-11-Targeting"><a href="#4-11-Targeting" class="headerlink" title="4.11 Targeting"></a>4.11 Targeting</h2><p><span id="concepts-targeting-data"></span></p><h3 id="4-11-1-Target-Data"><a href="#4-11-1-Target-Data" class="headerlink" title="4.11.1 Target Data"></a>4.11.1 Target Data</h3><p><a href="https://docs.unrealengine.com/en-US/API/Plugins/GameplayAbilities/Abilities/FGameplayAbilityTargetData/index.html">FGameplayAbilityTargetData</a>是用于通过网络传输定位数据的通用结构体. <code>TargetData</code>一般用于保存AActor/UObject引用, FHitResult和其他通用的Location/Direction/Origin信息. 然而, 本质上你可以继承它以增添想要的任何数据, 其可以简单理解为在<a href="#concepts-ga-data">客户端和服务端的<code>GameplayAbility</code>中传递数据</a>. 基础结构体<code>FGameplayAbilityTargetData</code>不能直接使用, 而是要继承它. GAS的<code>GameplayAbilityTargetTypes.h</code>中有一些开箱即用的派生<code>FGameplayAbilityTargetData</code>结构体.  </p><p><code>TargetData</code>一般由<a href="#concepts-targeting-actors">Target Actor</a>或者手动创建, 供<a href="#concepts-at">AbilityTask</a>使用, 或者<a href="#concepts-ge">GameplayEffect</a>通过<a href="#concepts-ge-context">EffectContext</a>使用. 因为其位于<code>EffectContext</code>中, 所以<a href="#concepts-ge-ec">Execution</a>, <a href="#concepts-ge-mmc">MMC</a>, <a href="#concepts-gc">GameplayCue</a>和<a href="#concepts-as">AttributeSet</a>的后端函数可以访问该<code>TargetData</code>.  </p><p>我们一般不直接传递<code>FGameplayAbilityTargetData</code>而是使用<a href="https://docs.unrealengine.com/en-US/API/Plugins/GameplayAbilities/Abilities/FGameplayAbilityTargetDataHandle/index.html">FGameplayAbilityTargetDataHandle</a>, 其包含一个<code>FGameplayAbilityTargetData</code>指针类型的TArray, 这个中间结构体可以为<code>TargetData</code>的多态性提供支持.  </p><p><strong><a href="#table-of-contents">⬆ 返回目录</a></strong></p><p><span id="concepts-targeting-actors"></span></p><h3 id="4-11-2-Target-Actor"><a href="#4-11-2-Target-Actor" class="headerlink" title="4.11.2 Target Actor"></a>4.11.2 Target Actor</h3><p><code>GameplayAbility</code>使用<code>WaitTargetData AbilityTask</code>生成<a href="https://docs.unrealengine.com/en-US/API/Plugins/GameplayAbilities/Abilities/AGameplayAbilityTargetActor/index.html">TargetActor</a>以在世界中可视化和获取定位信息. <code>TargetActor</code>可以选择使用<a href="#concepts-targeting-reticles">GameplayAbilityWorldReticles</a>显示当前目标. 经确认后, 定位信息将作为<a href="#concepts-targeting-data">TargetData</a>返回, 之后其可以传递给<code>GameplayEffect</code>.  </p><p><code>TargetActor</code>是基于<code>AActor</code>的, 因此它可以使用任意种类的可视组件来表示其在何处和如何定位的, 例如静态网格物(Static Mesh)和贴花(Decal). 静态网格物(Static Mesh)可以用来可视化角色将要建造的物体, 贴花(Decal)可以用来表现地面上的效果区域. 样例项目使用带有地面贴花的<a href="https://docs.unrealengine.com/en-US/API/Plugins/GameplayAbilities/Abilities/AGameplayAbilityTargetActor_Grou-/index.html">AGameplayAbilityTargetActor_GroundTrace</a>表示陨石技能的伤害区域效果. 它也可以什么都不显示, 例如, GASShooter中的枪支命中判断, 要对目标的射线检测显示些什么就是没有意义的.  </p><p>其使用基本的射线或者Overlap捕获定位信息, 并根据<code>TargetActor</code>的实现将<code>FHitResult</code>或<code>AActor</code>数组转换为<code>TargetData</code>. <code>WaitTargetData AbilityTask</code>通过<code>TEnumAsByte&lt;EGameplayTargetingConfirmation::Type&gt; ConfirmationType</code>参数决定目标何时被确认, 当不使用<code>TEnumAsByte&lt;EGameplayTargetingConfirmation::Type::Instant</code>时, <code>TargetActor</code>一般就在<code>Tick()</code>中执行射线/Overlap, 并根据它的实现来更新位置信息到<code>FHitResult</code>. 尽管是在<code>Tick()</code>中执行的射线/Overlap, 但是一般不用担心, 因为它是不同步的并且一般没有多个(尽管存在多个)<code>TargetActor</code>同时运行, 只是要留意它使用的是<code>Tick()</code>, 一些复杂的<code>TargetActor</code>可能会在其中做很多事情, 就像GASShooter中火箭筒的二技能. 当<code>Tick()</code>中的检测对客户端响应非常频繁时, 如果性能影响很大的话, 你可能就要考虑降低<code>TargetActor</code>的Tick频率. 对于<code>TEnumAsByte&lt;EGameplayTargetingConfirmation::Type::Instant</code>, <code>TargetActor</code>会立即生成, 产生<code>TargetData</code>, 然后销毁, 并且从不会调用<code>Tick()</code>.  </p><div class="table-container"><table><thead><tr><th style="text-align:center">EGameplayTargetingConfirmation::Type</th><th style="text-align:center">何时确认Target</th></tr></thead><tbody><tr><td style="text-align:center">Instant</td><td style="text-align:center">该定位无需特殊逻辑即可立即进行, 或者用户输入决定何时开始.</td></tr><tr><td style="text-align:center">UserConfirmed</td><td style="text-align:center">当<a href="#concepts-ga-input">Ability绑定到<code>Confirm</code>输入</a>且用户确认或调用<code>UAbilitySystemComponent::TargetConfirm()</code>时触发该定位. <code>TargetActor</code>也会响应绑定的<code>Cancel</code>输入或者调用<code>UAbilitySystemComponent::TargetCancel()</code>来取消定位.</td></tr><tr><td style="text-align:center">Custom</td><td style="text-align:center">GameplayTargeting Ability负责调用<code>UGameplayAbility::ConfirmTaskByInstanceName()</code>来决定何时准备好定位数据. <code>TargetActor</code>也可以响应<code>UGameplayAbility::CancelTaskByInstanceName()</code>来取消定位.</td></tr><tr><td style="text-align:center">CustomMulti</td><td style="text-align:center">GameplayTargeting Ability负责调用<code>UGameplayAbility::ConfirmTaskByInstanceName()</code>来决定何时准备好定位数据. <code>TargetActor</code>也可以响应<code>UGameplayAbility::CancelTaskByInstanceName()</code>来取消定位. 不应在数据生成后就结束AbilityTask, 因为其允许多次确认.</td></tr></tbody></table></div><p>并不是所有的<code>TargetActor</code>都支持每个<code>EGameplayTargetingConfirmation::Type</code>, 例如, <code>AGameplayAbilityTargetActor_GroundTrace</code>就不支持<code>Instant</code>确认.  </p><p><code>WaitTargetData AbilityTask</code>将一个<code>AGameplayAbilityTargetActor</code>类作为参数, 其会在每次<code>AbilityTask</code>激活时生成一个实例并且在<code>AbilityTask</code>结束时销毁该<code>TargetActor</code>. <code>WaitTargetDataUsingActor AbilityTask</code>接受一个已经生成的<code>TargetActor</code>, 但是在该<code>AbilityTask</code>结束时仍会销毁它. 这两种<code>AbilityTask</code>都是低效的, 因为它们在每次使用时都要生成或需要一个新生成的<code>TargetActor</code>, 它们用于原型开发是很好的, 但是在实际发布版本中, 如果有持续产生<code>TargetData</code>的场景, 像全自动开火, 你可能就要探索优化它的办法. GASShooter有一个自定义的<a href="https://github.com/tranek/GASShooter/blob/master/Source/GASShooter/Public/Characters/Abilities/GSGATA_Trace.h">AGameplayAbilityTargetActor</a>子类和一个完全重写的<a href="https://github.com/tranek/GASShooter/blob/master/Source/GASShooter/Public/Characters/Abilities/AbilityTasks/GSAT_WaitTargetDataUsingActor.h">WaitTargetDataWithReusableActor AbilityTask</a>, 其允许你复用<code>TargetActor</code>而无需将其销毁.  </p><p><code>TargetActor</code>默认是不可同步的. 然而, 如果在你的游戏中向其他玩家展示本地玩家正在定位的目标是有意义的, 那么它也可以被设计成可同步的, <code>WaitTargetData AbilityTask</code>也确实包含其通过RPC和服务端通信的默认功能. 如果<code>TargetActor</code>的<code>ShouldProduceTargetDataOnServer</code>属性设置为false, 那么客户端就会在确认时通过<code>UAbilityTask_WaitTargetData::OnTargetDataReadyCallback()</code>中的<code>CallServerSetReplicatedTargetData()</code>RPC它的<code>TargetData</code>到服务端. 如果<code>ShouldProduceTargetDataOnServer</code>为true, 那么客户端就会发送一个通用确认事件, <code>EAbilityGenericReplicatedEvent::GenericConfirm</code>, 在<code>UAbilityTask_WaitTargetData::OnTargetDataReadyCallback()</code>中RPC到服务端, 服务端在接收到RPC时就会执行射线或者Overlap检测以生成数据. 如果客户端取消该定位, 它会发送一个通用取消事件, <code>EAbilityGenericReplicatedEvent::GenericCancel</code>, 在<code>UAbilityTask_WaitTargetData::OnTargetDataCancelledCallback</code>中RPC到服务端. 你可以看到, 在<code>TargetActor</code>和<code>WaitTargetData AbilityTask</code>中存在大量委托, <code>TargetActor</code>响应输入来产生广播<code>TargetData</code>的准备, 确认或者取消委托, <code>WaitTargetData</code>监听<code>TargetActor</code>的<code>TargetData</code>的准备, 确认和取消委托, 并将该信息转发回<code>GameplayAbility</code>和服务端. 如果是向服务端发送<code>TargetData</code>, 为了防止作弊, 可能需要在服务端做校验以保证该<code>TargetData</code>是合理的. 直接在服务端上产生<code>TargetData</code>可以完全避免这个问题, 但是可能会导致所属(Owning)客户端的错误预测.  </p><p>根据使用的不同<code>AGameplayAbilityTargetActor</code>子类, <code>WaitTargetData AbilityTask</code>节点会暴露不同的<code>ExposeOnSpawn</code>参数, 一些常用的参数包括:  </p><div class="table-container"><table><thead><tr><th style="text-align:center">常用<code>TargetActor</code>参数</th><th style="text-align:center">定义</th></tr></thead><tbody><tr><td style="text-align:center">Debug</td><td style="text-align:center">如果为真, 每当非发行版本中的<code>TargetActor</code>执行射线检测时, 其会绘制debug射线/Overlap信息. 请记住, <code>non-Instant TargetActor</code>会在<code>Tick()</code>中执行射线检测, 因此这些debug绘制调用也会在<code>Tick()</code>中触发.</td></tr><tr><td style="text-align:center">Filter</td><td style="text-align:center">[可选]当射线/Overlap触发时, 用于从Target中过滤(移除)Actor的特殊结构体. 典型的使用案例是过滤玩家的<code>Pawn</code>, 其要求Target是特殊类. 查看<a href="#concepts-target-data-filters">Target Data Filters</a>以获得更多高级使用案例.</td></tr><tr><td style="text-align:center">Reticle Class</td><td style="text-align:center">[可选]<code>TargetActor</code>生成的<code>AGameplayAbilityWorldReticle</code>子类.</td></tr><tr><td style="text-align:center">Reticle Parameters</td><td style="text-align:center">[可选]配置你的Reticle. 查看<a href="#concepts-targeting-reticles">Reticles</a>.</td></tr><tr><td style="text-align:center">Start Location</td><td style="text-align:center">用于设置射线检测应该从何处开始的特殊结构体. 一般这应该是玩家的视口(Viewport), 枪口或者Pawn的位置.</td></tr></tbody></table></div><p>使用默认的<code>TargetActor</code>类时, Actor只有直接在射线/Overlap中时才是有效的, 如果它离开射线/Overlap(它移动开或你的视线转向别处), 就不再有效了. 如果你想<code>TargetActor</code>记住最后有效的Target, 就需要添加这项功能到一个自定义的<code>TargetActor</code>类. 我称之为持久化Target, 因为其会持续存在直到<code>TargetActor</code>接收到确认或取消消息, <code>TargetActor</code>会在它的射线/Overlap中找到一个新的有效Target, 或者Target不再有效(已销毁). GASShooter对火箭筒二技能的制导火箭定位使用了持久化Target.  </p><p><strong><a href="#table-of-contents">⬆ 返回目录</a></strong></p><p><span id="concepts-target-data-filters"></span></p><h3 id="4-11-3-TargetData过滤器"><a href="#4-11-3-TargetData过滤器" class="headerlink" title="4.11.3 TargetData过滤器"></a>4.11.3 TargetData过滤器</h3><p>同时使用<code>Make GameplayTargetDataFilter</code>和<code>Make Filter Handle</code>节点, 你可以过滤玩家的<code>Pawn</code>或者只选择某个特定类. 如果需要更多高级过滤条件, 可以继承<code>FGameplayTargetDataFilter</code>并重写<code>FilterPassesForActor</code>函数.  </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">USTRUCT</span>(BlueprintType)</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">GASDOCUMENTATION_API</span> FGDNameTargetDataFilter : <span class="keyword">public</span> FGameplayTargetDataFilter</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">GENERATED_BODY</span>()</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Returns true if the actor passes the filter and will be targeted */</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">bool</span> <span class="title">FilterPassesForActor</span><span class="params">(<span class="type">const</span> AActor* ActorToBeFiltered)</span> <span class="type">const</span> <span class="keyword">override</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line">However, <span class="keyword">this</span> will <span class="keyword">not</span> work directly into the Wait Target Data node as it <span class="keyword">requires</span> a FGameplayTargetDataFilterHandle. A <span class="keyword">new</span> custom Make Filter Handle must be made to accept the subclass:</span><br><span class="line"></span><br><span class="line">FGameplayTargetDataFilterHandle UGDTargetDataFilterBlueprintLibrary::<span class="built_in">MakeGDNameFilterHandle</span>(FGDNameTargetDataFilter Filter, AActor* FilterActor)</span><br><span class="line">&#123;</span><br><span class="line">FGameplayTargetDataFilter* NewFilter = <span class="keyword">new</span> <span class="built_in">FGDNameTargetDataFilter</span>(Filter);</span><br><span class="line">NewFilter-&gt;<span class="built_in">InitializeFilterContext</span>(FilterActor);</span><br><span class="line"></span><br><span class="line">FGameplayTargetDataFilterHandle FilterHandle;</span><br><span class="line">FilterHandle.Filter = <span class="built_in">TSharedPtr</span>&lt;FGameplayTargetDataFilter&gt;(NewFilter);</span><br><span class="line"><span class="keyword">return</span> FilterHandle;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong><a href="#table-of-contents">⬆ 返回目录</a></strong></p><p><span id="concepts-targeting-reticles"></span></p><h3 id="4-11-4-Gameplay-Ability-World-Reticles"><a href="#4-11-4-Gameplay-Ability-World-Reticles" class="headerlink" title="4.11.4 Gameplay Ability World Reticles"></a>4.11.4 Gameplay Ability World Reticles</h3><p>当使用已确认的<code>non-Instant</code> <a href="#concepts-targeting-actors">TargetActor</a>定位时, <a href="https://docs.unrealengine.com/en-US/API/Plugins/GameplayAbilities/Abilities/AGameplayAbilityWorldReticle/index.html">AGameplayAbilityWorldReticles(Reticles)</a>可以可视化正在定位的目标. <code>TargetActor</code>负责所有<code>Reticle</code>生命周期的生成和销毁. <code>Reticle</code>是AActor, 因此其可以使用任意种类的可视组件作为表现形式. GASShooter中常见的一种实现方式是使用<code>WidgetComponent</code>在屏幕空间中显示UMG Widget(永远面对玩家的摄像机). <code>Reticle</code>不知道其正在定位的Actor, 但是你可以通过继承在自定义<code>TargetActor</code>中实现该功能. <code>TargetActor</code>一般在每次<code>Tick()</code>中更新<code>Reticle</code>的位置为Target的位置.  </p><p>GASShooter对火箭筒二技能制导火箭锁定的目标使用了<code>Reticle</code>. 敌人身上的红色标识就是<code>Reticle</code>, 相似的白色图像是火箭筒的准星.  </p><p><img src="https://pic1.imgdb.cn/item/67a4c797d0e0a243d4fc540e.png" alt="Reticles in GASShooter">  </p><p><code>Reticle</code>带有一些面向设计师的<code>BlueprintImplementableEvents</code>(它们被设计用来在蓝图中开发):  </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** Called whenever bIsTargetValid changes value. */</span></span><br><span class="line"><span class="built_in">UFUNCTION</span>(BlueprintImplementableEvent, Category = Reticle)</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">OnValidTargetChanged</span><span class="params">(<span class="type">bool</span> bNewValue)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Called whenever bIsTargetAnActor changes value. */</span></span><br><span class="line"><span class="built_in">UFUNCTION</span>(BlueprintImplementableEvent, Category = Reticle)</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">OnTargetingAnActor</span><span class="params">(<span class="type">bool</span> bNewValue)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">UFUNCTION</span>(BlueprintImplementableEvent, Category = Reticle)</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">OnParametersInitialized</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">UFUNCTION</span>(BlueprintImplementableEvent, Category = Reticle)</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">SetReticleMaterialParamFloat</span><span class="params">(FName ParamName, <span class="type">float</span> value)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">UFUNCTION</span>(BlueprintImplementableEvent, Category = Reticle)</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">SetReticleMaterialParamVector</span><span class="params">(FName ParamName, FVector value)</span></span>;</span><br></pre></td></tr></table></figure><p><code>Reticle</code>可以选择使用<code>TargetActor</code>提供的<a href="https://docs.unrealengine.com/en-US/API/Plugins/GameplayAbilities/Abilities/FWorldReticleParameters/index.html">FWorldReticleParameters</a>来配置, 默认结构体只提供一个变量<code>FVector AOEScale</code>, 尽管你可以在技术上继承该结构体, 但是<code>TargetActor</code>只接受基类结构体, 不允许在默认<code>TargetActor</code>中子类化该结构体似乎有些短见, 然而, 如果你创建了自己的自定义<code>TargetActor</code>, 就可以提供自定义的<code>Reticle</code>参数结构体并在生成<code>Reticle</code>时手动传递它到<code>AGameplayAbilityWorldReticles</code>子类.  </p><p><code>Reticle</code>默认是不可同步的, 但是如果在你的游戏中向其他玩家展示本地玩家正在定位的目标是有意义的, 那么它也可以被设计成可同步的.  </p><p><code>Reticle</code>只会显示在默认<code>TargetActor</code>的当前有效Target上, 例如, 如果你正在使用<code>AGameplayAbilityTargetActor_SingleLineTrace</code>对目标执行射线检测, 敌人只有直接处于射线路径上时<code>Reticle</code>才会显示, 如果角色视线看向别处, 那么该敌人就不再是一个有效Target, 因此该<code>Reticle</code>就会消失. 如果你想<code>Reticle</code>保留在最后一个有效Target上, 就需要自定义<code>TargetActor</code>来记住最后一个有效Target并使<code>Reticle</code>保留在其上. 我称之为持久化Target, 因为其会持续存在直到<code>TargetActor</code>接收到确认或取消消息, <code>TargetActor</code>会在它的射线/Overlap中找到一个新的有效Target, 或者Target不再有效(已销毁). GASShooter对火箭筒二技能的制导火箭定位使用了持久化Target.  </p><p><strong><a href="#table-of-contents">⬆ 返回目录</a></strong></p><p><span id="concepts-targeting-containers"></span></p><h3 id="4-11-5-Gameplay-Effect-Containers-Targeting"><a href="#4-11-5-Gameplay-Effect-Containers-Targeting" class="headerlink" title="4.11.5 Gameplay Effect Containers Targeting"></a>4.11.5 Gameplay Effect Containers Targeting</h3><p><a href="#concepts-ge-containers">GameplayEffectContainer</a>提供了一个可选的产生<a href="#concepts-targeting-data">TargetData</a>的高效方法. 当<code>EffectContainer</code>在客户端和服务端上应用时, 该定位会立即进行, 它比<a href="#concepts-targeting-actors">TargetActor</a>更有效率, 因为它是运行在定位对象的CDO(Class Default Object)上的(没有Actor的生成和销毁), 但是它不支持用户输入, 无需确认即可立即进行, 不能取消, 并且不能从客户端向服务端发送数据(在两者上产生数据), 它对即时射线检测和碰撞Overlap很有用. Epic的<a href="https://www.unrealengine.com/marketplace/en-US/slug/action-rpg">Action RPG Sample Project</a>包含两种使用Container定位的样例 —— 定位Ability拥有者和从事件拉取<code>TargetData</code>, 它还在蓝图中实现了在距玩家某个偏移处(由蓝图子类设置)做球形射线检测(Sphere Trace), 你可以在C++或蓝图中继承<code>URPGTargetType</code>以实现自己的定位类型.  </p><p><strong><a href="#table-of-contents">⬆ 返回目录</a></strong></p><p><span id="cae"></span></p><h1 id="5-常用的Abilty和Effect"><a href="#5-常用的Abilty和Effect" class="headerlink" title="5. 常用的Abilty和Effect"></a>5. 常用的Abilty和Effect</h1><p><span id="cae-stun"></span></p><h2 id="5-1-眩晕-Stun"><a href="#5-1-眩晕-Stun" class="headerlink" title="5.1 眩晕(Stun)"></a>5.1 眩晕(Stun)</h2><p>一般在眩晕状态时, 我们就要取消Character所有已激活的<code>GameplayAbility</code>, 阻止新的<code>GameplayAbility</code>激活, 并在整个眩晕期间阻止移动. 样例项目的陨石<code>GameplayAbility</code>会在击中的目标上应用眩晕效果.  </p><p>为了取消目标活跃的<code>GameplayAbility</code>, 可以在眩晕<a href="#concepts-gt-change"><code>GameplayTag</code>添加</a>时调用<code>AbilitySystemComponent-&gt;CancelAbilities()</code>.  </p><p>为了在眩晕时阻止新的<code>GameplayAbility</code>激活, 可以在<code>GameplayAbility</code>的<a href="#concepts-ga-tags">Activation Blocked Tags GameplayTagContainer</a>中添加眩晕<code>GameplayTag</code>.  </p><p>为了在眩晕时阻止移动, 我们可以在拥有者拥有眩晕<code>GameplayTag</code>时重写<code>CharacterMovementComponent</code>的<code>GetMaxSpeed()</code>函数以返回0.  </p><p><strong><a href="#table-of-contents">⬆ 返回目录</a></strong></p><p><span id="cae-sprint"></span></p><h2 id="5-2-奔跑-Sprint"><a href="#5-2-奔跑-Sprint" class="headerlink" title="5.2 奔跑(Sprint)"></a>5.2 奔跑(Sprint)</h2><p>样例项目提供了一个如何奔跑的例子 —— 按住左Shift时跑得更快.  </p><p>更快的移动由<code>CharacterMovementComponent</code>通过网络发送flag到服务端预测性地处理. 详见<code>GDCharacterMovementComponent.h/cpp</code>.  </p><p><code>GA</code>处理响应左Shift输入, 告知<code>CMC</code>开始和停止奔跑, 并且在左Shift按下时预测性地消耗耐力. 详见<code>GA_Sprint_BP</code>.  </p><p><strong><a href="#table-of-contents">⬆ 返回目录</a></strong></p><p><span id="cae-ads"></span></p><h2 id="5-3-瞄准-Aim-Down-Sight"><a href="#5-3-瞄准-Aim-Down-Sight" class="headerlink" title="5.3 瞄准(Aim Down Sight)"></a>5.3 瞄准(Aim Down Sight)</h2><p>样例项目处理它和奔跑时完全一样, 除了降低移动速度而不是提高它.  </p><p>详见<code>GDCharacterMovementComponent.h/cpp</code>是如何预测性地降低移动速度的.  </p><p>详见<code>GA_AimDownSight_BP</code>是如何处理输入的. 瞄准时是不消耗耐力的.  </p><p><strong><a href="#table-of-contents">⬆ 返回目录</a></strong></p><p><span id="cae-ls"></span></p><h2 id="5-4-生命偷取-Lifesteal"><a href="#5-4-生命偷取-Lifesteal" class="headerlink" title="5.4 生命偷取(Lifesteal)"></a>5.4 生命偷取(Lifesteal)</h2><p>我在伤害<a href="#concepts-ge-ec">ExecutionCalculation</a>中处理生命偷取. <code>GameplayEffect</code>会有一个像<code>Effect.CanLifesteal</code>样的<code>GameplayTag</code>, <code>ExecutionCalculation</code>会检查<code>GameplayEffectSpec</code>是否有<code>Effect.CanLifesteal GameplayTag</code>, 如果该<code>GameplayTag</code>存在, <code>ExecutionCalculation</code>会使用作为Modifer的生命值<a href="#concepts-ge-dynamic">创建一个动态的<code>即刻(Instant)GameplayEffect</code></a>, 并将其应用回源(Source)ASC.  </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (SpecAssetTags.<span class="built_in">HasTag</span>(FGameplayTag::<span class="built_in">RequestGameplayTag</span>(<span class="built_in">FName</span>(<span class="string">&quot;Effect.Damage.CanLifesteal&quot;</span>))))</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">float</span> Lifesteal = Damage * LifestealPercent;</span><br><span class="line"></span><br><span class="line">UGameplayEffect* GELifesteal = <span class="built_in">NewObject</span>&lt;UGameplayEffect&gt;(<span class="built_in">GetTransientPackage</span>(), <span class="built_in">FName</span>(<span class="built_in">TEXT</span>(<span class="string">&quot;Lifesteal&quot;</span>)));</span><br><span class="line">GELifesteal-&gt;DurationPolicy = EGameplayEffectDurationType::Instant;</span><br><span class="line"></span><br><span class="line">int32 Idx = GELifesteal-&gt;Modifiers.<span class="built_in">Num</span>();</span><br><span class="line">GELifesteal-&gt;Modifiers.<span class="built_in">SetNum</span>(Idx + <span class="number">1</span>);</span><br><span class="line">FGameplayModifierInfo&amp; Info = GELifesteal-&gt;Modifiers[Idx];</span><br><span class="line">Info.ModifierMagnitude = <span class="built_in">FScalableFloat</span>(Lifesteal);</span><br><span class="line">Info.ModifierOp = EGameplayModOp::Additive;</span><br><span class="line">Info.Attribute = UPAAttributeSetBase::<span class="built_in">GetHealthAttribute</span>();</span><br><span class="line"></span><br><span class="line">SourceAbilitySystemComponent-&gt;<span class="built_in">ApplyGameplayEffectToSelf</span>(GELifesteal, <span class="number">1.0f</span>, SourceAbilitySystemComponent-&gt;<span class="built_in">MakeEffectContext</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong><a href="#table-of-contents">⬆ 返回目录</a></strong></p><p><span id="cae-random"></span></p><h2 id="5-5-在客户端和服务端中生成随机数"><a href="#5-5-在客户端和服务端中生成随机数" class="headerlink" title="5.5 在客户端和服务端中生成随机数"></a>5.5 在客户端和服务端中生成随机数</h2><p>有时你需要在<code>GameplayAbility</code>中生成随机数用于枪支后坐力或者子弹扩散, 客户端和服务端都需要生成相同的随机数, 要做到这一点, 我们必须在<code>GameplayAbility</code>激活时设置相同的<code>随机数种子</code>, 你需要在每次激活<code>GameplayAbility</code>时设置<code>随机数种子</code>, 以防客户端错误预测激活或者它的随机数列表与服务端的不同步.  </p><div class="table-container"><table><thead><tr><th style="text-align:center">随机种子设置方法</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center">使用<code>Activation Prediction Key</code></td><td style="text-align:center"><code>GameplayAbility</code>的<code>Activation Prediction Key</code>是一个确保同步并且在客户端和服务端的<code>Activation()</code>中都可用的int16类型值. 你可以在客户端和服务端中设置其作为<code>随机数种子</code>. 该方法的缺点是每次游戏开始时<code>Prediction Key</code>总是从0开始并且会在生成key之后持续增加, 这意味着每场游戏都有着及其相同的随机数序列, 这可能满足或不满足你的随机数需要.</td></tr><tr><td style="text-align:center">激活<code>GameplayAbility</code>时通过事件负载(Event Payload)发送种子</td><td style="text-align:center">通过事件激活<code>GameplayAbility</code>并通过可同步的事件负载(Event Payload)从客户端发送随机生成的种子到服务端, 这允许更高的随机性, 但是客户端也容易被破解而每次只发送相同的种子. 通过事件激活<code>GameplayAbility</code>也会阻止其从用户绑定激活.</td></tr></tbody></table></div><p>如果你的随机偏差很小, 大多数玩家是不会注意到每次游戏的随机序列都是相同的, 那么使用<code>Activation Prediction Key</code>作为随机种子就应该适用于你. 如果你正在做一些更复杂的事, 需要防范破解者, 那么使用<code>Server Initiated GameplayAbility</code>会更好, 服务端可以创建<code>Prediction Key</code>或者生成随机数种子来通过事件负载(Event Payload)发送.  </p><p><strong><a href="#table-of-contents">⬆ 返回目录</a></strong></p><p><span id="cae-crit"></span></p><h2 id="5-6-暴击-Critical-Hits"><a href="#5-6-暴击-Critical-Hits" class="headerlink" title="5.6 暴击(Critical Hits)"></a>5.6 暴击(Critical Hits)</h2><p>我在伤害<a href="#concepts-ge-ec">ExecutionCalculation</a>中处理暴击. <code>GameplayEffect</code>会有一个像<code>Effect.CanCrit</code>样的<code>GameplayTag</code>, <code>ExecutionCalculation</code>会检查<code>GameplayEffectSpec</code>是否有<code>Effect.CanCrit  GameplayTag</code>, 如果该<code>GameplayTag</code>存在, <code>ExecutionCalculation</code>就会生成一个与暴击率相关联的随机数(从Source捕获的<code>Attribute</code>), 如果成功的话就会增加暴击伤害(另一个从Source捕获的<code>Attribute</code>). 因为我没有预测伤害, 所以不必担心在客户端和服务端上同步随机数生成器的问题(<code>ExecutionCalculation</code>只运行在服务端上). 如果你尝试使用<code>MMC</code>预测性地执行伤害计算, 就必须从<code>GameplayEffectSpec-&gt;GameplayEffectContext-&gt;GameplayAbilityInstance</code>中获取随机数种子的引用.  </p><p>查看GASShooter是如何处理爆头问题的, 其概念是一样的, 除了不再依赖随机数作为概率而是检测<code>FHitResult</code>骨骼名.  </p><p><strong><a href="#table-of-contents">⬆ 返回目录</a></strong></p><p><span id="cae-nonstackingge"></span></p><h2 id="5-7-非堆栈GameplayEffect-但是只有其最高级-Greatest-Magnitude-才能实际影响Target"><a href="#5-7-非堆栈GameplayEffect-但是只有其最高级-Greatest-Magnitude-才能实际影响Target" class="headerlink" title="5.7 非堆栈GameplayEffect, 但是只有其最高级(Greatest Magnitude)才能实际影响Target"></a>5.7 非堆栈GameplayEffect, 但是只有其最高级(Greatest Magnitude)才能实际影响Target</h2><p>Paragon中的Slow Effect是非堆栈的. 应用每个实例并且像平常一样跟踪其生命周期, 但是只有最高级(Greatest Magnitude)的Slow Effect才能实际影响<code>Character</code>. GAS为这种场景提供了开箱即用的<code>AggregatorEvaluateMetaData</code>, 详见<a href="#concepts-as-onattributeaggregatorcreated">AggregatorEvaluateMetaData()</a>及其实现.  </p><p><strong><a href="#table-of-contents">⬆ 返回目录</a></strong></p><p><span id="cae-paused"></span></p><h2 id="5-8-游戏暂停时生成TargetData"><a href="#5-8-游戏暂停时生成TargetData" class="headerlink" title="5.8 游戏暂停时生成TargetData"></a>5.8 游戏暂停时生成TargetData</h2><p>如果你需要在等待玩家从<code>WaitTargetData AbilityTask</code>生成<a href="#concepts-targeting-data">TargetData</a>时暂停游戏, 我建议使用<code>slomo 0</code>而不是暂停.  </p><p><strong><a href="#table-of-contents">⬆ 返回目录</a></strong></p><p><span id="cae-onebuttoninteractionsystem"></span></p><h2 id="5-9-按钮交互系统-Button-Interaction-System"><a href="#5-9-按钮交互系统-Button-Interaction-System" class="headerlink" title="5.9 按钮交互系统(Button Interaction System)"></a>5.9 按钮交互系统(Button Interaction System)</h2><p>GASShooter实现了一个按钮交互系统, 玩家可以按下或按住’E’键来和可交互对象交互, 像复活玩家, 打开武器箱, 打开或关闭滑动门.  </p><p><strong><a href="#table-of-contents">⬆ 返回目录</a></strong></p><p><span id="debugging"></span></p><h1 id="6-调试GAS"><a href="#6-调试GAS" class="headerlink" title="6. 调试GAS"></a>6. 调试GAS</h1><p>通常在调试GAS相关的问题时, 你感兴趣的事情像:  </p><blockquote><p>“我的Attribute的值是多少?”<br>“我有哪些GameplayTag?”<br>“我现在有哪些GameplayEffect?”<br>“我已经授予的Ability有哪些, 哪个正在运行, 哪个被堵止激活?”</p></blockquote><p>GAS有两种技术可以在运行时解决这些问题 —— <a href="#debugging-sd">showdebug abilitysystem</a>和在<a href="#debugging-gd">GameplayDebugger</a>中Hook.  </p><p><strong>Tip:</strong> UE4倾向于优化C++代码, 这使得某些函数变得很难调试, 当深入追踪代码时很少遇到这种情况. 如果将Visual Studio的解决方案配置设置为<code>DebugGame Editor</code>仍然不能追踪代码或者监视变量, 可以使用<code>PRAGMA_DISABLE_OPTIMIZATION_ACTUAL</code>和<code>PRAGMA_ENABLE_OPTIMIZATION_ACTUAL</code>宏包裹优化函数来关闭优化, 这不能在插件代码中使用除非从源码重新编译插件. 这可以或不可以用于inline函数, 取决于它的作用和位置. 确保完成调试后移除这两个宏!  </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">PRAGMA_DISABLE_OPTIMIZATION_ACTUAL</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MyClass::MyFunction</span><span class="params">(int32 MyIntParameter)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// My code</span></span><br><span class="line">&#125;</span><br><span class="line">PRAGMA_ENABLE_OPTIMIZATION_ACTUAL</span><br></pre></td></tr></table></figure><p><strong><a href="#table-of-contents">⬆ 返回目录</a></strong></p><p><span id="debugging-sd"></span></p><h2 id="6-1-showdebug-abilitysystem"><a href="#6-1-showdebug-abilitysystem" class="headerlink" title="6.1 showdebug abilitysystem"></a>6.1 showdebug abilitysystem</h2><p>在游戏中的控制台输入<code>showdebug abilitysystem</code>. 该特性被分为三”页”, 三页都会显示当前拥有的<code>GameplayTag</code>, 在控制台输入<code>AbilitySystem.Debug.NextCategory</code>来换页.  </p><p>第一页显示了所有<code>Attribute</code>的<code>CurrentValue</code>: <img src="https://pic1.imgdb.cn/item/67a4c7b5d0e0a243d4fc541e.png" alt="First Page of showdebug abilitysystem">  </p><p>第二页显示了所有应用到你的<code>持续(Duration)</code>和<code>无限(Infinite)GameplayEffect</code>, 它们的堆栈数, 使用的<code>GameplayTag</code>和<code>Modifier</code>. <img src="https://pic1.imgdb.cn/item/67a4c7d0d0e0a243d4fc5422.png" alt="Second Page of showdebug abilitysystem">  </p><p>第三页显示了所有授予到你的<code>GameplayAbility</code>, 无论其是否正在运行, 无论其是否被阻止激活, 和当前正在运行的<code>AbilityTask</code>的状态.  <img src="https://pic1.imgdb.cn/item/67a4c7ead0e0a243d4fc5427.png" alt="Third Page of showdebug abilitysystem">  </p><p>你可以使用<code>PageUp</code>和<code>PageDown</code>切换Target, 页面只显示你本地控制的<code>Character</code>中的<code>ASC</code>数据, 然而, 使用<code>AbilitySystem.Debug.NextTarget</code>和<code>AbilitySystem.Debug.PrevTarget</code>可以显示其他<code>ASC</code>的数据, 但是不会显示调试信息的上半部分, 也不会更新绿色目标长方体, 因此无法知道当前定位的是哪个<code>ASC</code>, 该BUG已经被提交到<a href="https://issues.unrealengine.com/issue/UE-90437">https://issues.unrealengine.com/issue/UE-90437.</a>.  </p><p><strong>Note:</strong>  为了<code>showdebug abilitysystem</code>可以使用, 必须在GameMode中选择一个实际的HUD类, 否则就会找不到该命令并返回”Unknown Command”.  </p><p><strong><a href="#table-of-contents">⬆ 返回目录</a></strong></p><p><span id="debugging-gd"></span></p><h2 id="6-2-Gameplay-Debugger"><a href="#6-2-Gameplay-Debugger" class="headerlink" title="6.2 Gameplay Debugger"></a>6.2 Gameplay Debugger</h2><p>GAS向Gameplay Debugger中添加了功能, 使用<code>反引号(`)</code>键以访问Gameplay Debugger. 按下小键盘的3键以启用Ability分类, 取决于你所拥有的插件, 分类可能是不同的. 如果你的键盘没有小键盘, 比如笔记本, 那么你可以在项目设置(Project Settings)里修改键盘绑定.  </p><p>当你想要查看其他Character的<code>GameplayTag</code>, <code>GameplayEffect</code>和<code>GameplayAbility</code>时可以使用Gameplay Debugger, 可惜的是它不能显示Target的<code>Attribute</code>中的<code>CurrentValue</code>. 它会定位屏幕中央的任何Character, 你可以通过选择编辑器世界大纲(World Outliner)或者看向另一个不同的Character并再次按下<code>反引号(`)</code>键来修改Target. 当前监视的Character上方有最大的红色圆.  </p><p><strong><a href="#table-of-contents">⬆ 返回目录</a></strong></p><p><span id="debugging-log"></span></p><h2 id="6-3-GAS日志-Logging"><a href="#6-3-GAS日志-Logging" class="headerlink" title="6.3 GAS日志(Logging)"></a>6.3 GAS日志(Logging)</h2><p>GAS包含了大量不同详细级别的日志生成语句, 你很可能见到的是<code>ABILITY_LOG()</code>这样的语句. 默认的详细级别是<code>Display</code>, 更高的默认不会显示在控制台里.  </p><p>为了修改某个日志分类的详细级别, 在控制台中输入:  </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">log [category] [verbosity]</span><br></pre></td></tr></table></figure><p>例如, 为了开启<code>ABILITY_LOG()</code>语句, 应该在控制台中输入:  </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">log LogAbilitySystem VeryVerbose</span><br></pre></td></tr></table></figure><p>为了恢复默认, 输入:  </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">log LogAbilitySystem Display</span><br></pre></td></tr></table></figure><p>为了显示所有的日志分类, 输入:  </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">log list</span><br></pre></td></tr></table></figure><p>值得注意的GAS相关的日志分类:  </p><div class="table-container"><table><thead><tr><th style="text-align:center">日志分类</th><th style="text-align:center">默认详细级别</th></tr></thead><tbody><tr><td style="text-align:center">LogAbilitySystem</td><td style="text-align:center">Display</td></tr><tr><td style="text-align:center">LogAbilitySystemComponent</td><td style="text-align:center">Log</td></tr><tr><td style="text-align:center">LogGameplayCueDetails</td><td style="text-align:center">Log</td></tr><tr><td style="text-align:center">LogGameplayCueTranslator</td><td style="text-align:center">Display</td></tr><tr><td style="text-align:center">LogGameplayEffectDetails</td><td style="text-align:center">Log</td></tr><tr><td style="text-align:center">LogGameplayEffects</td><td style="text-align:center">Display</td></tr><tr><td style="text-align:center">LogGameplayTags</td><td style="text-align:center">Log</td></tr><tr><td style="text-align:center">LogGameplayTasks</td><td style="text-align:center">Log</td></tr><tr><td style="text-align:center">VLogAbilitySystem</td><td style="text-align:center">Display</td></tr></tbody></table></div><p>详情查看<a href="https://www.ue4community.wiki/Legacy/Logs,_Printing_Messages_To_Yourself_During_Runtime">日志Wiki</a>.  </p><p><strong><a href="#table-of-contents">⬆ 返回目录</a></strong></p><p><span id="optimizations"></span></p><h1 id="7-优化"><a href="#7-优化" class="headerlink" title="7. 优化"></a>7. 优化</h1><p><span id="optimizations-abilitybatching"></span></p><h2 id="7-1-Ability批处理"><a href="#7-1-Ability批处理" class="headerlink" title="7.1 Ability批处理"></a>7.1 Ability批处理</h2><p><a href="#concepts-ga">GameplayAbility</a>在一帧中的的激活、选择性地向服务器发送<code>TargetData</code>、结束可以被<a href="#concepts-ga-batching">批处理而将2-3个RPC压缩成一个RPC</a>. 这种RPC常用于枪支的命中判断.  </p><p><strong><a href="#table-of-contents">⬆ 返回目录</a></strong></p><p><span id="optimizations-gameplaycuebatching"></span></p><h2 id="7-2-GameplayCue批处理"><a href="#7-2-GameplayCue批处理" class="headerlink" title="7.2 GameplayCue批处理"></a>7.2 GameplayCue批处理</h2><p>如果你需要同时发送很多<a href="#concepts-gc">GameplayCue</a>, 可以考虑将其<a href="#concepts-gc-batching">批处理成一个RPC</a>, 目标就是减少RPC数量(<code>GameplayCue</code>是不可靠的网络多播(NetMulticast))并以尽可能少的数据量发送.  </p><p><strong><a href="#table-of-contents">⬆ 返回目录</a></strong></p><p><span id="optimizations-ascreplicationmode"></span></p><h2 id="7-3-AbilitySystemComponent同步模式-Replication-Mode"><a href="#7-3-AbilitySystemComponent同步模式-Replication-Mode" class="headerlink" title="7.3 AbilitySystemComponent同步模式(Replication Mode)"></a>7.3 AbilitySystemComponent同步模式(Replication Mode)</h2><p>默认情况下, <a href="#concepts-asc">ASC</a>处于<a href="#concepts-asc-rm">Full Replication</a>模式, 这会同步所有的<a href="#concepts-ge">GameplayEffect</a>到每个客户端(对单人游戏来说很好). 在多人游戏中, 设置玩家拥有的<code>ASC</code>为<code>Mixed Replication</code>模式, AI控制的Character为<code>Minimal Replication</code>模式, 这会将应用到玩家Character上的<code>GE</code>仅同步到该Character的拥有者, 应用到AI控制的Character上的<code>GE</code>永远不会同步到客户端. 无论是什么同步模式, <a href="#concepts-gt">GameplayTag</a>仍会进行同步, <a href="#concepts-gc">GameplayCue</a>仍会以不可靠的网络多播(NetMulticast)到所有客户端. 当所有客户端都不需要查看这些数据时, 这会减少从<code>GE</code>同步的网络数据.  </p><p><strong><a href="#table-of-contents">⬆ 返回目录</a></strong></p><p><span id="optimizations-attributeproxyreplication"></span></p><h2 id="7-4-Attribute代理同步"><a href="#7-4-Attribute代理同步" class="headerlink" title="7.4 Attribute代理同步"></a>7.4 Attribute代理同步</h2><p>在有很多玩家的大型游戏中, 像Fortnite大逃杀(Fortnite Battle Royale), 有大量存在于常相关<code>PlayerState</code>上的<a href="#concepts-asc">ASC</a>, 其会同步大量<a href="#concepts-a">Attribute</a>. 为了优化该瓶颈, Fortnite禁止在<code>PlayerState::ReplicateSubobjects()</code>中完全同步<code>ASC</code>和它的<a href="#concepts-as">AttributeSet</a>到模拟玩家控制的代理(Simulated Player-Controlled Proxy)上. Autonomou代理和AI控制的<code>Pawn</code>仍然根据其<a href="#concepts-asc-rm">同步模式</a>来完全同步. Fortnite使用了玩家Pawn上的可同步代理结构体, 而不是同步常相关<code>PlayerState</code>上的<code>ASC</code>的<code>Attribute</code>. 当服务端ASC上的<code>Attribute</code>改变时, 其也会在代理结构体中改变, 客户端会从代理结构体接收同步的<code>Attribute</code>并将修改返回其本地<code>ASC</code>, 这允许<code>Attribute</code>同步使用<code>Pawn</code>的相关性(Relevancy)和<code>NetUpdateFrequency</code>, 该代理结构体也会使用位掩码(Bitmask)同步一个小的<code>GameplayTag</code>白名单集合. 该优化减少了网络数据量, 并允许我们利用Pawn相关性(Relevancy). AI控制的<code>Pawn</code>的<code>ASC</code>位于已经使用其相关性的<code>Pawn</code>上, 因此其并不需要该优化.  </p><blockquote><p>I’m not sure if it is still necessary with other server side optimizations that have been done since then (Replication Graph, etc) and it is not the most maintainable pattern.</p></blockquote><p>来自Epic的Dave Ratti回答<a href="https://epicgames.ent.box.com/s/m1egifkxv3he3u3xezb9hzbgroxyhx89">社区问题#3</a>.  </p><p><strong><a href="#table-of-contents">⬆ 返回目录</a></strong></p><p><span id="optimizations-asclazyloading"></span></p><h2 id="7-5-ASC懒加载"><a href="#7-5-ASC懒加载" class="headerlink" title="7.5 ASC懒加载"></a>7.5 ASC懒加载</h2><p>Fortnite大逃杀(Fortnite Battle Royale)世界中有很多可损坏的<code>AActor</code>(树木, 建筑物等等), 每个都有一个<code>ASC</code>, 这会增加内存消耗, Fortnite通过只在需要时(当其第一次被玩家伤害时)懒加载<code>ASC</code>的方式优化该问题, 这会减少整体内存消耗, 因为某些<code>AActor</code>在一局比赛中可能永远不会被伤害.  </p><p><strong><a href="#table-of-contents">⬆ 返回目录</a></strong></p><p><span id="qol"></span></p><h1 id="8-Quality-of-Life-Suggestions"><a href="#8-Quality-of-Life-Suggestions" class="headerlink" title="8. Quality of Life Suggestions"></a>8. Quality of Life Suggestions</h1><p><span id="qol-gameplayeffectcontainers"></span></p><h2 id="8-1-Gameplay-Effect-Containers"><a href="#8-1-Gameplay-Effect-Containers" class="headerlink" title="8.1 Gameplay Effect Containers"></a>8.1 Gameplay Effect Containers</h2><p><a href="#concepts-ge-containers">GameplayEffectContainer</a>将<a href="#concepts-ge-spec">GameplayEffectSpec</a>, <a href="#concepts-targeting-data">TargetData</a>, 简单定位和其他相关功能整合进简单易用的结构体, 这对转移<code>GameplayEffectSpec</code>到Ability生成的抛射物很有用, 该抛射物之后会在碰撞体上应用<code>GameplayEffectSpec</code>.  </p><p><strong><a href="#table-of-contents">⬆ 返回目录</a></strong></p><p><span id="qol-asynctasksascdelegates"></span></p><h2 id="8-2-将蓝图AsyncTask绑定到ASC委托"><a href="#8-2-将蓝图AsyncTask绑定到ASC委托" class="headerlink" title="8.2 将蓝图AsyncTask绑定到ASC委托"></a>8.2 将蓝图AsyncTask绑定到ASC委托</h2><p>为了增加设计师友好的迭代次数, 特别是在为UI设计UMG Widget时, 可以创建蓝图AsyncTask(在C++中)以直接在UMG蓝图图表中绑定到<code>ASC</code>中常见的修改委托, 唯一的告诫就是其必须手动销毁(比如在widget销毁时), 否则就会永远存于内存中.样例项目包含三个蓝图AsyncTask.  </p><p>监听<code>Attribute</code>修改:  </p><p><img src="https://pic1.imgdb.cn/item/67a4c805d0e0a243d4fc5429.png" alt="Listen for Attributes Changes BP Node">  </p><p>监听冷却时间修改:  </p><p><img src="https://pic1.imgdb.cn/item/67a4c694d0e0a243d4fc53ca.png" alt="Listen for Cooldown Change BP Node">  </p><p>监听<code>GE</code>堆栈修改:  </p><p><img src="https://pic1.imgdb.cn/item/67a4c515d0e0a243d4fc5395.png" alt="Listen for GameplayEffect Stack Change BP Node">  </p><p><strong><a href="#table-of-contents">⬆ 返回目录</a></strong></p><p><span id="troubleshooting"></span></p><h1 id="9-疑难解答"><a href="#9-疑难解答" class="headerlink" title="9. 疑难解答"></a>9. 疑难解答</h1><p><span id="troubleshooting-notlocal"></span></p><h2 id="9-1-LogAbilitySystem-Warning-Can’t-activate-LocalOnly-or-LocalPredicted-ability-s-when-not-local"><a href="#9-1-LogAbilitySystem-Warning-Can’t-activate-LocalOnly-or-LocalPredicted-ability-s-when-not-local" class="headerlink" title="9.1 LogAbilitySystem: Warning: Can’t activate LocalOnly or LocalPredicted ability %s when not local!"></a>9.1 LogAbilitySystem: Warning: Can’t activate LocalOnly or LocalPredicted ability %s when not local!</h2><p>你需要在<a href="#concepts-asc-setup">客户端初始化<code>ASC</code></a>.  </p><p><strong><a href="#table-of-contents">⬆ 返回目录</a></strong></p><p><span id="troubleshooting-scriptstructcache"></span></p><h2 id="9-2-ScriptStructCache错误"><a href="#9-2-ScriptStructCache错误" class="headerlink" title="9.2 ScriptStructCache错误"></a>9.2 ScriptStructCache错误</h2><p>你需要调用<a href="#concepts-asg-initglobaldata">UAbilitySystemGlobals::InitGlobalData()</a>.  </p><p><strong><a href="#table-of-contents">⬆ 返回目录</a></strong></p><p><span id="troubleshooting-replicatinganimmontages"></span></p><h2 id="9-3-动画蒙太奇不能同步到客户端"><a href="#9-3-动画蒙太奇不能同步到客户端" class="headerlink" title="9.3 动画蒙太奇不能同步到客户端"></a>9.3 动画蒙太奇不能同步到客户端</h2><p>确保在<a href="#concepts-ga">GameplayAbility</a>中正在使用的是<code>PlayMontageAndWait</code>节点而不是<code>PlayMontage</code>, 该<a href="#concepts-at">AbilityTask</a>可以通过<code>ASC</code>自动同步蒙太奇而<code>PlayMontage</code>节点不可以.  </p><p><strong><a href="#table-of-contents">⬆ 返回目录</a></strong></p><p><span id="troubleshooting-duplicatingblueprintactors"></span></p><h2 id="9-4-复制的蓝图Actor会将AttributeSet设置为nullptr"><a href="#9-4-复制的蓝图Actor会将AttributeSet设置为nullptr" class="headerlink" title="9.4 复制的蓝图Actor会将AttributeSet设置为nullptr"></a>9.4 复制的蓝图Actor会将AttributeSet设置为nullptr</h2><p>这是一个<a href="https://issues.unrealengine.com/issue/UE-81109">虚幻引擎的bug</a>, 当使用从一个存在的蓝图Actor类复制的方式来创建新的类, 这会让这个类中将AttributeSet指针设置为空指针.  </p><p>对此有一些变通的方法, 我已经成功地不在我的类内创建定制的<code>AttributeSet</code>指针(头文件中没有指针, 也不在构造函数中调用<code>CreateDefaultSubobject</code>),<br>而是直接在PostInitializeComponents()中向<code>ASC</code>添加<code>AttributeSets</code>(样本项目中没有显示).<br>复制的AttributeSets将仍然存在于<code>ASC</code>的<code>SpawnedAttributes</code>数组中. 它看起来像这样:  </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">AGDPlayerState::PostInitializeComponents</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Super::<span class="built_in">PostInitializeComponents</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (AbilitySystemComponent)</span><br><span class="line">&#123;</span><br><span class="line">AbilitySystemComponent-&gt;<span class="built_in">AddSet</span>&lt;UGDAttributeSetBase&gt;();</span><br><span class="line"><span class="comment">// ... 其他你可能拥有的属性集</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这种情况下, 你想要读取或者修改<code>AttributeSet</code>的值, 就需要调用<code>ASC</code>实例中的函数, 而不是<a href="#concepts-as-attributes"><code>AttributeSet</code>中定义的宏</a>.  </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** 返回当前(最终)属性值 */</span></span><br><span class="line"><span class="function"><span class="type">float</span> <span class="title">GetNumericAttribute</span><span class="params">(<span class="type">const</span> FGameplayAttribute &amp;Attribute)</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 设置一个属性的基础值。 当前激活的修改器不会被清除并将在NewBaseValue上发挥作用 */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">SetNumericAttributeBase</span><span class="params">(<span class="type">const</span> FGameplayAttribute &amp;Attribute, <span class="type">float</span> NewBaseValue)</span></span>;</span><br></pre></td></tr></table></figure><p>所以GetHealth()的实现将会如下:  </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">float</span> <span class="title">AGDPlayerState::GetHealth</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (AbilitySystemComponent)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> AbilitySystemComponent-&gt;<span class="built_in">GetNumericAttribute</span>(UGDAttributeSetBase::<span class="built_in">GetHealthAttribute</span>());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0.0f</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>设置(初始化)生命值属性的实现将会是这样:  </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">float</span> NewHealth = <span class="number">100.0f</span>;</span><br><span class="line"><span class="keyword">if</span> (AbilitySystemComponent)</span><br><span class="line">&#123;</span><br><span class="line">AbilitySystemComponent-&gt;<span class="built_in">SetNumericAttributeBase</span>(UGDAttributeSetBase::<span class="built_in">GetHealthAttribute</span>(), NewHealth);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>顺便提一下, 往<code>ASC</code>组件注册的每个<code>AttributeSet</code>类最多只有一个对象.  </p><p><strong><a href="#table-of-contents">⬆ Back to Top</a></strong></p><p><span id="acronyms"></span></p><h1 id="10-ASC常用术语缩略"><a href="#10-ASC常用术语缩略" class="headerlink" title="10. ASC常用术语缩略"></a>10. ASC常用术语缩略</h1><div class="table-container"><table><thead><tr><th style="text-align:center">术语</th><th style="text-align:center">缩略</th></tr></thead><tbody><tr><td style="text-align:center">AbilitySystemComponent</td><td style="text-align:center">ASC</td></tr><tr><td style="text-align:center">AbilityTask</td><td style="text-align:center">AT</td></tr><tr><td style="text-align:center">Action RPG Sample Project by Epic</td><td style="text-align:center">ARPG, ARPG Sample</td></tr><tr><td style="text-align:center">CharacterMovementComponent</td><td style="text-align:center">CMC</td></tr><tr><td style="text-align:center">GameplayAbility</td><td style="text-align:center">GA</td></tr><tr><td style="text-align:center">GameplayAbilitySystem</td><td style="text-align:center">GAS</td></tr><tr><td style="text-align:center">GameplayCue</td><td style="text-align:center">GC</td></tr><tr><td style="text-align:center">GameplayEffect</td><td style="text-align:center">GE</td></tr><tr><td style="text-align:center">GameplayEffectExecutionCalculation</td><td style="text-align:center">ExecCalc, Execution</td></tr><tr><td style="text-align:center">GameplayTag</td><td style="text-align:center">Tag, GT</td></tr><tr><td style="text-align:center">ModiferMagnitudeCalculation</td><td style="text-align:center">ModMagCalc, MMC</td></tr></tbody></table></div><p><strong><a href="#table-of-contents">⬆ 返回目录</a></strong></p><p><span id="resources"></span></p><h1 id="11-其他资源"><a href="#11-其他资源" class="headerlink" title="11. 其他资源"></a>11. 其他资源</h1><p><a href="https://docs.unrealengine.com/en-US/InteractiveExperiences/GameplayAbilitySystem/index.html">官方文档</a>  </p><p>源代码! 特别是<code>GameplayPrediction.h</code>.  </p><p><a href="https://www.unrealengine.com/marketplace/en-US/slug/action-rpg">Epic的Action RPG样例项目</a>  </p><p><a href="https://epicgames.ent.box.com/s/m1egifkxv3he3u3xezb9hzbgroxyhx89">来自Epic的Dave Ratti回复社区关于GAS的问题</a>  </p><p><a href="https://unrealslackers.org">Unreal Slackers Discord</a>有一个专注于GAS<code>#gameplay-abilities-plugin</code>的文字频道  </p><p><a href="https://github.com/Pantong51/GASContent">Dan ‘Pan’的Github库</a>  </p><p><a href="https://www.youtube.com/channel/UCCFUhQ6xQyjXDZ_d6X_H_-A">SabreDartStudios的YouTube视频</a></p><p><strong><a href="#table-of-contents">⬆ 返回目录</a></strong></p><p><span id="changelog"></span></p><h1 id="12-GAS更新日志"><a href="#12-GAS更新日志" class="headerlink" title="12. GAS更新日志"></a>12. GAS更新日志</h1><p>这是从Unreal Engine官方升级日志和我遇到的且未记录的升级中整理的一份值得一看的升级列表, 如果你发现某些没有列在其中, 请提issue或者PR.  </p><p><strong><a href="#table-of-contents">⬆ 返回目录</a></strong></p><p><span id="changelog-4.26"></span></p><h2 id="4-26"><a href="#4-26" class="headerlink" title="4.26"></a>4.26</h2><ul><li>GAS plugin is no longer flagged as beta.</li><li>Crash Fix: Fixed a crash when adding a gameplay tag without a valid tag source selection.</li><li>Crash Fix: Added the path string arg to a message to fix a crash in UGameplayCueManager::VerifyNotifyAssetIsInValidPath.</li><li>Crash Fix: Fixed an access violation crash in AbilitySystemComponent_Abilities when using a ptr without checking it.</li><li>Bug Fix: Fixed a bug where stacking GEs that did not reset the duration on additional instances of the effect being applied.</li><li>Bug Fix: Fixed an issue that caused CancelAllAbilities to only cancel non-instanced abilities.</li><li>New: Added optional tag parameters to gameplay ability commit functions.</li><li>New: Added StartTimeSeconds to PlayMontageAndWait ability task and improved comments.</li><li>New: Added tag container “DynamicAbilityTags” to FGameplayAbilitySpec. These are optional ability tags that are replicated with the spec. They are also captured as source tags by applied gameplay effects.</li><li>New: GameplayAbility IsLocallyControlled and HasAuthority functions are now callable from Blueprint.</li><li>New: Visual logger will now only collect and store info about instant GEs if we’re currently recording visual logging data.</li><li>New: Added support for redirectors on gameplay attribute pins in blueprint nodes.</li><li>New: Added new functionality for when root motion movement related ability tasks end they will return the movement component’s movement mode to the movement mode it was in before the task started.</li></ul><p><strong><a href="#table-of-contents">⬆ 返回目录</a></strong></p><p><span id="changelog-4.25.1"></span></p><h2 id="4-25-1"><a href="#4-25-1" class="headerlink" title="4.25.1"></a>4.25.1</h2><ul><li>Fixed! UE-92787 Crash saving blueprint with a Get Float Attribute node and the attribute pin is set inline</li><li>Fixed! UE-92810 Crash spawning actor with instance editable gameplay tag property that was changed inline</li></ul><p><strong><a href="#table-of-contents">⬆ 返回目录</a></strong></p><p><span id="changelog-4.25"></span></p><h2 id="4-25"><a href="#4-25" class="headerlink" title="4.25"></a>4.25</h2><ul><li>Fixed prediction of RootMotionSource AbilityTasks</li><li><a href="#concepts-as-attributes">GAMEPLAYATTRIBUTE_REPNOTIFY()</a> now additionally takes in the old Attribute value. We must supply that as the optional parameter to our OnRep functions. Previously, it was reading the attribute value to try to get the old value. However, if called from a replication function, the old value had already been discarded before reaching SetBaseAttributeValueFromReplication so we’d get the new value instead.</li><li>Added <a href="#concepts-ga-netsecuritypolicy">NetSecurityPolicy</a> to UGameplayAbility.</li><li>Crash Fix: Fixed a crash when adding a gameplay tag without a valid tag source selection.</li><li>Crash Fix: Removed a few ways for attackers to crash a server through the ability system.</li><li>Crash Fix: We now make sure we have a GamplayEffect definition before checking tag requirements.</li><li>Bug Fix: Fixed an issue with gameplay tag categories not applying to function parameters in Blueprints if they were part of a function terminator node.</li><li>Bug Fix: Fixed an issue with gameplay effects’ tags not being replicated with multiple viewports.</li><li>Bug Fix: Fixed a bug where a gameplay ability spec could be invalidated by the InternalTryActivateAbility function while looping through triggered abilities.</li><li>Bug Fix: Changed how we handle updating gameplay tags inside of tag count containers. When deferring the update of parent tags while removing gameplay tags, we will now call the change-related delegates after the parent tags have updated. This ensures that the tag table is in a consistent state when the delegates broadcast.</li><li>Bug Fix: We now make a copy of the spawned target actor array before iterating over it inside when confirming targets because some callbacks may modify the array.</li><li>Bug Fix: Fixed a bug where stacking GamplayEffects that did not reset the duration on additional instances of the effect being applied and with set by caller durations would only have the duration correctly set for the first instance on the stack. All other GE specs in the stack would have a duration of 1 second. Added automation tests to detect this case.</li><li>Bug Fix: Fixed a bug that could occur if handling gameplay event delegates modified the list of gameplay event delegates.</li><li>Bug Fix: Fixed a bug causing GiveAbilityAndActivateOnce to behave inconsistently.</li><li>Bug Fix: Reordered some operations inside FGameplayEffectSpec::Initialize to deal with a potential ordering dependency.</li><li>New: UGameplayAbility now has an OnRemoveAbility function. It follows the same pattern as OnGiveAbility and is only called on the primary instance of the ability or the class default object.</li><li>New: When displaying blocked ability tags, the debug text now includes the total number of blocked tags.</li><li>New: Renamed UAbilitySystemComponent::InternalServerTryActiveAbility to UAbilitySystemComponent::InternalServerTryActivateAbility.Code that was calling InternalServerTryActiveAbility should now call InternalServerTryActivateAbility.</li><li>New: Continue to use the filter text for displaying gameplay tags when a tag is added or deleted. The previous behaviour cleared the filter.</li><li>New: Don’t reset the tag source when we add a new tag in the editor.</li><li>New: Added the ability to query an ability system component for all active gameplay effects that have a specified set of tags. The new function is called GetActiveEffectsWithAllTags and can be accessed through code or blueprints.</li><li>New: When root motion movement related ability tasks end they now return the movement component’s movement mode to the movement mode it was in before the task started.</li><li>New: Made SpawnedAttributes transient so it won’t save data that can become stale and incorrect. Added null checks to prevent any currently saved stale data from propagating. This prevents problems related to bad data getting stored in SpawnedAttributes.</li><li>API Change: AddDefaultSubobjectSet has been deprecated. AddAttributeSetSubobject should be used instead.</li><li>New: Gameplay Abilities can now specify the Anim Instance on which to play a montage.</li></ul><p><strong><a href="#table-of-contents">⬆ 返回目录</a></strong></p><p><span id="changelog-4.24"></span></p><h2 id="4-24"><a href="#4-24" class="headerlink" title="4.24"></a>4.24</h2><ul><li>Fixed blueprint node Attribute variables resetting to None on compile.</li><li>Need to call <a href="#concepts-asg-initglobaldata">UAbilitySystemGlobals::InitGlobalData()</a> to use <a href="#concepts-targeting-data">TargetData</a> otherwise you will get ScriptStructCache errors and clients will be disconnected from the server. My advice is to always call this in every project now whereas before 4.24 it was optional.</li><li>Fixed crash when copying a GameplayTag setter to a blueprint that didn’t have the variable previously defined.</li><li>UGameplayAbility::MontageStop() function now properly uses the OverrideBlendOutTime parameter.</li><li>Fixed GameplayTag query variables on components not being modified when edited.</li><li>Added the ability for GameplayEffectExecutionCalculations to support scoped modifiers against “temporary variables” that aren’t required to be backed by an attribute capture.<ul><li>Implementation basically enables GameplayTag-identified aggregators to be created as a means for an execution to expose a temporary value to be manipulated with scoped modifiers; you can now build formulas that want manipulatable values that don’t need to be captured from a source or target.</li><li>To use, an execution has to add a tag to the new member variable ValidTransientAggregatorIdentifiers; those tags will show up in the calculation modifier array of scoped mods at the bottom, marked as temporary variables—with updated details customizations accordingly to support feature</li></ul></li><li>Added restricted tag quality-of-life improvements. Removed the default option for restricted GameplayTag source. We no longer reset the source when adding restricted tags to make it easier to add several in a row.</li><li>APawn::PossessedBy() now sets the owner of the Pawn to the new Controller. Useful because Mixed Replication Mode expects the owner of the Pawn to be the Controller if the ASC lives on the Pawn.</li><li>Fixed bug with POD (Plain Old Data) in FAttributeSetInittterDiscreteLevels.</li></ul><p><strong><a href="#table-of-contents">⬆ 返回目录</a></strong></p>]]></content>
    
    
    <summary type="html">GAS中文文档，更新至5.3版本（更新中）</summary>
    
    
    
    <category term="GAS" scheme="https://sumikiru.top/categories/GAS/"/>
    
    
    <category term="GAS" scheme="https://sumikiru.top/tags/GAS/"/>
    
    <category term="UE" scheme="https://sumikiru.top/tags/UE/"/>
    
  </entry>
  
  <entry>
    <title>CLion配置C++与Lua</title>
    <link href="https://sumikiru.top/posts/31d79f30.html"/>
    <id>https://sumikiru.top/posts/31d79f30.html</id>
    <published>2025-01-28T18:29:50.000Z</published>
    <updated>2025-01-28T18:29:50.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="C-篇"><a href="#C-篇" class="headerlink" title="C++篇"></a>C++篇</h1><p>CLion 安装等最基本的操作跳过，下面讲一下配置。以下配置对于 vscode 同样适用。</p><h2 id="CMakeList"><a href="#CMakeList" class="headerlink" title="CMakeList"></a>CMakeList</h2><p>新建 Cmake 项目，然后将 <code>CMakeList.txt</code> 内容修改为：<br><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">cmake_minimum_required(VERSION 3.28)  # 指定cmake最低支持的版本  </span><br><span class="line">  </span><br><span class="line">project(Algorithm)  # 项目名称  </span><br><span class="line">set(CMAKE_CXX_STANDARD 20)  # C++版本为C++20  </span><br><span class="line">  </span><br><span class="line">add_executable(Algorithm main.cpp)  # (程序名 文件名)</span><br><span class="line">add_executable(test test.cpp)</span><br></pre></td></tr></table></figure><br>注意程序名和文件名，应该写直接定义的名称。<br>然后目录右键，重新加载 CMake 项目，就可以运行和调试了。详细教程可以看 <a href="https://www.bilibili.com/video/BV1kM411X7uA?vd_source=6176273f0f24da0db424c2d99bd01fd5">CLion 安装流程与注意事项</a><br>记得进入设置-&gt;构建、执行、部署-&gt;CMake，勾选”在编辑CMakeLists.txt或其他CMake配置文件时重新加载CMake项目”</p><h2 id="终端乱码"><a href="#终端乱码" class="headerlink" title="终端乱码"></a>终端乱码</h2><p>终端没办法输出中文，会乱码，<strong>最可靠</strong>的方法是在输出前加上 <code>system(&quot;chcp 65001&quot;)</code>，例如：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;chcp 65001&quot;</span>);</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;你好世界&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="代码格式化"><a href="#代码格式化" class="headerlink" title="代码格式化"></a>代码格式化</h2><ol><li>下载插件 <code>clang-format</code>，然后进入设置-&gt;编辑器-&gt;代码样式，”常规”选项中勾选”检测并使用现有的文件缩进进行编辑”以及”启用ClangFormat”，点击右下角”应用”以后再确定（后面不再重复说明）。</li><li><p>在项目根目录下新建文件：<code>.clang-format</code>，内容如下，可自行修改, 仅供参考：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Language: Cpp  </span><br><span class="line">Standard: c++20 # 标准: Cpp03, Cpp11, Auto 更改的只是格式化标准，不代表运行版本  </span><br><span class="line">BasedOnStyle: Google  </span><br><span class="line">UseTab: Never # 使用空格而不是缩进符  </span><br><span class="line">IndentWidth: 4 # 缩进宽度为4个空格  </span><br><span class="line">TabWidth: 4 # tab长度  </span><br><span class="line">ColumnLimit: 80 # 单行的长度不超过80字符  </span><br><span class="line"># 禁止将非空（如单行）块合并到一行  </span><br><span class="line">AllowShortBlocksOnASingleLine: Empty  </span><br><span class="line"># 禁止将非空（如单行）函数合并到一行  </span><br><span class="line">AllowShortFunctionsOnASingleLine: Empty</span><br></pre></td></tr></table></figure></li><li><p>（选做）进入设置-&gt;工具-&gt;保存时的操作，勾选上“重新设置代码格式”，这样就可以在保存时进行代码格式化了。当然，你也可以不这样做，每次需要格式化的时候按下快捷键 <code>Ctrl + Alt + Shift + L</code>。</p></li></ol><p>💭以下内容为选做：</p><h2 id="其他插件配置"><a href="#其他插件配置" class="headerlink" title="其他插件配置"></a>其他插件配置</h2><h3 id="Leetcode-插件"><a href="#Leetcode-插件" class="headerlink" title="Leetcode 插件"></a>Leetcode 插件</h3><p>名字为”Leetcode with labuladong”，个人认为比插件 Leetcode Editor 好用一些（最主要是设置文件名称的问题，Leetcode Editor 总是保存不了自定义配置）。<br>安装以后侧边栏能看到，按照说明走不多说，登录的时候需要用到 cookie，这里跟着官方文档走即可：<a href="https://labuladong.online/algo/intro/jetbrains/#%E7%99%BB%E5%BD%95-%E5%8A%9B%E6%89%A3-leetcode-%E8%B4%A6%E5%8F%B7">登录Leetcode账号</a>。</p><h4 id="插件设置"><a href="#插件设置" class="headerlink" title="插件设置"></a>插件设置</h4><p>之后进入设置-&gt;工具-&gt;Leetcode with labuladong，进行以下修改：</p><ul><li>Website: <code>leetcode.cn</code>（美国站就选另一个）</li><li>CodeType: <code>C++</code></li><li>FilePath：看你希望放在哪里，但至少保证这个文件夹下存在 <code>CMakeList.txt</code>，能够运行 cpp 文件。例如 FilePath 为 <code>E:\Study\Algorithm</code>，则力扣文件会放在 <code>E:\Study\Algorithm\leetcode</code> 路径下</li><li>HtmlContent: 推荐勾选</li><li>labuladongCookie：同样填登录时用到的 cookie</li><li>Code FileName: 建议改为 <code>$!&#123;question.frontendQuestionId&#125;-$&#123;question. titleSlug&#125;</code>，这样能保证不含中文名，运行或调试不会报错，例如 <code>1-two-sum.cpp</code></li><li>Code Template: 建议改为<figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">\#include &quot;leetcode.h&quot;</span><br><span class="line">$&#123;question.code&#125;</span><br><span class="line">int main() &#123;</span><br><span class="line">    system(&quot;chcp 65001&quot;);</span><br><span class="line">    Solution solution;</span><br><span class="line">    /**</span><br><span class="line">     * 采用以下方式书写：</span><br><span class="line">    vector&lt;int&gt; nums = &#123;2, 7, 11, 15&#125;;</span><br><span class="line">    int target = 9;</span><br><span class="line">    vector&lt;int&gt; ans = solution.twoSum(nums, target);</span><br><span class="line">    cout &lt;&lt; ans[0] &lt;&lt; ans[1];</span><br><span class="line">     */</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>🚩注意：不要采用修改 <code>utf-8</code> 编码的方式解决中文乱码问题，应该加入 <code>system(&quot;chcp 65001&quot;);</code><br>应用-&gt;确定即可。</p><p>至于文中的 <code>\#include &quot;leetcode.h&quot;</code>，反斜杠是转义字符，<code>leetcode.h</code> 以及 <code>main</code> 函数都是为了保证本地运行和调试能够正常进行。你需要在对应的 FilePath 下的 <code>leetcode/editor/cn</code> 下加入头文件 <code>leetcode.h</code>，内容看个人，下面给出范例：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 万能头文件 #include &lt;bits/stdc++.h&gt;</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;list&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;set&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span>  </span></span><br><span class="line">  </span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br></pre></td></tr></table></figure><p>其他看官方文档讲解即可。如果你发现你的 cpp 无法运行，请看下一节。</p><h3 id="Single-File-Execution"><a href="#Single-File-Execution" class="headerlink" title="Single File Execution"></a>Single File Execution</h3><p>插件全名为”C/C++ Single File Execution”，用户单个 cpp 文件的运行，可以很好解决前面所说的问题。<br>鼠标右键可以看到选项 <code>add executable for single c/cpp file</code>，点击后重新加载 CMake 项目（如未自动变化请手动右键文件根目录），它会自动在 <code>CMakeLists.txt</code> 末尾加上 <code>addexecutable()</code> 。</p><h3 id="杂项"><a href="#杂项" class="headerlink" title="杂项"></a>杂项</h3><p>一些其他推荐使用的插件：</p><ul><li>CodeGlance Pro</li><li>Key Promoter X</li><li>Nested Brackets Colorer</li><li>One Dark Theme</li><li>Atom Material Icons</li><li>Competitive Programming Helper（仅限 vscode）</li></ul><p>vscode 配置 C++，需要以下插件：</p><ul><li>C/C++</li><li>clangd</li><li>Clang-Format</li><li>Code Runner</li><li>Code Debugger</li><li>CodeLLDB<br>这样就不需要再配置 <code>launch.json</code> 和 <code>task.json</code> 文件了。</li></ul><h1 id="Lua-篇"><a href="#Lua-篇" class="headerlink" title="Lua 篇"></a>Lua 篇</h1><p>先下载好插件 <strong>EmmyLua</strong>，进入设置-&gt;语言和框架-&gt;EmmyLua-&gt;修改 Lua 版本。</p><h2 id="Lua-环境配置"><a href="#Lua-环境配置" class="headerlink" title="Lua 环境配置"></a>Lua 环境配置</h2><p>教程太多，这里不多赘述，推荐跟着教程 <a href="https://blog.csdn.net/weixin_44394801/article/details/123200893">Lua环境配置——雪野Solye</a> 完成，直到 Lua 测试时能够输出版本号。我的版本为 <code>5.4.2</code>。</p><h2 id="资源管理：LuaRocks"><a href="#资源管理：LuaRocks" class="headerlink" title="资源管理：LuaRocks"></a>资源管理：LuaRocks</h2><p>先看看自己的 Lua 文件夹下是不是缺少 <strong>include</strong> 文件夹，如果是，下载对应的 <code>dllw6_lib</code> 压缩包：<a href="https://luabinaries.sourceforge.net/download.html">下载链接</a><br>解压文件按照以下目录结构移动到 Lua 文件夹下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Lua-5.4.2_Win64_bin/</span><br><span class="line">│</span><br><span class="line">├── include/</span><br><span class="line">│   ├─── lauxlib.h</span><br><span class="line">│   ├─── lua.h</span><br><span class="line">│   ├─── lua.hpp</span><br><span class="line">│   ├─── luaconf.h</span><br><span class="line">│   └─── lualib.h</span><br><span class="line">│</span><br><span class="line">├── liblua54.a//不同平台可能不一致，可能是lua54.lib</span><br><span class="line">├── lua54.dll</span><br><span class="line">├── lua54.exe</span><br><span class="line">├── luac54.exe</span><br><span class="line">└── wlua54.exe</span><br></pre></td></tr></table></figure><p>现在下载 Luarocks，注意是 <code>win32.zip</code>（不论是 win32 还是 win64），放在 <code>Lua-5.4.2_Win64_bin</code> 文件夹以外的地方。注意版本，luarocks 3.11.1对应 lua 5.4<br>进入终端，cd 到 luarocks 所在文件夹, 比如：<code>E:\Lua\luarocks-3.11.1-win32</code>。</p><blockquote><p>以下参考自<a href="https://www.cnblogs.com/xulang/p/12535667.html">文章</a></p></blockquote><p>执行命令<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">install.bat /F /LUA $LuaBinDir /P $LuaRocksTargetDir /SELFCONTAINED /Q</span><br></pre></td></tr></table></figure><br>其中 <code>$LuaBinDir</code> 表示当前本机 Lua 运行环境地址，<code>$LuaRocksTargetDir</code> 表示要将 luarocks 安装到的地址（我直接安装在了 Lua 文件夹下，和 <code>Lua-5.4.2_Win64_bin</code> 平级）。不要使用 <code>/NOADMIN</code> 指令，会导致缺少权限无法完成。</p><p>比如 <code>install.bat /F /LUA E:\Lua\Lua-5.4.2_Win64_bin /P E:\Lua\luarocks-3.11.1 /SELFCONTAINED /Q</code><br>回车后出现 <code>Lua Rocks is installed!</code> 提示则成功，可以输入 <code>where luarocks</code> 查看 (cmd 可以，powershell 不行)，显示出 <code>luarocks.bat</code> 的地址即成功。</p><h2 id="调试：LuaSocket"><a href="#调试：LuaSocket" class="headerlink" title="调试：LuaSocket"></a>调试：LuaSocket</h2><blockquote><p>终端输入 <code>luarocks install luasocket</code>，成功即可进入下一部分。如果失败或者没有安装 luarocks，则执行以下步骤。<br>参考自视频：<a href="https://www.bilibili.com/video/BV1tJige4EsZ?vd_source=6176273f0f24da0db424c2d99bd01fd5">Windows环境下luasocket的编译和使用</a></p></blockquote><ol><li>cd 到 Lua 文件夹下，输入 <code>git clone https://github.com/lunarmodules/luasocket.git</code>，默认下载最新版本 <code>3.1.0</code>，下载后 Lua 文件夹下会有一个 luasocket 子文件夹。</li><li>用 vs 打开 <code>luasocket.sln</code>，确认重定向项目，生成-&gt;重新生成解决方案，这里会出现报错。</li><li>修改 luasocket 文件夹下的 <code>Lua.props</code>，将第 10-18 行修改为：</li></ol><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;PropertyGroup Label=<span class="string">&quot;UserMacros&quot;</span>&gt;</span><br><span class="line">  &lt;LUAV&gt;<span class="number">5.4</span>&lt;/LUAV&gt;</span><br><span class="line">  &lt;LUAPREFIX&gt;E:\Lua\lua<span class="number">-5.4</span><span class="number">.2</span>_Win64_bin&lt;/LUAPREFIX&gt;</span><br><span class="line">  &lt;LUALIB&gt;$(LUAPREFIX)&lt;/LUALIB&gt;</span><br><span class="line">  &lt;LUACDIR&gt;$(LUAPREFIX)&lt;/LUACDIR&gt;</span><br><span class="line">  &lt;LUALDIR&gt;$(LUAPREFIX)&lt;/LUALDIR&gt;</span><br><span class="line">  &lt;LUAINC&gt;$(LUAPREFIX)\include&lt;/LUAINC&gt;</span><br><span class="line">  &lt;LUALIBNAME&gt;liblua54.a&lt;/LUALIBNAME&gt;</span><br><span class="line">&lt;/PropertyGroup&gt;</span><br></pre></td></tr></table></figure><p>仅作参考，以自己的目录为准。值得注意的是 <code>LUALIBNAME</code>，windows 平台上的文件为 <code>liblua54.a</code>，而 linux 平台可能是 <code>lua54.lib</code>，请自行前往 <code>Lua-5.4.X_Win64_bin/</code> 查看。</p><ol><li>回到 vs，重新生成解决方案，如果未成功则说明第 3 步存在错误。</li><li>找到 <code>luasocket\x64\Release</code> 文件夹，拷贝 <code>mine</code> 和 <code>socket</code> 文件夹到 <code>Lua-5.4.X_Win64_bin</code> 文件夹下；并在 <code>Lua-5.4.X_Win64_bin</code> 文件夹下新建 <code>lua</code> 文件夹，将 <code>luasocket\src</code> 文件夹中的<strong>所有 lua 文件</strong>全部拷贝到 <code>Lua-5.4.X_Win64_bin</code> 文件夹下。</li><li><p>打开 CLion，在运行/调试配置进行如下设置：<br><img src="https://i.imgur.com/mQuZERG.png" alt=""></p><p><img src="https://i.imgur.com/dnoI1gE.png" alt=""><br>这样，就可以进行 lua 文件的运行和调试了。之前 clone 的 luasocket 文件夹可以删掉了。</p></li><li>调试的时候，你可能会发现：手动终止调试时，会出现报错（尽管不影响），并且无法重新启动调试。这是因为 Mobdebug 在 CLion 上会有一些 Bug。接下来我会自行配置 Mobdebug，尝试修复其 bug。</li></ol><h2 id="调试：Mobdebug"><a href="#调试：Mobdebug" class="headerlink" title="调试：Mobdebug"></a>调试：Mobdebug</h2><blockquote><p>参考自：<a href="https://github.com/EmmyLua/IntelliJ-EmmyLua/issues/352">Not working debug after resume #352</a><br>以及大佬 neopaf 提的 issue：<a href="https://github.com/neopaf/MobDebug/issues/1">IntelliJ IDEA + EmmyLua + mobdebug = very unstable handshake #1</a></p></blockquote><p>直接下载我修改好的也可以：<a href="https://github.com/sumikiru/MobDebug/blob/master/src/mobdebug.lua">MobDebug v0.805sumikiru</a>，然后就可以跳过该部分了。</p><p><a href="https://github.com/pkulchenko/MobDebug/blob/master/src/mobdebug.lua">MobDebug v0.805 下载地址</a>，下载好的 <code>mobdebug.lua</code> 放入 <code>lua-5.4.X_Win64_bin</code> 文件夹下。接下来进行修改：</p><ol><li><p>找到第 129 行，修改 basedir: </p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> basedir = <span class="string">&quot;E:/Lua/lua-5.4.2_Win64_bin&quot;</span></span><br></pre></td></tr></table></figure></li><li><p>找到第 492 行，注释掉改行：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- buf = peer:receive(1)</span></span><br></pre></td></tr></table></figure><p>到这里，就可以反复重新启动调试了。</p></li><li><p>在第 719 行后，加入：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- Manual addition of a judgment condition: whether the debug program is manually terminated in the IDE. If so, output and exit directly without reporting an error.</span></span><br><span class="line"><span class="comment">-- The judgment condition cannot be guaranteed to be entirely accurate.</span></span><br><span class="line"><span class="keyword">elseif</span> <span class="keyword">not</span> <span class="built_in">status</span> <span class="keyword">and</span> res <span class="keyword">and</span> res ~= <span class="string">&#x27;done&#x27;</span> <span class="keyword">and</span> res ~= <span class="string">&#x27;stack&#x27;</span> <span class="keyword">and</span> res ~= <span class="string">&#x27;exit&#x27;</span> <span class="keyword">and</span> <span class="keyword">not</span> abort <span class="keyword">then</span></span><br><span class="line">  <span class="built_in">io</span>.<span class="built_in">stderr</span>:<span class="built_in">write</span>(<span class="string">&#x27;Debugging ended: You have manually terminated the debugging session.&#x27;</span>)</span><br><span class="line">  <span class="comment">-- error(res, 2)</span></span><br><span class="line">  mobdebug.onexit(<span class="number">1</span>, <span class="literal">true</span>)</span><br></pre></td></tr></table></figure><p>这样，手动终止程序时，能够退出并提示”Debugging ended: You have manually terminated the debugging session.”</p></li></ol><h2 id="结束：Lua-文件目录结构"><a href="#结束：Lua-文件目录结构" class="headerlink" title="结束：Lua 文件目录结构"></a>结束：Lua 文件目录结构</h2><p>结束前，让我们先测试一下前面的操作是否成功。在 CLion 中运行包含以下代码的 lua 文件：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> socket = <span class="built_in">require</span>(<span class="string">&quot;socket&quot;</span>)  </span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;LuaSocket version:&quot;</span>, socket.<span class="built_in">_VERSION</span>)  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">local</span> mobdebug = <span class="built_in">require</span>(<span class="string">&quot;mobdebug&quot;</span>)  </span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;mobdebug version:&quot;</span>, mobdebug.<span class="built_in">_VERSION</span>)</span><br></pre></td></tr></table></figure><p>能够成功打印出版本号，则说明成功。</p><p><strong>确认 Lua 目录结构：</strong><br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">Lua-5.4.2_Win64_bin/</span><br><span class="line">│</span><br><span class="line">├── include/</span><br><span class="line">│   ├─── lauxlib.h</span><br><span class="line">│   ├─── lua.h</span><br><span class="line">│   ├─── lua.hpp</span><br><span class="line">│   ├─── luaconf.h</span><br><span class="line">│   └─── lualib.h</span><br><span class="line">│</span><br><span class="line">├── lua/</span><br><span class="line">│   ├─── ftp.lua</span><br><span class="line">│   ├─── headers.lua</span><br><span class="line">│   ├─── http.lua</span><br><span class="line">│   ├─── ltn12.lua</span><br><span class="line">│   ├─── mime.lua</span><br><span class="line">│   ├─── ftp.lua</span><br><span class="line">│   ├─── smtp.lua</span><br><span class="line">│   ├─── socket.lua</span><br><span class="line">│   ├─── tp.lua</span><br><span class="line">│   └─── url.lua</span><br><span class="line">│</span><br><span class="line">├── mime/</span><br><span class="line">│   ├─── core.dll</span><br><span class="line">│   ├─── core.exp</span><br><span class="line">│   ├─── core.lib</span><br><span class="line">│   └─── core.pdb</span><br><span class="line">│</span><br><span class="line">├── socket/</span><br><span class="line">│   ├─── core.dll</span><br><span class="line">│   ├─── core.exp</span><br><span class="line">│   ├─── core.lib</span><br><span class="line">│   └─── core.pdb</span><br><span class="line">│</span><br><span class="line">├── liblua54.a//不同平台可能不一致，可能是lua54.lib</span><br><span class="line">├── lua54.dll</span><br><span class="line">├── lua54.exe</span><br><span class="line">├── luac54.exe</span><br><span class="line">├── mobdebug.lua</span><br><span class="line">└── wlua54.exe</span><br></pre></td></tr></table></figure></p><h2 id="格式化"><a href="#格式化" class="headerlink" title="格式化"></a>格式化</h2><p>和前文 <code>clang-format</code> 配置一致。</p>]]></content>
    
    
    <summary type="html">CLion配置C++和Lua的运行与调试</summary>
    
    
    
    <category term="环境配置" scheme="https://sumikiru.top/categories/%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/"/>
    
    
    <category term="环境配置" scheme="https://sumikiru.top/tags/%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/"/>
    
    <category term="C++" scheme="https://sumikiru.top/tags/C/"/>
    
    <category term="Lua" scheme="https://sumikiru.top/tags/Lua/"/>
    
  </entry>
  
  <entry>
    <title>语言基础4.并发与多线程</title>
    <link href="https://sumikiru.top/posts/4fee29fb.html"/>
    <id>https://sumikiru.top/posts/4fee29fb.html</id>
    <published>2024-12-15T19:52:10.000Z</published>
    <updated>2024-12-23T23:16:03.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>参考文章：<a href="https://www.zhihu.com/tardis/zm/art/194198073">C++多线程开发基础入门教程</a>，<a href="https://www.zhihu.com/column/c_1479157429707059201">C++学习笔记：并发与多线程</a><br>参考视频：<a href="https://www.bilibili.com/video/BV1An4y1d7Jc?vd_source=6176273f0f24da0db424c2d99bd01fd5">C++编程进阶教程</a></p></blockquote><h1 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h1><h2 id="什么是线程、进程、并发"><a href="#什么是线程、进程、并发" class="headerlink" title="什么是线程、进程、并发"></a>什么是线程、进程、并发</h2><p><strong>线程</strong>（Thread）是操作系统能够进行CPU调度的<strong>最小单位</strong>，它被<strong>包含在进程（program）之中</strong>，一个进程可包含单个或者多个线程。<br>一条线程指的是进程中单一的控制流，每条线程执行不同的任务。</p><p><strong>进程</strong>是运行起来的可执行程序。<br><strong>并发</strong>是指多个任务同时发生，一个程序同时执行多个独立任务。</p><h2 id="进程与线程的关系"><a href="#进程与线程的关系" class="headerlink" title="进程与线程的关系"></a>进程与线程的关系</h2><p>一个进程可以包含多个线程，这些线程<font color="#00b050">共享</font>相同的<u>进程空间（代码段、数据段、堆）</u>和<u>系统资源（文件描述符、信号处理）</u>，但各自有<font color="#00b050">独立的栈空间和线程控制块</font>，不共享内存。</p><p>🚀详细区分：</p><ol><li><strong>容器</strong>：每个进程都有相应的线程。进程是线程的<font color="#00b050">容器</font>。</li><li><strong>最小单位</strong>：进程是<strong>资源分配</strong>的最小单位，而线程是<strong>程序执行</strong>的最小单位。</li><li><strong>地址空间</strong>：进程有自己<font color="#00b050">独立的地址空间</font>，而线程没有独立的地址空间，<strong>同一进程</strong>的线程<font color="#00b050">共享本进程的地址空间</font>。</li><li><strong>资源</strong>：进程之间的<font color="#00b050">资源是独立的</font>，而同一进程内的线程<font color="#00b050">共享本进程的资源</font>。</li><li><strong>并发执行</strong>：进程可以并发执行，<strong>同一进程</strong>内的多个线程也可以并发执行。</li></ol><p>锅炉爷爷是一个进程，每条手可以被看成一个线程。</p><h2 id="线程的特点"><a href="#线程的特点" class="headerlink" title="线程的特点"></a>线程的特点</h2><ol><li><strong>轻量级</strong>：与进程相比，线程的创建和销毁成本低。因为线程是进程的一个执行流，共享进程的大部分资源，只需要少量的额外开销来维护进程的状态和控制信息。</li><li><strong>共享地址空间和资源</strong>：同一进程内的线程共享进程地址空间和全局变量等资源，这使得线程间通信更加便捷。但是这也带来了数据同步和互斥问题，需要适当的同步机制来避免数据竞争和死锁的问题。</li><li><strong>并发执行</strong>：多个线程可以在同一时间内并发执行，提高了程序的执行效率。但是由于线程的执行顺序和速度受到操作系统调度策略和硬件性能的影响，因此线程的执行结果可能是不确定的。</li><li><strong>独立调度</strong>：线程是独立调度的基本单位。在多线程操作系统中，调度器根据线程的优先级、状态等因素来决定线程的调度顺序和执行时间。</li></ol><h2 id="什么是多线程编程"><a href="#什么是多线程编程" class="headerlink" title="什么是多线程编程"></a>什么是多线程编程</h2><p>一个<font color="#00b050">程序中创建多个线程并发</font>的执行，每个线程执行不同的任务。</p><h2 id="为什么使用多线程-并发（优点）"><a href="#为什么使用多线程-并发（优点）" class="headerlink" title="为什么使用多线程/并发（优点）"></a>为什么使用多线程/并发（优点）</h2><ol><li>充分利用 CPU 资源</li><li>提高程序响应速度</li><li>便于程序设计和维护</li></ol><h2 id="并发与并行的区别"><a href="#并发与并行的区别" class="headerlink" title="并发与并行的区别"></a>并发与并行的区别</h2><ul><li>并发：同一时间段，多个任务<font color="#00b050">交替</font>执行。</li><li>并行：同一时间段，多个任务<font color="#00b050">同时</font>执行。</li></ul><h2 id="线程的声明周期"><a href="#线程的声明周期" class="headerlink" title="线程的声明周期"></a>线程的声明周期</h2><ol><li>新建状态 New</li><li>就绪状态 Runnable</li><li>运行状态 Running</li><li>阻塞状态 Blocked</li><li>死亡状态 Dead</li></ol><h1 id="Thread-创建线程"><a href="#Thread-创建线程" class="headerlink" title="Thread 创建线程"></a>Thread 创建线程</h1><h2 id="总体代码"><a href="#总体代码" class="headerlink" title="总体代码"></a>总体代码</h2><p>需要包含头文件 <code>&lt;thread&gt;</code>。可通过回调函数、仿函数、Lambda表达式创建。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//通过函数来创建线程：</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">myprint</span><span class="params">()</span><span class="comment">//初始函数 //回调函数</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;自己创建的线程开始执行&quot;</span> &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;自己创建的线程执行中1&quot;</span> &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;自己创建的线程执行中2&quot;</span> &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;自己创建的线程执行中3&quot;</span> &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;自己创建的线程执行中4&quot;</span> &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;自己创建的线程执行中5&quot;</span> &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;自己创建的线程执行完毕&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test05_01</span><span class="params">()</span> <span class="comment">//通过函数来创建线程</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="function">thread <span class="title">myobj</span><span class="params">(myprint)</span></span>; <span class="comment">//thread：创建线程的类；//创建线程，调用myprint，从myprint开始执行；</span></span><br><span class="line"><span class="comment">// 🚩创建该线程以后，线程就已经开始执行，并不是等到调用join()或者detach()时才开始执行</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (myobj.<span class="built_in">joinable</span>())<span class="comment">//判断能不能join或者detach，true表示可以join或者detach；</span></span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;joinable() = true&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;joinable() = false&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 🚩当线程启动后，一定要在和线程相关的thread对象被销毁前，对线程调用join()或者detach()方法</span></span><br><span class="line">myobj.<span class="built_in">join</span>();<span class="comment">//阻塞主线程，让主线程等待子线程执行完毕，然后子线程和主线程汇合；</span></span><br><span class="line"><span class="comment">//myobj.detach(); //一旦使用detach()后，与这个主线程关联的thread对象就失去了与这个主线程的关联，此时这个子线程就会在后台运行（守护线程）；</span></span><br><span class="line"><span class="comment">//这个子线程就相当于被C++运行时库接管，这个子线程运行完后，由运行时库清理该线程相关资源；就不能再用join()接管回来了；</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (myobj.<span class="built_in">joinable</span>())</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;joinable2() = true&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;joinable2() = false&quot;</span> &lt;&lt; endl; <span class="comment">//join()之后也不能再join</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;主线程运行结束&quot;</span> &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;主线程运行结束2&quot;</span> &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;主线程运行结束3&quot;</span> &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;主线程运行结束4&quot;</span> &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;主线程运行结束5&quot;</span> &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;主线程运行结束6&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 通过类来创建线程，类作为可调用对象（仿函数）：</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TA</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">TA</span>(<span class="type">int</span> i):<span class="built_in">m_i</span>(i) <span class="comment">//有参构造 //不能用引用int &amp;i</span></span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;TA有参构造函数被执行&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">TA</span>(<span class="type">const</span> TA &amp;ta) :<span class="built_in">m_i</span>(ta.m_i) <span class="comment">//拷贝构造</span></span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;TA拷贝构造函数被执行&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">~<span class="built_in">TA</span>() <span class="comment">//析构</span></span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;TA析构函数被执行&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">()</span><span class="comment">//不能带参数 //operator()()就是线程的入口点</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;operator()线程开始执行&quot;</span> &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;m_i = &quot;</span> &lt;&lt; m_i &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;m_i = &quot;</span> &lt;&lt; m_i &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;m_i = &quot;</span> &lt;&lt; m_i &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;m_i = &quot;</span> &lt;&lt; m_i &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;m_i = &quot;</span> &lt;&lt; m_i &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;m_i = &quot;</span> &lt;&lt; m_i &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;operator()线程执行完毕&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//int &amp;m_i;</span></span><br><span class="line"><span class="type">int</span> m_i;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test05_02</span><span class="params">()</span> <span class="comment">//通过类来创建线程</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> myi = <span class="number">6</span>;</span><br><span class="line"><span class="function">TA <span class="title">ta</span><span class="params">(myi)</span></span>;</span><br><span class="line"><span class="function">thread <span class="title">myjob</span><span class="params">(ta)</span></span>;<span class="comment">//ta: 可调用对象//ta是被复制到了线程中（拷贝构造），主线程结束后这个被复杂的对象依然存在；只要没有引用、指针就不会有问题；</span></span><br><span class="line">myjob.<span class="built_in">join</span>();<span class="comment">//等待线程结束</span></span><br><span class="line"><span class="comment">//如果用detach()，因为有局部变量ta，且构造函数里是引用，主线程运行结束后会回收这块局部变量ta的内存，在子线程的构造函数里就获取不到这个地址了，会产生不可预料的后果；</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;主线程与子线程汇合&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//用Lambda表达式创建线程：（前提是和test05_03一样在局部作用域中才行，不能赋值给全局变量）</span></span><br><span class="line"><span class="keyword">auto</span> mylamthread = []() <span class="comment">//线程入口</span></span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Lambda线程开始执行&quot;</span> &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Lambda线程执行结束&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test05_03</span><span class="params">()</span><span class="comment">//用Lambda表达式创建线程</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="function">thread <span class="title">myjob</span><span class="params">(mylamthread)</span></span>;</span><br><span class="line">myjob.<span class="built_in">join</span>();</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;主线程与子线程汇合&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="通过可调用对象创建线程"><a href="#通过可调用对象创建线程" class="headerlink" title="通过可调用对象创建线程"></a>通过可调用对象创建线程</h2><ol><li>函数指针</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">FunctionPtrTask</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Executed&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">void</span> (*ptr)() = []()  <span class="comment">// 另一种</span></span><br><span class="line">&#123;  </span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Executed&quot;</span> &lt;&lt; endl;  </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="function">thread <span class="title">t</span><span class="params">(FunctionPtrTask)</span></span>;</span><br><span class="line">t.<span class="built_in">join</span>();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>成员函数指针</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">TestClass</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MemberFunctionTask</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Executed&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">TestClass obj;</span><br><span class="line"><span class="function">thread <span class="title">t</span><span class="params">(&amp;TestClass::MemberFunctionTask, &amp;obj)</span></span>;</span><br><span class="line">t.<span class="built_in">join</span>();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>Lambda 表达式</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line"><span class="comment">// Lambda表达式放在全局作用域中会导致类型问题，建议放在局部作用域中使用</span></span><br><span class="line">    <span class="function">thread <span class="title">t</span><span class="params">([]()  </span></span></span><br><span class="line"><span class="params"><span class="function">    &#123;  </span></span></span><br><span class="line"><span class="params"><span class="function">        std::cout &lt;&lt; <span class="string">&quot;Executed&quot;</span> &lt;&lt; endl;  </span></span></span><br><span class="line"><span class="params"><span class="function">    &#125;)</span></span>;  </span><br><span class="line">    t.<span class="built_in">join</span>();  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>或者：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    function&lt;<span class="type">void</span>(<span class="type">void</span>)&gt; Lambda = []()  </span><br><span class="line">    &#123;  </span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Executed&quot;</span> &lt;&lt; endl;  </span><br><span class="line">    &#125;;  </span><br><span class="line">    <span class="function">thread <span class="title">t</span><span class="params">(Lambda)</span></span>;  </span><br><span class="line">    t.<span class="built_in">join</span>();  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>🤔例子：不在同一作用域，有警告<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">function&lt;<span class="type">void</span>(<span class="type">void</span>)&gt; WrongLambda = []()  <span class="comment">//警告</span></span><br><span class="line">&#123;  </span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Executed&quot;</span> &lt;&lt; endl;  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"><span class="built_in">void</span> (*ptr)() = []()  <span class="comment">//函数指针同理</span></span><br><span class="line">&#123;  </span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Executed&quot;</span> &lt;&lt; endl;  </span><br><span class="line">&#125;;</span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="function">thread <span class="title">t</span><span class="params">(WrongLambda)</span></span>;  </span><br><span class="line">    t.<span class="built_in">join</span>();  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ol><li>仿函数 functor（也叫函数对象）</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Functor</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">()</span><span class="comment">//不能带参数</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Executed&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Functor functor;</span><br><span class="line"><span class="function">thread <span class="title">t</span><span class="params">(functor)</span></span>;</span><br><span class="line">t.<span class="built_in">join</span>();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>绑定对象（<code>std::bind</code> 创建）</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">FunctionWithArgs</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;a = &quot;</span> &lt;&lt; a &lt;&lt; <span class="string">&quot;,b = &quot;</span> &lt;&lt; b &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">auto</span> BoundFunc = std::<span class="built_in">bind</span>(FunctionWithArgs, <span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line"><span class="function">thread <span class="title">t</span><span class="params">(BoundFunc)</span></span>;</span><br><span class="line">t.<span class="built_in">join</span>();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="线程参数传递"><a href="#线程参数传递" class="headerlink" title="线程参数传递"></a>线程参数传递</h2><h3 id="通过值传递"><a href="#通过值传递" class="headerlink" title="通过值传递"></a>通过值传递</h3><p>见前文，1-4 都没传递任何参数。如果要值传递参数且不使用 <code>std::bind</code>，参考以下代码：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="built_in">void</span> (*ptr)(<span class="type">int</span>) = [](<span class="type">int</span> x)  </span><br><span class="line">    &#123;  </span><br><span class="line">        std::cout &lt;&lt; x &lt;&lt; endl;  </span><br><span class="line">    &#125;;  </span><br><span class="line">    <span class="function">thread <span class="title">t</span><span class="params">(ptr, <span class="number">45</span>)</span></span>; <span class="comment">//输出45 </span></span><br><span class="line">    t.<span class="built_in">join</span>();  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>或者在使用了 <code>std::bind</code> 的情况下：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">FunctionWithArgs</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;a = &quot;</span> &lt;&lt; a &lt;&lt; <span class="string">&quot;,b = &quot;</span> &lt;&lt; b &lt;&lt; endl;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="keyword">auto</span> BoundFunc = std::<span class="built_in">bind</span>(FunctionWithArgs, <span class="number">1</span>, placeholders::_1);  </span><br><span class="line">    <span class="function">thread <span class="title">t</span><span class="params">(BoundFunc, <span class="number">2</span>)</span></span>; <span class="comment">//a = 1,b = 2  </span></span><br><span class="line">    t.<span class="built_in">join</span>();  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="通过引用传递"><a href="#通过引用传递" class="headerlink" title="通过引用传递"></a>通过引用传递</h3><p>这意味着原始数据和线程中使用的数据是同一个实体（而不是副本），这就需要小心了，如果你在一个线程中修改了数据，这些修改将在所有引用该数据的线程中可见。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">ModifyAndPrint</span><span class="params">(<span class="type">int</span>&amp; a, <span class="type">int</span>&amp; b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">a += <span class="number">5</span>;</span><br><span class="line">b += <span class="number">10</span>;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Modified Values:&quot;</span> &lt;&lt; a &lt;&lt; <span class="string">&quot;,&quot;</span> &lt;&lt; b &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> x = <span class="number">5</span>;</span><br><span class="line"><span class="type">int</span> y = <span class="number">10</span>;</span><br><span class="line"><span class="function">thread <span class="title">t</span><span class="params">(ModifyAndPrint, std::ref(x), std::ref(y))</span></span>;</span><br><span class="line">t.<span class="built_in">join</span>();</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Values in main thread: &quot;</span> &lt;&lt; x &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; y &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Modified Values:10,20</span></span><br><span class="line"><span class="comment">//Values in main thread: 10, 20</span></span><br></pre></td></tr></table></figure><p>这里使用了 <code>std::ref</code> 来包装 <code>x</code> 和 <code>y</code> 的引用并进行参数传递。</p><p>🚀注意事项：</p><ul><li>线程安全性：引用传递数据时需要保证对数据的访问是线程安全的，否则可能遇到数据竞争等并发问题。</li><li>资源管理：特别是在新线程使用了动态分配的内存时，确保这些资源在不再需要的时候被正确释放。</li><li>异常处理：新线程中抛出的异常不会自动传播到创建该子线程的线程，所以需要确保在新线程中处理可能产生的所有异常（不要尝试在主线程中捕获子线程中可能产生的异常）。</li></ul><h2 id="join-与-detach-的区别"><a href="#join-与-detach-的区别" class="headerlink" title="join 与 detach 的区别"></a>join 与 detach 的区别</h2><ul><li><strong><code>join</code></strong>：阻塞调用，等待线程完成，适用于需要同步和资源管理的场景。</li><li><strong><code>detach</code></strong>：非阻塞调用，线程独立运行，适用于后台任务或不需要同步的场景。 </li><li><strong>必须调用 <code>join</code> 或 <code>detach</code></strong>：否则程序会崩溃。</li><li>调用 <code>join</code> 或 <code>detach</code> 后，线程对象不再与实际线程相关联，线程对象可以安全销毁。</li><li>一个线程对象只能调用一次 <code>join</code> / <code>detach</code> 方法。</li></ul><p>✅表格：</p><div class="table-container"><table><thead><tr><th>特性</th><th>join</th><th>detach</th></tr></thead><tbody><tr><td>阻塞性</td><td>阻塞调用，等待线程完成</td><td>非阻塞调用，立即返回（从主线程分离，和主线程并发执行）</td></tr><tr><td>资源管理</td><td>线程完成后，资源被回收</td><td>线程独立运行，资源由操作系统管理</td></tr><tr><td>线程控制</td><td>主线程需要等待线程完成</td><td>主线程不需要等待线程完成</td></tr><tr><td>线程对象状态</td><td>调用 <code>join</code> 后，线程对象变为无效</td><td>调用 <code>detach</code> 后，线程对象变为无效</td></tr><tr><td>使用场景</td><td>需要等待线程结果或同步时</td><td>线程独立运行，不需要同步（如后台任务）</td></tr></tbody></table></div><p>💻代码示例：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">SayHello</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(i &lt; <span class="number">1000</span>)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Hello: &quot;</span> &lt;&lt; i &lt;&lt; endl;</span><br><span class="line">i++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="function">thread <span class="title">t</span><span class="params">(SayHello)</span></span>;</span><br><span class="line">t.<span class="built_in">join</span>();<span class="comment">//阻塞主线程</span></span><br><span class="line"><span class="comment">//t.detach();//从主线程中分离出去</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;This is main Thread.&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用t.join();</span></span><br><span class="line"><span class="comment">//Hello: 0</span></span><br><span class="line"><span class="comment">//Hello: 1</span></span><br><span class="line"><span class="comment">//......</span></span><br><span class="line"><span class="comment">//Hello: 998</span></span><br><span class="line"><span class="comment">//Hello: 999</span></span><br><span class="line"><span class="comment">//This is main Thread.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//使用t.detach();</span></span><br><span class="line"><span class="comment">//This is main Thread.Hello://顺序是乱的，因为detach后的线程t和主线程是并发执行的</span></span><br></pre></td></tr></table></figure></p><h2 id="主线程包含的内容"><a href="#主线程包含的内容" class="headerlink" title="主线程包含的内容"></a>主线程包含的内容</h2><ol><li>线程 ID：系统中的唯一标识符，区分不同线程。</li><li>线程栈 (Thread Stack)：每个线程</li><li>线程状态：新建 New，就绪 Ready，运行 Running，阻塞 Blocked，终止 Terminated</li><li>线程上下文（Thread Context）</li><li>线程函数（Thread Function）</li><li>线程优先级</li><li>线程属性</li><li>线程同步原语：互斥锁 Mutex、条件变量、信号量 Semaphore，帮助线程在访问共享资源时避免冲突和竞态条件。</li></ol><h2 id="this-thread"><a href="#this-thread" class="headerlink" title="this_thread"></a>this_thread</h2><p><code>std::this_thread</code> 是 C++11 引入的一个<font color="#00b050">命名空间</font>，提供了与当前线程相关的操作。它包含一些静态成员函数，用于获取当前线程的信息或控制当前线程的行为。</p><ol><li><strong>获取当前线程的 ID</strong>：<code>this_thread::get_id()</code></li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">threadFunction</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Thread ID: &quot;</span> &lt;&lt; this_thread::<span class="built_in">get_id</span>() &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">thread <span class="title">t</span><span class="params">(threadFunction)</span></span>;</span><br><span class="line">    t.<span class="built_in">join</span>();</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Main Thread ID: &quot;</span> &lt;&lt; std::this_thread::<span class="built_in">get_id</span>() &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Thread ID: 140234567890176</span></span><br><span class="line"><span class="comment">//Main Thread ID: 140234576282880</span></span><br></pre></td></tr></table></figure><ol><li><strong>暂停当前线程一段时间</strong>：<code>this_thread::sleep_for()</code></li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;chrono&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">threadFunction</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Thread starts&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="comment">// 参数为一个 std::chrono::duration 类型的对象</span></span><br><span class="line">    this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">seconds</span>(<span class="number">2</span>)); <span class="comment">// 暂停2秒</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Thread resumes after 2 seconds&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">thread <span class="title">t</span><span class="params">(threadFunction)</span></span>;</span><br><span class="line">    t.<span class="built_in">join</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li><strong>暂停当前线程到指定时间点</strong>：<code>std::this_thread::sleep_until()</code></li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;chrono&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">threadFunction</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> now = std::chrono::system_clock::<span class="built_in">now</span>();</span><br><span class="line">    <span class="keyword">auto</span> endTime = now + std::chrono::<span class="built_in">seconds</span>(<span class="number">2</span>); <span class="comment">// 当前时间 + 2 秒</span></span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Thread starts&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="comment">// 参数为一个 std::chrono::time_point 类型的对象</span></span><br><span class="line">    this_thread::<span class="built_in">sleep_until</span>(endTime); <span class="comment">// 暂停到指定时间点</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Thread resumes after 2 seconds&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">thread <span class="title">t</span><span class="params">(threadFunction)</span></span>;</span><br><span class="line">    t.<span class="built_in">join</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Thread starts</span></span><br><span class="line"><span class="comment">//Thread resumes after 2 seconds</span></span><br></pre></td></tr></table></figure><ol><li><strong>主动让出 CPU 时间片</strong>：<code>std::this_thread::yield()</code></li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">threadFunction</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; ++i) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Thread is running&quot;</span> &lt;&lt; endl;</span><br><span class="line">        this_thread::<span class="built_in">yield</span>(); <span class="comment">// 让出CPU时间片，允许其他线程运行。用于实现线程的协作式调度，避免长时间占用CPU</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">thread <span class="title">t</span><span class="params">(threadFunction)</span></span>;</span><br><span class="line">    t.<span class="built_in">join</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="线程同步"><a href="#线程同步" class="headerlink" title="线程同步"></a>线程同步</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>线程同步（Thread Synchronization）是指通过一定机制来<font color="#00b050">控制多个线程之间的执行顺序，以确保它们能够正确地访问和修改共享资源</font>，从而避免数据竞争和不一致性问题。<br><img src="https://i.imgur.com/dXCWFZc.png" alt="|861"><br>✅C++提供了多种线程同步机制（重要）：</p><ol><li><strong>互斥锁（Mutex）</strong>：当一个线程想要访问共享资源时，它<font color="#00b050">首先会尝试获取与该资源关联的互斥锁</font>。如果锁已经被其他线程持有，则该线程被阻塞，直到锁被释放。这样可以确保任何时候只有一个线程能够访问共享资源。包含于头文件 <code>&lt;mutex&gt;</code> 中。</li><li><strong>条件变量（Condition Value）</strong>：使线程在满足某条件前等待，通常与互斥锁一起使用，以便在<font color="#00b050">等待条件成立时释放锁，并在条件成立时创建锁</font>。这允许线程在等待期间不占用锁，提高并发性能。包含于头文件 <code>&lt;condition_variable&gt;</code> 中。</li><li><strong>信号量（Semaphore）</strong>：允许<font color="#00b050">多个线程同时访问共享资源，但限制同时访问的线程数量</font>。信号量内部维护一个计数器，用于表示可用资源的数量。当线程需要访问资源时，它会尝试减少计数器的值；当线程释放资源时，它会增加计数器的值。当计数器的值小于零时，尝试获取资源的线程将被阻塞。（PV 操作）</li><li><strong>原子操作（Atomic Operations）</strong>：原子操作是不可中断的操作（执行过程中<font color="#00b050">不会被其他线程打断</font>），用于安全地更新共享数据，而<font color="#00b050">无需使用互斥锁等同步机制</font>。包含于 C++11 及以后的头文件 <code>&lt;atomic&gt;</code> 中。</li><li><strong>读写锁</strong>：允许<font color="#00b050">多个线程同时读取</font>，但只允许<font color="#00b050">一个线程写入</font>。</li><li><strong>栅栏（Barrier）</strong>：用于协调多个线程的执行，使得它们<font color="#00b050">在某个同步点等待</font>，直到所有线程都到达该点（C++20 新特性）。</li></ol><h2 id="🚩互斥锁-mutex"><a href="#🚩互斥锁-mutex" class="headerlink" title="🚩互斥锁 mutex"></a>🚩互斥锁 mutex</h2><blockquote><p>当一个线程想要访问共享资源时，它<font color="#00b050">首先会尝试获取与该资源关联的互斥锁</font>。如果锁已经被其他线程持有，则该线程被阻塞，直到锁被释放。这样可以确保任何时候只有一个线程能够访问共享资源。</p></blockquote><p>💻代码示例：</p><p>未引入互斥锁时：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//共享变量</span></span><br><span class="line"><span class="type">int</span> counter = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">increment_counter</span><span class="params">(<span class="type">int</span> times)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; times; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//数据竞争，多个线程可能同时执行这行代码</span></span><br><span class="line">counter++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="function">thread <span class="title">t1</span><span class="params">(increment_counter, <span class="number">100000</span>)</span></span>;</span><br><span class="line"><span class="function">thread <span class="title">t2</span><span class="params">(increment_counter, <span class="number">100000</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">t1.<span class="built_in">join</span>();</span><br><span class="line">t2.<span class="built_in">join</span>();</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;最终结果：&quot;</span> &lt;&lt; counter &lt;&lt; endl;<span class="comment">// 145593</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>🚩引入互斥锁（需要头文件 <code>&lt;mutex&gt;</code>）：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> counter = <span class="number">0</span>;  </span><br><span class="line">mutex mtx;  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">increment_counter</span><span class="params">(<span class="type">int</span> times)</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; times; i++)  </span><br><span class="line">    &#123;  </span><br><span class="line">        mtx.<span class="built_in">lock</span>();<span class="comment">//访问临界变量前先加锁  </span></span><br><span class="line">        counter++;  </span><br><span class="line">        mtx.<span class="built_in">unlock</span>();   <span class="comment">//访问完成，解锁  </span></span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="function">thread <span class="title">t1</span><span class="params">(increment_counter, <span class="number">100000</span>)</span></span>;  </span><br><span class="line">    <span class="function">thread <span class="title">t2</span><span class="params">(increment_counter, <span class="number">100000</span>)</span></span>;  </span><br><span class="line">  </span><br><span class="line">    t1.<span class="built_in">join</span>();  </span><br><span class="line">    t2.<span class="built_in">join</span>();  </span><br><span class="line">  </span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;最终结果：&quot;</span> &lt;&lt; counter &lt;&lt; endl; <span class="comment">// 200000  </span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><ol><li><strong>死锁</strong>：<br>如果线程在持有互斥量的情况下调用了另一个阻塞操作（如另一个互斥量的 <code>lock()</code>），并且这个阻塞操作永远不会完成（因为其他线程持有它需要的资源），那么就会发生死锁。避免死锁的一种方法是始终<font color="#00b050">按照相同的顺序锁定互斥量</font>，或者使用更高级的<font color="#00b050">同步原语</font>，如  <code>std::lock_guard</code> 或 <code>std::unique_lock</code>，它们可以自动管理锁的获取和释放。</li><li><strong>异常安全</strong>：<br>如果在锁定互斥量后抛出异常，那么必须确保互斥量被正确解锁。使用 <code>std::lock_guard</code> 或 <code>std::unique_lock</code> 可以自动处理这种情况，因为它们在析构时会释放锁。</li><li><strong>不要手动解锁未锁定的互斥量</strong>：<br>调用 <code>unlock</code> 之前，必须确保互斥量已经被 <code>lock</code> 锁定。否则该行为是未定义的。</li><li><strong>不要多次锁定同一个互斥量</strong>：<br>对于非递归互斥量（如 <code>std::mutex</code>），不要在同一线程中多次锁定它，这会导致未定义行为。如果需要递归锁定，使用 <code>std::recursive_mutex</code>。</li><li><strong>使用 RAII 管理锁</strong>：<br>使用 RAII（资源获取即初始化）原则来管理锁的生命周期，通过 <code>std::lock_guard</code> 或者 <code>std::unique_lock</code> 来确保锁在不需要时自动释放。</li><li><strong>避免长时间持有锁</strong>：<br>尽量缩短持有锁的时间，以<font color="#00b050">减少线程之间的争用</font>，提高程序并发性能。</li><li><strong>考虑使用更高级的同步原语</strong>：<br>除了 <code>std::mutex</code>，还可以使用条件变量 <code>std::condition_variable</code>、读写锁 <code>std::shared_mutex</code> 等等。</li></ol><p>🚀使用 <code>std::lock_guard</code> 或 <code>std::unique_lock</code>（遵循 RAII 原则）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span>  </span></span><br><span class="line">  </span><br><span class="line">std::mutex mtx;  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">SafeFunction</span><span class="params">()</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mtx)</span></span>;  <span class="comment">//锁定互斥量  </span></span><br><span class="line">    <span class="comment">//这里执行需要互斥访问的代码。  </span></span><br><span class="line">    <span class="comment">//如果抛出异常，lock_guard会在析构时自动解锁 mtx    try &#123;  </span></span><br><span class="line">        <span class="keyword">if</span> (<span class="comment">/*一些可能造成异常的代码*/</span>)  </span><br><span class="line">        &#123;  </span><br><span class="line">            <span class="keyword">throw</span> std::<span class="built_in">runtime_error</span>(<span class="string">&quot;An error occurred!&quot;</span>);  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125; <span class="built_in">catch</span> (<span class="type">const</span> std::exception&amp; e)&#123;  </span><br><span class="line">        <span class="comment">//处理异常，不需要担心解锁，lock_guard会处理  </span></span><br><span class="line">        std::cerr &lt;&lt; e.<span class="built_in">what</span>() &lt;&lt; std::endl;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="comment">//lock_guard会在析构/离开作用域时自动解锁 mtx</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="✅关于RAII"><a href="#✅关于RAII" class="headerlink" title="✅关于RAII"></a>✅关于RAII</h3><p>全称为 <strong>Resource Acquisition Is Initialization</strong>（资源获取即初始化）。它是 C++ 中管理资源（如内存、文件句柄、互斥锁等）的一种重要机制。RAII 的核心思想是将资源的获取和释放与对象的生命周期绑定，从而<font color="#00b050">确保资源在对象创建时自动获取，在对象销毁时自动释放</font>。</p><p><strong>优点</strong>：自动管理资源、异常安全、简化代码。</p><p>RAII 的实现依赖于构造和析构函数。💻示例代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">FileHandler</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">FileHandler</span>(<span class="type">const</span> string&amp; filename) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Opening file: &quot;</span> &lt;&lt; filename &lt;&lt; endl;</span><br><span class="line">        <span class="comment">// 模拟打开文件</span></span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">FileHandler</span>() &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Closing file&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="comment">// 模拟关闭文件</span></span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">write</span><span class="params">(<span class="type">const</span> string&amp; data)</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Writing data: &quot;</span> &lt;&lt; data &lt;&lt; endl;</span><br><span class="line">        <span class="comment">// 模拟写入文件</span></span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">FileHandler <span class="title">file</span><span class="params">(<span class="string">&quot;example.txt&quot;</span>)</span></span>; <span class="comment">// 资源获取</span></span><br><span class="line">    file.<span class="built_in">write</span>(<span class="string">&quot;Hello, RAII!&quot;</span>);       <span class="comment">// 使用资源</span></span><br><span class="line">    <span class="comment">// 资源在 file 对象销毁时自动释放</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Opening file: example.txt</span></span><br><span class="line"><span class="comment">//Writing data: Hello, RAII!</span></span><br><span class="line"><span class="comment">//Closing file</span></span><br></pre></td></tr></table></figure><ul><li><strong>构造函数</strong>：在 <code>FileHandler</code> 对象创建时，构造函数会自动打开文件（模拟）。 </li><li><strong>析构函数</strong>：在 <code>FileHandler</code> 对象销毁时，析构函数会自动关闭文件（模拟）。</li><li><strong>资源管理</strong>：通过对象的生命周期管理文件的打开和关闭，避免了手动调用 <code>close()</code> 的复杂性。</li></ul><p>🚩RAII 在标准库中应用：</p><ol><li>动态内存管理：<code>unique_ptr</code> 和 <code>shared_ptr</code></li><li>互斥锁管理：<code>lock_guard</code> 和 <code>unique_lock</code></li><li>文件管理: <code>ifstream</code> 和 <code>ofstream</code></li></ol><h3 id="mutex-的四种类型"><a href="#mutex-的四种类型" class="headerlink" title="mutex 的四种类型"></a>mutex 的四种类型</h3><ol><li><strong><code>std::mutex</code></strong>：最基本的互斥锁，适用于简单的资源保护。</li><li><strong><code>std::recursive_mutex</code></strong>：支持递归锁定，适用于递归函数或多次锁定场景。</li><li><strong><code>std::timed_mutex</code></strong>：支持超时锁定，适用于需要避免长时间阻塞的场景。</li><li><strong><code>std::recursive_timed_mutex</code></strong>：结合递归锁定和超时锁定功能，适用于复杂的同步需求。</li></ol><p>💻代码示例：<br><code>recursive_mutex</code>：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line">std::recursive_mutex mtx; <span class="comment">// 定义一个递归互斥锁</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">recursiveFunction</span><span class="params">(<span class="type">int</span> count)</span> </span>&#123;</span><br><span class="line">    <span class="function">std::lock_guard&lt;std::recursive_mutex&gt; <span class="title">lock</span><span class="params">(mtx)</span></span>;<span class="comment">//锁定互斥量</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Count: &quot;</span> &lt;&lt; count &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">if</span> (count &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">recursiveFunction</span>(count - <span class="number">1</span>); <span class="comment">// 递归调用</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::thread <span class="title">t</span><span class="params">(recursiveFunction, <span class="number">5</span>)</span></span>;</span><br><span class="line">    t.<span class="built_in">join</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//Count: 5</span></span><br><span class="line"><span class="comment">//Count: 4</span></span><br><span class="line"><span class="comment">//Count: 3</span></span><br><span class="line"><span class="comment">//Count: 2</span></span><br><span class="line"><span class="comment">//Count: 1</span></span><br><span class="line"><span class="comment">//Count: 0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//或者：</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">recursiveFunction</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    mtx.<span class="built_in">lock</span>();<span class="comment">//第一次锁定</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Thread: &quot;</span> &lt;&lt; std::this_thread::<span class="built_in">get_id</span>() &lt;&lt; <span class="string">&quot; locked mutex.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    mtx.<span class="built_in">lock</span>();<span class="comment">//可以多次锁定</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Thread: &quot;</span> &lt;&lt; std::this_thread::<span class="built_in">get_id</span>() &lt;&lt; <span class="string">&quot; locked mutex.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">mtx.<span class="built_in">unlock</span>();</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;Thread: &quot;</span> &lt;&lt; std::this_thread::<span class="built_in">get_id</span>() &lt;&lt; <span class="string">&quot; unlocked mutex.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">mtx.<span class="built_in">unlock</span>();</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;Thread: &quot;</span> &lt;&lt; std::this_thread::<span class="built_in">get_id</span>() &lt;&lt; <span class="string">&quot; unlocked mutex.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><code>timed_mutex</code>:<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;chrono&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line">std::timed_mutex mtx; <span class="comment">// 定义一个定时互斥锁</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">threadFunction</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mtx.<span class="built_in">try_lock_for</span>(std::chrono::<span class="built_in">seconds</span>(<span class="number">1</span>))) &#123; <span class="comment">// 尝试锁定 1 秒，使用try_lock_for或者try_lock_until</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Thread ID: &quot;</span> &lt;&lt; std::this_thread::<span class="built_in">get_id</span>() &lt;&lt; <span class="string">&quot; acquired the lock&quot;</span> &lt;&lt; endl;</span><br><span class="line">        std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">seconds</span>(<span class="number">2</span>)); <span class="comment">// 模拟工作</span></span><br><span class="line">        mtx.<span class="built_in">unlock</span>();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Thread ID: &quot;</span> &lt;&lt; std::this_thread::<span class="built_in">get_id</span>() &lt;&lt; <span class="string">&quot; failed to acquire the lock&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::thread <span class="title">t1</span><span class="params">(threadFunction)</span></span>;</span><br><span class="line">    <span class="function">std::thread <span class="title">t2</span><span class="params">(threadFunction)</span></span>;</span><br><span class="line"></span><br><span class="line">    t1.<span class="built_in">join</span>();</span><br><span class="line">    t2.<span class="built_in">join</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Thread ID: 140234567890176 acquired the lock</span></span><br><span class="line"><span class="comment">//Thread ID: 140234576282880 failed to acquire the lock</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">threadFunction</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> deadline = std::chrono::system_clock::<span class="built_in">now</span>() + std::chrono::<span class="built_in">seconds</span>(<span class="number">1</span>); <span class="comment">// 设置截止时间</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mtx.<span class="built_in">try_lock_until</span>(deadline)) &#123; <span class="comment">// 尝试在截止时间之前获取锁</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Thread ID: &quot;</span> &lt;&lt; std::this_thread::<span class="built_in">get_id</span>() &lt;&lt; <span class="string">&quot; acquired the lock&quot;</span> &lt;&lt; endl;</span><br><span class="line">        std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">seconds</span>(<span class="number">2</span>)); <span class="comment">// 模拟工作</span></span><br><span class="line">        mtx.<span class="built_in">unlock</span>();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Thread ID: &quot;</span> &lt;&lt; std::this_thread::<span class="built_in">get_id</span>() &lt;&lt; <span class="string">&quot; failed to acquire the lock&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><code>recursive_timed_mutex</code>：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;chrono&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line">std::recursive_timed_mutex mtx; <span class="comment">// 定义一个递归定时互斥锁</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">recursiveFunction</span><span class="params">(<span class="type">int</span> count)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mtx.<span class="built_in">try_lock_for</span>(std::chrono::<span class="built_in">seconds</span>(<span class="number">1</span>))) &#123; <span class="comment">// 尝试锁定 1 秒</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Count: &quot;</span> &lt;&lt; count &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">if</span> (count &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">recursiveFunction</span>(count - <span class="number">1</span>); <span class="comment">// 递归调用</span></span><br><span class="line">        &#125;</span><br><span class="line">        mtx.<span class="built_in">unlock</span>();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Failed to acquire the lock at count: &quot;</span> &lt;&lt; count &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::thread <span class="title">t</span><span class="params">(recursiveFunction, <span class="number">5</span>)</span></span>;</span><br><span class="line">    t.<span class="built_in">join</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Count: 5</span></span><br><span class="line"><span class="comment">//Count: 4</span></span><br><span class="line"><span class="comment">//Count: 3</span></span><br><span class="line"><span class="comment">//Count: 2</span></span><br><span class="line"><span class="comment">//Count: 1</span></span><br><span class="line"><span class="comment">//Count: 0</span></span><br></pre></td></tr></table></figure></p><p>（了解）关于 <code>std::chrono</code>：<br>它提供了高精度的时间操作和计时功能，允许开发者以灵活的方式处理时间点和时间段。<code>std::chrono</code> 的核心概念包括 <strong>时间点（time_point）</strong>、<strong>时间段（duration）</strong> 和 <strong>时钟（clock）</strong>。</p><p>常用操作有：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//时间段duration的操作---------------------------------------</span></span><br><span class="line"><span class="comment">//创建时间段</span></span><br><span class="line">std::<span class="function">chrono::seconds <span class="title">sec</span><span class="params">(<span class="number">10</span>)</span></span>;          <span class="comment">// 10 秒</span></span><br><span class="line">std::<span class="function">chrono::milliseconds <span class="title">ms</span><span class="params">(<span class="number">500</span>)</span></span>;     <span class="comment">// 500 毫秒</span></span><br><span class="line">std::<span class="function">chrono::microseconds <span class="title">us</span><span class="params">(<span class="number">1000</span>)</span></span>;    <span class="comment">// 1000 微秒</span></span><br><span class="line"><span class="comment">//时间段转换</span></span><br><span class="line">std::chrono::seconds sec = std::chrono::<span class="built_in">duration_cast</span>&lt;std::chrono::seconds&gt;(ms);</span><br><span class="line"><span class="comment">//时间段运算</span></span><br><span class="line">std::<span class="function">chrono::seconds <span class="title">sec1</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line">std::<span class="function">chrono::seconds <span class="title">sec2</span><span class="params">(<span class="number">20</span>)</span></span>;</span><br><span class="line">std::chrono::seconds sec3 = sec1 + sec2; <span class="comment">// 30 秒</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//时间点time_point的操作--------------------------------------</span></span><br><span class="line"><span class="comment">//获取当前时间点</span></span><br><span class="line"><span class="keyword">auto</span> now = std::chrono::system_clock::<span class="built_in">now</span>();</span><br><span class="line"><span class="comment">//时间点转换为时间戳</span></span><br><span class="line">std::<span class="type">time_t</span> <span class="type">now_time_t</span> = std::chrono::system_clock::<span class="built_in">to_time_t</span>(now);</span><br><span class="line"><span class="comment">//时间点运算</span></span><br><span class="line"><span class="keyword">auto</span> now = std::chrono::system_clock::<span class="built_in">now</span>();</span><br><span class="line"><span class="keyword">auto</span> future = now + std::chrono::<span class="built_in">seconds</span>(<span class="number">10</span>); <span class="comment">// 当前时间 + 10 秒</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//时钟clock的操作--------------------------------------------</span></span><br><span class="line"><span class="comment">//获取当前时间点</span></span><br><span class="line"><span class="keyword">auto</span> now = std::chrono::system_clock::<span class="built_in">now</span>();</span><br><span class="line"><span class="comment">//获取稳定时间点</span></span><br><span class="line"><span class="keyword">auto</span> steady_now = std::chrono::steady_clock::<span class="built_in">now</span>();</span><br></pre></td></tr></table></figure></p><h3 id="lock-guard"><a href="#lock-guard" class="headerlink" title="lock_guard"></a>lock_guard</h3><blockquote><p>什么是 <code>lock_guard</code>？为什么需要 <code>lock_guard</code>？</p></blockquote><p><code>lock_guard</code> 是一个模板类，位于 <code>&lt;mutex&gt;</code> 头文件中，符合 RAII 风格，用于管理 <code>mutex</code> 的生命周期，解决了手动管理 <code>mutex</code> 锁定和解锁时可能出现的问题（忘记解锁、异常情况下未解锁等）。<br>可以理解为，<code>lock_guard</code> 是对 mutex 的一种管理封装，它可以更好地管理 mutex。</p><blockquote><p>💻代码示例</p></blockquote><p><strong>通过设定作用域，使得std::lock_guard在合适的地方被析构</strong>（在互斥量锁定到互斥量解锁之间的代码叫做临界区（需要互斥访问共享资源的那段代码称为临界区），临界区范围应该尽可能的小，即lock互斥量后应该尽早unlock），<strong>通过使用{}来调整作用域范围，可使得互斥量m在合适的地方被解锁</strong>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line">mutex m;<span class="comment">//实例化m对象，不要理解为定义变量</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">proc1</span><span class="params">(<span class="type">int</span> a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">lock_guard&lt;mutex&gt; <span class="title">g1</span><span class="params">(m)</span></span>;<span class="comment">//用此语句替换了m.lock()；lock_guard传入一个参数时，该参数为互斥量，此时调用了lock_guard的构造函数，申请锁定m</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;proc1函数正在改写a&quot;</span> &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;原始a为&quot;</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;现在a为&quot;</span> &lt;&lt; a + <span class="number">2</span> &lt;&lt; endl;</span><br><span class="line">&#125;<span class="comment">//此时不需要写m.unlock(),g1出了作用域被释放，自动调用析构函数，于是m被解锁</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">proc2</span><span class="params">(<span class="type">int</span> a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function">lock_guard&lt;mutex&gt; <span class="title">g2</span><span class="params">(m)</span></span>;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;proc2函数正在改写a&quot;</span> &lt;&lt; endl;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;原始a为&quot;</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;现在a为&quot;</span> &lt;&lt; a + <span class="number">1</span> &lt;&lt; endl;</span><br><span class="line">    &#125;<span class="comment">//通过使用&#123;&#125;来调整作用域范围，可使得m在合适的地方被解锁</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;作用域外的内容3&quot;</span> &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;作用域外的内容4&quot;</span> &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;作用域外的内容5&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">0</span>;</span><br><span class="line">    <span class="function">thread <span class="title">t1</span><span class="params">(proc1, a)</span></span>;</span><br><span class="line">    <span class="function">thread <span class="title">t2</span><span class="params">(proc2, a)</span></span>;</span><br><span class="line">    t1.<span class="built_in">join</span>();</span><br><span class="line">    t2.<span class="built_in">join</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//proc1函数正在改写a</span></span><br><span class="line"><span class="comment">//原始a为0</span></span><br><span class="line"><span class="comment">//现在a为2</span></span><br><span class="line"><span class="comment">//proc2函数正在改写a</span></span><br><span class="line"><span class="comment">//原始a为0</span></span><br><span class="line"><span class="comment">//现在a为1</span></span><br><span class="line"><span class="comment">//作用域外的内容3</span></span><br><span class="line"><span class="comment">//作用域外的内容4</span></span><br><span class="line"><span class="comment">//作用域外的内容5</span></span><br></pre></td></tr></table></figure><p><code>std::lock_guard</code> 也可以传入两个参数，第一个参数被 <code>adopt_lock</code> 标识时，表示构造函数中不再进行互斥量锁定，因此<strong>此时需要提前手动锁定</strong>。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line">mutex m;<span class="comment">//实例化m对象，不要理解为定义变量</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">proc1</span><span class="params">(<span class="type">int</span> a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    m.<span class="built_in">lock</span>();<span class="comment">//手动锁定</span></span><br><span class="line">    <span class="function">lock_guard&lt;mutex&gt; <span class="title">g1</span><span class="params">(m, std::adopt_lock)</span></span>;<span class="comment">// adapt_lock是一个标记(tag)，告诉 lock_guard 互斥锁 m 已经被锁定</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;proc1函数正在改写a&quot;</span> &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;原始a为&quot;</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;现在a为&quot;</span> &lt;&lt; a + <span class="number">2</span> &lt;&lt; endl;</span><br><span class="line">&#125;<span class="comment">//自动解锁</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">proc2</span><span class="params">(<span class="type">int</span> a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">lock_guard&lt;mutex&gt; <span class="title">g2</span><span class="params">(m)</span></span>;<span class="comment">//自动锁定</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;proc2函数正在改写a&quot;</span> &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;原始a为&quot;</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;现在a为&quot;</span> &lt;&lt; a + <span class="number">1</span> &lt;&lt; endl;</span><br><span class="line">&#125;<span class="comment">//自动解锁</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">0</span>;</span><br><span class="line">    <span class="function">thread <span class="title">t1</span><span class="params">(proc1, a)</span></span>;</span><br><span class="line">    <span class="function">thread <span class="title">t2</span><span class="params">(proc2, a)</span></span>;</span><br><span class="line">    t1.<span class="built_in">join</span>();</span><br><span class="line">    t2.<span class="built_in">join</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ul><li><code>lock_guard</code> 禁用了拷贝构造函数和拷贝复制运算符，所以它<font color="#00b050">不支持拷贝语义</font>，只能通过<font color="#00b050">直接创建对象</font>来使用。这样可以避免多个 <code>lock_guard</code> 对象同时管理同一个互斥锁而导致的错误行为。</li><li><code>lock_guard</code> 仅用于管理 mutex 的锁定和解锁（单一职责），对于更复杂的锁定需求，使用 <code>std::unique_lock</code>。</li></ul><h3 id="unique-lock"><a href="#unique-lock" class="headerlink" title="unique_lock"></a>unique_lock</h3><blockquote><p>为什么需要 <code>unique_lock</code>？</p></blockquote><p><code>mutex</code> 在管理方面有瑕疵，因此使用互斥量封装器 <code>lock_guard</code> 来智能管理 mutex，但其功能较弱，需要功能更加强大的 <code>unique_lock</code>（也叫”灵活锁”）。</p><blockquote><p><code>lock_guard</code> 的瑕疵在于？</p></blockquote><p>下表给出二者区别：</p><div class="table-container"><table><thead><tr><th>特性</th><th>lock_guard</th><th>unique_lock</th></tr></thead><tbody><tr><td>自动锁定</td><td>✅</td><td>✅</td></tr><tr><td>自动解锁</td><td>✅</td><td>✅</td></tr><tr><td>手动加锁</td><td>✅</td><td>✅</td></tr><tr><td>延迟锁定</td><td>不支持</td><td>支持</td></tr><tr><td>手动解锁</td><td>不支持，只能通过作用域自动解锁</td><td>支持</td></tr><tr><td>参数</td><td>支持 adopt_lock</td><td>支持 adopt_lock/try_to_lock/defer_lock</td></tr><tr><td>与条件变量结合</td><td>不支持</td><td>支持</td></tr><tr><td>递归锁</td><td>不支持</td><td>支持</td></tr><tr><td>灵活性</td><td>低</td><td>高</td></tr><tr><td>性能开销</td><td>低</td><td>高</td></tr><tr><td>适用场景</td><td>简单的锁管理</td><td>复杂的锁管理</td></tr></tbody></table></div><h4 id="💻代码示例"><a href="#💻代码示例" class="headerlink" title="💻代码示例"></a>💻代码示例</h4><p>构造（多种锁定策略）</p><ul><li><code>std::defer_lock</code>：延迟锁定，互斥锁在构造时不锁定。需要时调用 <code>lock</code> 手动锁定，结束时自动解锁。</li><li><code>std::try_to_lock</code>：尝试锁定，如果互斥锁已被占用，则立即返回。</li><li><code>std::adopt_lock</code>：接管已经锁定的互斥锁。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">mutex mtx;</span><br><span class="line">timed_mutex TimeMtx;</span><br><span class="line"><span class="function">unique_lock&lt;mutex&gt; <span class="title">lock</span><span class="params">(mtx)</span></span>;<span class="comment">//自动上锁</span></span><br><span class="line"><span class="function">unique_lock&lt;timed_mutex&gt; <span class="title">TimeLock</span><span class="params">(TimeMtx, std::chrono::seconds(<span class="number">1</span>))</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">unique_lock&lt;mutex&gt; <span class="title">lock1</span><span class="params">(mtx, std::defer_lock)</span></span>;<span class="comment">//延迟锁定，不要自动锁定</span></span><br><span class="line"><span class="function">unique_lock&lt;mutex&gt; <span class="title">lock2</span><span class="params">(mtx, std::try_to_lock)</span></span>;<span class="comment">//尝试锁定</span></span><br><span class="line"><span class="function">unique_lock&lt;mutex&gt; <span class="title">lock3</span><span class="params">(mtx, std::adopt_lock)</span></span>;<span class="comment">//接收已经锁定的mutex</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//所有权转移（unique_lock对象之间的转移）</span></span><br><span class="line"><span class="function">unique_lock&lt;mutex&gt; <span class="title">lock4</span><span class="params">(move(lock))</span></span>;<span class="comment">//所有权转移，此时由lock来管理互斥量mtx</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//判断是否锁成功</span></span><br><span class="line"><span class="keyword">if</span> (lock2.<span class="built_in">owns_lock</span>())</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;锁成功&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="🚩条件变量-condition-variable"><a href="#🚩条件变量-condition-variable" class="headerlink" title="🚩条件变量 condition_variable"></a>🚩条件变量 condition_variable</h2><blockquote><p>什么是条件变量 <code>std::condition_variable</code>？</p></blockquote><p><code>std::condition_variable</code> 是 C++11 引入的一个同步原语，用于实现线程间的通信和同步。它通常与 <code>std::mutex</code> 配合使用，<font color="#00b050">允许一个线程等待另一个线程的通知</font>，从而实现线程间的协作。</p><blockquote><p>条件变量的使用场景？</p></blockquote><ul><li><strong>生产者-消费者模型</strong>：一个线程生产数据，另一个线程消费数据，通过条件变量实现同步。</li><li><strong>事件通知</strong>：一个线程等待某个事件的发生，另一个线程在事件发生时通知它。</li><li><strong>线程协作</strong>：多个线程需要协作完成任务，通过条件变量实现同步。</li></ul><h3 id="💻代码示例-1"><a href="#💻代码示例-1" class="headerlink" title="💻代码示例"></a>💻代码示例</h3><ul><li><strong>等待（wait）</strong>：一个线程调用 <code>wait()</code> 方法，进入等待状态，直到另一个线程调用 <code>notify_one()</code> 或 <code>notify_all()</code> 通知它。<br>线程进入等待期间，会释放与之关联的互斥锁，允许其他线程访问共享数据。当线程被唤醒后，会重新获取互斥锁并继续执行。</li><li><strong>通知（notify）</strong>：另一个线程调用 <code>notify_one()</code> 或 <code>notify_all()</code> 方法，唤醒等待的线程。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//两个线程交替执行</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;thread&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;mutex&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;condition_variable&gt;</span>  </span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;  </span><br><span class="line">  </span><br><span class="line">mutex mtx;  </span><br><span class="line">condition_variable cv;  </span><br><span class="line"><span class="type">int</span> MyValue = <span class="number">0</span>;  </span><br><span class="line"><span class="type">bool</span> turn = <span class="literal">false</span>;  <span class="comment">//控制哪个线程该执行  </span></span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Increment</span><span class="params">(<span class="type">int</span> thread_id)</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; ++i) &#123;  </span><br><span class="line">        <span class="function">unique_lock&lt;mutex&gt; <span class="title">lock</span><span class="params">(mtx)</span></span>;  </span><br><span class="line">        cv.<span class="built_in">wait</span>(lock, [&amp;] &#123; <span class="keyword">return</span> thread_id == <span class="number">1</span> ? !turn : turn; &#125;);  </span><br><span class="line">        ++MyValue;  </span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Thread &quot;</span> &lt;&lt; thread_id &lt;&lt; <span class="string">&quot; incremented value to: &quot;</span> &lt;&lt; MyValue &lt;&lt; endl;  </span><br><span class="line">        <span class="comment">// 切换turn标志并通知另一个线程  </span></span><br><span class="line">        turn = !turn;  </span><br><span class="line">        cv.<span class="built_in">notify_all</span>();    <span class="comment">//这里只需要notify_one()即可  </span></span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="function">thread <span class="title">t1</span><span class="params">(Increment, <span class="number">1</span>)</span></span>;  </span><br><span class="line">    <span class="function">thread <span class="title">t2</span><span class="params">(Increment, <span class="number">2</span>)</span></span>;  </span><br><span class="line">    t1.<span class="built_in">join</span>();  </span><br><span class="line">    t2.<span class="built_in">join</span>();  </span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Final Value: &quot;</span> &lt;&lt; MyValue &lt;&lt; endl;  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Thread 1 incremented value to: 1</span></span><br><span class="line"><span class="comment">//Thread 2 incremented value to: 2</span></span><br><span class="line"><span class="comment">//Thread 1 incremented value to: 3</span></span><br><span class="line"><span class="comment">//Thread 2 incremented value to: 4</span></span><br><span class="line"><span class="comment">//Thread 1 incremented value to: 5</span></span><br><span class="line"><span class="comment">//Thread 2 incremented value to: 6</span></span><br><span class="line"><span class="comment">//Final Value: 6</span></span><br></pre></td></tr></table></figure><ol><li><code>wait(std::unique_lock&lt;std::mutex&gt;&amp;, Predicate)</code>，其中 <code>Predicate</code> 指可调用对象。</li><li><code>wait_for(std::unique_lock&lt;std::mutex&gt;&amp;, std::chrono::seconds, Predicate)</code>：允许指定一个超时时间，这段时间内没有收到唤醒信号/条件不满足，则函数会返回，并且线程会重新获取互斥锁。</li><li><code>notify_one()</code>：唤醒一个等待的线程，适用于只有一个线程需要被唤醒的场景。<br>例如，生产者-消费者模型中，生产者生产一个数据后，只需要唤醒一个消费者。</li><li><strong><code>notify_all()</code></strong>：唤醒所有等待的线程，适用于多个线程需要被唤醒的场景。<br>例如，多个消费者等待同一个条件变量时，生产者生产数据后，需要唤醒所有消费者。</li></ol><p>代码示例：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//生产者-消费者模型</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;condition_variable&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span>  </span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;  </span><br><span class="line">  </span><br><span class="line">std::mutex mtx; <span class="comment">// 定义一个互斥锁  </span></span><br><span class="line">std::condition_variable cv; <span class="comment">// 定义一个条件变量  </span></span><br><span class="line">std::queue&lt;<span class="type">int</span>&gt; SharedQueue; <span class="comment">// 共享队列 </span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">producer</span><span class="params">(<span class="type">bool</span> notify_all)</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">50000</span>; ++i) &#123;   <span class="comment">//样本数较大时效果更加直观  </span></span><br><span class="line">        <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mtx)</span></span>; <span class="comment">// 自动锁定    </span></span><br><span class="line">SharedQueue.<span class="built_in">push</span>(i); <span class="comment">// 生产数据    </span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Produced: &quot;</span> &lt;&lt; i &lt;&lt; endl;  </span><br><span class="line">        <span class="keyword">if</span> (notify_all) &#123;  </span><br><span class="line">            cv.<span class="built_in">notify_all</span>(); <span class="comment">// 通知所有消费者    </span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">            cv.<span class="built_in">notify_one</span>(); <span class="comment">// 通知一个消费者    </span></span><br><span class="line">&#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">consumer</span><span class="params">(<span class="type">int</span> id)</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;  </span><br><span class="line">        <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mtx)</span></span>; <span class="comment">// 自动锁定    </span></span><br><span class="line">cv.<span class="built_in">wait</span>(lock, [] &#123; <span class="keyword">return</span> !SharedQueue.<span class="built_in">empty</span>(); &#125;); <span class="comment">// 等待队列非空  </span></span><br><span class="line">        <span class="type">int</span> value = SharedQueue.<span class="built_in">front</span>(); <span class="comment">// 消费数据    </span></span><br><span class="line">SharedQueue.<span class="built_in">pop</span>();  </span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Consumer &quot;</span> &lt;&lt; id &lt;&lt; <span class="string">&quot; consumed: &quot;</span> &lt;&lt; value &lt;&lt; endl;  </span><br><span class="line">        <span class="keyword">if</span> (value == <span class="number">4</span>) <span class="keyword">break</span>; <span class="comment">// 结束条件  </span></span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">    <span class="type">bool</span> notify_all = <span class="literal">true</span>; <span class="comment">// 选择 notify_all 或 notify_one</span></span><br><span class="line">    <span class="function">std::thread <span class="title">producerThread</span><span class="params">(producer, notify_all)</span></span>;  </span><br><span class="line">    <span class="function">std::thread <span class="title">consumerThread1</span><span class="params">(consumer, <span class="number">1</span>)</span></span>;  </span><br><span class="line">    <span class="function">std::thread <span class="title">consumerThread2</span><span class="params">(consumer, <span class="number">2</span>)</span></span>;  </span><br><span class="line">  </span><br><span class="line">    producerThread.<span class="built_in">join</span>();  </span><br><span class="line">    consumerThread1.<span class="built_in">join</span>();  </span><br><span class="line">    consumerThread2.<span class="built_in">join</span>();  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>选择 <code>notify_one()</code>：等待队列中的第一个线程（和 id 等无关）执行函数<br><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Produced: 0</span><br><span class="line">Produced: 1</span><br><span class="line">Produced: 2</span><br><span class="line">...</span><br><span class="line">Consumer 1 consumed: 0</span><br><span class="line">Consumer 1 consumed: 1</span><br><span class="line">Produced: 9</span><br><span class="line">Produced: 10</span><br><span class="line">Consumer 1 consumed: 3</span><br><span class="line">Consumer 1 consumed: 4</span><br><span class="line">Consumer 1 consumed: 5</span><br><span class="line">...</span><br><span class="line">Consumer 1 consumed: 49999</span><br></pre></td></tr></table></figure></p><p>选择 <code>notify_all()</code>：由于消费者线程之间的竞争，很可能出现仅有 consumer 1/2 参与的情况。<br><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Produced: 0</span><br><span class="line">Produced: 1</span><br><span class="line">Produced: 2</span><br><span class="line">...</span><br><span class="line">Consumer 1 consumed: 0</span><br><span class="line">Consumer 1 consumed: 1</span><br><span class="line">Produced: 9</span><br><span class="line">Produced: 10</span><br><span class="line">Consumer 2 consumed: 3</span><br><span class="line">Consumer 2 consumed: 4</span><br><span class="line">Consumer 2 consumed: 5</span><br><span class="line">...</span><br><span class="line">Consumer 1 consumed: 49999</span><br></pre></td></tr></table></figure><br>每次运行的输出结果不会完全一致，但大体逻辑不变。<br><img src="https://i.imgur.com/uqJNdUG.png" alt="|916"></p><h2 id="🚩读写锁-shared-mutex"><a href="#🚩读写锁-shared-mutex" class="headerlink" title="🚩读写锁 shared_mutex"></a>🚩读写锁 shared_mutex</h2><h3 id="基本概念-1"><a href="#基本概念-1" class="headerlink" title="基本概念"></a>基本概念</h3><blockquote><p>什么是读写锁？</p></blockquote><p>读写锁（共享锁、独占锁）是一种同步机制，允许多个线程同时读取资源，但是同一时间只允许一个线程写入资源。</p><blockquote><p>基本特征？</p></blockquote><p>读读之间不互斥，写写/读写之间互斥。</p><div class="table-container"><table><thead><tr><th>特性</th><th>描述</th></tr></thead><tbody><tr><td>共享锁</td><td>- 允许多个线程同时持有<br>- 多个线程可以并发地读取共享资源<br>- 不能与独占锁同时持有</td></tr><tr><td>独占锁</td><td>- 只能有一个线程持有<br>- 持有独占锁的线程可以写入共享资源<br>- 当持有独占锁时，其他线程不能持有共享锁或独占锁</td></tr><tr><td>读写分离</td><td>- 读操作和写操作分开处理，提高并发性能<br>- 当持有独占锁时，其他线程不能持有共享锁或独占锁</td></tr><tr><td>互斥性</td><td>- 读写锁中的写操作与其他写操作、读操作互斥<br>- 读操作之间不互斥</td></tr><tr><td>公平性</td><td>- 有些读写锁实现提供公平性机制，确保读线程和写线程不会被长期阻塞</td></tr><tr><td>性能</td><td>- 在<font color="#00b050">读多写少</font>的情况下能显著提高性能<br>- 在写多的情况下，读写锁的性能优势可能不明显</td></tr></tbody></table></div><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><h4 id="shared-mutex"><a href="#shared-mutex" class="headerlink" title="shared_mutex"></a>shared_mutex</h4><p><code>std::shared_mutex</code> 是 C++17 引入的一种互斥锁，支持多读单写的并发访问模式。<br>它允许多个线程同时持有共享锁（读锁），但在持有独占锁时，其他线程不能再持有任何类型的锁。<br><img src="https://i.imgur.com/p13vBAL.png" alt="|566"><br>虽然其存在排他性锁定的成员函数（lock/unlock 等），但是一般使用：<br><code>unique_lock</code> / <code>lock_guard</code> 管理<font color="#00b050">独占锁</font>（排他性锁定），<code>shared_mutex</code> 管理<font color="#00b050">共享锁定</font>。<br><code>unique_lock</code> 和 <code>shared_mutex</code> 都会自动上锁（构造函数实现了）。前者位于头文件 <code>&lt;mutex&gt;</code> 中，后者位于头文件 <code>&lt;shared_mutex&gt;</code> 中。</p><h4 id="shared-lock"><a href="#shared-lock" class="headerlink" title="shared_lock"></a>shared_lock</h4><p>C++17 引入的一种锁管理器，用于管理 <code>shared_mutex</code> 的共享锁。<code>shared_lock</code> 同样可以自动获取和释放锁。<br><code>shared_lock</code> 也称通用共享互斥所有权包装器，<code>unique_lock</code> 也称独占所有权包装器，二者配合使用对 <code>shared_mutex</code> 进行管理，实现读写锁。</p><div class="table-container"><table><thead><tr><th>成员函数</th><th>作用</th></tr></thead><tbody><tr><td><code>std::shared_lock(mutex_type&amp; m)</code></td><td>构造时获取共享锁</td></tr><tr><td><code>std::shared_lock(mutex_type&amp; m, std::defer_lock)</code></td><td>构造时不获取锁</td></tr><tr><td><code>std::shared_lock(mutex_type&amp; m, std::try_to_lock)</code></td><td>构造时尝试获取共享锁</td></tr><tr><td><code>std::shared_lock(mutex_type&amp; m, std::adopt_lock)</code></td><td>构造时认为调用者已经持有共享锁</td></tr><tr><td><code>lock()</code></td><td>获取共享锁</td></tr><tr><td><code>try_lock()</code></td><td>尝试获取共享锁</td></tr><tr><td><code>unlock()</code></td><td>释放共享锁</td></tr><tr><td><code>owns_lock()</code></td><td>返回结果：锁是否被持有</td></tr><tr><td><code>release()</code></td><td>释放锁的所有权，但不解锁</td></tr></tbody></table></div><hr><p>💻代码示例：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;shared_mutex&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span>  </span></span><br><span class="line">  </span><br><span class="line">std::shared_mutex rw_mutex; <span class="comment">// 读写锁  </span></span><br><span class="line"><span class="type">int</span> shared_data = <span class="number">0</span>; <span class="comment">// 共享数据  </span></span><br><span class="line">  </span><br><span class="line"><span class="comment">// 读线程函数  </span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">reader</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">    <span class="function">std::shared_lock <span class="title">lock</span><span class="params">(rw_mutex)</span></span>; <span class="comment">// 申请共享锁  </span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Reader thread: &quot;</span> &lt;&lt; std::this_thread::<span class="built_in">get_id</span>() &lt;&lt; <span class="string">&quot; reads value: &quot;</span> &lt;&lt; shared_data &lt;&lt; std::endl;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">// 写线程函数  </span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">writer</span><span class="params">(<span class="type">int</span> value)</span> </span>&#123;  </span><br><span class="line">    <span class="function">std::unique_lock <span class="title">lock</span><span class="params">(rw_mutex)</span></span>; <span class="comment">// 申请独占锁  </span></span><br><span class="line">    shared_data = value; <span class="comment">// 修改共享数据  </span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Writer thread: &quot;</span> &lt;&lt; std::this_thread::<span class="built_in">get_id</span>() &lt;&lt; <span class="string">&quot; writes value: &quot;</span> &lt;&lt; shared_data &lt;&lt; std::endl;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">    std::vector&lt;std::thread&gt; threads; <span class="comment">// 用于存储线程的向量  </span></span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 创建读线程  </span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; ++i) &#123;  </span><br><span class="line">        threads.<span class="built_in">emplace_back</span>(reader);  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="comment">// 创建写线程  </span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; ++i) &#123;  </span><br><span class="line">        threads.<span class="built_in">emplace_back</span>(writer, i);  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="comment">// 等待所有线程完成  </span></span><br><span class="line">    <span class="keyword">for</span> (std::thread&amp; t : threads) &#123;  </span><br><span class="line">        t.<span class="built_in">join</span>();  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>输出结果：<br><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Reader thread: Reader thread: 3 reads value: Reader thread: 5 reads value: 00</span><br><span class="line">Reader thread: 4 reads value: 0</span><br><span class="line"></span><br><span class="line">Reader thread: 6 reads value: 0</span><br><span class="line">2 reads value: 0</span><br><span class="line">Writer thread: 7 writes value: 0</span><br><span class="line">Writer thread: 8 writes value: 1</span><br></pre></td></tr></table></figure><br>读的输出比较混乱，是因为读与读操作之间并不互斥。</p><h2 id="🚩原子变量和原子操作-atomic"><a href="#🚩原子变量和原子操作-atomic" class="headerlink" title="🚩原子变量和原子操作 atomic"></a>🚩原子变量和原子操作 atomic</h2><h3 id="基本概念-2"><a href="#基本概念-2" class="headerlink" title="基本概念"></a>基本概念</h3><blockquote><p>原子变量是什么？</p></blockquote><p>原子变量是指使用 <code>std::atomic</code> 模板类定义的变量，确保在多线程环境中，对变量的读写操作是线程安全的，不会被其他线程中断或干扰。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义原子变量</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;atomic&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">std::atomic&lt;<span class="type">int</span>&gt; <span class="title">atomicInt</span><span class="params">(<span class="number">10</span>)</span></span>;<span class="comment">//int型的原子变量</span></span><br></pre></td></tr></table></figure></p><blockquote><p>原子变量的特性</p></blockquote><ul><li><strong>原子性</strong>：对原子变量的读、写、修改操作是不可分割的，即操作<font color="#00b050">要么完全完成，要么完全不完成</font>。</li><li><strong>无锁</strong>：原子操作<font color="#00b050">不需要锁机制</font>，因此不会引起上下文切换，具有更高的性能。（上下文切换：指操作系统从一个线程转换到另一线程的过程）</li><li><strong>易用性</strong>：标准库提供了原子操作接口，简化了<font color="#00b050">多线程编程中的同步问题</font>。</li></ul><blockquote><p>原子操作是什么？</p></blockquote><p>原子操作是指对原子变量进行的不可分割的操作。不可分割的意思是这些操作要么完全执行，要么完全不执行，不会在执行过程中被其他线程打断。</p><h3 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;atomic&gt;</span>  </span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;  </span><br><span class="line">  </span><br><span class="line">atomic&lt;<span class="type">int</span>&gt; num = <span class="number">0</span>;  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">AddNum</span><span class="params">()</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000000</span>; ++i) &#123;  </span><br><span class="line">        num++;  </span><br><span class="line">        <span class="comment">//num += 1;//结果为2000000</span></span><br><span class="line">        <span class="comment">//num = num + 1;  //结果为1259262</span></span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">    <span class="function">thread <span class="title">t1</span><span class="params">(AddNum)</span></span>;  </span><br><span class="line">    <span class="function">thread <span class="title">t2</span><span class="params">(AddNum)</span></span>;  </span><br><span class="line">    t1.<span class="built_in">join</span>();  </span><br><span class="line">    t2.<span class="built_in">join</span>();  </span><br><span class="line">    cout &lt;&lt; num &lt;&lt; endl;<span class="comment">//2000000</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>✅注意：原子变量可以进行原子操作，原子操作才是真正保证变量是线程安全的根本原因。即使使用原子变量，如果进行的不是原子操作，也无法保证线程安全。<br>如果使用 <code>num = num + 1</code>，会发现输出结果并不是预期的 2000000，这是因为该操作并不是原子操作（没有被 <code>atomic</code> 类重载）。</p><h3 id="常见原子操作方法"><a href="#常见原子操作方法" class="headerlink" title="常见原子操作方法"></a>常见原子操作方法</h3><ol><li>加载和存储操作<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> value = atomicInt.<span class="built_in">load</span>();<span class="comment">//原子加载</span></span><br><span class="line">atomicInt.<span class="built_in">store</span>(<span class="number">10</span>);<span class="comment">//原子存储</span></span><br></pre></td></tr></table></figure></li><li>读写操作（等价于 load 和 store）<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> value = atomicInt;<span class="comment">//原子读取</span></span><br><span class="line">atomicInt = <span class="number">10</span>;<span class="comment">//原子写入</span></span><br></pre></td></tr></table></figure></li><li>自增自减操作<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">atomicInt++;</span><br><span class="line">atomicInt--;</span><br><span class="line">++atomicInt;</span><br><span class="line">--atomicInt;</span><br></pre></td></tr></table></figure></li><li>复合赋值操作<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">atomicInt += <span class="number">5</span>;<span class="comment">//原子加</span></span><br><span class="line">atomicInt &amp;= <span class="number">3</span>;<span class="comment">//原子位与</span></span><br></pre></td></tr></table></figure></li><li>高级操作<br><code>compare_exchange</code>：比较当前值和期望值，如果相等则将当前值替换为新值，否则更新期望值。<br><code>fetch_add</code> / <code>fetch_sub</code> / <code>fetch_and</code>：对当前值进行加法/减法/按位与操作，并返回操作前的值。<br><code>exchange</code>：交换当前值和新值，并返回旧值。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> expected = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> desired = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> (atomicInt.<span class="built_in">compare_exchange_strong</span>(expected, desired))</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 如果atomicInt == expected，则让atomicInt = desired并返回true</span></span><br><span class="line"><span class="comment">// 否则expected = atomicInt，返回false</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">atomicInt.<span class="built_in">fetch_add</span>(<span class="number">1</span>, memory_order_relaxed);</span><br><span class="line"></span><br><span class="line"><span class="function">std::atomic&lt;<span class="type">int</span>&gt; <span class="title">value</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line"><span class="type">int</span> old_value = value.<span class="built_in">exchange</span>(<span class="number">20</span>); <span class="comment">// 交换值，返回旧值 10，现在value = 20</span></span><br></pre></td></tr></table></figure>以上原子操作仅针对原子变量生效。<h3 id="原子操作的内存序问题"><a href="#原子操作的内存序问题" class="headerlink" title="原子操作的内存序问题"></a>原子操作的内存序问题</h3>原子操作可以指定不同的内存顺序，以控制操作的可见性和排序。<br>内存序不会影响原子操作的原子性，但会影响操作的可见性和顺序。</li></ol><div class="table-container"><table><thead><tr><th>顺序</th><th>特点</th></tr></thead><tbody><tr><td><code>memory_order_relaxed</code></td><td>没有同步或顺序约束，仅保证原子性</td></tr><tr><td><code>memory_order_acquire</code></td><td>确保该操作之前的所有读操作不会被重排序到该操作之后</td></tr><tr><td><code>memory_order_release</code></td><td>确保该操作之后的所有写操作不会被重排序到该操作之前</td></tr><tr><td><code>memory_order_acq_rel</code></td><td>同时具备 acquire 和 release 的属性</td></tr><tr><td><code>memory_order_seq_cst</code></td><td>顺序一致性，保证所有线程的操作按照顺序发生</td></tr></tbody></table></div><h2 id="🚩信号量-semaphore"><a href="#🚩信号量-semaphore" class="headerlink" title="🚩信号量 semaphore"></a>🚩信号量 semaphore</h2><h3 id="基本概念-3"><a href="#基本概念-3" class="headerlink" title="基本概念"></a>基本概念</h3><blockquote><p>什么是信号量？</p></blockquote><p>信号量（Semaphore）是一种用于管理和协调多线程或多进程访问共享资源的同步机制。它<font color="#00b050">通过计数器来控制对资源的访问数量</font>，确保多个线程或进程能够安全地使用共享资源而不会发生数据竞争或死锁。传统的锁（如互斥锁）可以用来保护共享资源，但对于某些场景（如<font color="#00b050">资源的计数管理</font>），信号量提供了更灵活和高效的解决方案。</p><blockquote><p>信号量的类型？</p></blockquote><ol><li>计数信号量：允许对资源的多次访问，计数信号量的值可以是任意非负整数，表示可以同时访问资源的线程或进程的数量。</li><li>二元信号量：也称为互斥信号量 mutex，其值只能是 0 或 1，类似于互斥锁，用于实现对资源的互斥访问。</li></ol><blockquote><p>信号量的作用？</p></blockquote><p><img src="https://i.imgur.com/dyvLJVP.png" alt="|684"></p><blockquote><p>信号量的基本操作？</p></blockquote><ul><li>P 操作（等待，wait）：如果信号量的值大于 0，则将其减 1，否则线程会被阻塞，直到信号量的值大于 0。</li><li>V 操作（释放，signal）：将信号量的值加 1，如果有线程被阻塞在 P 操作上，则唤醒一个阻塞的线程。<br>PV 操作均为原子操作。类似加锁解锁的操作。<br><img src="https://i.imgur.com/EE1rJR3.png" alt="|590"><h3 id="counting-semaphore"><a href="#counting-semaphore" class="headerlink" title="counting_semaphore"></a>counting_semaphore</h3><code>std::counting_semaphore</code> 是 C++20 标准库中的一个类模板，实现了一个计数信号量。需要头文件 <code>&lt;semaphore&gt;</code><br>禁止拷贝构造，禁止拷贝赋值操作（不允许 <code>a(b)</code> 或者 <code>a = b</code>）。</li></ul><div class="table-container"><table><thead><tr><th>成员函数</th><th>作用</th></tr></thead><tbody><tr><td><code>void acquire()</code></td><td>尝试获取信号量，如果信号量的计数值为 0，则阻塞当前线程，直到计数值大于 0。</td></tr><tr><td><code>bool try_acquire()</code></td><td>- 尝试获取信号量。如果信号量的计数值大于 0，则将其减 1 并返回 <code>true</code>。 <br>- 如果计数值为 0，则立即返回 <code>false</code>，不会阻塞。</td></tr><tr><td><code>bool try_acquire_for(const chrono::duration&amp;)</code></td><td>- 如果在指定时间内信号量的计数值大于 0，则将其减 1 并返回 <code>true</code>。<br>- 如果超时仍未获取到信号量，则返回 <code>false</code>。</td></tr><tr><td><code>bool try_acquire_until(const chrono::time_point&amp;)</code></td><td>- 如果在指定时间点之前信号量的计数值大于 0，则将其减 1 并返回 <code>true</code>。<br>- 如果超时仍未获取到信号量，则返回 <code>false</code>。</td></tr><tr><td><code>void release(std::ptrdiff_t update = 1)</code></td><td>释放信号量，增加信号量的计数值。默认加 1。</td></tr></tbody></table></div><p>示例：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;semaphore&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个最大值为 5 的计数信号量</span></span><br><span class="line"><span class="function">std::counting_semaphore&lt;5&gt; <span class="title">semaphore</span><span class="params">(<span class="number">3</span>)</span></span>; <span class="comment">// 初始值为 3</span></span><br><span class="line">semaphore.<span class="built_in">acquire</span>(); <span class="comment">// 计数值减 1，变为 2</span></span><br><span class="line">semaphore.<span class="built_in">release</span>(); <span class="comment">// 计数值增加 1，变为 3</span></span><br><span class="line">semaphore.<span class="built_in">release</span>(<span class="number">2</span>); <span class="comment">// 计数值增加 2，变为 5</span></span><br><span class="line"><span class="comment">// 创建一个动态最大值的计数信号量</span></span><br><span class="line">std::counting_semaphore&lt;&gt; <span class="built_in">dynamic_semaphore</span>(<span class="number">2</span>); <span class="comment">// 初始值为 2</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (semaphore.<span class="built_in">try_acquire_for</span>(std::chrono::<span class="built_in">seconds</span>(<span class="number">1</span>))) &#123;</span><br><span class="line">    <span class="comment">// 成功获取信号量</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 超时未获取到信号量</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="💻代码示例-2"><a href="#💻代码示例-2" class="headerlink" title="💻代码示例"></a>💻代码示例</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;semaphore&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span>  </span></span><br><span class="line">  </span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;  </span><br><span class="line">  </span><br><span class="line"><span class="function">std::counting_semaphore&lt;1&gt; <span class="title">sem</span><span class="params">(<span class="number">1</span>)</span></span>;  <span class="comment">//初始值为1的计数信号量; sem.max()为1  </span></span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">worker</span><span class="params">(<span class="type">int</span> id)</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    sem.<span class="built_in">acquire</span>();  <span class="comment">//P操作，等待信号量大于0并将其减1  </span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;worker &quot;</span> &lt;&lt; id &lt;&lt; <span class="string">&quot; is working&quot;</span> &lt;&lt; endl;  </span><br><span class="line">    std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">seconds</span>(<span class="number">1</span>));    <span class="comment">//模拟工作  </span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;worker &quot;</span> &lt;&lt; id &lt;&lt; <span class="string">&quot; is done&quot;</span> &lt;&lt; endl;  </span><br><span class="line">    sem.<span class="built_in">release</span>();  <span class="comment">//V操作，将信号量加1  </span></span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;max &quot;</span> &lt;&lt; sem.<span class="built_in">max</span>() &lt;&lt; endl;  </span><br><span class="line">    vector&lt;thread&gt; threads;  </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; ++i) &#123;  </span><br><span class="line">        threads.<span class="built_in">emplace_back</span>(worker, i);  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">for</span> (thread&amp; t : threads) &#123;  </span><br><span class="line">        t.<span class="built_in">join</span>();  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：<br><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">max 1</span><br><span class="line">worker 0 is working</span><br><span class="line">worker 0 is done</span><br><span class="line">worker 3 is working</span><br><span class="line">worker 3 is done</span><br><span class="line">worker 4 is working</span><br><span class="line">worker 4 is done</span><br><span class="line">worker 1 is working</span><br><span class="line">worker 1 is done</span><br><span class="line">worker 2 is working</span><br><span class="line">worker 2 is done</span><br></pre></td></tr></table></figure></p><p>使用多个信号量：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 信号量，用于线程同步，初始计数值为0，用于控制 work 线程的执行</span></span><br><span class="line"><span class="function">std::counting_semaphore&lt;1&gt; <span class="title">ready</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 信号量，用于线程同步，初始计数值为1，用于控制 prepare 线程的执行</span></span><br><span class="line"><span class="function">std::counting_semaphore&lt;1&gt; <span class="title">done</span><span class="params">(<span class="number">1</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">prepare</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    done.<span class="built_in">acquire</span>(); <span class="comment">// 减少信号量 done 的计数值，确保 prepare 在 work 完成之前不再执行</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Preparing...\n&quot;</span>;</span><br><span class="line">    std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">seconds</span>(<span class="number">2</span>)); <span class="comment">// 模拟准备工作的耗时</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Preparation done.\n&quot;</span>;</span><br><span class="line">    ready.<span class="built_in">release</span>(); <span class="comment">// 增加信号量 ready 的计数值，通知 work 线程可以开始工作</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">work</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ready.<span class="built_in">acquire</span>(); <span class="comment">// 等待 ready 信号量，确保准备工作完成后再执行</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Working...\n&quot;</span>;</span><br><span class="line">    std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">seconds</span>(<span class="number">2</span>)); <span class="comment">// 模拟工作的耗时</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Work done.\n&quot;</span>;</span><br><span class="line">    done.<span class="built_in">release</span>(); <span class="comment">// 增加信号量 done 的计数值，通知 prepare 线程可以重新进入准备阶段</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::thread <span class="title">t1</span><span class="params">(prepare)</span></span>; <span class="comment">// 创建 prepare 线程，执行准备工作</span></span><br><span class="line">    <span class="function">std::thread <span class="title">t2</span><span class="params">(work)</span></span>; <span class="comment">// 创建 work 线程，执行主要工作</span></span><br><span class="line"></span><br><span class="line">    t1.<span class="built_in">join</span>(); <span class="comment">// 等待 prepare 线程执行完成</span></span><br><span class="line">    t2.<span class="built_in">join</span>(); <span class="comment">// 等待 work 线程执行完成</span></span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;All tasks completed.\n&quot;</span>; <span class="comment">// 所有工作完成</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>输出结果：<br><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Preparing...</span><br><span class="line">Preparation done.</span><br><span class="line">Working...</span><br><span class="line">Work done.</span><br><span class="line">All tasks completed.</span><br></pre></td></tr></table></figure></p><h2 id="栅栏-barrier"><a href="#栅栏-barrier" class="headerlink" title="栅栏 barrier"></a>栅栏 barrier</h2><h3 id="基本概念-4"><a href="#基本概念-4" class="headerlink" title="基本概念"></a>基本概念</h3><blockquote><p>什么是栅栏？</p></blockquote><p>栅栏是一种同步原语，用于协调多个线程的执行，使得它们能够<font color="#00b050">在某个特定的点（即栅栏）等待</font>。直到所有线程都达到这一个点，才能继续执行。<br>位于 C++20 的头文件 <code>&lt;barrier&gt;</code> 中。</p><blockquote><p>栅栏的作用？</p></blockquote><p>确保并发任务在某些关键时刻同步，比如等待所有线程完成某个阶段的工作，然后再进入下一阶段。<br><img src="https://i.imgur.com/kD6MTES.png" alt="|807"><br>用于阶段同步和批处理。</p><blockquote><p>栅栏的特点？</p></blockquote><ol><li><strong>同步点</strong>：栅栏用于创建一个同步点，确保多个线程在同一时刻同步。</li><li><strong>计数器</strong>：栅栏内部维护一个计数器，记录到达栅栏的线程数量。当计数器达到预设值时，所有等待的线程被同时唤醒。</li><li><strong>可重用性</strong>：C++20 中的 <code>std::barrier</code> 是可重用的，线程可以反复使用同一个栅栏对象进行同步。</li></ol><h3 id="💻代码实现"><a href="#💻代码实现" class="headerlink" title="💻代码实现"></a>💻代码实现</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span>    </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;barrier&gt;</span>  </span></span><br><span class="line">  </span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">worker</span><span class="params">(<span class="type">int</span> id, std::barrier&lt;&gt;&amp; sync_point)</span> <span class="comment">//同步点需要为引用  </span></span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Worker &quot;</span> &lt;&lt; id &lt;&lt; <span class="string">&quot; is doing phase 1 work.\n&quot;</span>;  </span><br><span class="line">    std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">milliseconds</span>(<span class="number">100</span> * id));   <span class="comment">//模拟不同的工作时间  </span></span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 到达栅栏，等待其他线程  </span></span><br><span class="line">    sync_point.<span class="built_in">arrive_and_wait</span>();  </span><br><span class="line">  </span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Worker &quot;</span> &lt;&lt; id &lt;&lt; <span class="string">&quot; has completed phase 1 and is doing phase 2 work.\n&quot;</span>;  </span><br><span class="line">    std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">milliseconds</span>(<span class="number">100</span> * id));   <span class="comment">//模拟不同的工作时间  </span></span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> num_threads = <span class="number">5</span>;  </span><br><span class="line">    <span class="function">std::barrier <span class="title">sync_point</span><span class="params">(num_threads)</span></span>;   <span class="comment">//创建barrier对象，记录同步点  </span></span><br><span class="line">  </span><br><span class="line">    vector&lt;thread&gt; threads;  </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= num_threads; ++i) &#123;  </span><br><span class="line">        threads.<span class="built_in">emplace_back</span>(worker, i, std::<span class="built_in">ref</span>(sync_point));  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">for</span> (thread&amp; t : threads)&#123;  </span><br><span class="line">        t.<span class="built_in">join</span>();  </span><br><span class="line">    &#125;  </span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;All tasks completed.\n&quot;</span>; <span class="comment">// 所有工作完成  </span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：<br><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Worker Worker 2 is doing phase 1 work.</span><br><span class="line">1 is doing phase 1 work.</span><br><span class="line">Worker 3 is doing phase 1 work.</span><br><span class="line">Worker 4 is doing phase 1 work.</span><br><span class="line">Worker 5 is doing phase 1 work.</span><br><span class="line">Worker Worker 5 has completed phase 1 and is doing phase 2 work.</span><br><span class="line">Worker 1 has completed phase 1 and is doing phase 2 work.</span><br><span class="line">Worker 3 has completed phase 1 and is doing phase 2 work.</span><br><span class="line">4 has completed phase 1 and is doing phase 2 work.</span><br><span class="line">Worker 2 has completed phase 1 and is doing phase 2 work.</span><br><span class="line">All tasks completed.</span><br></pre></td></tr></table></figure></p><h2 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h2><blockquote><p>什么是死锁？</p></blockquote><p>死锁是指两个或者多个进程<font color="#00b050">互相等待对方释放资源</font>，从而导致所有进程或线程都无法继续执行的现象。<br><img src="https://i.imgur.com/tSbM0ar.png" alt="|647"></p><blockquote><p>死锁的必要条件？</p></blockquote><ol><li><strong>互斥</strong>：资源一次只能被一个资源占用。</li><li><strong>请求和保持</strong>：线程已经持有至少一个资源，同时又申请新的资源，而新资源已经被其他线程占有。</li><li><strong>不剥夺</strong>：已经获得的资源在未使用完之前，不能被强行剥夺，只能在使用完毕后自己释放。</li><li><strong>循环等待</strong>：存在一个线程循环的链，链中的每个线程都持有下一个线程需要的资源。<br>要想解决死锁这一问题，就需要避开上面四点，可以使用高级同步工具（如 <code>unique_lock</code> 等）。</li></ol><h3 id="💻代码示例-3"><a href="#💻代码示例-3" class="headerlink" title="💻代码示例"></a>💻代码示例</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//当线程1 持有 mtx1 并等待 mtx2 时，线程2 持有 mtx2 并等待 mtx1。</span></span><br><span class="line"><span class="comment">//两个线程互相等待对方释放锁，导致死锁</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"></span><br><span class="line">std::mutex mtx1; <span class="comment">// 第一个互斥锁</span></span><br><span class="line">std::mutex mtx2; <span class="comment">// 第二个互斥锁</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">thread1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock1</span><span class="params">(mtx1)</span></span>; <span class="comment">// 先锁定 mtx1</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Thread 1 acquired mtx1\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 模拟一些工作</span></span><br><span class="line">    std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">milliseconds</span>(<span class="number">100</span>));</span><br><span class="line"></span><br><span class="line">    <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock2</span><span class="params">(mtx2)</span></span>; <span class="comment">// 再锁定 mtx2</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Thread 1 acquired mtx2\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">thread2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock2</span><span class="params">(mtx2)</span></span>; <span class="comment">// 先锁定 mtx2</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Thread 2 acquired mtx2\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 模拟一些工作</span></span><br><span class="line">    std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">milliseconds</span>(<span class="number">100</span>));</span><br><span class="line"></span><br><span class="line">    <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock1</span><span class="params">(mtx1)</span></span>; <span class="comment">// 再锁定 mtx1</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Thread 2 acquired mtx1\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::thread <span class="title">t1</span><span class="params">(thread1)</span></span>;</span><br><span class="line">    <span class="function">std::thread <span class="title">t2</span><span class="params">(thread2)</span></span>;</span><br><span class="line"></span><br><span class="line">    t1.<span class="built_in">join</span>();</span><br><span class="line">    t2.<span class="built_in">join</span>();</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;All threads completed.\n&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Thread 1 acquired mtx1</span></span><br><span class="line"><span class="comment">//Thread 2 acquired mtx2</span></span><br><span class="line"><span class="comment">//导致死锁</span></span><br></pre></td></tr></table></figure><ol><li><p>同时锁定两个锁</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">thread1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">lock</span>(mtx1, mtx2); <span class="comment">// 同时锁定 mtx1 和 mtx2</span></span><br><span class="line">    <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock1</span><span class="params">(mtx1, std::adopt_lock)</span></span>;</span><br><span class="line">    <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock2</span><span class="params">(mtx2, std::adopt_lock)</span></span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Thread 1 acquired both locks\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">thread2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::<span class="built_in">lock</span>(mtx1, mtx2); <span class="comment">// 同时锁定 mtx1 和 mtx2</span></span><br><span class="line">    <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock1</span><span class="params">(mtx1, std::adopt_lock)</span></span>;</span><br><span class="line">    <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock2</span><span class="params">(mtx2, std::adopt_lock)</span></span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Thread 2 acquired both locks\n&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>统一锁定顺序</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">thread1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock1</span><span class="params">(mtx1)</span></span>; <span class="comment">// 先锁定 mtx1</span></span><br><span class="line">    <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock2</span><span class="params">(mtx2)</span></span>; <span class="comment">// 再锁定 mtx2</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Thread 1 acquired both locks\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">thread2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock1</span><span class="params">(mtx1)</span></span>; <span class="comment">// 先锁定 mtx1</span></span><br><span class="line">    <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock2</span><span class="params">(mtx2)</span></span>; <span class="comment">// 再锁定 mtx2</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Thread 2 acquired both locks\n&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>使用 <code>std::unique_lock</code> 和 <code>std::defer_lock</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">thread1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock1</span><span class="params">(mtx1, std::defer_lock)</span></span>;</span><br><span class="line">    <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock2</span><span class="params">(mtx2, std::defer_lock)</span></span>;</span><br><span class="line">    std::<span class="built_in">lock</span>(lock1, lock2); <span class="comment">// 同时锁定</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Thread 1 acquired both locks\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">thread2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock1</span><span class="params">(mtx1, std::defer_lock)</span></span>;</span><br><span class="line">    <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock2</span><span class="params">(mtx2, std::defer_lock)</span></span>;</span><br><span class="line">    std::<span class="built_in">lock</span>(lock1, lock2); <span class="comment">// 同时锁定</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Thread 2 acquired both locks\n&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h1 id="异步编程"><a href="#异步编程" class="headerlink" title="异步编程"></a>异步编程</h1><h2 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h2><blockquote><p>什么是异步？</p></blockquote><p>允许程序在等待某些操作完成时继续执行其他任务，而不是阻塞或等待这些操作完成。</p><blockquote><p>异步编程的优点？为什么选择异步编程？</p></blockquote><ul><li><strong>提高性能</strong>：通过并发执行多个任务，异步编程可以更高效地利用 CPU 资源。</li><li><strong>提高响应速度</strong>：异步编程时程序在等待某些操作完成时继续响应用户输入，提高用户体验。</li><li><strong>简化 I/O 操作</strong>：异步编程非常适合处理 I/O 密集型操作，比如文件读取、网络请求等。</li></ul><h2 id="🚩async"><a href="#🚩async" class="headerlink" title="🚩async"></a>🚩async</h2><h3 id="基本概念-5"><a href="#基本概念-5" class="headerlink" title="基本概念"></a>基本概念</h3><blockquote><p>什么是 <code>async</code>？</p></blockquote><p><code>async</code> 是一个函数模板，包含在头文件 <code>&lt;future&gt;</code> 中，用于启动一个异步任务。<br>它接受一个可调用对象作为参数，并在一个单独的线程上异步执行该对象。<br><code>std::async</code> <strong>自动管理异步任务的生命周期</strong>，并返回一个 <code>std::future</code> 对象，该对象可用于获取异步操作的结果。</p><blockquote><p>什么是 <code>future</code>？</p></blockquote><p><code>std::future</code> 是一个模板类，用于表示异步操作的结果。<br><code>std::future</code> 对象需要借助 <code>std::async</code>、<code>std::promise</code>、<code>std::packaged_task</code> 结合使用。</p><h3 id="💻代码实现-1"><a href="#💻代码实现-1" class="headerlink" title="💻代码实现"></a>💻代码实现</h3><p>🚀<code>future</code> 的基本成员函数：</p><div class="table-container"><table><thead><tr><th>成员函数</th><th>作用</th></tr></thead><tbody><tr><td><code>get()</code></td><td>获取异步任务的返回值。如果任务尚未完成，会阻塞直到任务完成。</td></tr><tr><td><code>wait()</code></td><td>等待异步任务完成，但不获取返回值。</td></tr><tr><td><code>wait_for()</code></td><td>等待异步任务完成，直到指定的时间。<br>如果任务在指定时间内完成，返回 <code>std::future_status::ready</code>；<br>如果任务未完成，返回 <code>std::future_status::timeout</code>。</td></tr><tr><td><code>wait_until()</code></td><td>等待异步任务完成，直到指定的时间点。<br>如果任务在指定时间点前完成，返回 <code>std::future_status::ready</code>；<br>如果任务未完成，返回 <code>std::future_status::timeout</code>。</td></tr><tr><td><code>valid()</code></td><td>检查 <code>std::future</code> 对象是否持有有效的异步任务。<br>如果对象有效，返回 <code>true</code>；否则返回 <code>false</code>。</td></tr><tr><td><code>share()</code></td><td>返回一个 <code>std::shared_future</code> 对象，允许多个线程共享异步任务的结果。</td></tr></tbody></table></div><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;future&gt;</span>  </span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">myfunc</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;  </span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;This is myfunc&quot;</span> &lt;&lt; <span class="string">&quot; &quot;</span>;  </span><br><span class="line">    <span class="keyword">return</span> a + b;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">    <span class="comment">// async的返回对象必须要赋值使用，不能直接async(myfunc, 1, 2);  </span></span><br><span class="line">    future&lt;<span class="type">int</span>&gt; MyFunc = <span class="built_in">async</span>(myfunc, <span class="number">1</span>, <span class="number">2</span>);<span class="comment">/* 等价于 thread t(myfunc, 1, 2); t.join(); 所以会输出&quot;This is my func&quot; */</span>    </span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;MyFunc == &quot;</span> &lt;&lt; MyFunc.<span class="built_in">get</span>() &lt;&lt; <span class="string">&quot; test&quot;</span> &lt;&lt; endl;  <span class="comment">// MyFunc.get()的返回值为3</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">//MyFunc == This is myfunc 3 test//输出顺序不固定，但test一定在3之后输出，3一定在两句以后输出</span></span><br></pre></td></tr></table></figure><p>✅注意：</p><ul><li><code>get()</code> <font color="#00b050">等待异步操作完成</font>后，再获取结果。如果异步操作尚未完成，调用 <code>get()</code> 的线程将被阻塞，直到操作完成。</li><li>一旦调用 <code>get()</code>，它将返回异步操作的结果，并且 <code>future</code> 对象<font color="#00b050">将变为无效状态</font>，不能再调用 <code>get()</code>。一个 <code>future</code> 对象只能调用一次 <code>get()</code>。</li><li><code>wait()</code> 等待异步操作完成，但不获取结果。与 <code>get()</code> 不同之处在于，调用 <code>wait()</code> 后，<code>future</code> 对象仍然有效，可以继续使用 <code>get()</code> 来获取结果。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;future&gt;</span>  </span></span><br><span class="line">  </span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">myfunc</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;  </span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;This is myfunc &quot;</span>;  </span><br><span class="line">    <span class="keyword">return</span> a + b;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">    future&lt;<span class="type">int</span>&gt; MyFunc = <span class="built_in">async</span>(myfunc, <span class="number">1</span>, <span class="number">2</span>);  </span><br><span class="line">    MyFunc.<span class="built_in">wait</span>();  <span class="comment">//等待异步操作完成，之后进行下一步操作</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;MyFunc == &quot;</span> &lt;&lt; MyFunc.<span class="built_in">get</span>() &lt;&lt; <span class="string">&quot; test&quot;</span> &lt;&lt; endl;  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">//This is myfunc MyFunc == 3 test//此时输出顺序固定</span></span><br></pre></td></tr></table></figure><h3 id="三种启动策略"><a href="#三种启动策略" class="headerlink" title="三种启动策略"></a>三种启动策略</h3><div class="table-container"><table><thead><tr><th>启动策略</th><th>是否创建新线程</th><th>任务执行时机</th><th>适用场景</th></tr></thead><tbody><tr><td><code>std::launch::async</code></td><td>是</td><td>立即执行，创建新线程</td><td>需要并发执行的任务，任务可以立即开始执行。</td></tr><tr><td><code>std::launch::deferred</code></td><td>否</td><td>延迟执行，调用 <code>get()</code> 或 <code>wait()</code> 时</td><td>不需要立即执行的任务，任务可以在需要时才执行。</td></tr><tr><td>默认</td><td>由实现决定</td><td>由实现决定</td><td>不确定任务是否需要立即执行，由实现自动选择执行方式。</td></tr></tbody></table></div><ol><li><p><code>launch::async</code>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span>   <span class="comment">// this_thread需要头文件和std命名空间  </span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;future&gt;</span>  </span></span><br><span class="line">  </span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">myfunc</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;  </span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;This is myfunc: &quot;</span> &lt;&lt; this_thread::<span class="built_in">get_id</span>() &lt;&lt; endl;  </span><br><span class="line">    <span class="keyword">return</span> a + b;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">    future&lt;<span class="type">int</span>&gt; MyFunc = <span class="built_in">async</span>(launch::async, myfunc, <span class="number">1</span>, <span class="number">2</span>);  </span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;This is main: &quot;</span> &lt;&lt; this_thread::<span class="built_in">get_id</span>() &lt;&lt; endl;  </span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;This is from myfunc: &quot;</span> &lt;&lt; MyFunc.<span class="built_in">get</span>() &lt;&lt; endl;  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">//This is main: This is myfunc: 21  </span></span><br><span class="line"><span class="comment">//This is from myfunc:  </span></span><br><span class="line"><span class="comment">//3</span></span><br></pre></td></tr></table></figure><p>这里由于策略原因，多句话立即同时执行了，<code>async</code> 创建的新线程和主线程同时进行。<br>加上 <code>wait()</code> 即可观察正确的线程 id：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">    future&lt;<span class="type">int</span>&gt; MyFunc = <span class="built_in">async</span>(launch::async, myfunc, <span class="number">1</span>, <span class="number">2</span>);  </span><br><span class="line">    MyFunc.<span class="built_in">wait</span>();  </span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;This is main: &quot;</span> &lt;&lt; this_thread::<span class="built_in">get_id</span>() &lt;&lt; endl;  </span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;This is from myfunc: &quot;</span> &lt;&lt; MyFunc.<span class="built_in">get</span>() &lt;&lt; endl;  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">//This is myfunc: 2  </span></span><br><span class="line"><span class="comment">//This is main: 1  </span></span><br><span class="line"><span class="comment">//This is from myfunc: 3</span></span><br></pre></td></tr></table></figure></li><li><p><code>launch::deferred</code>：<br>需要注意的是，可能隐藏潜在的并发问题，因为任务可能在查询结果时才执行。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">    future&lt;<span class="type">int</span>&gt; MyFunc = <span class="built_in">async</span>(launch::deferred, myfunc, <span class="number">1</span>, <span class="number">2</span>);  </span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;This is main: &quot;</span> &lt;&lt; this_thread::<span class="built_in">get_id</span>() &lt;&lt; endl;  </span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;This is from myfunc: &quot;</span> &lt;&lt; MyFunc.<span class="built_in">get</span>() &lt;&lt; endl;  <span class="comment">// 调用get()方法时才执行myfunc()</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">//This is main: 1  </span></span><br><span class="line"><span class="comment">//This is from myfunc: This is myfunc: 1  </span></span><br><span class="line"><span class="comment">//3</span></span><br></pre></td></tr></table></figure><p>加入 <code>wait</code> 方法：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">    future&lt;<span class="type">int</span>&gt; MyFunc = <span class="built_in">async</span>(launch::deferred, myfunc, <span class="number">1</span>, <span class="number">2</span>);  </span><br><span class="line">    MyFunc.<span class="built_in">wait</span>();  </span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;This is main: &quot;</span> &lt;&lt; this_thread::<span class="built_in">get_id</span>() &lt;&lt; endl;  </span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;This is from myfunc: &quot;</span> &lt;&lt; MyFunc.<span class="built_in">get</span>() &lt;&lt; endl;  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">//This is myfunc: 1  </span></span><br><span class="line"><span class="comment">//This is main: 1  </span></span><br><span class="line"><span class="comment">//This is from myfunc: 3</span></span><br></pre></td></tr></table></figure><p>可以看出，<code>launch::deferred</code> 策略并没有创建新的线程，并且在调用 <code>get</code> 方法时才执行 <code>myfunc()</code></p></li></ol><h2 id="🚩promise"><a href="#🚩promise" class="headerlink" title="🚩promise"></a>🚩promise</h2><h3 id="基本概念-6"><a href="#基本概念-6" class="headerlink" title="基本概念"></a>基本概念</h3><blockquote><p>promise 是什么？</p></blockquote><p><code>std::promise</code> 是一个用于设置异步操作结果的机制。它允许在一个线程中<font color="#00b050">设置值或异常</font>，然后在另一个线程中通过 <code>std::future</code> 对象检索这些值或异常。<br>通常与 <code>std::async</code>、<code>std::packaged_task</code> 或 <code>std::thread</code> 结合使用。需要头文件 <code>&lt;future&gt;</code>。</p><p>一个 promise 对象可以创建多个 future 对象。<br><img src="https://i.imgur.com/Srt7GAa.png" alt="|607"></p><h3 id="💻代码实现-2"><a href="#💻代码实现-2" class="headerlink" title="💻代码实现"></a>💻代码实现</h3><p>设置值：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">AsyncTask</span><span class="params">(promise&lt;<span class="type">int</span>&gt; prom)</span> </span>&#123;  </span><br><span class="line">    std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">seconds</span>(<span class="number">1</span>));  </span><br><span class="line">    prom.<span class="built_in">set_value</span>(<span class="number">3</span>);  <span class="comment">// 设置异步操作的结果  </span></span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">    std::promise&lt;<span class="type">int</span>&gt; prom;  </span><br><span class="line">    std::future&lt;<span class="type">int</span>&gt; FutureObj = prom.<span class="built_in">get_future</span>(); <span class="comment">//获取与promise关联的future。&lt;int&gt;指prom.set_value的参数类型</span></span><br><span class="line">  </span><br><span class="line">    <span class="function">std::thread <span class="title">t</span><span class="params">(AsyncTask, std::move(prom))</span></span>;  <span class="comment">//启动异步任务，并传递参数promise  </span></span><br><span class="line">  </span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;The result is: &quot;</span> &lt;&lt; FutureObj.<span class="built_in">get</span>() &lt;&lt; endl;  </span><br><span class="line">  </span><br><span class="line">    t.<span class="built_in">join</span>();   <span class="comment">//等待线程结束。必须加上  </span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">//The result is: 3</span></span><br></pre></td></tr></table></figure><br><code>promise</code> 比 <code>async</code> 更加灵活，拥有更多功能。</p><div class="table-container"><table><thead><tr><th>成员函数</th><th>作用</th></tr></thead><tbody><tr><td><code>get_future()</code></td><td>获取与 <code>std::promise</code> 关联的 <code>std::future</code> 对象。</td></tr><tr><td><code>set_value()</code></td><td>设置 <code>std::promise</code> 的值。</td></tr><tr><td><code>set_exception()</code></td><td>设置 <code>std::promise</code> 的异常。</td></tr><tr><td><code>set_value_at_thread_exit()</code></td><td>在线程退出时设置值。</td></tr><tr><td><code>set_exception_at_thread_exit()</code></td><td>在线程退出时设置异常。</td></tr></tbody></table></div><p>处理异常：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;future&gt;</span>  </span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">producer</span><span class="params">(std::promise&lt;<span class="type">int</span>&gt;&amp; promise)</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">try</span> &#123;  </span><br><span class="line">        <span class="keyword">throw</span> std::<span class="built_in">runtime_error</span>(<span class="string">&quot;An error occurred!&quot;</span>);  </span><br><span class="line">    &#125; <span class="built_in">catch</span> (<span class="type">const</span> std::exception&amp; e) &#123;  </span><br><span class="line">        promise.<span class="built_in">set_exception</span>(std::<span class="built_in">current_exception</span>()); <span class="comment">// 设置异常  </span></span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">consumer</span><span class="params">(std::future&lt;<span class="type">int</span>&gt;&amp; future)</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">try</span> &#123;  </span><br><span class="line">        <span class="type">int</span> value = future.<span class="built_in">get</span>(); <span class="comment">// 获取值，此时会捕获到抛出的异常 </span></span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Received value: &quot;</span> &lt;&lt; value &lt;&lt; std::endl;  </span><br><span class="line">    &#125; <span class="built_in">catch</span> (<span class="type">const</span> std::exception&amp; e) &#123;  </span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Exception caught: &quot;</span> &lt;&lt; e.<span class="built_in">what</span>() &lt;&lt; std::endl;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">    std::promise&lt;<span class="type">int</span>&gt; promise;  </span><br><span class="line">    std::future&lt;<span class="type">int</span>&gt; future = promise.<span class="built_in">get_future</span>();  </span><br><span class="line">  </span><br><span class="line">    <span class="function">std::thread <span class="title">producer_thread</span><span class="params">(producer, std::ref(promise))</span></span>;  </span><br><span class="line">    <span class="function">std::thread <span class="title">consumer_thread</span><span class="params">(consumer, std::ref(future))</span></span>;  </span><br><span class="line">  </span><br><span class="line">    producer_thread.<span class="built_in">join</span>();  </span><br><span class="line">    consumer_thread.<span class="built_in">join</span>();  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="comment">//Exception caught: An error occurred!</span></span><br></pre></td></tr></table></figure></p><h3 id="注意事项-1"><a href="#注意事项-1" class="headerlink" title="注意事项"></a>注意事项</h3><ol><li><strong>只能设置一次值或异常</strong>：<code>std::promise</code> 只能设置一次值或异常。如果多次调用 <code>set_value()</code> 或 <code>set_exception()</code>，会导致未定义行为。</li><li><strong>线程安全</strong>：<code>std::promise</code> 和 <code>std::future</code> 是线程安全的，但需要确保在适当的时机调用 <code>set_value()</code> 和 <code>get()</code>。</li><li><strong>不能被直接复制</strong>：<code>std::promise</code> 对象<font color="#00b050">不能被复制</font>，只能通过 <code>std::move</code> 转移控制权。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">std::promise&lt;<span class="type">int</span>&gt; promise;</span><br><span class="line">std::promise&lt;<span class="type">int</span>&gt; promise2 = std::<span class="built_in">move</span>(promise);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MyFunc</span><span class="params">(promise&lt;<span class="type">int</span>&gt; prom)</span> </span>&#123;</span><br><span class="line">prom.<span class="built_in">set_exception</span>(std::<span class="built_in">current_exception</span>());</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">std::thread <span class="title">t</span><span class="params">(MyFunc, std::move(promise))</span></span>;<span class="comment">//值传递</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MyFunc</span><span class="params">(promise&lt;<span class="type">int</span>&gt;&amp; prom)</span> </span>&#123;<span class="comment">//不可以为const，因为set_exception()</span></span><br><span class="line">prom.<span class="built_in">set_exception</span>(std::<span class="built_in">current_exception</span>());</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">std::thread <span class="title">t</span><span class="params">(MyFunc, std::ref(promise))</span></span>;<span class="comment">//引用传递</span></span><br></pre></td></tr></table></figure></li></ol><h2 id="🚩packaged-task"><a href="#🚩packaged-task" class="headerlink" title="🚩packaged_task"></a>🚩packaged_task</h2><h3 id="基本概念-7"><a href="#基本概念-7" class="headerlink" title="基本概念"></a>基本概念</h3><blockquote><p>什么是 <code>packaged_task</code>？</p></blockquote><p><code>packaged_task</code> 是一个模板类，用于<font color="#00b050">封装可调用对象，并将任务的执行与结果的获取分离</font>。同样需要头文件 <code>&lt;future&gt;</code>。</p><h3 id="💻代码实现-3"><a href="#💻代码实现-3" class="headerlink" title="💻代码实现"></a>💻代码实现</h3><p>在另一个线程中执行任务：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">    <span class="function">std::packaged_task&lt;<span class="title">int</span><span class="params">(<span class="type">int</span>,<span class="type">int</span>)</span>&gt; <span class="title">task</span><span class="params">([](<span class="type">int</span> a, <span class="type">int</span> b) &#123; <span class="keyword">return</span> a + b; &#125;)</span></span>;  </span><br><span class="line">    std::future&lt;<span class="type">int</span>&gt; result = task.<span class="built_in">get_future</span>();  </span><br><span class="line">      </span><br><span class="line">    <span class="function">std::thread <span class="title">t</span><span class="params">(std::move(task), <span class="number">1</span>, <span class="number">2</span>)</span></span>;   <span class="comment">//packaged_task同样不可以复制  </span></span><br><span class="line">    t.<span class="built_in">join</span>();  </span><br><span class="line">      </span><br><span class="line">    cout &lt;&lt; result.<span class="built_in">get</span>() &lt;&lt; endl;  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//另一种构造写法：</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Multiply</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> a * b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="function">std::packaged_task&lt;<span class="title">decltype</span><span class="params">(Multiply)</span>&gt; <span class="title">task</span><span class="params">(Multiply)</span></span>;</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>重置对象，获取新的 <code>future</code> 对象：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">    <span class="function">std::packaged_task&lt;<span class="title">int</span><span class="params">(<span class="type">int</span>,<span class="type">int</span>)</span>&gt; <span class="title">task</span><span class="params">([](<span class="type">int</span> a, <span class="type">int</span> b) &#123; <span class="keyword">return</span> a + b; &#125;)</span></span>;  </span><br><span class="line">    std::future&lt;<span class="type">int</span>&gt; result = task.<span class="built_in">get_future</span>();  </span><br><span class="line">  </span><br><span class="line">    <span class="built_in">task</span>(<span class="number">1</span>, <span class="number">2</span>); <span class="comment">//执行任务  </span></span><br><span class="line">    cout &lt;&lt; result.<span class="built_in">get</span>() &lt;&lt; endl;  </span><br><span class="line">  </span><br><span class="line">    task.<span class="built_in">reset</span>();   <span class="comment">//重置packaged_task，因为其只能执行一次任务</span></span><br><span class="line">    result = task.<span class="built_in">get_future</span>(); <span class="comment">//必须获取新的future对象，因为每个future对象在调用get方法后会失效  </span></span><br><span class="line">  </span><br><span class="line">    <span class="built_in">task</span>(<span class="number">3</span>, <span class="number">4</span>);  </span><br><span class="line">    cout &lt;&lt; result.<span class="built_in">get</span>() &lt;&lt; endl;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="comment">//3  </span></span><br><span class="line"><span class="comment">//7</span></span><br></pre></td></tr></table></figure></p><div class="table-container"><table><thead><tr><th>成员函数</th><th>作用</th></tr></thead><tbody><tr><td><code>get_future()</code></td><td>获取与 <code>std::packaged_task</code> 关联的 <code>std::future</code> 对象。</td></tr><tr><td><code>operator()</code></td><td>执行封装的可调用对象，并将结果存储在 <code>std::future</code> 中。</td></tr><tr><td><code>make_ready_at_thread_exit()</code></td><td>在线程退出时执行任务，并将结果存储在 <code>std::future</code> 中。</td></tr><tr><td><code>reset()</code></td><td>重置 <code>std::packaged_task</code>，允许重新执行任务。</td></tr></tbody></table></div><h3 id="注意事项-2"><a href="#注意事项-2" class="headerlink" title="注意事项"></a>注意事项</h3><ol><li><code>std::packaged_task</code> 使用 <code>operator()</code> 执行任务，并将结果存储在 <code>std::future</code> 中。</li><li><strong>不可复制</strong>： <code>packaged_task</code> 可移动，但不可复制。因此，构建 <code>thread</code> 中值传递 <code>std::packaged_task</code> 时需要使用 <code>std::move</code>（引用传递用 <code>std::ref</code>）。</li><li><strong>只能执行一次任务</strong>：<code>std::packaged_task</code> 只能执行一次任务。如果需要重新执行任务，应使用 <code>reset()</code> 重置 <code>std::packaged_task</code>。</li><li><strong>线程安全</strong>：<code>std::packaged_task</code> 和 <code>std::future</code> 是线程安全的，但需要确保在适当的时机调用 <code>get_future()</code> 和 <code>get()</code>。</li></ol><h2 id="三种异步工具的比较"><a href="#三种异步工具的比较" class="headerlink" title="三种异步工具的比较"></a>三种异步工具的比较</h2><div class="table-container"><table><thead><tr><th>特性</th><th>async</th><th>promise</th><th>packaged_task</th></tr></thead><tbody><tr><td>代码写法</td><td>简单，自动管理线程和任务执行</td><td>复杂，手动管理线程和任务执行</td><td>复杂，手动管理线程和任务执行</td></tr><tr><td>成员函数</td><td>自动设置值或异常</td><td><code>get_future()</code>、<code>set_value()</code>、<code>set_exception()</code></td><td><code>get_future()</code>、<code>operator()</code>、<code>reset()</code></td></tr><tr><td>应用场景</td><td>简单异步任务</td><td>复杂线程间通信，灵活性最高</td><td>任务调度、线程池、封装可调用对象</td></tr></tbody></table></div><p>共同点是，它们均为 C++11 新特性，包含在头文件 <code>&lt;future&gt;</code> 中，并且都需要搭配 <code>future</code> 对象实现功能。</p><h4 id="之间的关系"><a href="#之间的关系" class="headerlink" title="之间的关系"></a>之间的关系</h4><p>以下内容摘自 <a href="https://www.51cto.com/article/713316.html">Thread、Future、Promise、Packaged_task、Async之间有什么关系？</a><br><img src="https://i.imgur.com/aljI5fH.png" alt="|852"></p><ul><li><code>packaged_task</code> ≈ <code>promise</code> + function</li><li><code>async</code> ≈ <code>thread</code> + <code>packaged_task</code></li><li>通过 <code>promise</code> 的 <code>get_future()</code> 可拿到 <code>future</code> 对象</li><li>通过 <code>future</code> 对象的 <code>share()</code> 可拿到 <code>shared_future</code> 对象</li></ul><p><code>promise</code> 只能 <code>set_value</code>，不太好执行复杂的逻辑，有执行函数+阻塞的需求时，就可以考虑使用 <code>packaged_task</code>。</p><p><code>shared_future</code>：<br>普通的 <code>future</code> 有个特点，它不能拷贝，只能移动，这就意味着只能有一个线程一个实例可以通过 <code>get()</code> 拿到对应的结果。<br>如果想要多个线程多个实例拿到结果，就可以使用 <code>shared_future</code>，那怎么拿到 <code>shared_future</code>，可以通过普通 <code>future</code> 的 <code>shared()</code> 方法。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;future&gt;</span>  </span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">    std::promise&lt;<span class="type">int</span>&gt; prom;  </span><br><span class="line">    future&lt;<span class="type">int</span>&gt; fu = prom.<span class="built_in">get_future</span>();  </span><br><span class="line">    shared_future&lt;<span class="type">int</span>&gt; shared_fu = fu.<span class="built_in">share</span>();  </span><br><span class="line">    future&lt;<span class="type">void</span>&gt; f1 = std::<span class="built_in">async</span>(std::launch::async, [shared_fu]() &#123; std::cout &lt;&lt; shared_fu.<span class="built_in">get</span>() &lt;&lt; std::endl; &#125;);  </span><br><span class="line">    future&lt;<span class="type">void</span>&gt; f2 = std::<span class="built_in">async</span>(std::launch::async, [shared_fu]() &#123; std::cout &lt;&lt; shared_fu.<span class="built_in">get</span>() &lt;&lt; std::endl; &#125;);  </span><br><span class="line">    prom.<span class="built_in">set_value</span>(<span class="number">102</span>);  </span><br><span class="line">    f1.<span class="built_in">get</span>();  </span><br><span class="line">    f2.<span class="built_in">get</span>();  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="comment">//102102//这里的输出顺序无法确定（毕竟因为异步）</span></span><br></pre></td></tr></table></figure></p><hr><h1 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h1><h2 id="基本概念-8"><a href="#基本概念-8" class="headerlink" title="基本概念"></a>基本概念</h2><blockquote><p>什么是线程池？作用是什么？</p></blockquote><p>线程池是指一种<font color="#00b050">预先创建一组线程</font>的机制，这些线程在应用程序启动时就已经创建好，等待执行任务。<br>每当有新的任务需要执行时，线程池会从线程集合中分配一个空闲线程来执行该任务，而不是每次都重新创建和销毁线程。（池化思想，如 epoll、SQL）</p><blockquote><p>为什么使用线程池？</p></blockquote><ol><li><strong>提高性能</strong>：<font color="#00b050">创建和销毁线程开销较大</font>，线程池通过重用的线程，减少了这种开销，提高程序性能。</li><li><strong>控制并发量</strong>：线程池允许<font color="#00b050">限制并发线程的数量</font>，防止系统因创建过多线程而出现资源耗尽的问题（如 CPU 过载、内存不足）。</li><li><strong>简化线程管理</strong>：使用线程池可以<font color="#00b050">避免手动管理线程的生命周期</font>，减少代码复杂性。线程池通常还提供了<font color="#00b050">任务排队和调度</font>的功能，使得多线程编程更加容易。</li></ol><blockquote><p>线程池的使用场景？</p></blockquote><ol><li><strong>服务器应用</strong>：比如 Web 服务器，处理每个客户端请求时不必为每个请求创建一个新线程，而是从线程池中取出线程来处理请求。</li><li><strong>高性能计算</strong></li><li><strong>异步任务处理</strong></li></ol><blockquote><p>一个线程池应该包含什么？</p></blockquote><ol><li><strong>线程池管理器（ThreadPool Manager）</strong>：负责创建并管理线程池，包括线程的创建、销毁、任务分配等。</li><li><strong>工作线程（Worker Thread）</strong>：线程池中的线程，负责执行具体的任务。这些线程通常是预先创建好的，并且在任务执行完毕后不会立即销毁，而是返回到线程池中等待下一个任务。</li><li><strong>任务队列（Task Queue）</strong>：用于存储待执行的任务。当有新的任务提交到线程池时，任务会被放入任务队列中，等待工作线程来执行。</li><li><strong>任务（Task）</strong>：需要执行的工作单元，通常是一个函数或方法。<br>图例：<br><img src="https://i.imgur.com/w5pFYyP.png" alt="|954"></li></ol><h2 id="💻代码实现-4"><a href="#💻代码实现-4" class="headerlink" title="💻代码实现"></a>💻代码实现</h2><p>来自 <a href="https://github.com/lzpong/threadpool?tab=readme-ov-file">threadpool-lzpong</a></p><p><code>threadpool.h</code>：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> THREAD_POOL_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> THREAD_POOL_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;atomic&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;future&gt;</span></span></span><br><span class="line"><span class="comment">//#include &lt;condition_variable&gt;</span></span><br><span class="line"><span class="comment">//#include &lt;thread&gt;</span></span><br><span class="line"><span class="comment">//#include &lt;functional&gt;</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdexcept&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> std</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//线程池最大容量,应尽量设小一点</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>  THREADPOOL_MAX_NUM 16</span></span><br><span class="line"><span class="comment">//线程池是否可以自动增长(如果需要,且不超过 THREADPOOL_MAX_NUM)</span></span><br><span class="line"><span class="comment">//#define  THREADPOOL_AUTO_GROW</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//线程池,可以提交变参函数或Lambda\表达式的匿名函数执行,可以获取执行返回值</span></span><br><span class="line"><span class="comment">//不直接支持类成员函数, 支持类静态成员函数或全局函数,Operator()函数等</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">threadpool</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">short</span> _initSize;       <span class="comment">//初始化线程数量</span></span><br><span class="line"><span class="keyword">using</span> Task = function&lt;<span class="built_in">void</span>()&gt;; <span class="comment">//定义类型</span></span><br><span class="line">vector&lt;thread&gt; _pool;          <span class="comment">//线程池</span></span><br><span class="line">queue&lt;Task&gt; _tasks;            <span class="comment">//任务队列</span></span><br><span class="line">mutex _lock;                   <span class="comment">//任务队列同步锁</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> THREADPOOL_AUTO_GROW</span></span><br><span class="line">mutex _lockGrow;               <span class="comment">//线程池增长同步锁</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">// !THREADPOOL_AUTO_GROW</span></span></span><br><span class="line">condition_variable _task_cv;   <span class="comment">//条件阻塞</span></span><br><span class="line">atomic&lt;<span class="type">bool</span>&gt; _run&#123; <span class="literal">true</span> &#125;;     <span class="comment">//线程池是否执行</span></span><br><span class="line">atomic&lt;<span class="type">int</span>&gt;  _idlThrNum&#123; <span class="number">0</span> &#125;;  <span class="comment">//空闲线程数量</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="title">threadpool</span><span class="params">(<span class="type">unsigned</span> <span class="type">short</span> size = <span class="number">4</span>)</span> </span>&#123; _initSize = size; <span class="built_in">addThread</span>(size); &#125;</span><br><span class="line"><span class="keyword">inline</span> ~<span class="built_in">threadpool</span>()</span><br><span class="line">&#123;</span><br><span class="line">_run=<span class="literal">false</span>;</span><br><span class="line">_task_cv.<span class="built_in">notify_all</span>(); <span class="comment">// 唤醒所有线程执行</span></span><br><span class="line"><span class="keyword">for</span> (thread&amp; thread : _pool) &#123;</span><br><span class="line"><span class="comment">//thread.detach(); // 让线程“自生自灭”</span></span><br><span class="line"><span class="keyword">if</span> (thread.<span class="built_in">joinable</span>())</span><br><span class="line">thread.<span class="built_in">join</span>(); <span class="comment">// 等待任务结束， 前提：线程一定会执行完</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">// 提交一个任务</span></span><br><span class="line"><span class="comment">// 调用.get()获取返回值会等待任务执行完,获取返回值</span></span><br><span class="line"><span class="comment">// 有两种方法可以实现调用类成员，</span></span><br><span class="line"><span class="comment">// 一种是使用   bind： .commit(std::bind(&amp;Dog::sayHello, &amp;dog));</span></span><br><span class="line"><span class="comment">// 一种是用   mem_fn： .commit(std::mem_fn(&amp;Dog::sayHello), this)</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> F, <span class="keyword">class</span>... Args&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">commit</span><span class="params">(F&amp;&amp; f, Args&amp;&amp;... args)</span> -&gt; future&lt;<span class="title">decltype</span><span class="params">(f(args...))</span>&gt;</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (!_run)    <span class="comment">// stoped ??</span></span><br><span class="line"><span class="keyword">throw</span> <span class="built_in">runtime_error</span>(<span class="string">&quot;commit on ThreadPool is stopped.&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> RetType = <span class="keyword">decltype</span>(<span class="built_in">f</span>(args...)); <span class="comment">// typename std::result_of&lt;F(Args...)&gt;::type, 函数 f 的返回值类型</span></span><br><span class="line"><span class="keyword">auto</span> task = make_shared&lt;packaged_task&lt;<span class="built_in">RetType</span>()&gt;&gt;(</span><br><span class="line"><span class="built_in">bind</span>(forward&lt;F&gt;(f), forward&lt;Args&gt;(args)...)</span><br><span class="line">); <span class="comment">// 把函数入口及参数,打包(绑定)</span></span><br><span class="line">future&lt;RetType&gt; future = task-&gt;<span class="built_in">get_future</span>();</span><br><span class="line">&#123;    <span class="comment">// 添加任务到队列</span></span><br><span class="line">lock_guard&lt;mutex&gt; lock&#123; _lock &#125;;<span class="comment">//对当前块的语句加锁  lock_guard 是 mutex 的 stack 封装类，构造的时候 lock()，析构的时候 unlock()</span></span><br><span class="line">_tasks.<span class="built_in">emplace</span>([task]() &#123; <span class="comment">// push(Task&#123;...&#125;) 放到队列后面</span></span><br><span class="line">(*task)();</span><br><span class="line">&#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> THREADPOOL_AUTO_GROW</span></span><br><span class="line"><span class="keyword">if</span> (_idlThrNum &lt; <span class="number">1</span> &amp;&amp; _pool.<span class="built_in">size</span>() &lt; THREADPOOL_MAX_NUM)</span><br><span class="line"><span class="built_in">addThread</span>(<span class="number">1</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">// !THREADPOOL_AUTO_GROW</span></span></span><br><span class="line">_task_cv.<span class="built_in">notify_one</span>(); <span class="comment">// 唤醒一个线程执行</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> future;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 提交一个无参任务, 且无返回值</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">F</span>&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">commit2</span><span class="params">(F&amp;&amp; task)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (!_run) <span class="keyword">return</span>;</span><br><span class="line">&#123;</span><br><span class="line">lock_guard&lt;mutex&gt; lock&#123; _lock &#125;;</span><br><span class="line">_tasks.<span class="built_in">emplace</span>(std::forward&lt;F&gt;(task));</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> THREADPOOL_AUTO_GROW</span></span><br><span class="line"><span class="keyword">if</span> (_idlThrNum &lt; <span class="number">1</span> &amp;&amp; _pool.<span class="built_in">size</span>() &lt; THREADPOOL_MAX_NUM)</span><br><span class="line"><span class="built_in">addThread</span>(<span class="number">1</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">// !THREADPOOL_AUTO_GROW</span></span></span><br><span class="line">_task_cv.<span class="built_in">notify_one</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//空闲线程数量</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">idlCount</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> _idlThrNum; &#125;</span><br><span class="line"><span class="comment">//线程数量</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">thrCount</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> _pool.<span class="built_in">size</span>(); &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> THREADPOOL_AUTO_GROW</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">// !THREADPOOL_AUTO_GROW</span></span></span><br><span class="line"><span class="comment">//添加指定数量的线程</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">addThread</span><span class="params">(<span class="type">unsigned</span> <span class="type">short</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> THREADPOOL_AUTO_GROW</span></span><br><span class="line"><span class="keyword">if</span> (!_run)    <span class="comment">// stoped ??</span></span><br><span class="line"><span class="keyword">throw</span> <span class="built_in">runtime_error</span>(<span class="string">&quot;Grow on ThreadPool is stopped.&quot;</span>);</span><br><span class="line">unique_lock&lt;mutex&gt; lockGrow&#123; _lockGrow &#125;; <span class="comment">//自动增长锁</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">// !THREADPOOL_AUTO_GROW</span></span></span><br><span class="line"><span class="keyword">for</span> (; _pool.<span class="built_in">size</span>() &lt; THREADPOOL_MAX_NUM &amp;&amp; size &gt; <span class="number">0</span>; --size)</span><br><span class="line">&#123;   <span class="comment">//增加线程数量,但不超过 预定义数量 THREADPOOL_MAX_NUM</span></span><br><span class="line">_pool.<span class="built_in">emplace_back</span>( [<span class="keyword">this</span>]&#123; <span class="comment">//工作线程函数</span></span><br><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>) <span class="comment">//防止 _run==false 时立即结束,此时任务队列可能不为空</span></span><br><span class="line">&#123;</span><br><span class="line">Task task; <span class="comment">// 获取一个待执行的 task</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// unique_lock 相比 lock_guard 的好处是：可以随时 unlock() 和 lock()</span></span><br><span class="line">unique_lock&lt;mutex&gt; lock&#123; _lock &#125;;</span><br><span class="line">_task_cv.<span class="built_in">wait</span>(lock, [<span class="keyword">this</span>] &#123; <span class="comment">// wait 直到有 task, 或需要停止</span></span><br><span class="line"><span class="keyword">return</span> !_run || !_tasks.<span class="built_in">empty</span>();</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">if</span> (!_run &amp;&amp; _tasks.<span class="built_in">empty</span>())</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">_idlThrNum--;</span><br><span class="line">task = <span class="built_in">move</span>(_tasks.<span class="built_in">front</span>()); <span class="comment">// 按先进先出从队列取一个 task</span></span><br><span class="line">_tasks.<span class="built_in">pop</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">task</span>();<span class="comment">//执行任务</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> THREADPOOL_AUTO_GROW</span></span><br><span class="line"><span class="keyword">if</span> (_idlThrNum&gt;<span class="number">0</span> &amp;&amp; _pool.<span class="built_in">size</span>() &gt; _initSize) <span class="comment">//支持自动释放空闲线程,避免峰值过后大量空闲线程</span></span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">// !THREADPOOL_AUTO_GROW</span></span></span><br><span class="line">&#123;</span><br><span class="line">unique_lock&lt;mutex&gt; lock&#123; _lock &#125;;</span><br><span class="line">_idlThrNum++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line">&#123;</span><br><span class="line">unique_lock&lt;mutex&gt; lock&#123; _lock &#125;;</span><br><span class="line">_idlThrNum++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span>  <span class="comment">//https://github.com/lzpong/</span></span></span><br></pre></td></tr></table></figure></p><p><code>main.cpp</code>：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;threadpool.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">fun1</span><span class="params">(<span class="type">int</span> slp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;  hello, fun1 !  %d\n&quot;</span> ,std::this_thread::<span class="built_in">get_id</span>());</span><br><span class="line"><span class="keyword">if</span> (slp&gt;<span class="number">0</span>) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot; ======= fun1 sleep %d  =========  %d\n&quot;</span>,slp, std::this_thread::<span class="built_in">get_id</span>());</span><br><span class="line">std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">milliseconds</span>(slp));</span><br><span class="line"><span class="comment">//Sleep(slp );</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">gfun</span> &#123;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d  hello, gfun !  %d\n&quot;</span> ,n, std::this_thread::<span class="built_in">get_id</span>() );</span><br><span class="line"><span class="keyword">return</span> <span class="number">42</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;    <span class="comment">//函数必须是 static 的才能使用线程池</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">Afun</span><span class="params">(<span class="type">int</span> n = <span class="number">0</span>)</span> </span>&#123;</span><br><span class="line">std::cout &lt;&lt; n &lt;&lt; <span class="string">&quot;  hello, Afun !  &quot;</span> &lt;&lt; std::this_thread::<span class="built_in">get_id</span>() &lt;&lt; std::endl;</span><br><span class="line"><span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> std::string <span class="title">Bfun</span><span class="params">(<span class="type">int</span> n, std::string str, <span class="type">char</span> c)</span> </span>&#123;</span><br><span class="line">std::cout &lt;&lt; n &lt;&lt; <span class="string">&quot;  hello, Bfun !  &quot;</span>&lt;&lt; str.<span class="built_in">c_str</span>() &lt;&lt;<span class="string">&quot;  &quot;</span> &lt;&lt; (<span class="type">int</span>)c &lt;&lt;<span class="string">&quot;  &quot;</span> &lt;&lt; std::this_thread::<span class="built_in">get_id</span>() &lt;&lt; std::endl;</span><br><span class="line"><span class="keyword">return</span> str;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">std::threadpool executor&#123; <span class="number">50</span> &#125;;</span><br><span class="line">A a;</span><br><span class="line">std::future&lt;<span class="type">void</span>&gt; ff = executor.<span class="built_in">commit</span>(fun1,<span class="number">0</span>);</span><br><span class="line">std::future&lt;<span class="type">int</span>&gt; fg = executor.<span class="built_in">commit</span>(gfun&#123;&#125;,<span class="number">0</span>);</span><br><span class="line">std::future&lt;<span class="type">int</span>&gt; gg = executor.<span class="built_in">commit</span>(a.Afun, <span class="number">9999</span>); <span class="comment">//IDE提示错误,但可以编译运行</span></span><br><span class="line">std::future&lt;std::string&gt; gh = executor.<span class="built_in">commit</span>(A::Bfun, <span class="number">9998</span>,<span class="string">&quot;mult args&quot;</span>, <span class="number">123</span>);</span><br><span class="line">std::future&lt;std::string&gt; fh = executor.<span class="built_in">commit</span>([]()-&gt;std::string &#123; std::cout &lt;&lt; <span class="string">&quot;hello, fh !  &quot;</span> &lt;&lt; std::this_thread::<span class="built_in">get_id</span>() &lt;&lt; std::endl; <span class="keyword">return</span> <span class="string">&quot;hello,fh ret !&quot;</span>; &#125;);</span><br><span class="line"></span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot; =======  sleep ========= &quot;</span> &lt;&lt; std::this_thread::<span class="built_in">get_id</span>() &lt;&lt; std::endl;</span><br><span class="line">std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">microseconds</span>(<span class="number">900</span>));</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">50</span>; i++) &#123;</span><br><span class="line">executor.<span class="built_in">commit</span>(fun1,i*<span class="number">100</span> );</span><br><span class="line">&#125;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot; =======  commit all ========= &quot;</span> &lt;&lt; std::this_thread::<span class="built_in">get_id</span>()&lt;&lt; <span class="string">&quot; idlsize=&quot;</span>&lt;&lt;executor.<span class="built_in">idlCount</span>() &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot; =======  sleep ========= &quot;</span> &lt;&lt; std::this_thread::<span class="built_in">get_id</span>() &lt;&lt; std::endl;</span><br><span class="line">std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">seconds</span>(<span class="number">3</span>));</span><br><span class="line"></span><br><span class="line">ff.<span class="built_in">get</span>(); <span class="comment">//调用.get()获取返回值会等待线程执行完,获取返回值</span></span><br><span class="line">std::cout &lt;&lt; fg.<span class="built_in">get</span>() &lt;&lt; <span class="string">&quot;  &quot;</span> &lt;&lt; fh.<span class="built_in">get</span>().<span class="built_in">c_str</span>()&lt;&lt; <span class="string">&quot;  &quot;</span> &lt;&lt; std::this_thread::<span class="built_in">get_id</span>() &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot; =======  sleep ========= &quot;</span> &lt;&lt; std::this_thread::<span class="built_in">get_id</span>() &lt;&lt; std::endl;</span><br><span class="line">std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">seconds</span>(<span class="number">3</span>));</span><br><span class="line"></span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot; =======  fun1,55 ========= &quot;</span> &lt;&lt; std::this_thread::<span class="built_in">get_id</span>() &lt;&lt; std::endl;</span><br><span class="line">executor.<span class="built_in">commit</span>(fun1,<span class="number">55</span>).<span class="built_in">get</span>();    <span class="comment">//调用.get()获取返回值会等待线程执行完</span></span><br><span class="line"></span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;end... &quot;</span> &lt;&lt; std::this_thread::<span class="built_in">get_id</span>() &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function">std::threadpool <span class="title">pool</span><span class="params">(<span class="number">4</span>)</span></span>;</span><br><span class="line">std::vector&lt; std::future&lt;<span class="type">int</span>&gt; &gt; results;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">8</span>; ++i) &#123;</span><br><span class="line">results.<span class="built_in">emplace_back</span>(</span><br><span class="line">pool.<span class="built_in">commit</span>([i] &#123;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;hello &quot;</span> &lt;&lt; i &lt;&lt; std::endl;</span><br><span class="line">std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">seconds</span>(<span class="number">1</span>));</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;world &quot;</span> &lt;&lt; i &lt;&lt; std::endl;</span><br><span class="line"><span class="keyword">return</span> i*i;</span><br><span class="line">&#125;)</span><br><span class="line">);</span><br><span class="line">&#125;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot; =======  commit all2 ========= &quot;</span> &lt;&lt; std::this_thread::<span class="built_in">get_id</span>() &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> &amp;&amp; result : results)</span><br><span class="line">std::cout &lt;&lt; result.<span class="built_in">get</span>() &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">std::cout &lt;&lt; std::endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">catch</span> (std::exception&amp; e) &#123;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;some unhappy happened...  &quot;</span> &lt;&lt; std::this_thread::<span class="built_in">get_id</span>() &lt;&lt; e.<span class="built_in">what</span>() &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>C++11 语言细节：</p><ol><li><code>using Task = function&lt;void()&gt;</code> 是类型别名，简化了 <code>typedef</code> 的用法。<code>function&lt;void()&gt;</code> 可以认为是一个函数类型，接受任意原型是 <code>void()</code> 的函数，或是函数对象，或是匿名函数。<code>void()</code> 意思是不带参数，没有返回值。</li><li><code>pool.emplace_back([this]&#123;...&#125;)</code> 和 <code>pool.push_back([this]&#123;...&#125;)</code> 功能一样，只不过前者性能会更好。</li><li><code>pool.emplace_back([this]&#123;...&#125;)</code> 构造了一个线程对象，执行函数是 Lambda匿名函数。</li><li>所有对象的初始化方式均采用了 <code>&#123;&#125;</code>，而不再使用 <code>()</code> 方式，因为风格不够一致且容易出错。</li><li>匿名函数： <code>[this]&#123;...&#125;</code> 不多说。<code>[]</code> 是捕捉器，<code>this</code> 是引用域外的变量 this指针，内部使用死循环, 由 <code>cv_task.wait(lock,[this]&#123;...&#125;)</code> 来阻塞线程。</li><li><code>delctype(expr)</code> 用来推断 <code>expr</code> 的类型，和 <code>auto</code> 是类似的，相当于类型占位符，占据一个类型的位置；<code>auto f(A a, B b) -&gt; decltype(a+b)</code> 是一种用法，不能写作 <code>decltype(a+b) f(A a, B b)</code>。</li><li><code>commit</code> 方法是不是略奇葩！可以带任意多的参数，第一个参数是 f，后面依次是函数 f 的参数(<em>注意:参数要传struct/class的话,建议用pointer,小心变量的作用域</em>)！可变参数模板是 c++11 的一大亮点。</li><li><code>commit</code> 直接使用智能调用 <code>stdcall</code> 函数，但有两种方法可以实现调用类成员，一种是使用 bind：<code>commit(std::bind(&amp;Dog::sayHello, &amp;dog));</code> 一种是用 mem_fn： <code>commit(std::mem_fn(&amp;Dog::sayHello), &amp;dog)；</code>。</li><li><code>make_shared()</code> 用来构造 <code>shared_ptr</code> 智能指针。用法大体是 <code>shared_ptr p = make_shared(4)</code> 然后 <code>*p == 4</code> 。智能指针的好处就是自动 delete。</li><li><code>bind</code> 函数，接受函数 f 和部分参数，返回currying后的匿名函数，譬如 <code>bind(add, 4)</code> 可以实现类似 <code>add(4)</code> 的函数。</li><li><code>forward()</code> 函数，类似于 <code>move()</code> 函数，后者是将参数右值化，前者是不改变最初传入的类型的引用类型(左值还是左值，右值还是右值)。</li><li><code>packaged_task</code> 就是任务函数的封装类，通过 <code>get_future()</code> 获取 <code>future</code> ，然后通过 <code>future</code> 可以获取函数的返回值(<code>future.get()</code>)；<code>packaged_task</code> 本身可以像函数一样调用。</li><li><code>queue</code> 是队列类， <code>front()</code> 获取头部元素， <code>pop()</code> 移除头部元素；<code>back()</code> 获取尾部元素，<code>push()</code> 尾部添加元素。</li><li><code>lock_guard</code> 是 <code>mutex</code> 的 stack 封装类，构造的时候 <code>lock()</code>，析构的时候 <code>unlock()</code>，是 C++ RAII 的 idea。</li><li><code>condition_variable cv;</code> 条件变量，需要配合 <code>unique_lock</code> 使用；<code>unique_lock</code> 相比 <code>lock_guard</code> 的好处是：可以随时 <code>unlock()</code> 和 <code>lock()</code>。 <code>cv.wait()</code> 之前需要持有 mutex，<code>wait()</code> 本身会解锁，如果条件满足则会重新持有锁。</li><li>最后线程池析构的时候，<code>join()</code> 可以等待任务都执行完再结束，很安全。</li></ol><h4 id="简单写法"><a href="#简单写法" class="headerlink" title="简单写法"></a>简单写法</h4><p><code>ThreadPool.hpp</code>：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once  </span></span><br><span class="line">  </span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;future&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;condition_variable&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;type_traits&gt;</span>  </span></span><br><span class="line">  </span><br><span class="line"><span class="comment">//线程池  </span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ThreadPool</span>  </span><br><span class="line">&#123;  </span><br><span class="line"><span class="keyword">public</span>:  </span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">ThreadPool</span><span class="params">(<span class="type">int</span> ThreadNums)</span></span>;    <span class="comment">//加上explicit避免产生诸如ThreadPool pool = 1;这样的隐式转换  </span></span><br><span class="line">    ~<span class="built_in">ThreadPool</span>();  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">//添加任务到队列  </span></span><br><span class="line">    <span class="comment">//F&amp;&amp;万能引用，如果F是左值，那得到的就是左值；如果F是右值，那得到的就是右值  </span></span><br><span class="line">    <span class="comment">//F为可调用对象类型，Arg为其对应的参数类型  </span></span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> F, <span class="keyword">typename</span> ...Arg&gt;   <span class="comment">//...Arg为可变参数模板，任意个数的参数  </span></span><br><span class="line">    <span class="function"><span class="keyword">auto</span> <span class="title">EnterQueues</span><span class="params">(F&amp;&amp; f, Arg&amp;&amp;... arg)</span> -&gt; std::future&lt;<span class="keyword">typename</span> std::invoke_result&lt;F, Arg...&gt;::type&gt;</span>;  </span><br><span class="line">    <span class="comment">//result_of是类型萃取工具，利用::type来推导出可调用对象F在传入参数Arg...时的返回类型。头文件&lt;type_traits&gt;  </span></span><br><span class="line">    <span class="comment">//C++17中result_of被启用，使用invoke_result  </span></span><br><span class="line">  </span><br><span class="line"><span class="keyword">private</span>:  </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">worker</span><span class="params">()</span></span>;  <span class="comment">//线程的执行内容  </span></span><br><span class="line">    <span class="type">bool</span> IsStop;    <span class="comment">//标识，当前线程池是不是停止  </span></span><br><span class="line">    std::condition_variable cv;  </span><br><span class="line">    std::mutex mtx;  </span><br><span class="line">    std::vector&lt;std::thread&gt; workers;   <span class="comment">//线程集合（线程池）  </span></span><br><span class="line">    std::queue&lt;std::function&lt;<span class="type">void</span>()&gt;&gt; MyQueue;  <span class="comment">//任务队列，任务封装成了void返回类型的函数  </span></span><br><span class="line">    <span class="comment">//如果用户放进来的函数有返回值，要想获得这个返回值，就需要利用packaged_task返回一个future对象，利用该对象获取返回值  </span></span><br><span class="line">&#125;;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">//构造函数  </span></span><br><span class="line">ThreadPool::<span class="built_in">ThreadPool</span>(<span class="type">int</span> ThreadNums) : <span class="built_in">IsStop</span>(<span class="literal">false</span>)  </span><br><span class="line">&#123;  </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; ThreadNums; ++i) &#123;  </span><br><span class="line">        workers.<span class="built_in">emplace_back</span>([<span class="keyword">this</span>]() &#123;  </span><br><span class="line">            <span class="keyword">this</span>-&gt;<span class="built_in">worker</span>(); <span class="comment">//此时线程就开始运行了  </span></span><br><span class="line">        &#125;);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">//析构函数  </span></span><br><span class="line">ThreadPool::~<span class="built_in">ThreadPool</span>()  </span><br><span class="line">&#123;  </span><br><span class="line">    <span class="comment">//更改停止标识  </span></span><br><span class="line">    &#123;   <span class="comment">//添加作用域，离开后自动释放。加锁保证线程安全地将IsStop置为true  </span></span><br><span class="line">        <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mtx)</span></span>;  </span><br><span class="line">        IsStop = <span class="literal">true</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">//通知所有阻塞中的线程，让它们继续进行  </span></span><br><span class="line">    cv.<span class="built_in">notify_all</span>();  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">//确保线程执行完成  </span></span><br><span class="line">    <span class="keyword">for</span> (std::thread&amp; OneThread : workers)  </span><br><span class="line">    &#123;  </span><br><span class="line">        OneThread.<span class="built_in">join</span>();   <span class="comment">//都加入（阻塞）到主线程中（不是指执行），当所有子线程释放以后，主线程才能释放  </span></span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">//添加任务  </span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> F, <span class="keyword">typename</span> ...Arg&gt;   <span class="comment">//...Arg为可变参数模板，任意个数的参数  </span></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">ThreadPool::EnterQueues</span><span class="params">(F&amp;&amp; f, Arg&amp;&amp;... arg)</span> -&gt; std::future&lt;<span class="keyword">typename</span> std::invoke_result&lt;F, Arg...&gt;::type&gt;  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="comment">//获得f执行后的类型  </span></span><br><span class="line">    <span class="keyword">using</span> functype = <span class="keyword">typename</span> std::result_of&lt;<span class="built_in">F</span>(Arg...)&gt;::type;  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">//获得一个智能指针，指向一个被包装为functype()的task  </span></span><br><span class="line">    <span class="comment">//之所以使用指针而不是使用局部变量，是为了延长生命周期  </span></span><br><span class="line">    <span class="keyword">auto</span> task = std::make_shared&lt;std::packaged_task&lt;<span class="built_in">functype</span>()&gt;&gt;(  </span><br><span class="line">            std::<span class="built_in">bind</span>(std::forward&lt;F&gt;(f), std::forward&lt;Arg&gt;(arg)...)    <span class="comment">//绑定成function&lt;void()&gt;类型  </span></span><br><span class="line">            );  </span><br><span class="line">    <span class="comment">//std::forward完美转发，发的是右值则传右值，发的是左值则传左值  </span></span><br><span class="line">  </span><br><span class="line">    <span class="comment">//获得future  </span></span><br><span class="line">    std::future&lt;functype&gt; rsFuture = task-&gt;<span class="built_in">get_future</span>();  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">//将任务添加到队列  </span></span><br><span class="line">    &#123;  </span><br><span class="line">        <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lockGuard</span><span class="params">(mtx)</span></span>;  </span><br><span class="line">        <span class="keyword">if</span> (IsStop)  </span><br><span class="line">        &#123;  </span><br><span class="line">            <span class="keyword">throw</span> std::<span class="built_in">runtime_error</span>(<span class="string">&quot;出错：线程池已经停止了&quot;</span>);  </span><br><span class="line">        &#125;  </span><br><span class="line">  </span><br><span class="line">        MyQueue.<span class="built_in">emplace</span>([task]() &#123;  </span><br><span class="line">            (*task)();  </span><br><span class="line">        &#125;);  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">//通知线程去执行任务  </span></span><br><span class="line">    cv.<span class="built_in">notify_one</span>();  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">return</span> rsFuture;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">//每个具体的工作任务  </span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ThreadPool::worker</span><span class="params">()</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>)  </span><br><span class="line">    &#123;  </span><br><span class="line">        <span class="comment">//定义任务  </span></span><br><span class="line">        std::function&lt;<span class="type">void</span>()&gt; task;  </span><br><span class="line">  </span><br><span class="line">        <span class="comment">//从队列中取得一个任务  </span></span><br><span class="line">        &#123;  </span><br><span class="line">            <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">uniqueLock</span><span class="params">(mtx)</span></span>;  </span><br><span class="line">  </span><br><span class="line">            cv.<span class="built_in">wait</span>(uniqueLock, [<span class="keyword">this</span>]() &#123;  </span><br><span class="line">                <span class="keyword">return</span> !<span class="keyword">this</span>-&gt;MyQueue.<span class="built_in">empty</span>() || <span class="keyword">this</span>-&gt;IsStop;  </span><br><span class="line">            &#125;);  </span><br><span class="line">  </span><br><span class="line">            <span class="keyword">if</span> (IsStop &amp;&amp; MyQueue.<span class="built_in">empty</span>())  </span><br><span class="line">            &#123;  </span><br><span class="line">                <span class="keyword">return</span>;  </span><br><span class="line">            &#125;  </span><br><span class="line">            task = std::<span class="built_in">move</span>(MyQueue.<span class="built_in">front</span>());  </span><br><span class="line">            MyQueue.<span class="built_in">pop</span>();  </span><br><span class="line">        &#125;  </span><br><span class="line">  </span><br><span class="line">        <span class="comment">//执行任务  </span></span><br><span class="line">        <span class="built_in">task</span>();  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><code>main.cpp</code>：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;ThreadPool.hpp&quot;</span>  </span></span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;chcp 65001&quot;</span>);  </span><br><span class="line">    <span class="function">ThreadPool <span class="title">MyPool</span><span class="params">(<span class="number">4</span>)</span></span>;  </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; ++i) &#123;  <span class="comment">//即使是i &lt; 20，仍然只有4个线程运行  </span></span><br><span class="line">        std::future&lt;<span class="type">int</span>&gt; MyFuture = MyPool.<span class="built_in">EnterQueues</span>([](<span class="type">int</span> a, <span class="type">int</span> b) -&gt; <span class="type">int</span> &#123;  </span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;当前线程: &quot;</span> &lt;&lt; std::this_thread::<span class="built_in">get_id</span>() &lt;&lt; std::endl;  </span><br><span class="line">            <span class="keyword">return</span> a + b;  </span><br><span class="line">        &#125;, <span class="number">10</span> * i, <span class="number">10</span> * i);  </span><br><span class="line">  </span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;thread rs: &quot;</span> &lt;&lt; MyFuture.<span class="built_in">get</span>() &lt;&lt; std::endl;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>✅注：关于 hpp 文件<br>HPP（Header Plus Plus）是C++中的一种特殊头文件格式，它将类的声明和实现代码放在同一个文件中。与传统的 <code>.h</code> 和 <code>.cpp</code> 文件不同，HPP文件允许在头文件中直接包含实现代码，从而减少了代码文件的数量和编译次数。这种文件格式特别适合用于编写模板类和开源库，因为它简化了代码的管理和使用。</p><p>输出结果：<br><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">thread rs: 当前线程: 2</span><br><span class="line">0</span><br><span class="line">thread rs: 当前线程: 3</span><br><span class="line">20</span><br><span class="line">thread rs: 当前线程: 4</span><br><span class="line">40</span><br><span class="line">thread rs: 当前线程: 5</span><br><span class="line">60</span><br><span class="line">thread rs: 当前线程: 2</span><br><span class="line">80</span><br><span class="line">thread rs: 当前线程: 3</span><br><span class="line">100</span><br><span class="line">thread rs: 当前线程: 4</span><br><span class="line">120</span><br><span class="line">thread rs: 当前线程: 5</span><br><span class="line">140</span><br><span class="line">thread rs: 当前线程: 2</span><br><span class="line">160</span><br><span class="line">thread rs: 当前线程: 3</span><br><span class="line">180</span><br><span class="line">thread rs: 当前线程: 4</span><br><span class="line">200</span><br><span class="line">thread rs: 当前线程: 5</span><br><span class="line">220</span><br><span class="line">thread rs: 当前线程: 2</span><br><span class="line">240</span><br><span class="line">thread rs: 当前线程: 3</span><br><span class="line">260</span><br><span class="line">thread rs: 当前线程: 4</span><br><span class="line">280</span><br><span class="line">thread rs: 当前线程: 5</span><br><span class="line">300</span><br><span class="line">thread rs: 当前线程: 2</span><br><span class="line">320</span><br><span class="line">thread rs: 当前线程: 3</span><br><span class="line">340</span><br><span class="line">thread rs: 当前线程: 4</span><br><span class="line">360</span><br><span class="line">thread rs: 当前线程: 5</span><br><span class="line">380</span><br></pre></td></tr></table></figure></p>]]></content>
    
    
    <summary type="html">C++基础：多线程</summary>
    
    
    
    <category term="C++语言基础" scheme="https://sumikiru.top/categories/C-%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="C++" scheme="https://sumikiru.top/tags/C/"/>
    
    <category term="多线程" scheme="https://sumikiru.top/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>语言基础3.文件操作与C++11新特性</title>
    <link href="https://sumikiru.top/posts/9da932c7.html"/>
    <id>https://sumikiru.top/posts/9da932c7.html</id>
    <published>2024-09-12T12:06:29.000Z</published>
    <updated>2024-12-14T16:38:20.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>文章参考: <a href="https://www.zhihu.com/column/c_1479157429707059201">C++学习笔记——CODspielen</a></p></blockquote><h1 id="文件操作"><a href="#文件操作" class="headerlink" title="文件操作"></a>文件操作</h1><h2 id="文本操作"><a href="#文本操作" class="headerlink" title="文本操作"></a>文本操作</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fstream&gt;</span><span class="comment">//包含读写文件的头文件</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//ofstream，写文件；</span></span><br><span class="line"><span class="comment">//ifstream，读文件；</span></span><br><span class="line"><span class="comment">//fstream，读写文件；</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//文件类型分为文本文件和二进制文件；</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span><span class="comment">//写文件</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//1, 包含头文件fstream；</span></span><br><span class="line"><span class="comment">//2, 创建流对象；</span></span><br><span class="line">ofstream ofs;<span class="comment">//写文件；</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//3, 指定打开方式；</span></span><br><span class="line">ofs.<span class="built_in">open</span>(<span class="string">&quot;text01.txt&quot;</span>, ios::out);<span class="comment">//ios::out是写文件的打开方式</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//打开方式：</span></span><br><span class="line"><span class="comment">//ios::in读文件</span></span><br><span class="line"><span class="comment">//ios::out写文件</span></span><br><span class="line"><span class="comment">//ios::trunc如果文件存在，先删除，再创建</span></span><br><span class="line"><span class="comment">//ios::binary二进制方式</span></span><br><span class="line"><span class="comment">//可配合使用，中间加|; 如用二进制写文件，ios::binary | ios::out</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//4, 往文件里写内容；</span></span><br><span class="line">ofs &lt;&lt; <span class="string">&quot;张三&quot;</span> &lt;&lt; endl;<span class="comment">//左移运算符&lt;&lt;意思就是输出，这里是往文件里输出，cout是往屏幕上输出；</span></span><br><span class="line">ofs &lt;&lt; <span class="string">&quot;男&quot;</span> &lt;&lt; endl;</span><br><span class="line">ofs &lt;&lt; <span class="string">&quot;18岁&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">//5,关闭文件</span></span><br><span class="line">ofs.<span class="built_in">close</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span><span class="comment">//读文件</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">ifstream ifs;<span class="comment">//读文件的流对象</span></span><br><span class="line">ifs.<span class="built_in">open</span>(<span class="string">&quot;text01.txt&quot;</span>,ios::in);<span class="comment">//ios::in是读文件</span></span><br><span class="line"><span class="keyword">if</span> (!ifs.<span class="built_in">is_open</span>())<span class="comment">//判断文件是否打开成功</span></span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;文件打开失败&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//读数据有4种方式</span></span><br><span class="line"><span class="comment">//第1种：</span></span><br><span class="line"><span class="comment">//char buf[1024] = &#123; 0 &#125;;//初始化字符数组</span></span><br><span class="line"><span class="comment">//while (ifs&gt;&gt;buf)</span></span><br><span class="line"><span class="comment">//&#123;</span></span><br><span class="line"><span class="comment">//cout &lt;&lt; buf &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//第2种：</span></span><br><span class="line"><span class="comment">/*char buf[1024] = &#123; 0 &#125;;</span></span><br><span class="line"><span class="comment">while (ifs.getline(buf, sizeof(buf)))</span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">cout &lt;&lt; buf &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">&#125;*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//第3种：</span></span><br><span class="line">string buf;</span><br><span class="line"><span class="keyword">while</span> (<span class="built_in">getline</span>(ifs, buf))</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; buf &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//第4种(不推荐)：</span></span><br><span class="line"><span class="comment">//char c;</span></span><br><span class="line"><span class="comment">//while ((c = ifs.get()) != EOF)//每次只读一个字符, EOF是文件尾部 end of file</span></span><br><span class="line"><span class="comment">//&#123;</span></span><br><span class="line"><span class="comment">//cout &lt;&lt; c;</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line">ifs.<span class="built_in">close</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">test01</span>();</span><br><span class="line"><span class="built_in">test02</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="二进制操作"><a href="#二进制操作" class="headerlink" title="二进制操作"></a>二进制操作</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fstream&gt;</span><span class="comment">//包含读写文件的头文件</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="type">char</span> m_Name[<span class="number">64</span>];<span class="comment">//姓名//用C语言中的字符数组，不要用C++的字符串string，容易出问题！</span></span><br><span class="line"><span class="type">int</span> m_Age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test03</span><span class="params">()</span><span class="comment">//写文件</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//1,包含头文件fstream；</span></span><br><span class="line"><span class="comment">//2,创建流对象，同时打开文件；</span></span><br><span class="line"><span class="comment">//ofstream ofs;</span></span><br><span class="line"><span class="function">ofstream <span class="title">ofs</span><span class="params">(<span class="string">&quot;person.txt&quot;</span>, ios::out | ios::binary)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//3,打开文件；</span></span><br><span class="line"><span class="comment">//ofs.open(&quot;person.txt&quot;,ios::out | ios::binary);//用二进制写文件；</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//4,写文件；</span></span><br><span class="line">Person p = &#123; <span class="string">&quot;李四&quot;</span>, <span class="number">28</span> &#125;;</span><br><span class="line">ofs.<span class="built_in">write</span>((<span class="type">const</span> <span class="type">char</span>*)&amp;p, <span class="built_in">sizeof</span>(Person));<span class="comment">//person.txt文件里会有乱码或遗漏，不过能读回来就行；</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//5,关闭文件；</span></span><br><span class="line">ofs.<span class="built_in">close</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test04</span><span class="params">()</span><span class="comment">//读文件</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">ifstream ifs;</span><br><span class="line">ifs.<span class="built_in">open</span>(<span class="string">&quot;person.txt&quot;</span>, ios::in | ios::binary);</span><br><span class="line"><span class="keyword">if</span> (!ifs.<span class="built_in">is_open</span>())<span class="comment">//判断文件是否打开成功</span></span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;文件打开失败&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Person p;</span><br><span class="line">ifs.<span class="built_in">read</span>((<span class="type">char</span>*)&amp;p, <span class="built_in">sizeof</span>(Person));</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;姓名:&quot;</span> &lt;&lt; p.m_Name &lt;&lt; <span class="string">&quot;\t&quot;</span> &lt;&lt; <span class="string">&quot;年龄：&quot;</span> &lt;&lt; p.m_Age &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">ifs.<span class="built_in">close</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="新特性"><a href="#新特性" class="headerlink" title="新特性"></a>新特性</h1><h2 id="易用性的改进"><a href="#易用性的改进" class="headerlink" title="易用性的改进"></a>易用性的改进</h2><h3 id="auto"><a href="#auto" class="headerlink" title="auto"></a>auto</h3><p>不建议滥用，方便直接写出类型的就直接写。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">double</span> <span class="title">func01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">1.1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Test01</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> m_a;</span><br><span class="line">string m_b;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01_01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">auto</span> b = <span class="number">1</span>;<span class="comment">//自动推导b为int类型；</span></span><br><span class="line"><span class="keyword">auto</span> c = <span class="built_in">func01</span>();<span class="comment">//自动推导c为double类型；</span></span><br><span class="line"></span><br><span class="line">Test01 str;</span><br><span class="line"><span class="keyword">auto</span> d = str;<span class="comment">//自动推导d为自定义的Test01类型；</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func02</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (vector&lt;<span class="type">int</span>&gt;::iterator it = v.<span class="built_in">begin</span>(); it != v.<span class="built_in">end</span>(); it++)<span class="comment">//传统写法</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> ii = v.<span class="built_in">begin</span>(); ii != v.<span class="built_in">end</span>(); ii++)<span class="comment">//用auto自动推导ii为vector&lt;int&gt;的迭代器类型</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//C++14中也可作为函数返回类型的推导</span></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">func14</span><span class="params">(<span class="type">int</span> i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//如果函数实现中含有多个return语句，这些表达式必须可以推断为相同的类型；</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//如果return语句返回初始化列表，返回值类型推导也会失败；</span></span><br><span class="line"><span class="comment">//return &#123; 1, 2, 3 &#125;; // error</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//如果函数是虚函数，不能使用返回值类型推导；</span></span><br><span class="line"><span class="comment">/*virtual auto func() </span></span><br><span class="line"><span class="comment">&#123; </span></span><br><span class="line"><span class="comment">return 1; </span></span><br><span class="line"><span class="comment">&#125;*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//返回类型推导可以用在递归函数中，但是递归调用必须以至少一个返回语句作为先导；</span></span><br><span class="line"><span class="keyword">if</span> (i == <span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> i;  <span class="comment">// return int</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">func14</span>(i - <span class="number">1</span>) + i; <span class="comment">// ok</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//auto使用注意事项：</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">1，定义变量时必须初始化：</span></span><br><span class="line"><span class="comment">auto a;//没有初始化a，无法推导a的类型；</span></span><br><span class="line"><span class="comment">a = 10;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">2, VS编译器不支持函数形参是auto变量；</span></span><br><span class="line"><span class="comment">void func(auto a)</span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">3，auto变量不能作为自定义类型结构体或者类的成员变量；</span></span><br><span class="line"><span class="comment">class A</span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">public:</span></span><br><span class="line"><span class="comment">//auto a; //不可以作为成员变量；</span></span><br><span class="line"><span class="comment">//auto b = 0; //即便初始化了，也不可以；</span></span><br><span class="line"><span class="comment">&#125;;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">4，不可以定义一个auto数组；</span></span><br><span class="line"><span class="comment">auto arr[] = &#123;1, 2, 3&#125;;//不允许；</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">5，模板实例化类型不能是auto类型；</span></span><br><span class="line"><span class="comment">vector&lt;int&gt; a;</span></span><br><span class="line"><span class="comment">//vector&lt;auto&gt; b;//不可以；</span></span><br><span class="line"><span class="comment">//vector&lt;auto&gt; c = &#123; 1 &#125;;//即便初始化了，也不可以；</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure></p><h3 id="decltype"><a href="#decltype" class="headerlink" title="decltype"></a>decltype</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;typeinfo&gt;</span><span class="comment">//typeid用</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">decltype类似auto的反函数，auto可以声明一个变量，而decltype可以从一个变量或表达式中得到其类型，再定义其他变量；</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> <span class="comment">//匿名枚举变量</span></span><br><span class="line">&#123;</span><br><span class="line">OK,</span><br><span class="line">ERROR</span><br><span class="line">&#125; flag;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02_01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> i;</span><br><span class="line"><span class="keyword">decltype</span>(i) j = <span class="number">0</span>;<span class="comment">//decltype(i)就是从i获取到i的类型为int，然后用这个类型定义变量j；</span></span><br><span class="line">cout &lt;&lt; <span class="built_in">typeid</span>(j).<span class="built_in">name</span>() &lt;&lt; endl;<span class="comment">//输出int，也就是j的类型也是int，是从i获取的；</span></span><br><span class="line">cout &lt;&lt; <span class="built_in">typeid</span>(j).<span class="built_in">hash_code</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="type">float</span> a;</span><br><span class="line"><span class="type">double</span> b;</span><br><span class="line"><span class="keyword">decltype</span>(a + b) c;</span><br><span class="line">cout &lt;&lt; <span class="built_in">typeid</span>(c).<span class="built_in">name</span>() &lt;&lt; endl;<span class="comment">//输出double</span></span><br><span class="line"></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; tmp;</span><br><span class="line"><span class="keyword">decltype</span>(tmp.<span class="built_in">begin</span>())k; <span class="comment">//定义k为迭代器类型</span></span><br><span class="line"><span class="keyword">for</span> (k = tmp.<span class="built_in">begin</span>(); k != tmp.<span class="built_in">end</span>(); k++)<span class="comment">//也可以直接用for(auto k = tmp.begin(); k != tmp.end(); k++)</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">decltype</span>(flag) flag2;<span class="comment">//可以用decltype获取到类型，再定义其他变量；</span></span><br><span class="line">cout &lt;&lt; <span class="built_in">typeid</span>(flag2).<span class="built_in">name</span>() &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="built_in">typeid</span>(flag2).<span class="built_in">hash_code</span>() &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">test02_01</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="追踪函数的返回类型"><a href="#追踪函数的返回类型" class="headerlink" title="追踪函数的返回类型"></a>追踪函数的返回类型</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;typeinfo&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">func03</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> <span class="comment">//传统写法</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">func04</span><span class="params">(<span class="type">int</span> a, <span class="type">double</span> b)</span>-&gt;<span class="type">int</span> <span class="comment">//指定函数返回值类型，前面换成auto，这样更灵活</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">func05</span><span class="params">(<span class="type">int</span> a, <span class="type">double</span> b)</span>-&gt;<span class="title">decltype</span><span class="params">(a + b)</span> <span class="comment">//借助decltype，指定函数返回值类型</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test03_01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="type">double</span> b = <span class="number">9.8</span>;</span><br><span class="line"><span class="keyword">auto</span> c = <span class="built_in">func04</span>(a, b);</span><br><span class="line"><span class="keyword">auto</span> d = <span class="built_in">func05</span>(a, b);</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;c= &quot;</span> &lt;&lt; c &lt;&lt; <span class="string">&quot; typeid= &quot;</span> &lt;&lt; <span class="built_in">typeid</span>(c).<span class="built_in">name</span>() &lt;&lt; endl; <span class="comment">//19, int</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;d= &quot;</span> &lt;&lt; d &lt;&lt; <span class="string">&quot; typeid= &quot;</span> &lt;&lt; <span class="built_in">typeid</span>(d).<span class="built_in">name</span>() &lt;&lt; endl; <span class="comment">//19.8, double</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//配合模板使用：</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T1, <span class="keyword">class</span> T2&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">mul</span><span class="params">(<span class="type">const</span> T1 &amp;t1, <span class="type">const</span> T2 &amp;t2)</span>-&gt;<span class="title">decltype</span><span class="params">(t1 * t2)</span> <span class="comment">//乘法运算</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> t1 * t2; <span class="comment">//t2和t2类型是不确定的，是泛型的，所以要用decltype来指定类型，用auto自动推导；</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test03_02</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">auto</span> m = <span class="number">8</span>;</span><br><span class="line"><span class="keyword">auto</span> n = <span class="number">12.6</span>;</span><br><span class="line"><span class="keyword">auto</span> k = <span class="built_in">mul</span>(m, n);</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;k= &quot;</span> &lt;&lt; k &lt;&lt; <span class="string">&quot; typeid= &quot;</span> &lt;&lt; <span class="built_in">typeid</span>(k).<span class="built_in">name</span>() &lt;&lt; endl; <span class="comment">//100.8, double</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="初始化列表和成员"><a href="#初始化列表和成员" class="headerlink" title="初始化列表和成员"></a>初始化列表和成员</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="type">int</span> m_a;</span><br><span class="line"><span class="type">int</span> m_b;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">/*A(int i, int j) //传统有参构造写法</span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">m_a = i;</span></span><br><span class="line"><span class="comment">m_b = j;</span></span><br><span class="line"><span class="comment">&#125;*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*A() :m_a(1), m_b(2) //初始化列表，利用有参构造直接赋值，但不可传参</span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">&#125;*/</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">A</span>(<span class="type">int</span> i, <span class="type">int</span> j) :<span class="built_in">m_a</span>(i), <span class="built_in">m_b</span>(j) <span class="comment">//初始化列表，等价于有参构造</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="type">int</span> m_a&#123;<span class="number">1</span>&#125;; <span class="comment">//直接赋值初始化，不依赖构造函数</span></span><br><span class="line"><span class="type">int</span> m_b = <span class="number">2</span>;  <span class="comment">//直接赋值初始化，不依赖构造函数</span></span><br><span class="line">string m_name &#123; <span class="string">&quot;Tom&quot;</span> &#125;; <span class="comment">//直接赋值初始化，不依赖构造函数</span></span><br><span class="line"></span><br><span class="line">A tmp&#123; <span class="number">10</span>, <span class="number">20</span> &#125;;<span class="comment">//实例化对象时直接赋值初始化，需要存在有参构造或初始化列表</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test04_01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">B obj;</span><br><span class="line">cout &lt;&lt; obj.m_a &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; obj.m_b &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; obj.m_name &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; obj.tmp.m_a &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; obj.tmp.m_b &lt;&lt; endl;</span><br><span class="line"><span class="comment">//1 2 Tom 10 20</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//列表初始化：</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Test04_01</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> a;</span><br><span class="line"><span class="type">int</span> b;</span><br><span class="line">string name;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test04_02</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Test04_01 t = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="string">&quot;Jerry&quot;</span> &#125;;<span class="comment">//用&#123;&#125;的方式赋值就叫列表初始化</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> a1 = <span class="number">2</span>;<span class="comment">//传统写法</span></span><br><span class="line"><span class="type">int</span> a2 = &#123; <span class="number">3</span> &#125;;<span class="comment">//也可以直接这样写，也叫列表初始化</span></span><br><span class="line"><span class="type">int</span> a3&#123; <span class="number">4</span> &#125;;<span class="comment">//也可以直接这样写，也叫列表初始化</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> arr1[] = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> &#125;;<span class="comment">//传统写法</span></span><br><span class="line"><span class="type">int</span> arr2[]&#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span> &#125;;<span class="comment">//列表初始化</span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; arr3&#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//💭防止类型收窄：</span></span><br><span class="line"><span class="comment">//类型收窄指的是导致数据内容发生变化或者精度丢失的隐式类型转换。使用列表初始化可以防止类型收窄；</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test04_03</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> a = <span class="number">1024</span>;</span><br><span class="line"><span class="type">char</span> b = a;<span class="comment">//可编译通过，但数据会丢失，收窄，因为放不下</span></span><br><span class="line"><span class="comment">//cout &lt;&lt; b &lt;&lt; endl;//显示不出内容，要用C语言的打印</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d \n&quot;</span>, b); <span class="comment">//输出0，数据丢失了</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//char c = &#123; a &#125;;//用列表初始化，不会收窄，但是类型转换错误</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="基于范围的for循环"><a href="#基于范围的for循环" class="headerlink" title="基于范围的for循环"></a>基于范围的for循环</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func05_01</span><span class="params">(T &amp;a)</span><span class="comment">// 原写法func05_01(int *a)是把数组a的元素地址传入，形参中的数组是指针变量，不是数组，无法确定元素个数</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> temp : a)<span class="comment">//基于范围的for循环，数组的范围需要是确定的；改成模板后可以使用；</span></span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; temp &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test05_01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> a[]&#123; <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span> &#125;;</span><br><span class="line"><span class="type">int</span> len = <span class="built_in">sizeof</span>(a) / <span class="built_in">sizeof</span>(a[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line"><span class="comment">//#if 0</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; i++)<span class="comment">//传统写法</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> temp = a[i];</span><br><span class="line">temp *= <span class="number">2</span>;</span><br><span class="line">cout &lt;&lt; temp &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> temp : a) <span class="comment">//等价于上述写法</span></span><br><span class="line">&#123;</span><br><span class="line">temp *= <span class="number">2</span>;</span><br><span class="line">cout &lt;&lt; temp &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line"><span class="comment">//#endif //条件编译</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; i++)<span class="comment">//传统写法</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> &amp;temp = a[i]; <span class="comment">//引用，可以改数组元素的值</span></span><br><span class="line">temp *= <span class="number">2</span>;</span><br><span class="line">cout &lt;&lt; temp &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> &amp;temp : a) <span class="comment">//引用</span></span><br><span class="line">&#123;</span><br><span class="line">temp *= <span class="number">2</span>;</span><br><span class="line">cout &lt;&lt; temp &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">//基于范围的for循环，数组的范围需要是确定的</span></span><br><span class="line"><span class="built_in">func05_01</span>(a);<span class="comment">//把数组a的元素地址传入</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="静态断言"><a href="#静态断言" class="headerlink" title="静态断言"></a>静态断言</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cassert&gt;</span> <span class="comment">//断言头文件</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">C++提供了调试工具assert，是一个宏，用于在运行阶段对断言进行检查，如果条件为真，执行程序，否则调用abort()；</span></span><br><span class="line"><span class="comment">C++11新增了static_assert，静态断言，不用等到运行阶段检查，在编译阶段就检查，可以更早报告错误，同时减少运行时的开销；</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test06_01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">bool</span> flag = <span class="literal">false</span>;</span><br><span class="line"><span class="comment">//assert(flag);</span></span><br><span class="line"><span class="built_in">assert</span>(!flag);<span class="comment">//断言，如果flag == true，就继续往下执行；否则中断，提示错误</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;hello world&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test06_02</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//静态断主语法：static_assert(条件(常量表达式), &quot;提示的字符串&quot;); //因为是编译阶段就检查，所以条件是常量，不能是变量；</span></span><br><span class="line"><span class="built_in">static_assert</span>(<span class="built_in">sizeof</span>(<span class="type">void</span>*) == <span class="number">4</span>, <span class="string">&quot;64位系统不支持&quot;</span>); <span class="comment">//指针占4位，说明是32位系统</span></span><br><span class="line"><span class="comment">//static_assert(sizeof(void*) == 8, &quot;32位系统不支持&quot;); //指针占8位，说明是64位系统</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;hello C++ 11&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="noexcept修饰符"><a href="#noexcept修饰符" class="headerlink" title="noexcept修饰符"></a>noexcept修饰符</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">C++11使用noexcept替代throw()；</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func07_01</span><span class="params">()</span><span class="comment">//可抛出异常</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func07_02</span><span class="params">()</span> <span class="title">throw</span><span class="params">()</span> <span class="comment">//不可抛出任何异常，但C++11已经不用throw()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func07_03</span><span class="params">()</span> <span class="keyword">noexcept</span> <span class="comment">//不可抛出任何异常，相当于noexcept(true)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>🚀noexcept 和 try/catch:<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdexcept&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 示例1：noexcept用法</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SafeDivide</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">double</span> <span class="title">divide</span><span class="params">(<span class="type">double</span> numerator, <span class="type">double</span> denominator)</span> <span class="keyword">noexcept</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (denominator == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 如果分母为0，不抛出异常，而是返回0</span></span><br><span class="line">            <span class="comment">// 因为函数声明为noexcept，如果有异常将调用std::terminate</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> numerator / denominator;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 示例2：try-catch用法</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">UnsafeDivide</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">double</span> <span class="title">divide</span><span class="params">(<span class="type">double</span> numerator, <span class="type">double</span> denominator)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (denominator == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 如果分母为0，抛出异常</span></span><br><span class="line">            <span class="keyword">throw</span> std::<span class="built_in">invalid_argument</span>(<span class="string">&quot;Denominator cannot be zero.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> numerator / denominator;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 使用noexcept函数</span></span><br><span class="line">    <span class="type">double</span> result1 = SafeDivide::<span class="built_in">divide</span>(<span class="number">10</span>, <span class="number">0</span>);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Result with SafeDivide: &quot;</span> &lt;&lt; result1 &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用try-catch捕获UnsafeDivide函数的异常</span></span><br><span class="line">    <span class="type">double</span> result2;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        result2 = UnsafeDivide::<span class="built_in">divide</span>(<span class="number">10</span>, <span class="number">0</span>);</span><br><span class="line">    &#125; <span class="built_in">catch</span> (<span class="type">const</span> std::invalid_argument&amp; e) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Caught exception: &quot;</span> &lt;&lt; e.<span class="built_in">what</span>() &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">        <span class="comment">// 处理异常，例如给result2赋值</span></span><br><span class="line">        result2 = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Result with UnsafeDivide: &quot;</span> &lt;&lt; result2 &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="nullptr的使用"><a href="#nullptr的使用" class="headerlink" title="nullptr的使用"></a>nullptr的使用</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">nullptr是为了解决以前C++中NULL的二义性(0和空指针)而引进的一种新的类型，因为NULL实际上代表的是0；</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func08_01</span><span class="params">(<span class="type">int</span> a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; __LINE__ &lt;&lt; endl;<span class="comment">//打印行数</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func08_01</span><span class="params">(<span class="type">int</span> *a)</span><span class="comment">//重载</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; __LINE__ &lt;&lt; endl;<span class="comment">//打印行数</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test08_01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> *p = <span class="literal">NULL</span>;</span><br><span class="line"><span class="type">int</span> *p2 = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> *p3 = <span class="literal">nullptr</span>;<span class="comment">//空指针，nullptr只能给指针赋值，不能给int变量赋值</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">func08_01</span>(<span class="number">0</span>);<span class="comment">//现在是默认用C++11，没有歧义，会调用值传递那个函数，但是以前的版本会有歧义；</span></span><br><span class="line"><span class="built_in">func08_01</span>(<span class="literal">NULL</span>);<span class="comment">//报错：还是调用值传递那个函数，产生歧义；</span></span><br><span class="line"><span class="built_in">func08_01</span>(<span class="literal">nullptr</span>);<span class="comment">//这样就会调用指针传递那个函数；</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">func08_01</span>(p);</span><br><span class="line"><span class="built_in">func08_01</span>(p2);</span><br><span class="line"><span class="built_in">func08_01</span>(p3);</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> a = <span class="literal">NULL</span>;<span class="comment">//警告：将NULL转换为非指针的int类型</span></span><br><span class="line"><span class="comment">//int b = nullptr;//不能给int变量赋值</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (p == p3)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;equal&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="🚩强类型枚举"><a href="#🚩强类型枚举" class="headerlink" title="🚩强类型枚举"></a>🚩强类型枚举</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">传统枚举中，即使枚举名不同，但是如果变量相同，也会判定为重定义；</span></span><br><span class="line"><span class="comment">也不能指定成员变量的类型；</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//enum Status</span></span><br><span class="line"><span class="comment">//&#123;</span></span><br><span class="line"><span class="comment">//OK,</span></span><br><span class="line"><span class="comment">//Error</span></span><br><span class="line"><span class="comment">//&#125;;</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//enum Status2</span></span><br><span class="line"><span class="comment">//&#123;</span></span><br><span class="line"><span class="comment">//OK,</span></span><br><span class="line"><span class="comment">//Error</span></span><br><span class="line"><span class="comment">//&#125;;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">强类型枚举：在enum后加上class或struct修饰；</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">enum class</span> <span class="title class_">Status</span></span><br><span class="line">&#123;</span><br><span class="line">OK,</span><br><span class="line">Error</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">enum struct</span> <span class="title class_">Status2</span></span><br><span class="line">&#123;</span><br><span class="line">OK,</span><br><span class="line">Error</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">enum class</span> <span class="title class_">Status3</span> : <span class="type">char</span> <span class="comment">//强类型枚举，可以指定成员变量的类型；</span></span><br><span class="line">&#123;</span><br><span class="line">OK = <span class="number">3</span>,</span><br><span class="line">Error = <span class="number">4</span> <span class="comment">//可以赋值</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">enum class</span> <span class="title class_">Status4</span> : <span class="type">long</span> <span class="type">long</span> <span class="comment">//强类型枚举，可以指定成员变量的类型；</span></span><br><span class="line">&#123;</span><br><span class="line">OK,</span><br><span class="line">Error</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test09_01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//需要加枚举类型的作用域；</span></span><br><span class="line"><span class="comment">//Status flag = OK;</span></span><br><span class="line">Status flag = Status::OK;</span><br><span class="line">Status2 flag2 = Status2::Error;</span><br><span class="line">Status3 flag3 = Status3::OK;</span><br><span class="line">Status3 flag4 = Status3::Error;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d %d %d %d\n&quot;</span>, flag, flag2, flag3, flag4);</span><br><span class="line"></span><br><span class="line"><span class="comment">//成员变量类型可被指定</span></span><br><span class="line">cout &lt;&lt; <span class="built_in">sizeof</span>(Status::OK) &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="built_in">sizeof</span>(Status2::OK) &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="built_in">sizeof</span>(Status3::OK) &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="built_in">sizeof</span>(Status4::OK) &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>优点：</p><ol><li><strong>类型安全</strong>：强类型枚举提供了更强的类型安全保障，确保了不同枚举类型的值不能隐式转换，减少了类型混淆的错误。</li><li><strong>作用域限制</strong>：强类型枚举不会污染外围作用域，枚举值被限定在枚举类的作用域内。</li><li><strong>可读性</strong>：强类型枚举通过明确的名称限定提供了更好的代码可读性，避免了枚举值在同一作用域下的潜在冲突。</li><li><strong>命名空间支持</strong>：强类型枚举可以包含在命名空间中，避免枚举值与全局变量冲突。</li><li><strong>与类集成</strong>：可将强类型枚举作为类成员或与类其他成员一起使用，提高类的封装性和数据完整性。</li><li><strong>constexpr支持</strong>：强类型枚举可以与constexpr结合使用，使得枚举值可以在编译时进行计算。</li></ol><p>缺点：</p><ul><li><strong>隐式转换限制</strong>：缺少了隐式转换的能力，这是在需要将强类型枚举值转换为整数类型时的一个不便。</li></ul><h3 id="常量表达式-constexpr"><a href="#常量表达式-constexpr" class="headerlink" title="常量表达式 constexpr"></a>常量表达式 constexpr</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">常量表达式允许一些计算发生在编译阶段，而不是运行阶段；</span></span><br><span class="line"><span class="comment">如果有些事可以在编译时做，并且只需要做一次，那么就不需要每次程序运行时都计算，可节省运行资源，提高程序运行效率；</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">getNum</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">const</span> <span class="type">int</span> <span class="title">getNum2</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="type">int</span> <span class="title">getNum3</span><span class="params">()</span> <span class="comment">//常量表达式</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">enum class</span> <span class="title class_">Num_e</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//e1 = getNum(),//枚举成员初始化必须是整型常量</span></span><br><span class="line"><span class="comment">//e1 = getNum2(),//就算用const修饰的函数，也是不允许的</span></span><br><span class="line">e1 = <span class="built_in">getNum3</span>(),<span class="comment">//用常量表达式就可以 //在编译阶段就执行，运行时就不用执行了</span></span><br><span class="line">e2</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test10_01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> tmp = <span class="built_in">getNum3</span>(); <span class="comment">//常量</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> tmp1 = <span class="built_in">getNum3</span>(); <span class="comment">//也是常量</span></span><br><span class="line">cout &lt;&lt; tmp &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">enum class</span> <span class="title class_">Num_e1</span></span><br><span class="line">&#123;</span><br><span class="line">e1 = tmp,</span><br><span class="line">e2 = tmp1<span class="comment">//也是可以的，tmp必须是constexpr或者const修饰的变量</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d, %d, %d, %d\n&quot;</span>, Num_e::e1, Num_e::e2, Num_e1::e1, Num_e1::e2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">constexpr函数的限制：</span></span><br><span class="line"><span class="comment">1，函数中只能有一个return语句，但在C++14中大幅放松；</span></span><br><span class="line"><span class="comment">2，函数必须有返回值，不能是void函数；</span></span><br><span class="line"><span class="comment">3，在使用前必须已经有定义；</span></span><br><span class="line"><span class="comment">4，return返回语句表达式中，不能使用到非常量表达式的函数、全局数据，且必须是一个常量表达式，或者就是一个常量，但在C++14中大幅放松；</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="type">int</span> <span class="title">func10_01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//允许包含typedef, using , 静态断言；</span></span><br><span class="line"><span class="built_in">static_assert</span>(<span class="number">1</span>, <span class="string">&quot;fail&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">return</span> a;<span class="comment">//新编译器可以</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> a_10 = <span class="number">12</span>;<span class="comment">//全局变量</span></span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="type">int</span> <span class="title">func10_02</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> a_10;<span class="comment">//新编译器可以</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="type">int</span> <span class="title">func10_03</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//return  getNum();//这样不行，因为getNum()是在运行时才调用，而constexpr函数要在编译时就调用，所以无法赋值；</span></span><br><span class="line"><span class="keyword">return</span> <span class="built_in">getNum3</span>();<span class="comment">//getNum3()也是在编译时被调用，这样可以</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test10_02</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> m_a = <span class="built_in">func10_01</span>();</span><br><span class="line"><span class="type">int</span> m_b = <span class="built_in">func10_02</span>();</span><br><span class="line"><span class="type">int</span> m_c = <span class="built_in">func10_03</span>();</span><br><span class="line">cout &lt;&lt; m_a &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; m_b &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; m_c &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//类中函数成员是常量表达式</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Date</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">//constexpr修饰构造函数，那么这个构造函数体必须为空，但是可以通过初始化列表的方式初始化；</span></span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="title">Date</span><span class="params">(<span class="type">int</span> y, <span class="type">int</span> m, <span class="type">int</span> d)</span> : year(y), month(m), day(d)</span></span><br><span class="line"><span class="function">&#123;</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//constexpr int GetYear() 这样写会报错，因为year不是一个常量或者常量表达式</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">GetYear</span><span class="params">()</span> <span class="type">const</span><span class="comment">//对外接口，加上constexpr后面会提示类型不兼容，需要使用常函数</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> year;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">GetMonth</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> month;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">GetDay</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> day;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="type">int</span> year;</span><br><span class="line"><span class="type">int</span> month;</span><br><span class="line"><span class="type">int</span> day;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test10_03</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> Date <span class="title">obj</span><span class="params">(<span class="number">2077</span>, <span class="number">8</span>, <span class="number">8</span>)</span></span>;<span class="comment">//必须用常量或常量表达式给构造函数传参数</span></span><br><span class="line">cout &lt;&lt; obj.<span class="built_in">GetYear</span>() &lt;&lt; <span class="string">&quot;年&quot;</span> &lt;&lt; obj.<span class="built_in">GetMonth</span>() &lt;&lt; <span class="string">&quot;月&quot;</span> &lt;&lt; obj.<span class="built_in">GetDay</span>() &lt;&lt; <span class="string">&quot;日&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//C++14支持变量模板：</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">constexpr</span> T pi = <span class="built_in">T</span>(<span class="number">3.1415926535897932385L</span>);</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test10_04</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; pi&lt;<span class="type">int</span>&gt; &lt;&lt; endl; <span class="comment">// 3</span></span><br><span class="line">cout &lt;&lt; pi&lt;<span class="type">double</span>&gt; &lt;&lt; endl; <span class="comment">// 3.14159</span></span><br><span class="line"><span class="comment">//pi&lt;int&gt;是在用int类型实例化模板</span></span><br><span class="line"><span class="comment">//(int)pi_variable则是在对pi_variable（如果它是一个变量或对象）进行类型转换</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="原生字符串"><a href="#原生字符串" class="headerlink" title="原生字符串"></a>原生字符串</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//原生字符串使用户所见即所得，会保留用户输入的格式输出；格式：R&quot;()&quot;;</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">R&quot;(hello world)&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">R&quot;(hello \n</span></span><br><span class="line"><span class="string">world)&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">string str = <span class="string">R&quot;(hello \4 \r</span></span><br><span class="line"><span class="string">abc, mike</span></span><br><span class="line"><span class="string">hello\n)&quot;</span>;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; str &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">hello world</span><br><span class="line">hello \n</span><br><span class="line">world</span><br><span class="line"></span><br><span class="line">hello \4 \r</span><br><span class="line">abc, mike</span><br><span class="line">hello\n</span><br></pre></td></tr></table></figure></p><h2 id="🚩类的改进"><a href="#🚩类的改进" class="headerlink" title="🚩类的改进"></a>🚩类的改进</h2><h3 id="继承构造"><a href="#继承构造" class="headerlink" title="继承构造"></a>继承构造</h3><p>格式 <code>using Base::Base;</code><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">继承构造：</span></span><br><span class="line"><span class="comment">C++11允许子类继承父类的构造函数，但默认构造、拷贝构造、移动构造除外；</span></span><br><span class="line"><span class="comment">继承构造只能初始化父类中的参数；</span></span><br><span class="line"><span class="comment">父类中的构造函数不能是私有的；</span></span><br><span class="line"><span class="comment">继承不能是虚继承；</span></span><br><span class="line"><span class="comment">使用了继承构造后，子类将不会再提供默认构造了；</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A1</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">A1</span>(<span class="type">int</span> x, <span class="type">int</span> y) <span class="comment">//有参构造</span></span><br><span class="line">&#123;</span><br><span class="line">a = x;</span><br><span class="line">b = y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line"><span class="type">int</span> a;</span><br><span class="line"><span class="type">int</span> b;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B1</span> : <span class="keyword">public</span> A1</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> 0</span></span><br><span class="line"><span class="built_in">B12</span>(<span class="type">int</span> x, <span class="type">int</span> y):<span class="built_in">A12</span>(x, y)<span class="comment">//通过参数列表给父类构造函数传参 //C++11里不用这样写，会自动继承</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> A1::A1; <span class="comment">//继承构造</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">show</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;a= &quot;</span> &lt;&lt; a &lt;&lt; <span class="string">&quot;, b= &quot;</span> &lt;&lt; b &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//没有增加新的成员变量</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test12_01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="function">B1 <span class="title">obj</span><span class="params">(<span class="number">77</span>, <span class="number">44</span>)</span></span>;</span><br><span class="line">obj.<span class="built_in">show</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="委托构造"><a href="#委托构造" class="headerlink" title="委托构造"></a>委托构造</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">委托构造：</span></span><br><span class="line"><span class="comment">如果一个类包含多个构造函数，C++11允许在一个构造函数的定义中使用另一个构造函数，但必须通过初始化列表操作；</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A2</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">/*A2() //传统默认构造</span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">&#125;*/</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">A2</span>() :<span class="built_in">A2</span>(<span class="number">1</span>, <span class="string">&#x27;a&#x27;</span>) <span class="comment">//委托构造，在默认构造中调用其他构造函数，必须用初始化列表 //通过形参自动识别为调用A2(int x, char y)这个</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//两个参数都写死</span></span><br><span class="line"><span class="comment">//被调用的构造函数如果是private，也可以调用成功</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">A2</span>(<span class="type">int</span> x) :<span class="built_in">A2</span>(x, <span class="string">&#x27;b&#x27;</span>)<span class="comment">//委托构造</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//只有一个是变量，另一个写死</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">A2</span>(<span class="type">char</span> x) :<span class="built_in">A2</span>(<span class="number">16</span>, x)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">A2</span>(<span class="type">int</span> x, <span class="type">char</span> y) :<span class="built_in">a</span>(x), <span class="built_in">b</span>(y)<span class="comment">//如果是private，也可以被调用成功</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="type">int</span> a;</span><br><span class="line"><span class="type">char</span> b;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test12_02</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">A2 obj;<span class="comment">//没有传参，也就是调默认构造A2() :A2(1, &#x27;a&#x27;)，而默认构造中委托调用了其他构造，所以也发生了传参；</span></span><br><span class="line">cout &lt;&lt; obj.a &lt;&lt; obj.b &lt;&lt; endl;<span class="comment">//在委托构造中已经传了参数，所以已经被赋值了；//1a</span></span><br><span class="line"></span><br><span class="line"><span class="function">A2 <span class="title">obj1</span><span class="params">(<span class="number">5</span>)</span></span>;<span class="comment">//传一个参数，会自动识别为调用A2(int x) :A2(x, &#x27;b&#x27;)这个构造函数，而这个函数只委托了另一个构造函数；</span></span><br><span class="line">cout &lt;&lt; obj1.a &lt;&lt; obj1.b &lt;&lt; endl;<span class="comment">//5b</span></span><br><span class="line"></span><br><span class="line"><span class="function">A2 <span class="title">obj2</span><span class="params">(<span class="string">&#x27;c&#x27;</span>)</span></span>;</span><br><span class="line">cout &lt;&lt; obj2.a &lt;&lt; obj2.b &lt;&lt; endl;<span class="comment">//16c</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="继承控制：final和override"><a href="#继承控制：final和override" class="headerlink" title="继承控制：final和override"></a>继承控制：final和override</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">继承控制：final和override</span></span><br><span class="line"><span class="comment">final：阻止类的进一步派生和虚函数的进一步重写；</span></span><br><span class="line"><span class="comment">override：确保在子类中声明的函数跟基类的虚函数一模一样；</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A3</span> <span class="keyword">final</span> <span class="comment">//加了final不能被继承</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="type">int</span> a;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//class A4 : public A3 //不能继承</span></span><br><span class="line"><span class="comment">//&#123;</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//&#125;;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A5</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">func</span><span class="params">()</span> <span class="keyword">final</span> </span>= <span class="number">0</span>;<span class="comment">//纯虚函数 //加了final 虚函数不能被重写</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A6</span> : <span class="keyword">public</span> A5</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">//virtual void func() //子类重写，如果父类中有final就不能被重写</span></span><br><span class="line"><span class="comment">//&#123;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B2</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span> a)</span> </span>= <span class="number">0</span>; <span class="comment">//纯虚函数</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B3</span> : <span class="keyword">public</span> B2</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span> a)</span> <span class="keyword">override</span> <span class="comment">//子类重写，如果漏了父类中的形参，那这个函数就被重定义了，如果不希望重定义，就加上override；</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//加了override，如果子类重写和父类不同，就会提示错误</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="类默认函数的控制：-default和-delete函数"><a href="#类默认函数的控制：-default和-delete函数" class="headerlink" title="类默认函数的控制：=default和=delete函数"></a>类默认函数的控制：=default和=delete函数</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">类默认函数的控制：=default和=delete函数</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">如果程序员显式定义了有参构造，编译器将不会自动再隐式生成默认构造了；</span></span><br><span class="line"><span class="comment">=default函数：让编译器提供默认构造，不用程序员手写；</span></span><br><span class="line"><span class="comment">C++有4类特殊的成员函数，分别是默认构造、拷贝构造、析构、赋值运算符重载函数，default只能修饰这4类函数；</span></span><br><span class="line"><span class="comment">可以类内声明、类外实现；</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">=delete函数：只需在函数声明后加上=delete，就可将该函数禁用；</span></span><br><span class="line"><span class="comment">delete可以修饰普通函数和有参构造，不限于默认的4类；</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">X</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">/*X() //为了可以创建对象，手写默认构造，但是手写的没有编译器提供的效率高，</span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">&#125;*/</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">X</span>() = <span class="keyword">default</span>;<span class="comment">//让编译器提供默认构造，不是手写；</span></span><br><span class="line"><span class="comment">//X(int a) = default; //不可用default修饰</span></span><br><span class="line"><span class="comment">//int func() = default; //不可用default修饰</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">X</span>(<span class="type">int</span> i)</span><br><span class="line">&#123;</span><br><span class="line">a = i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> a;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">X1</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line"><span class="built_in">X1</span>(); <span class="comment">//类内声明</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">X1</span>(<span class="type">int</span> i)</span><br><span class="line">&#123;</span><br><span class="line">a = i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> a;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">X1::<span class="built_in">X1</span>() = <span class="keyword">default</span>;<span class="comment">//类外实现，要加作用域</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">X2</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">X2</span>()<span class="comment">//默认构造</span></span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;X2的默认构造的调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//X2(const X2 &amp;x)//拷贝构造</span></span><br><span class="line"><span class="comment">//&#123;</span></span><br><span class="line"><span class="comment">//cout &lt;&lt; &quot;X2的拷贝构造的调用&quot; &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">X2</span>(<span class="type">const</span> X2 &amp;x) = <span class="keyword">delete</span>;<span class="comment">//禁用拷贝构造，类似写进private //如果什么都不写，编译器会默认提供，如果想禁用还是要加=delete;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//X2 &amp;operator =(const X2 &amp;x) //赋值运算符重载函数，重载&quot;=&quot;</span></span><br><span class="line"><span class="comment">//&#123;</span></span><br><span class="line"><span class="comment">//cout &lt;&lt; &quot;X2的重载=运算符函数的调用&quot; &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">//return *this;</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line">X2 &amp;<span class="keyword">operator</span>= (<span class="type">const</span> X2 &amp;x) = <span class="keyword">delete</span>; <span class="comment">//禁用赋值运算符重载，类似写进private //如果什么都不写，编译器会默认提供，如果想禁用还是要加=delete;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">func</span><span class="params">()</span> </span>= <span class="keyword">delete</span>;<span class="comment">//可以修饰普通函数，让func()不可被调用；</span></span><br><span class="line"><span class="built_in">X2</span>(<span class="type">int</span> x) = <span class="keyword">delete</span>;<span class="comment">//可以修饰有参构造；</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//只在栈上创建对象、禁止在堆区创建对象，可以禁用重载new和delete的函数：</span></span><br><span class="line"><span class="function"><span class="type">void</span> *<span class="keyword">operator</span> <span class="title">new</span><span class="params">(<span class="type">size_t</span> t)</span> </span>= <span class="keyword">delete</span>; <span class="comment">//禁用new，也可以写进private；</span></span><br><span class="line"><span class="type">void</span> *<span class="keyword">operator</span> <span class="keyword">new</span>[](<span class="type">size_t</span> t) = <span class="keyword">delete</span>;<span class="comment">//禁用new一个数组</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="keyword">operator</span> <span class="title">delete</span><span class="params">(<span class="type">void</span> *ptr)</span> </span>= <span class="keyword">delete</span>; <span class="comment">//禁用delete；</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test12_03</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">X2 obj1;<span class="comment">//调用默认构造</span></span><br><span class="line"><span class="comment">//X2 obj2 = obj1;//调用拷贝构造</span></span><br><span class="line"></span><br><span class="line">X2 obj3;<span class="comment">//调用默认构造</span></span><br><span class="line"><span class="comment">//obj3 = obj1;//调用赋值运算符重载函数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//obj3.func();//无法调用</span></span><br><span class="line"><span class="comment">//X2 obj4(6);//无法调用</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//X2 *p = new X2; //无法在堆区创建对象</span></span><br><span class="line"><span class="comment">//X2 *p = new X2[10]; //无法在堆区创建数组</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="模板的改进"><a href="#模板的改进" class="headerlink" title="模板的改进"></a>模板的改进</h2><h3 id="右尖括号-gt-改进"><a href="#右尖括号-gt-改进" class="headerlink" title="右尖括号&gt;改进"></a>右尖括号&gt;改进</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">右尖括号&gt;改进：</span></span><br><span class="line"><span class="comment">C++11中，要求编译器对模板的&gt;做单独处理，能够判断出&quot;&gt;&gt;&quot;是一个右移操作符还是模板参数表的结束标记；</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="type">int</span> i&gt; </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C1</span> </span><br><span class="line">&#123; </span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt; </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C2</span> </span><br><span class="line">&#123; </span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test13_01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">C2&lt;C1&lt;<span class="number">8</span>&gt;&gt; obj1; <span class="comment">//模板实例化对象，模板嵌套模板//旧版本C++要求C2&lt;C1&lt;8&gt; &gt;中的&gt; &gt;之间必须有空格，而C++11不需要；</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="模板的别名-using"><a href="#模板的别名-using" class="headerlink" title="模板的别名 using"></a>模板的别名 using</h3><p>格式 <code>using 别名 = 原类型;</code><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">模板的别名：</span></span><br><span class="line"><span class="comment">传统方法：typedef起别名；</span></span><br><span class="line"><span class="comment">C++11：using  ..= ..</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> int32; <span class="comment">//传统方法</span></span><br><span class="line"><span class="keyword">using</span> my_int = <span class="type">int</span>; <span class="comment">//C++11</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test13_02</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//is_same 判断类型是否相同，如果相同就返回true</span></span><br><span class="line">cout &lt;&lt; is_same&lt;int32, my_int&gt;::value &lt;&lt; endl;<span class="comment">//1，说明int32和my_int类型相同</span></span><br><span class="line">cout &lt;&lt; <span class="built_in">typeid</span>(int32).<span class="built_in">name</span>() &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="built_in">typeid</span>(my_int).<span class="built_in">name</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">int32 a = <span class="number">1</span>;</span><br><span class="line">my_int b = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="函数模板的默认模板参数"><a href="#函数模板的默认模板参数" class="headerlink" title="函数模板的默认模板参数"></a>函数模板的默认模板参数</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">函数模板的默认模板参数：</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//普通函数带默认参数；</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test13_03</span><span class="params">(<span class="type">int</span> a = <span class="number">3</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//类模板默认模板参数；</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span> = <span class="type">int</span>&gt;</span><br><span class="line"><span class="keyword">class</span> C3</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">T a;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//函数模板默认模板参数；</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T </span>= <span class="type">int</span>&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test13_04</span><span class="params">(T a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//类模板的默认模板参数必须从右往左定义：</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T1</span> = <span class="type">int</span>, <span class="keyword">class</span> T2 = <span class="type">double</span>&gt; <span class="comment">//两个都给默认参数，支持</span></span><br><span class="line"><span class="keyword">class</span> C4</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">T1 t1;</span><br><span class="line">T2 t2;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T1</span>, <span class="keyword">class</span> <span class="title class_">T2</span>&gt; <span class="comment">//两个都不给默认参数，支持</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C5</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">T1 t1;</span><br><span class="line">T2 t2;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//template&lt;class T1 = int, class T2&gt; //左边给默认参数，右边不给，不支持</span></span><br><span class="line"><span class="comment">//class C6</span></span><br><span class="line"><span class="comment">//&#123;</span></span><br><span class="line"><span class="comment">//public:</span></span><br><span class="line"><span class="comment">//T1 t1;</span></span><br><span class="line"><span class="comment">//T2 t2;</span></span><br><span class="line"><span class="comment">//&#125;;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T1</span>, <span class="keyword">class</span> <span class="title class_">T2</span> = <span class="type">int</span>&gt; <span class="comment">//左边不给默认参数，右边给，支持</span></span><br><span class="line"><span class="keyword">class</span> C7</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">T1 t1;</span><br><span class="line">T2 t2;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//函数模板则没有必须从右往左的限制：</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T1</span> = <span class="type">int</span>, <span class="keyword">class</span> T2 = <span class="type">double</span>&gt; <span class="comment">//两个都给默认参数，支持</span></span><br><span class="line"><span class="type">void</span> <span class="built_in">test13_05</span>(T1 a, T2 b)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; a &lt;&lt; b &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T1</span>, <span class="keyword">class</span> <span class="title class_">T2</span>&gt;<span class="comment">//两个都不给默认参数，支持</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test13_06</span><span class="params">(T1 a, T2 b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; a &lt;&lt; b &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T1</span> = <span class="type">int</span>, <span class="keyword">class</span> T2&gt;<span class="comment">//左边不给默认参数，右边给，支持</span></span><br><span class="line"><span class="type">void</span> <span class="built_in">test13_07</span>(T1 a, T2 b)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; a &lt;&lt; b &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T1</span>, <span class="keyword">class</span> <span class="title class_">T2</span> = <span class="type">int</span>&gt;<span class="comment">//左边给默认参数，右边不给，支持</span></span><br><span class="line"><span class="type">void</span> <span class="built_in">test13_08</span>(T1 a, T2 b)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; a &lt;&lt; b &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="可变参数模板（难点）"><a href="#可变参数模板（难点）" class="headerlink" title="可变参数模板（难点）"></a>可变参数模板（难点）</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">可变参数模板：是C++11新增的最强大的特性之一，它对参数进行了高度泛化；</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> ... T&gt; <span class="comment">//在class和T中间加... //T叫作模板参数包，可传多个参数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func001</span><span class="params">(T ... a)</span><span class="comment">//a叫作函数参数包，可传多个参数</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;num= &quot;</span> &lt;&lt; <span class="keyword">sizeof</span>...(a) &lt;&lt; endl;<span class="comment">//查看a内参数的个数，sizeof...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test13_09</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">func001</span>&lt;<span class="type">int</span>&gt;(<span class="number">10</span>);<span class="comment">//只传一个参数</span></span><br><span class="line"><span class="built_in">func001</span>&lt;<span class="type">int</span>, <span class="type">double</span>, <span class="type">char</span>&gt;(<span class="number">3</span>, <span class="number">3.14</span>, <span class="string">&#x27;d&#x27;</span>); <span class="comment">//可以同时传多个不同类型参数</span></span><br><span class="line"><span class="built_in">func001</span>(<span class="number">11</span>, <span class="number">13.5</span>, <span class="number">34</span>, <span class="string">&#x27;c&#x27;</span>);<span class="comment">//自动类型推导，可以同时传多个不同类型参数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="递归展开模板参数包"><a href="#递归展开模板参数包" class="headerlink" title="递归展开模板参数包"></a>递归展开模板参数包</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//递归展开模板参数包（较常用）：</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//#if 0</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">debug</span><span class="params">()</span><span class="comment">//递归终止函数，也就是参数包里没有数据了会终止</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;empty&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//#endif</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> 0</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">debug</span><span class="params">(T t)</span><span class="comment">//递归终止函数，参数包里只有1个元素时就终止</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;last = &quot;</span> &lt;&lt; t &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T1, <span class="keyword">class</span> ... T2&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">debug</span><span class="params">(T1 t1, T2 ... t2)</span><span class="comment">//参数包展开函数</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; t1 &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line"><span class="built_in">debug</span>(t2...); <span class="comment">//t2...每调一次就减少一个元素，直到为空，才调用终止函数</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test13_10</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">debug</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>);</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">递归调用过程：</span></span><br><span class="line"><span class="comment">debug(1, 2, 3, 4);</span></span><br><span class="line"><span class="comment">debug(2, 3, 4);</span></span><br><span class="line"><span class="comment">debug(3, 4);</span></span><br><span class="line"><span class="comment">debug(4);</span></span><br><span class="line"><span class="comment">debug();</span></span><br><span class="line"><span class="comment">然后再回溯；</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">debug</span>(<span class="number">22</span>, <span class="string">&quot;Tom&quot;</span>, <span class="number">3.14</span>, <span class="string">&#x27;c&#x27;</span>); <span class="comment">//可以同时传不同类型</span></span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="非递归展开模板参数包"><a href="#非递归展开模板参数包" class="headerlink" title="非递归展开模板参数包"></a>非递归展开模板参数包</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//非递归展开模板参数包：</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(T x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; x &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> ... T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">expand</span><span class="params">(T ... t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//借助逗号运算符和初始化列表</span></span><br><span class="line"><span class="type">int</span> a[] = &#123; (<span class="built_in">print</span>(t), <span class="number">0</span>)... &#125;;<span class="comment">//...表示每调用一次就减少一个元素，直到为空，才调用终止函数，当前相当于t2=(print(t), 0)</span></span><br><span class="line"><span class="comment">//最后a[] = &#123;0, 0, 0, ... ,0&#125;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test13_11</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">expand</span>(<span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>); <span class="comment">//必须传相同类型</span></span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line"><span class="comment">//输出结果：5 6 7 8</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注：关于 <code>(print (t), 0)</code>，每个逗号运算符中的 <code>print(t)</code> 调用都会打印一个参数，然后返回0（因为这个数组 a 的成员元素类型为 int）。数组中的每个元素都使用一个 <code>0</code> 进行初始化（为1为2都可以，数组仅作存储用途）。括号用来确保逗号运算符的作用。</p><h4 id="继承方式展开模板参数包"><a href="#继承方式展开模板参数包" class="headerlink" title="继承方式展开模板参数包"></a>继承方式展开模板参数包</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//继承方式展开模板参数包：</span></span><br><span class="line"><span class="comment">//1，可变参数模板声明；</span></span><br><span class="line"><span class="comment">//2，递归继承模板类；</span></span><br><span class="line"><span class="comment">//3，递归终止条件；</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> ... T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Car</span><span class="comment">//前置声明，不然后面会报错</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Car</span>&lt;&gt;<span class="comment">//递归终止函数</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">Head</span>, <span class="keyword">class</span> ... Tail&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Car</span>&lt;Head, Tail...&gt; : <span class="keyword">public</span> Car&lt;Tail...&gt; <span class="comment">//递归继承自己</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Car</span>()</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;type= &quot;</span> &lt;&lt; <span class="built_in">typeid</span>(Head).<span class="built_in">name</span>() &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test13_12</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Car&lt;<span class="type">int</span>, <span class="type">double</span>, <span class="type">char</span>*, <span class="type">float</span>&gt; Ferrari;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="模板类递归和特化方式展开参数包"><a href="#模板类递归和特化方式展开参数包" class="headerlink" title="模板类递归和特化方式展开参数包"></a>模板类递归和特化方式展开参数包</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//模板类递归和特化方式展开参数包：</span></span><br><span class="line"><span class="comment">//1，变长模板声明；</span></span><br><span class="line"><span class="comment">//2，变长模板类定义；</span></span><br><span class="line"><span class="comment">//3，递归终止条件；</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="type">int</span> ... i&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span><span class="comment">//前置声明</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span>&lt;&gt;<span class="comment">//递归终止函数</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="type">int</span> val = <span class="number">1</span>;<span class="comment">//最后没有可变参数了，就*1</span></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="type">int</span> sum = <span class="number">0</span>;<span class="comment">//最后没有可变参数了，就+0</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="type">int</span> first, <span class="type">int</span> ... last&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span>&lt;first, last...&gt;</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="type">int</span> val = first * Test&lt;last...&gt;::val; <span class="comment">//递归求积</span></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="type">int</span> sum = first + Test&lt;last...&gt;::sum; <span class="comment">//递归求和</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test13_13</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Test&lt;<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span> ,<span class="number">6</span>&gt; t;</span><br><span class="line">cout &lt;&lt; t.val &lt;&lt; endl; <span class="comment">//720</span></span><br><span class="line">cout &lt;&lt; t.sum &lt;&lt; endl; <span class="comment">//20</span></span><br><span class="line"></span><br><span class="line">cout &lt;&lt; Test&lt;<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>&gt;::val &lt;&lt; endl; <span class="comment">//720</span></span><br><span class="line">cout &lt;&lt; Test&lt;<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>&gt;::sum &lt;&lt; endl; <span class="comment">//20</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="变参模板的应用"><a href="#变参模板的应用" class="headerlink" title="变参模板的应用"></a>变参模板的应用</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//变参模板的应用：</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//1，print函数：</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printX</span><span class="params">()</span> <span class="comment">//递归终止函数</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T, <span class="keyword">class</span>...Types&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printX</span><span class="params">(<span class="type">const</span> T &amp;firstArg, <span class="type">const</span> Types &amp;...args)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; firstArg &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line"><span class="built_in">printX</span>(args...);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test13_14</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">printX</span>(<span class="number">45</span>, <span class="number">9.8</span>, <span class="string">&quot;abc&quot;</span>, <span class="string">&#x27;m&#x27;</span>);</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//2，max函数：</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">maximun</span><span class="params">(<span class="type">int</span> n)</span> <span class="comment">//递归终止函数</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span>...T&gt;</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">maximun</span><span class="params">(<span class="type">int</span> n, T...args)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">max</span>(n, <span class="built_in">maximun</span>(args...));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test13_15</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="built_in">maximun</span>(<span class="number">57</span>, <span class="number">48</span>, <span class="number">60</span>, <span class="number">100</span>, <span class="number">20</span>, <span class="number">18</span>) &lt;&lt; endl; <span class="comment">//100</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//C++11之后已经支持了直接求多个数求最大值的操作：</span></span><br><span class="line">cout &lt;&lt; <span class="built_in">max</span>(&#123; <span class="number">57</span>, <span class="number">48</span>, <span class="number">60</span>, <span class="number">100</span>, <span class="number">20</span>, <span class="number">18</span> &#125;) &lt;&lt; endl; <span class="comment">//100</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//3，sum函数：</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">sum</span><span class="params">(T t)</span> <span class="comment">//递归终止函数</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T1, <span class="keyword">class</span> ... T2&gt;</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">sum</span><span class="params">(T1 first, T2...last)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> first + <span class="built_in">sum</span>(last...);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test13_16</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="built_in">sum</span>(<span class="number">33</span>, <span class="number">16</span>, <span class="number">28</span>, <span class="number">55</span>, <span class="number">100</span>) &lt;&lt; endl; <span class="comment">//232</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//C++14支持别名模板：</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">class</span> <span class="title class_">U</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">A13</span> </span><br><span class="line">&#123;</span><br><span class="line">T t;</span><br><span class="line">U u;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">using</span> B13 = A13&lt;T, <span class="type">int</span>&gt;;</span><br></pre></td></tr></table></figure><h2 id="右值引用及其应用"><a href="#右值引用及其应用" class="headerlink" title="右值引用及其应用"></a>右值引用及其应用</h2><h3 id="右值引用"><a href="#右值引用" class="headerlink" title="右值引用"></a>右值引用</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">C语言中，赋值表达式中，=左边的叫左值，=右边的叫右值；</span></span><br><span class="line"><span class="comment">而C++中，可以取地址、有名字的就是左值，反之就是右值；</span></span><br><span class="line"><span class="comment">例如，</span></span><br><span class="line"><span class="comment">int b = 1;</span></span><br><span class="line"><span class="comment">int c = 2;</span></span><br><span class="line"><span class="comment">int a = b + c;</span></span><br><span class="line"><span class="comment">&amp;a是可以操作的，而&amp;(b+c)不可以，所以a是左值，b+c是右值；</span></span><br><span class="line"><span class="comment">右值表示字面常量、表达式、函数的非引用返回值等；</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">左值引用和右值引用都必须马上初始化；引用就是起别名；</span></span><br><span class="line"><span class="comment">左值引用是有名字变量的别名，而右值引用是匿名变量的别名；</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> &amp;<span class="title">func01_01</span><span class="params">()</span> <span class="comment">//返回值为引用</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> tmp;<span class="comment">//静态变量不会释放</span></span><br><span class="line"><span class="keyword">return</span> tmp; <span class="comment">//返回的是左值</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01_01</span><span class="params">()</span> <span class="comment">//左值引用</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> a;</span><br><span class="line"><span class="comment">//int &amp;b; //没有马上初始化</span></span><br><span class="line"><span class="type">int</span> &amp;b = a; <span class="comment">//左值引用，起别名</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> &amp;c = a; <span class="comment">//左值引用</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//int &amp;d = 1; //error，右值</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> &amp;d = <span class="number">1</span>; <span class="comment">//常引用，可以，右值</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> &amp;e = <span class="built_in">func01_01</span>(); <span class="comment">//左值引用</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> &amp;f = <span class="built_in">func01_01</span>(); <span class="comment">//左值引用</span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> tmp = <span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> &amp;g = tmp; <span class="comment">//左值引用</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//const int &amp; 万能引用</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">func01_02</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">8</span>; <span class="comment">//返回的是右值</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01_02</span><span class="params">()</span> <span class="comment">//右值引用</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> &amp;&amp;a = <span class="number">1</span>; <span class="comment">//1这块内存本来没名字，给这块内存起个名字叫a，以后就可以用a操作这块内存；</span></span><br><span class="line"><span class="comment">//如果直接用1，使用完了就释放了，用右值引用可以继续使用这块内存；</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> &amp;&amp;b = <span class="built_in">func01_02</span>(); <span class="comment">//右值引用</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> i = <span class="number">2</span>;</span><br><span class="line"><span class="type">int</span> j = <span class="number">3</span>;</span><br><span class="line"><span class="type">int</span> &amp;&amp;c = i + j; <span class="comment">//右值引用</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> k = <span class="number">6</span>;</span><br><span class="line"><span class="comment">//int &amp;&amp;d = k; //error，不能把一个左值赋值给一个右值引用</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func01_03</span><span class="params">(<span class="type">int</span> &amp;tmp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;左值 = &quot;</span> &lt;&lt; tmp &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func01_03</span><span class="params">(<span class="type">int</span> &amp;&amp;tmp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;右值 = &quot;</span> &lt;&lt; tmp &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01_03</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="built_in">func01_03</span>(a);<span class="comment">//a是左值，调用左值那个</span></span><br><span class="line"><span class="built_in">func01_03</span>(<span class="number">11</span>); <span class="comment">//11是常量，是右值，调用右值那个</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="返回值优化技术与移动语义"><a href="#返回值优化技术与移动语义" class="headerlink" title="返回值优化技术与移动语义"></a>返回值优化技术与移动语义</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">移动语义：</span></span><br><span class="line"><span class="comment">右值引用是用来支持移动语义的，移动语义可以将资源（堆，系统对象等）从一个对象转移到另一个对象，</span></span><br><span class="line"><span class="comment">这样可以减少不必要的临时对象的创建、拷贝、析构，可以大幅提高程序的效率；临时对象的创建和析构会拖慢程序的速度；</span></span><br><span class="line"><span class="comment">移动语义和拷贝语义是相对的，类似文件的剪切与复制；</span></span><br><span class="line"><span class="comment">通过移动语义，临时对象中的资源可以转移到其他对象里；</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">移动语义的定义：</span></span><br><span class="line"><span class="comment">现有的C++可以定义拷贝构造和赋值函数，但要实现转移语义，需要定义转移构造函数，也可以定义转移赋值操作符；</span></span><br><span class="line"><span class="comment">对于右值的拷贝和赋值，会调用转移构造函数和转移赋值操作符；</span></span><br><span class="line"><span class="comment">普通函数的操作符也可以通过右值引用操作符实现转移语义；</span></span><br><span class="line"><span class="comment">即便不做优化，使用移动构造函数也可以减少临时对象的创建、拷贝、析构操作，提高程序效率；</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">移动构造和移动赋值注意点：</span></span><br><span class="line"><span class="comment">参数为非const右值，用&amp;&amp;；</span></span><br><span class="line"><span class="comment">参数不可以是常量，因为需要修改右值；</span></span><br><span class="line"><span class="comment">参数的资源链接和标记必须修改，也就是把原来的地址置空，否则会导致浅拷贝的问题；</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">对于需要动态申请大量资源的类，应该加上移动构造和移动赋值函数，提高程序效率；</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyString</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">MyString</span>(<span class="type">const</span> <span class="type">char</span> *tmp = <span class="string">&quot;abc&quot;</span>) <span class="comment">//有参构造</span></span><br><span class="line">&#123;</span><br><span class="line">len = <span class="built_in">strlen</span>(tmp); <span class="comment">//长度</span></span><br><span class="line">str = <span class="keyword">new</span> <span class="type">char</span>[len + <span class="number">1</span>]; <span class="comment">//堆区申请空间</span></span><br><span class="line"><span class="built_in">strcpy_s</span>(str, len + <span class="number">1</span>, tmp); <span class="comment">//将tmp中字符串复制到str</span></span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;有参构造的调用：str =&quot;</span> &lt;&lt; str &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">MyString</span>(<span class="type">const</span> MyString &amp;tmp) <span class="comment">//拷贝构造</span></span><br><span class="line">&#123;</span><br><span class="line">len = tmp.len;</span><br><span class="line">str = <span class="keyword">new</span> <span class="type">char</span>[len + <span class="number">1</span>]; <span class="comment">//深拷贝，防止堆区内存重复释放（浅拷贝）</span></span><br><span class="line"><span class="built_in">strcpy_s</span>(str, len + <span class="number">1</span>, tmp.str);</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;拷贝构造的调用：str =&quot;</span> &lt;&lt; tmp.str &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">MyString</span>(MyString &amp;&amp;t) <span class="comment">//移动构造 //参数是非const的右值引用 //加了移动构造就不会调用拷贝构造，可以减少临时变量的操作</span></span><br><span class="line">&#123;</span><br><span class="line">len = t.len;</span><br><span class="line">str = t.str; <span class="comment">//拷贝地址，没有重新申请内存！就是浅拷贝！</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;移动构造的调用：str =&quot;</span> &lt;&lt; t.str &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">t.str = <span class="literal">nullptr</span>;<span class="comment">//要把原来的指针置空，否则会两次释放同一块堆区的地址，产生浅拷贝的问题！</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">MyString &amp;<span class="keyword">operator</span> = (<span class="type">const</span> MyString &amp;tmp) <span class="comment">//运算符重载</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (&amp;tmp == <span class="keyword">this</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//先释放原来的内存</span></span><br><span class="line">len = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">delete</span>[]str;</span><br><span class="line"></span><br><span class="line"><span class="comment">//在堆区重新申请内存</span></span><br><span class="line">len = tmp.len;</span><br><span class="line">str = <span class="keyword">new</span> <span class="type">char</span>[len + <span class="number">1</span>];</span><br><span class="line"><span class="built_in">strcpy_s</span>(str, len + <span class="number">1</span>, tmp.str);</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;运算符重载的调用：str =&quot;</span> &lt;&lt; tmp.str &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">MyString &amp;<span class="keyword">operator</span> = (MyString &amp;&amp;t)<span class="comment">//移动赋值 //参数是非const的右值引用 //加了移动赋值就不会调用普通运算符重载函数，可提高效率</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (&amp;t == <span class="keyword">this</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//先释放原来的内存</span></span><br><span class="line">len = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">delete</span>[]str;</span><br><span class="line"></span><br><span class="line"><span class="comment">//不需要在堆区重新申请内存</span></span><br><span class="line">len = t.len;</span><br><span class="line">str = t.str;<span class="comment">//浅拷贝</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;移动赋值函数的调用：str =&quot;</span> &lt;&lt; t.str &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">t.str = <span class="literal">nullptr</span>;<span class="comment">//要把原来的指针置空，否则会产生浅拷贝的问题</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">~<span class="built_in">MyString</span>() <span class="comment">//析构函数</span></span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;析构函数的调用，&quot;</span>;</span><br><span class="line"></span><br><span class="line">len = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (str != <span class="literal">nullptr</span>) <span class="comment">//移动构造中t.str置空后，就不会跑进这个分支，也能提升效率；</span></span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;已操作delete，str = &quot;</span> &lt;&lt; str;</span><br><span class="line"><span class="keyword">delete</span>[]str;</span><br><span class="line">str = <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="type">char</span> *str = <span class="literal">nullptr</span>; <span class="comment">//初始化</span></span><br><span class="line"><span class="type">int</span> len = <span class="number">0</span>; <span class="comment">//初始化</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">MyString <span class="title">func</span><span class="params">()</span> <span class="comment">//返回普通对象，不是引用，返回的是右值</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="function">MyString <span class="title">obj</span><span class="params">(<span class="string">&quot;CODspielen&quot;</span>)</span></span>;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;&amp;obj (取地址) = &quot;</span> &lt;&lt; (<span class="type">void</span> *)&amp;obj &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> obj; <span class="comment">//内存中生成一个临时对象，放在内存中一个临时区域内，由旧对象初始化新对象，所以调用了拷贝构造；</span></span><br><span class="line"><span class="comment">//这里返回的其实是临时创建的对象，不是obj；</span></span><br><span class="line"><span class="comment">//如果使用了移动构造，这里调用移动构造函数，不调用拷贝构造；</span></span><br><span class="line"><span class="comment">//返回后，调用析构函数；</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02_01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">MyString s = <span class="built_in">func</span>(); <span class="comment">//临时对象直接给s；</span></span><br><span class="line"><span class="comment">//这里做了一次优化，如果没优化，会再调用一次拷贝构造，再调用一次析构；</span></span><br><span class="line"><span class="comment">//优化就是直接把临时对象给到s，不再经历临时变量；</span></span><br><span class="line"><span class="comment">//当main函数结束后，s释放了，再调用析构函数；</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;&amp;s (取地址) = &quot;</span> &lt;&lt; (<span class="type">void</span> *)&amp;s &lt;&lt; endl;</span><br><span class="line"><span class="comment">//在QT里，这里S的地址会等于obj的地址，也就是不使用临时变量了，所以只会调用一次有参构造、一次析构，</span></span><br><span class="line"><span class="comment">//而VS里要调用拷贝构造和另一次析构；</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//是否开启返回值优化选项：在cmd命令行里添加语句;</span></span><br><span class="line"><span class="comment">//g++ xxx.cpp -fno-elide-constructors -std = c++11</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02_02</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">MyString &amp;&amp;s1 = <span class="built_in">func</span>(); <span class="comment">//右值引用，调用移动构造函数；</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;&amp;s1 (取地址) = &quot;</span> &lt;&lt; (<span class="type">void</span> *)&amp;s1 &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02_03</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="function">MyString <span class="title">s2</span><span class="params">(<span class="string">&quot;CODplay&quot;</span>)</span></span>; <span class="comment">//实例化对象</span></span><br><span class="line">s2 = <span class="built_in">func</span>(); <span class="comment">//调用赋值运算符；</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;&amp;s2 (取地址) = &quot;</span> &lt;&lt; (<span class="type">void</span> *)&amp;s2 &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="move和完美转发forward"><a href="#move和完美转发forward" class="headerlink" title="move和完美转发forward"></a>move和完美转发forward</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//move和完美转发forward：</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02_04</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> a = <span class="number">9</span>; <span class="comment">//a为左值</span></span><br><span class="line"><span class="comment">//int &amp;&amp;b = a; //error, 不能把一个左值赋值给一个右值引用</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> &amp;&amp;b = <span class="built_in">move</span>(a); <span class="comment">//这样就可以把左值a赋值给右值b，将左值转化成右值</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;b= &quot;</span> &lt;&lt; b &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//完美转发forward适用于：需要将一组参数原封不动地传递给另一个函数，</span></span><br><span class="line"><span class="comment">//包括参数值、左右值、是否是const；</span></span><br><span class="line"><span class="comment">//完美转发过程中，所有这些属性都不变，同时不产生额外的开销；</span></span><br><span class="line"><span class="comment">//在泛型函数中，这样的需求非常普遍；</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//传统写法，需要重载：</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func02_01</span><span class="params">(<span class="type">const</span> T &amp;)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;const T &amp;&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func02_01</span><span class="params">(T &amp;)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;T &amp;&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func02_01</span><span class="params">(T &amp;&amp;)</span> <span class="comment">//这里会发生引用折叠</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;T &amp;&amp;&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">forward_val</span><span class="params">(<span class="type">const</span> T &amp;tmp)</span> <span class="comment">//const版本</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">func02_01</span>(tmp);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">forward_val</span><span class="params">(T &amp;tmp)</span> <span class="comment">//普通版本</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">func02_01</span>(tmp);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02_05</span><span class="params">()</span><span class="comment">//传统方法，需要重载const和普通两个版本</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> a = <span class="number">0</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> &amp;b = <span class="number">1</span>;</span><br><span class="line">forward_val(a);<span class="comment">//左值</span></span><br><span class="line">forward_val(b);<span class="comment">//右值</span></span><br><span class="line">forward_val(<span class="number">12</span>);<span class="comment">//右值</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//c++中，利用引用折叠，结合新的模板推导规划，可以完成完美转发；</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">const</span> <span class="type">int</span> T;</span><br><span class="line"><span class="keyword">typedef</span> T &amp; TR;</span><br><span class="line">TR &amp;v = <span class="number">1</span>;<span class="comment">//引用折叠 //等于是const int &amp;&amp;v = 1;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//C++11引用折叠规则：</span></span><br><span class="line"><span class="comment">//一旦定义中出现了左传引用，引用折叠总是先将其折叠为左值引用</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">TR的类型定义声明v的类型v的实际类型</span></span><br><span class="line"><span class="comment">T &amp;TRT &amp;</span></span><br><span class="line"><span class="comment">T &amp;TR &amp;T &amp;</span></span><br><span class="line"><span class="comment">T &amp;TR &amp;&amp;T &amp;</span></span><br><span class="line"><span class="comment">T &amp;&amp;TRT &amp;&amp;</span></span><br><span class="line"><span class="comment">T &amp;&amp;TR &amp;T &amp;</span></span><br><span class="line"><span class="comment">T &amp;&amp;TR &amp;&amp;T &amp;&amp;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//forward写法：</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">forward_val1</span><span class="params">(T &amp;&amp;tmp)</span> <span class="comment">//右值引用 //只需要写一个，不需要重载</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">func02_01</span>(forward&lt;T&gt;(tmp));<span class="comment">//保持原参数tmp的左右值属性</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02_06</span><span class="params">()</span><span class="comment">//传统方法，需要重载const和普通两个版本</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> a = <span class="number">0</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> &amp;b = <span class="number">1</span>;</span><br><span class="line">forward_val1(a);<span class="comment">//左值</span></span><br><span class="line">forward_val1(b);<span class="comment">//右值</span></span><br><span class="line">forward_val1(<span class="number">12</span>);<span class="comment">//右值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="🚩智能指针"><a href="#🚩智能指针" class="headerlink" title="🚩智能指针"></a>🚩智能指针</h2><p>C++11中有<code>unique_ptr</code>, <code>shared_ptr</code>, <code>weak_ptr</code>等智能指针，定义在<code>&lt;memory&gt;</code>中；<br>可以对动态资源进行管理，在任何情况下，已构造的对象会销毁，即它的析构函数最终会被调用。</p><h3 id="unique-ptr"><a href="#unique-ptr" class="headerlink" title="unique_ptr"></a>unique_ptr</h3><ul><li><code>unique_ptr</code> 是一个模板，创建的是<font color="#2DC26B">对象</font>，不用加 <code>*</code>。</li><li>持有对对象的<font color="#2DC26B">独有权</font>，同一时刻只能有一个 <code>unique_ptr</code> 绑定给定的对象（通过禁止拷贝语义，只用移动语义 <code>move</code> 来实现）。</li><li><code>unique_ptr</code> 生命周期：<font color="#2DC26B">从指针创建开始，直到离开作用域就释放</font>。</li><li>离开作用域时，若其指向对象，则这个对象被销毁，默认使用 <code>delete</code> 操作，用户也可以指定其他操作。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">test03_01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="function">unique_ptr&lt;<span class="type">int</span>&gt; <span class="title">up1</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>(<span class="number">11</span>))</span></span>;<span class="comment">//创建智能指针对象up1，指向new出来的堆区空间；</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;*up1= &quot;</span> &lt;&lt; *up1 &lt;&lt; endl; <span class="comment">//11 //重载了operator*()；</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//unique_ptr&lt;int&gt; up2 = up1; //原来要用拷贝构造，但是使用了智能指针后，up1就是唯一的能指向堆区这块空间的指针，自动禁用了拷贝构造，不能拷贝一个up2也指向这块空间；</span></span><br><span class="line">unique_ptr&lt;<span class="type">int</span>&gt; up2 = <span class="built_in">move</span>(up1); <span class="comment">//但是可以使用移动构造，相当于把这块内存给了up2指针，而up1就不能再使用了，还是有唯一性的；</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;*up2= &quot;</span> &lt;&lt; *up2 &lt;&lt; endl;</span><br><span class="line"><span class="comment">//cout &lt;&lt; &quot;*up1= &quot; &lt;&lt; *up1 &lt;&lt; endl;//转移给up2后，up1就变成野指针了，不能再使用</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Test03_01</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">~<span class="built_in">Test03_01</span>()</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;析构函数的调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test03_02</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="function">unique_ptr&lt;Test03_01&gt; <span class="title">up3</span><span class="params">(<span class="keyword">new</span> Test03_01)</span></span>; <span class="comment">//无需手动释放</span></span><br><span class="line">up3 = <span class="literal">nullptr</span>; <span class="comment">//也可以手动释放，直接指向空；</span></span><br><span class="line">up3.<span class="built_in">reset</span>();<span class="comment">//手动释放，用reset()实现；//可以连续手动释放多次，只会析构一次，不会出现多次释放同一个空间</span></span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line"><span class="comment">//如果是自动释放，在这里要离开这个作用域了，此时才会调用析构函数；</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test03_03</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="function">unique_ptr&lt;<span class="type">int</span>&gt; <span class="title">up1</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>(<span class="number">11</span>))</span></span>;</span><br><span class="line">up1.<span class="built_in">reset</span>();<span class="comment">//如果是无参，作用是显式释放堆区内存</span></span><br><span class="line">up1.<span class="built_in">reset</span>(<span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">22</span>)); <span class="comment">//如果有参，就是先释放原来的内存，再重新给up1绑定一块新的堆区内存；</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;*up1= &quot;</span> &lt;&lt; *up1 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> *p = up1.<span class="built_in">release</span>();<span class="comment">//释放控制权，但不释放堆区内存，就是把这块内存给到*p，up1就不再有控制权了，就变成野指针了；</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;*p= &quot;</span> &lt;&lt; *p &lt;&lt; endl;</span><br><span class="line"><span class="keyword">delete</span> p;<span class="comment">//*p不是智能指针，需要手动释放了；</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="shared-ptr"><a href="#shared-ptr" class="headerlink" title="shared_ptr"></a>shared_ptr</h3><blockquote><p>和 <code>unique_ptr</code> 相反，<code>shared_ptr</code> 允许多个智能指针的对象<font color="#2DC26B">共享同一块堆区</font>分配的内存，通过引用计数实现。<br>如果最后一个这样的指针被销毁，也就是计数变成 0，这个对象才会被自动删除。</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">test03_04</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="function">shared_ptr&lt;<span class="type">int</span>&gt; <span class="title">sp1</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>(<span class="number">8</span>))</span></span>;</span><br><span class="line">shared_ptr&lt;<span class="type">int</span>&gt; sp2 = sp1; <span class="comment">//可以调用拷贝构造，sp2和sp1都绑定堆区空间；</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;计数器1 = &quot;</span> &lt;&lt; sp1.<span class="built_in">use_count</span>() &lt;&lt; <span class="string">&quot;  计数器2 = &quot;</span> &lt;&lt; sp2.<span class="built_in">use_count</span>() &lt;&lt; endl; <span class="comment">//2  2</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;*sp1 = &quot;</span> &lt;&lt; *sp1 &lt;&lt; <span class="string">&quot;  *sp2 = &quot;</span> &lt;&lt; *sp2 &lt;&lt; endl; <span class="comment">//8  8</span></span><br><span class="line"></span><br><span class="line">sp1.<span class="built_in">reset</span>();<span class="comment">//sp1被释放，只是释放sp1和堆区空间的绑定，计数器减1，只要没有到0，堆区空间就不会被释放；</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;计数器1 = &quot;</span> &lt;&lt; sp1.<span class="built_in">use_count</span>() &lt;&lt; <span class="string">&quot;  计数器2 = &quot;</span> &lt;&lt; sp2.<span class="built_in">use_count</span>() &lt;&lt; endl; <span class="comment">//0  1</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;*sp2 = &quot;</span> &lt;&lt; *sp2 &lt;&lt; endl; <span class="comment">//8</span></span><br><span class="line"></span><br><span class="line">sp2.<span class="built_in">reset</span>();<span class="comment">//sp1被释放，计数器减到0，堆区空间也被释放</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;计数器1 = &quot;</span> &lt;&lt; sp1.<span class="built_in">use_count</span>() &lt;&lt; <span class="string">&quot;  计数器2 = &quot;</span> &lt;&lt; sp2.<span class="built_in">use_count</span>() &lt;&lt; endl; <span class="comment">//0  0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="weak-ptr"><a href="#weak-ptr" class="headerlink" title="weak_ptr"></a>weak_ptr</h3><ul><li>配合 <code>shared_ptr</code> 使用，可以从一个 <code>shared_ptr</code> 或者另一个 <code>weak_ptr</code> 对象构造，它的构造和析构<font color="#2DC26B">不会引起引用计数的变化</font>。</li><li>没有重载 <code>*</code> 和 <code>-&gt;</code>，但可以使用 <code>lock</code> 获得一个可用的 <code>shared_ptr</code> 对象。</li><li><code>weak_ptr</code> 可以指向 <code>shared_ptr</code> 指针指向的内存空间，但是<font color="#2DC26B">并不拥有该内存</font>。</li><li>如果使用 <code>weak_ptr</code> 的成员函数 <code>lock</code>，则可以返回其指向内存的一个 <code>shared_ptr</code> 对象，且在所指向内存已经无效时，返回空值 <code>nullptr</code>。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">test03_05</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="function">shared_ptr&lt;<span class="type">int</span>&gt; <span class="title">sp1</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>(<span class="number">6</span>))</span></span>;</span><br><span class="line">shared_ptr&lt;<span class="type">int</span>&gt; sp2 = sp1; <span class="comment">//2个指针变量绑定同一块内存</span></span><br><span class="line">weak_ptr&lt;<span class="type">int</span>&gt; wp = sp1; <span class="comment">//3个指针变量绑定同一块内存</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;计数器1 = &quot;</span> &lt;&lt; sp1.<span class="built_in">use_count</span>() </span><br><span class="line">&lt;&lt; <span class="string">&quot;  计数器2 = &quot;</span> &lt;&lt; sp2.<span class="built_in">use_count</span>() </span><br><span class="line">&lt;&lt; <span class="string">&quot;  计数器3 = &quot;</span> &lt;&lt; wp.<span class="built_in">use_count</span>() &lt;&lt; endl; <span class="comment">//2  2  2 //wp不绑定堆区内存，所以只有2个计数器</span></span><br><span class="line"></span><br><span class="line">shared_ptr&lt;<span class="type">int</span>&gt; sp3 = wp.<span class="built_in">lock</span>(); <span class="comment">//使用lock获得一个可用的shared_ptr对象</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;计数器1 = &quot;</span> &lt;&lt; sp1.<span class="built_in">use_count</span>()</span><br><span class="line">&lt;&lt; <span class="string">&quot;  计数器2 = &quot;</span> &lt;&lt; sp2.<span class="built_in">use_count</span>()</span><br><span class="line">&lt;&lt; <span class="string">&quot;  计数器3 = &quot;</span> &lt;&lt; wp.<span class="built_in">use_count</span>() </span><br><span class="line">&lt;&lt; <span class="string">&quot;  计数器4 = &quot;</span> &lt;&lt; sp3.<span class="built_in">use_count</span>() &lt;&lt; endl; <span class="comment">//3  3  3  3</span></span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;*sp1 = &quot;</span> &lt;&lt; *sp1 &lt;&lt; <span class="string">&quot;  *sp2 = &quot;</span> &lt;&lt; *sp2 &lt;&lt; <span class="string">&quot;  *sp3 = &quot;</span> &lt;&lt; *sp3  &lt;&lt; endl; <span class="comment">//6  6  6</span></span><br><span class="line"><span class="comment">//cout &lt;&lt; &quot;*wp = &quot; &lt;&lt; *wp &lt;&lt; endl; //wp没有和堆区内存绑定，不能用wp操作内存；</span></span><br><span class="line"></span><br><span class="line">sp1.<span class="built_in">reset</span>();</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;计数器1 = &quot;</span> &lt;&lt; sp1.<span class="built_in">use_count</span>()</span><br><span class="line">&lt;&lt; <span class="string">&quot;  计数器2 = &quot;</span> &lt;&lt; sp2.<span class="built_in">use_count</span>()</span><br><span class="line">&lt;&lt; <span class="string">&quot;  计数器3 = &quot;</span> &lt;&lt; wp.<span class="built_in">use_count</span>()</span><br><span class="line">&lt;&lt; <span class="string">&quot;  计数器4 = &quot;</span> &lt;&lt; sp3.<span class="built_in">use_count</span>() &lt;&lt; endl; <span class="comment">//0  2  2  2</span></span><br><span class="line"></span><br><span class="line">sp2.<span class="built_in">reset</span>();</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;计数器1 = &quot;</span> &lt;&lt; sp1.<span class="built_in">use_count</span>()</span><br><span class="line">&lt;&lt; <span class="string">&quot;  计数器2 = &quot;</span> &lt;&lt; sp2.<span class="built_in">use_count</span>()</span><br><span class="line">&lt;&lt; <span class="string">&quot;  计数器3 = &quot;</span> &lt;&lt; wp.<span class="built_in">use_count</span>()</span><br><span class="line">&lt;&lt; <span class="string">&quot;  计数器4 = &quot;</span> &lt;&lt; sp3.<span class="built_in">use_count</span>() &lt;&lt; endl; <span class="comment">//0  0  1  1</span></span><br><span class="line"></span><br><span class="line">sp3.<span class="built_in">reset</span>();</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;计数器1 = &quot;</span> &lt;&lt; sp1.<span class="built_in">use_count</span>()</span><br><span class="line">&lt;&lt; <span class="string">&quot;  计数器2 = &quot;</span> &lt;&lt; sp2.<span class="built_in">use_count</span>()</span><br><span class="line">&lt;&lt; <span class="string">&quot;  计数器3 = &quot;</span> &lt;&lt; wp.<span class="built_in">use_count</span>()</span><br><span class="line">&lt;&lt; <span class="string">&quot;  计数器4 = &quot;</span> &lt;&lt; sp3.<span class="built_in">use_count</span>() &lt;&lt; endl; <span class="comment">//0  0  0  0</span></span><br><span class="line"></span><br><span class="line">wp.<span class="built_in">reset</span>();<span class="comment">//上述操作已经可以使得堆区空间被释放，这里可加也可不加；</span></span><br><span class="line"></span><br><span class="line">shared_ptr&lt;<span class="type">int</span>&gt; tmp = wp.<span class="built_in">lock</span>(); <span class="comment">//如果堆区空间已经释放，则用wp.lock()创建的对象返回nullptr；</span></span><br><span class="line"><span class="keyword">if</span> (tmp == <span class="literal">nullptr</span>)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;堆区空间已经释放&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h2><blockquote><p>闭包定义：带有<font color="#00b0f0">上下文</font>的函数，有<font color="#00b0f0">状态</font>的函数，也是一个<font color="#00b0f0">类</font>。</p></blockquote><ul><li>带有状态，即<font color="#2DC26B">拥有自己的变量</font>，而不是全局变量，也不是传进来的变量。</li><li>函数和状态捆绑，就形成了闭包。</li><li>闭包的状态捆绑，必须发生在<font color="#00b050">运行时</font>。</li><li>闭包的实现：<font color="#00b050">仿函数、bind 绑定器、Lambda 表达式</font>。<h3 id="仿函数"><a href="#仿函数" class="headerlink" title="仿函数"></a>仿函数</h3>仿函数 <code>functor</code> （不是 C++11 的新内容）就是使一个类的使用看上去像一个函数，其实现就是在类中实现一个 <code>operator()</code>，这个类就有了类似的函数行为，就是一个仿函数类了。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyFunc</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">MyFunc</span>(<span class="type">int</span> i) :<span class="built_in">r</span>(i) <span class="comment">//构造</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> tmp)</span> <span class="comment">//仿函数，重载operator()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> tmp + r;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> <span class="comment">//仿函数，重载operator()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> (a &gt; b &amp;&amp; b &gt; r);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="type">int</span> r; <span class="comment">//class自己带的变量，也就是有状态</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test04_01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="function">MyFunc <span class="title">obj</span><span class="params">(<span class="number">8</span>)</span></span>;<span class="comment">//创建变量，并且给r赋值</span></span><br><span class="line">cout &lt;&lt; <span class="built_in">obj</span>(<span class="number">5</span>) &lt;&lt; endl; <span class="comment">//return 5 + 8</span></span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="built_in">obj</span>(<span class="number">23</span>, <span class="number">44</span>) &lt;&lt; endl; <span class="comment">//false</span></span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="built_in">obj</span>(<span class="number">77</span>, <span class="number">44</span>) &lt;&lt; endl; <span class="comment">//true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="function-与-bind-的使用"><a href="#function-与-bind-的使用" class="headerlink" title="function 与 bind 的使用"></a>function 与 bind 的使用</h3><h4 id="function"><a href="#function" class="headerlink" title="function"></a>function</h4></li><li>C++中，可调用的实体主要包括：函数、函数指针、函数引用、可隐式转换为函数指定的对象，或者实现了 <code>operator()</code> 的对象。</li><li>C++11 中，新增了 <code>std::function</code> 类模板（头文件 <code>&lt;functional&gt;</code>），是对 C++中所有可调用实体的一种案例类型的打包。</li><li>通过指定参数模板，可以统一处理函数、函数对象、函数指针，并允许保存和延迟执行它们。</li><li><code>function</code> 对象最大的作用：实现函数回调，但是不能用来检查相等/不相等，不过可以与 <code>NULL</code> / <code>nullptr</code> 比较。</li><li>格式 <code>function&lt;void(int)&gt;</code> 表示返回类型为 void，接受一个 int 参数的可调用对象。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//普通函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func04_01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt;  __func__ &lt;&lt; <span class="string">&quot;的调用&quot;</span> &lt;&lt; endl; <span class="comment">//__func__就是输出函数名</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//类中静态函数</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Test41</span> </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">test_func</span><span class="params">(<span class="type">int</span> a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; __func__ &lt;&lt; <span class="string">&quot;的调用，&quot;</span> &lt;&lt; a &lt;&lt;  endl;;</span><br><span class="line"><span class="keyword">return</span> a * <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//仿函数</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Test42</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; __func__ &lt;&lt; <span class="string">&quot;的调用，&quot;</span> &lt;&lt; a &lt;&lt; endl;;</span><br><span class="line"><span class="keyword">return</span> a * <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test04_02</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">function&lt;<span class="type">void</span>(/*没参数就不用写，或者写<span class="type">void</span>; */)&gt; f1 = func04_01; <span class="comment">//创建function对象，和可调用的实体绑定，这里绑定普通函数</span></span><br><span class="line"><span class="built_in">f1</span>(); <span class="comment">//等价于直接调用func04_01();</span></span><br><span class="line"></span><br><span class="line">function &lt;<span class="type">int</span>(<span class="type">int</span>)&gt; f2 = Test41::test_func; <span class="comment">//绑定类内静态函数；//静态函数才可以直接这样写；</span></span><br><span class="line">cout &lt;&lt; <span class="built_in">f2</span>(<span class="number">19</span>) &lt;&lt; endl;; <span class="comment">//等价于直接调用Test41::test_func();</span></span><br><span class="line"></span><br><span class="line">Test42 obj;</span><br><span class="line">function&lt;<span class="type">int</span>(<span class="type">int</span>)&gt; f3 = obj; <span class="comment">//绑定仿函数，也就是绑定对象，因为仿函数本身调用是obj()，相当于函数名；</span></span><br><span class="line">cout &lt;&lt; <span class="built_in">f3</span>(<span class="number">7</span>) &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>🤔注：可调用实体</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">myFunction</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 函数体</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">myFunction</span>(<span class="number">10</span>); <span class="comment">// 直接调用函数</span></span><br></pre></td></tr></table></figure><ol><li><strong>函数指针</strong>：<br>函数指针是指向函数的指针，可以通过函数指针来调用函数。函数指针的类型必须与目标函数的类型相匹配。</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">void</span> (*funcPtr)(<span class="type">int</span>) = myFunction;<span class="comment">// void为返回类型，int为接收参数类型</span></span><br><span class="line"><span class="built_in">funcPtr</span>(<span class="number">10</span>); <span class="comment">// 通过函数指针调用函数</span></span><br></pre></td></tr></table></figure><ol><li><strong>函数引用</strong>：<br>函数引用是函数的别名，可以通过函数引用来调用函数。函数引用<font color="#00b050">在声明时必须初始化</font>，并且<font color="#00b050">不能更改引用目标</font>。</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">void</span> (&amp;funcRef)(<span class="type">int</span>) = myFunction;</span><br><span class="line"><span class="built_in">funcRef</span>(<span class="number">10</span>); <span class="comment">// 通过函数引用调用函数</span></span><br></pre></td></tr></table></figure><ol><li><strong>可隐式转换为函数指针的对象：</strong><br>某些对象可以隐式转换为函数指针，例如通过 <code>std::function</code> 或 <code>std::mem_fn</code> 包装的函数对象。</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">std::function&lt;<span class="type">void</span>(<span class="type">int</span>)&gt; funcObj = myFunction;</span><br><span class="line"><span class="built_in">funcObj</span>(<span class="number">10</span>); <span class="comment">// 通过std::function对象调用函数</span></span><br></pre></td></tr></table></figure><ol><li><strong>实现了 <code>operator()</code> 的对象</strong>：<br>这些对象被称为函数对象或仿函数（Functor）。它们通过重载 <code>operator()</code> 来实现类似函数调用的行为。</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">MyFunctor</span> &#123;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 函数对象的实现</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">MyFunctor functor;</span><br><span class="line"><span class="built_in">functor</span>(<span class="number">10</span>); <span class="comment">// 通过函数对象调用</span></span><br></pre></td></tr></table></figure><h4 id="bind"><a href="#bind" class="headerlink" title="bind"></a>bind</h4><ul><li>预先把可调用实体的某些参数绑定到已有的变量，产生一个新的可调用实体，在回调函数中常用。</li><li>C++11 中，<code>bind</code> 的参数个数不受限，绑定具体哪些参数也不受限，由用户指定，非常灵活。绑定的参数可以是占位符（比如 <code>placeholder::_2</code>）</li><li>同样在头文件 <code>&lt;functional&gt;</code> 中，基本语法为 <code>std::bind(callable, arg1, arg2, ..., argN)</code>，其中 <code>callable</code> 表示可调用对象，函数返回类型为 <code>function&lt;RetType&gt;(ArgsType)</code></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">func04_02</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; x &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; y &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test04_03</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">bind</span>(func04_02, <span class="number">11</span>, <span class="number">22</span>)(<span class="comment">/*这里面可以额外传参，也可以不加*/</span>); <span class="comment">//11 22 //把func04_02和11，22绑定，等价于直接调用func04_02(11, 22)；</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">bind</span>(func04_02, placeholders::_1, placeholders::_2)(<span class="number">5</span>, <span class="number">6</span>); <span class="comment">//5 6 //placeholders::_1，占位符，调用函数时，被后面括号中的第1个参数替换</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//placeholders::写起来比较麻烦，使用命名空间，using namespace placeholders; //写在头文件处</span></span><br><span class="line"><span class="built_in">bind</span>(func04_02, _1, _2)(<span class="number">17</span>, <span class="number">18</span>); <span class="comment">//17 18 //这样就可以直接写_1, _2 </span></span><br><span class="line"><span class="built_in">bind</span>(func04_02, <span class="number">33</span>, _3)(<span class="number">77</span>, <span class="number">88</span>, <span class="number">44</span>, <span class="number">55</span>); <span class="comment">//33 44 //_3是占位符，先占位，会被后面括号中的第3个参数替换 </span></span><br><span class="line"><span class="built_in">bind</span>(func04_02, _2, _1)(<span class="number">99</span>, <span class="number">77</span>); <span class="comment">//77 99</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//bind与function结合使用：</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Test43</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span><span class="comment">//非静态成员函数</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;x = &quot;</span> &lt;&lt; x &lt;&lt; <span class="string">&quot;，y = &quot;</span> &lt;&lt; y &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> a; <span class="comment">//成员变量</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> placeholder;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test04_04</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//绑定非静态成员函数：</span></span><br><span class="line">Test43 obj; <span class="comment">//需要先创建对象，而静态成员函数不需要创建对象；</span></span><br><span class="line">function&lt;<span class="type">void</span>(<span class="type">int</span>, <span class="type">int</span>)&gt; f1 = <span class="built_in">bind</span>(&amp;Test43::func, &amp;obj, _1, _2); <span class="comment">//bind绑定成员函数后，传给function绑定</span></span><br><span class="line"><span class="built_in">f1</span>(<span class="number">98</span>, <span class="number">87</span>);<span class="comment">// x = 98, y = 87// 相当于调用obj.func(98, 87);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//绑定成员变量：</span></span><br><span class="line">function&lt;<span class="type">int</span>&amp; ()&gt; f2 = <span class="built_in">bind</span>(&amp;Test43::a, &amp;obj); <span class="comment">//bind绑定变量后，传给function绑定</span></span><br><span class="line"><span class="built_in">f2</span>() = <span class="number">111</span>; <span class="comment">//等价于obj.a = 111;</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;obj.a = &quot;</span> &lt;&lt; obj.a &lt;&lt; endl; <span class="comment">// obj.a = 111</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="🚩Lambda-表达式"><a href="#🚩Lambda-表达式" class="headerlink" title="🚩Lambda 表达式"></a>🚩Lambda 表达式</h3><p>lambda表达式是一个匿名函数，基于数学中的λ演算得名。<br>C++11中的lambda表达式用于<font color="#00b050">定义并创建匿名的函数对象</font>，以简化编程工作；通常配合回调函数使用。</p><p>💭<strong>Lambda 表达式的结构</strong>：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[]()<span class="keyword">mutable</span> exeption -&gt;<span class="type">int</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br><code>[]</code>：捕获列表，标识一个 Lambda 表达式的开始，不能省略。可认为是函数名。<font color="#00b050">捕获外面的参数属性</font>（而非参数本身），相当于类的成员变量。<br><code>()</code>：没有参数时可以省略，有参数时写在 () 里，和普通函数的参数写法一致。<br><code>mutable</code>：用于修饰类的成员变量，允许在 <code>const</code> 成员函数中修改被 <code>mutable</code> 修饰的成员变量。</p><hr><p>💭 <code>[]</code> 内通常有：</p><ol><li>空，无任何对象参数</li><li><code>=</code>，表示全部值传递</li><li><code>&amp;</code>，表示全部引用传递</li><li><code>this</code>，类内成员变量，和全局变量</li><li><code>a</code>，将 a 按值传递进行传递，默认为 const，如果要修改可以加上 <code>mutable</code> 在 <code>()</code> 后</li><li><code>&amp;a</code>，将 a 按引用传递进行传递</li><li><code>a, &amp;b</code>，a 值传递，b 引用传递</li><li><code>=, &amp;a, &amp;b</code>，除了 a 和 b 引用传递外，其余值传递（<code>=</code> 要放在前面）</li><li><code>&amp;, a, b</code>，除了 a 和 b 值传递外，其余引用传递（<code>&amp;</code> 要放在前面）</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> tmp0 = <span class="number">9</span>; <span class="comment">//全局变量</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Test44</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="type">int</span> i = <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">auto</span> f1 = [=]()</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; i &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; tmp0 &lt;&lt; endl;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">f1</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> f2 = [&amp;]()</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; i &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; tmp0 &lt;&lt; endl;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">f2</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> f3 = [<span class="keyword">this</span>]() <span class="comment">//this可以捕获类内成员变量，和全局变量</span></span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; i &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; tmp0 &lt;&lt; endl; <span class="comment">//虽然是this，全局变量也可以捕获</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">f3</span>();</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test04_05</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//外部变量</span></span><br><span class="line"><span class="type">int</span> a = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> b = <span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> c = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> f1 = []() <span class="comment">//可以用指针接收；</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;;<span class="comment">//需要加;</span></span><br><span class="line"><span class="built_in">f1</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> f2 = [a, b]() <span class="comment">//a,b用值传递</span></span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; a &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; b &lt;&lt; endl;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">f2</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> f3 = [a, b](<span class="type">int</span> x, <span class="type">int</span> y)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; a &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; b &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; x &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; y &lt;&lt; endl;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">f3</span>(<span class="number">14</span>, <span class="number">16</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> f4 = [=]() <span class="comment">//外面变量全部以值传递，传给Lambda表达式；</span></span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; a &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; b &lt;&lt; endl;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">f4</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> f5 = [&amp;]() <span class="comment">//外面变量全部以引用传递，传给Lambda表达式；</span></span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; a &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; b &lt;&lt; endl;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">f5</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> f6 = [&amp;, a]() <span class="comment">//&amp;要放前面，a用值传递，其他用引用传递；</span></span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; a &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; b &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; c &lt;&lt; endl;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">f6</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> f7 = [=, &amp;b]() <span class="comment">//=要放前面，b用引用传递，其他用值传递；</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//a++; //默认是const，是右值，不可修改；</span></span><br><span class="line">cout &lt;&lt; a &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; b &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; c &lt;&lt; endl;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">f7</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> f8 = [=]() <span class="keyword">mutable</span> <span class="comment">//默认是const修饰函数体，想改需要加mutable；</span></span><br><span class="line">&#123;</span><br><span class="line">a++;</span><br><span class="line">cout &lt;&lt; a &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; b &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; c &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; tmp0 &lt;&lt; endl; <span class="comment">//全局变量</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//[]捕获的变量是同一个作用域下的变量，和全局变量；</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">f8</span>();</span><br><span class="line"></span><br><span class="line">Test44 t;</span><br><span class="line">t.<span class="built_in">func</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>🚀值传递和引用传递的区别</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">test04_06</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">auto</span> a = <span class="number">88</span>;</span><br><span class="line"><span class="keyword">auto</span> f1 = [=]() <span class="keyword">mutable</span> <span class="comment">//传进来的a给了新建的一个变量，mutable改的只是这个新建的变量，而a本身不会被改，操作的不是同一个地址的内存；</span></span><br><span class="line">&#123;</span><br><span class="line">a += <span class="number">10</span>;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;a = &quot;</span> &lt;&lt; a &lt;&lt; endl; <span class="comment">//98, 这里是捕获的副本a_ = 98;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">f1</span>();</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;a2 = &quot;</span> &lt;&lt; a &lt;&lt; endl; <span class="comment">//88, 还是没有改变；相当于普通函数值传递不会改变实参，只改变形参；</span></span><br><span class="line"></span><br><span class="line">a = <span class="number">222</span>;</span><br><span class="line"><span class="built_in">f1</span>();<span class="comment">//108, 和222没关系，f1()内的临时变量被操作；修改的是捕获的副本a_，而不是原始变量; 由于并没有再次使用Lambda捕获，所以还是使用之前的副本a_来做更改</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> b = <span class="number">66</span>;</span><br><span class="line"><span class="keyword">auto</span> f2 = [&amp;]() <span class="comment">//引用传递不会新建变量，而是取地址，操作的是同一块内存；</span></span><br><span class="line">&#123;</span><br><span class="line">b += <span class="number">10</span>;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;b = &quot;</span> &lt;&lt; b &lt;&lt; endl;<span class="comment">//76</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">f2</span>();</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;b2 = &quot;</span> &lt;&lt; b &lt;&lt; endl;<span class="comment">//76，外面的也被改了；相当于普通函数引用传递，可以改变实参；</span></span><br><span class="line"></span><br><span class="line">b = <span class="number">333</span>;</span><br><span class="line"><span class="built_in">f2</span>(); <span class="comment">//343, 和333有关系了；</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>Lambda 表达式比仿函数更简洁。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">test04_07</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> tmp = <span class="number">10</span>;</span><br><span class="line"><span class="function">MyFunc <span class="title">obj</span><span class="params">(tmp)</span></span>;<span class="comment">//调用仿函数构造函数</span></span><br><span class="line">cout &lt;&lt; <span class="built_in">obj</span>(<span class="number">7</span>) &lt;&lt; endl;<span class="comment">//调用仿函数</span></span><br><span class="line">cout &lt;&lt; <span class="built_in">obj</span>(<span class="number">18</span>, <span class="number">14</span>) &lt;&lt; endl;<span class="comment">//调用仿函数</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> f = [tmp](<span class="type">int</span> r) <span class="comment">//用lambda表达式，不需要写class和operator()重载了</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> tmp + r;</span><br><span class="line">&#125;;</span><br><span class="line">cout &lt;&lt; <span class="built_in">f</span>(<span class="number">8</span>) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> r = <span class="number">8</span>;</span><br><span class="line"><span class="keyword">auto</span> f1 = [r](<span class="type">int</span> a, <span class="type">int</span> b)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">return</span> (a &gt; b &amp;&amp; b &gt; r);</span><br><span class="line">&#125;;</span><br><span class="line">cout &lt;&lt; <span class="built_in">f1</span>(<span class="number">19</span>, <span class="number">16</span>) &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>仿函数是编译器实现 Lambda 的一种方式，通过编译器将 Lambda 表达式转化为一个仿函数的对象。<br>Lambda 表达式可以视为仿函数的一种<font color="#00b050">等价形式</font>。</p></blockquote><hr><p>💭Lambda 表达式的类型：</p><ul><li>在 C++11 中是闭包类型，每个 Lambda 表达式会产生一个临时对象（右值）。因此严格来说，Lambda 表达式并非函数指针。</li><li>C++11 允许 Lambda 表达式向函数指针转换，但前提是 <font color="#00b050">Lambda 表达式没有捕获任何变量</font>，且函数指针指向的函数原型必须跟 Lambda 表达式有着<font color="#00b050">相同的签名</font>（返回类型、参数列表）。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">test04_08</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// std::function可以在任何情况下包装Lambda表达式</span></span><br><span class="line">function&lt;<span class="type">void</span>(<span class="type">int</span>)&gt; f1 = [](<span class="type">int</span> a) <span class="comment">//没有返回值，直接绑定lambda表达式</span></span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">f1</span>(<span class="number">100</span>); <span class="comment">//100，f1是function对象</span></span><br><span class="line"></span><br><span class="line">function&lt;<span class="type">int</span>(<span class="type">int</span>)&gt; f2 = [](<span class="type">int</span> a) <span class="comment">//有返回值，直接绑定lambda表达式</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> a + <span class="number">5</span>;</span><br><span class="line">&#125;;</span><br><span class="line">cout &lt;&lt; <span class="built_in">f2</span>(<span class="number">110</span>) &lt;&lt; endl; <span class="comment">//115</span></span><br><span class="line"></span><br><span class="line">function&lt;<span class="type">int</span>(<span class="type">int</span>, <span class="type">int</span>)&gt; f3 = bind <span class="comment">//bind先绑定lambda表达式，再传给function去绑定f3</span></span><br><span class="line">( </span><br><span class="line">[](<span class="type">int</span> a, <span class="type">int</span> b) </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> a * <span class="number">2</span> + b;</span><br><span class="line">&#125;,</span><br><span class="line">_2, <span class="comment">//把传入的第2个值用于a</span></span><br><span class="line">_1 <span class="comment">//把传入的第1个值用于b</span></span><br><span class="line">);</span><br><span class="line">cout &lt;&lt; <span class="built_in">f3</span>(<span class="number">10</span>, <span class="number">8</span>) &lt;&lt; endl; <span class="comment">//26 //把8用于int a，把10用于int b</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> f4 = [](<span class="type">int</span> x, <span class="type">int</span> y) -&gt; <span class="type">int</span> <span class="comment">//[]内没有捕获任何外部变量时，才能转化为函数指针</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> x + y;</span><br><span class="line">&#125;; <span class="comment">// auto等价于int (*)(int,int)，而不是function&lt;int(int, int)&gt;</span></span><br><span class="line">cout &lt;&lt; <span class="built_in">f4</span>(<span class="number">3</span>, <span class="number">5</span>) &lt;&lt; endl; <span class="comment">//8</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">decltype</span>(f4) tmp = f4; <span class="comment">//用decltype推导出f4的类型，用这个类型创建对象tmp，把f4赋值给tmp；</span></span><br><span class="line">cout &lt;&lt; <span class="built_in">tmp</span>(<span class="number">6</span>, <span class="number">8</span>) &lt;&lt; endl;<span class="comment">//14</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 推荐使用using，等价于using PFUC = int (*)(int, int);</span></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">int</span><span class="params">(*PFUC)</span><span class="params">(<span class="type">int</span>, <span class="type">int</span>)</span></span>;<span class="comment">//定义函数指针，参数类型、返回值与lambda表达式相同</span></span><br><span class="line">PFUC p1 = f4; <span class="comment">//lambda表达式转化为函数指针; //等价于int (*p1)(int, int) = f4;</span></span><br><span class="line">cout &lt;&lt; <span class="built_in">p1</span>(<span class="number">10</span>, <span class="number">19</span>) &lt;&lt; endl;<span class="comment">//29</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//decltype(f4) tmp = p1;//不可把函数指针转化为lambda表达式</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>✅注：易错点区分<br>使用函数指针（隐式转换，使用 <code>auto</code> 时结果一致 ）：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">TestTransform</span><span class="params">()</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="built_in">int</span>(*f4)(<span class="type">int</span>,<span class="type">int</span>) = [](<span class="type">int</span> x, <span class="type">int</span> y) -&gt; <span class="type">int</span> <span class="comment">//[]内不能捕获外部变量，才能转化为函数指针  </span></span><br><span class="line">    &#123;  </span><br><span class="line">        <span class="keyword">return</span> x + y;  </span><br><span class="line">    &#125;;  </span><br><span class="line">    <span class="built_in">int</span>(*p1)(<span class="type">int</span>, <span class="type">int</span>) = f4;  </span><br><span class="line">    <span class="built_in">p1</span>(<span class="number">9</span>,<span class="number">9</span>);  </span><br><span class="line">    <span class="keyword">using</span> funcPtr = <span class="built_in">int</span>(*)(<span class="type">int</span>, <span class="type">int</span>);  </span><br><span class="line">    funcPtr p2 = f4;  </span><br><span class="line">    <span class="built_in">p2</span>(<span class="number">9</span>,<span class="number">9</span>);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>直接使用 <code>std::function</code> 对象存储 Lambda 表达式（较复杂）：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">TestTransform</span><span class="params">()</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    function&lt;<span class="type">int</span>(<span class="type">int</span>, <span class="type">int</span>)&gt; f4 = [](<span class="type">int</span> x, <span class="type">int</span> y) -&gt; <span class="type">int</span> <span class="comment">//[]内不能捕获外部变量，才能转化为函数指针  </span></span><br><span class="line">    &#123;  </span><br><span class="line">        <span class="keyword">return</span> x + y;  </span><br><span class="line">    &#125;;  </span><br><span class="line">    <span class="comment">//int (*p1)(int, int) = f4;    //不能直接将function对象赋值给函数指针，二者无法转换  </span></span><br><span class="line">    function&lt;<span class="type">int</span>(<span class="type">int</span>, <span class="type">int</span>)&gt; p1 = f4;  </span><br><span class="line">    <span class="built_in">p1</span>(<span class="number">9</span>,<span class="number">9</span>);  </span><br><span class="line">    <span class="keyword">using</span> FuncObj = function&lt;<span class="built_in">int</span>(<span class="type">int</span>, <span class="type">int</span>)&gt;;  </span><br><span class="line">    FuncObj p2 = f4;  </span><br><span class="line">    <span class="built_in">p2</span>(<span class="number">9</span>,<span class="number">9</span>);  </span><br><span class="line">    <span class="comment">//使用 std::function::target&lt;T&gt;() 方法获取 std::function 对象内部的可调用对象。  </span></span><br><span class="line">    <span class="comment">//如果 std::function 对象内部存储的是一个函数指针，则可以将其转换为函数指针类型。  </span></span><br><span class="line">    <span class="built_in">int</span> (*p3)(<span class="type">int</span>, <span class="type">int</span>) = *f4.<span class="built_in">target</span>&lt;<span class="built_in">int</span>(*)(<span class="type">int</span>, <span class="type">int</span>)&gt;(); <span class="comment">//target返回函数  </span></span><br><span class="line">    <span class="built_in">p3</span>(<span class="number">9</span>,<span class="number">9</span>);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>💡lambda 表达式与 <code>for_each</code>（需要头文件 <code>&lt;algorithm&gt;</code> 结合使用）：<br><code>for_each(InputIterator first, InputIterator last, Function func)</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> tmp01 = <span class="number">5</span>;<span class="comment">//全局变量</span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; nums;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; largeNums; <span class="comment">//大于tmp的数</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushLargeNums</span><span class="params">(<span class="type">int</span> &amp;n)</span> <span class="comment">//回调函数</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (n &gt; tmp01)</span><br><span class="line">&#123;</span><br><span class="line">largeNums.<span class="built_in">push_back</span>(n);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printNums</span><span class="params">(<span class="type">int</span> &amp;n)</span> <span class="comment">//回调函数</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; n &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test04_09</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">nums.<span class="built_in">push_back</span>(i + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//传统写法：</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> it = nums.<span class="built_in">begin</span>(); it != nums.<span class="built_in">end</span>(); it++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (*it &gt; tmp01)</span><br><span class="line">&#123;</span><br><span class="line">largeNums.<span class="built_in">push_back</span>(*it);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;传统方法打印1：&quot;</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; largeNums.<span class="built_in">size</span>(); i++)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; largeNums[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;传统方法打印2：&quot;</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> it = largeNums.<span class="built_in">begin</span>(); it != largeNums.<span class="built_in">end</span>(); it++)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">//用lambda表达式和for_each：</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//打印方式1：for_each + 回调函数</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;for_each + 回调函数：&quot;</span>;</span><br><span class="line">largeNums.<span class="built_in">clear</span>();</span><br><span class="line">for_each(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>(), pushLargeNums); </span><br><span class="line">for_each(largeNums.<span class="built_in">begin</span>(), largeNums.<span class="built_in">end</span>(), printNums);</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">//打印方式2：for_each + lambda表达式：</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;for_each + lambda表达式：&quot;</span>;</span><br><span class="line">largeNums.<span class="built_in">clear</span>();</span><br><span class="line">for_each</span><br><span class="line">(</span><br><span class="line">nums.<span class="built_in">begin</span>(),</span><br><span class="line">nums.<span class="built_in">end</span>(),</span><br><span class="line">[&amp;](<span class="type">int</span> &amp;n)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (n &gt; tmp01)</span><br><span class="line">&#123;</span><br><span class="line">largeNums.<span class="built_in">push_back</span>(n);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">for_each</span><br><span class="line">(</span><br><span class="line">largeNums.<span class="built_in">begin</span>(),</span><br><span class="line">largeNums.<span class="built_in">end</span>(),</span><br><span class="line">[](<span class="type">int</span> &amp;n)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; n &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">);</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>💭C++14 中的更新（泛型 Lambda）：</p><ul><li>在 C++11 中，Lambda 表达式的形式参数需要被声明为具体的类型，比如 <code>(int x)</code></li><li>C++14 中引入了泛型 Lambda，允许形式参数声明中使用类型说明符 <code>auto</code></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> f = [](<span class="keyword">auto</span> x, <span class="keyword">auto</span> y) </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> x + y; </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//泛型lambda函数遵循模板参数推导的规则：</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">unnamed_lambda</span> </span><br><span class="line">&#123;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T, <span class="keyword">class</span> U&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">operator</span><span class="params">()</span><span class="params">(T x, U y)</span> <span class="type">const</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line"><span class="keyword">return</span> x + y; </span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">auto</span> lambda = unnamed_lambda&#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Lambda捕获参数中使用赋值表达式：</span></span><br><span class="line"><span class="keyword">auto</span> lambda1 = [value = <span class="number">1</span>]()</span><br><span class="line">&#123; </span><br><span class="line"><span class="keyword">return</span> value; </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//lambda表达式参数可以用auto：</span></span><br><span class="line"><span class="keyword">auto</span> lambda2 = [](<span class="keyword">auto</span> a)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> a;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">C++基础：文件操作与C++11新特性</summary>
    
    
    
    <category term="C++语言基础" scheme="https://sumikiru.top/categories/C-%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="C++" scheme="https://sumikiru.top/tags/C/"/>
    
    <category term="文件操作" scheme="https://sumikiru.top/tags/%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/"/>
    
    <category term="C++11新特性" scheme="https://sumikiru.top/tags/C-11%E6%96%B0%E7%89%B9%E6%80%A7/"/>
    
  </entry>
  
  <entry>
    <title>7.1贪心算法篇(2)</title>
    <link href="https://sumikiru.top/posts/5846fa02.html"/>
    <id>https://sumikiru.top/posts/5846fa02.html</id>
    <published>2024-08-14T00:12:25.000Z</published>
    <updated>2025-02-06T14:42:00.324Z</updated>
    
    
    <summary type="html">贪心算法部分</summary>
    
    
    
    <category term="leetcode刷题笔记" scheme="https://sumikiru.top/categories/leetcode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="C++" scheme="https://sumikiru.top/tags/C/"/>
    
    <category term="leetcode" scheme="https://sumikiru.top/tags/leetcode/"/>
    
    <category term="贪心" scheme="https://sumikiru.top/tags/%E8%B4%AA%E5%BF%83/"/>
    
  </entry>
  
  <entry>
    <title>语言基础2.面向对象</title>
    <link href="https://sumikiru.top/posts/816de279.html"/>
    <id>https://sumikiru.top/posts/816de279.html</id>
    <published>2024-08-10T12:14:15.000Z</published>
    <updated>2025-02-06T14:42:00.321Z</updated>
    
    <content type="html"><![CDATA[<h1 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h1><h2 id="内存分区"><a href="#内存分区" class="headerlink" title="内存分区"></a>内存分区</h2><div class="table-container"><table><thead><tr><th style="text-align:center">代码区</th><th style="text-align:center">全局区</th><th style="text-align:center">栈区</th><th style="text-align:center">堆区</th></tr></thead><tbody><tr><td style="text-align:center">存放二进制代码，由操作系统管理</td><td style="text-align:center">存放全局变量、静态变量、常量</td><td style="text-align:center">由编译器自动分配和释放，存放函数参数值、局部变量</td><td style="text-align:center">由程序员分配和释放，若程序员不处理，程序结束时由操作系统回收</td></tr><tr><td style="text-align:center">1. 程序运行前就存在；<br>2. 存放 CPU 执行的机器指令；<br>3. 共享：对于需要频繁执行的程序，只需在内存中有一份即可；<br>4. 只读：防止程序意外修改指令。</td><td style="text-align:center">1. 程序运行前就存在；<br>2. 存放全局变量、静态变量、常量；<br>3. 程序结束由操作系统释放。</td><td style="text-align:center">1. 由编译器自动分配和释放，存放函数参数值、局部变量；<br>2. 注意不要返回局部变量的地址，因为栈区开闭的数据由编译器自动释放。</td><td style="text-align:center">1. 由程序员分配和释放;<br>2. 利用 new 在堆区开辟数据。</td></tr></tbody></table></div><p>🤔通过代码分析：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> b = <span class="number">20</span>;<span class="comment">//不在函数体中，全局变量，存放在全局区；</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> d = <span class="number">30</span>;<span class="comment">//const修饰的全局变量，也叫全局常量；</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> *<span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> *p = <span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">10</span>);<span class="comment">//利用new把数据开辟到堆区；//作用类似C语言的malloc()</span></span><br><span class="line"><span class="comment">//指针也是局部变量，放在栈区，指针保存的数据放在堆区；</span></span><br><span class="line"><span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> *p = <span class="built_in">func</span>();</span><br><span class="line">cout &lt;&lt; *p &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; *p &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; *p &lt;&lt; endl;</span><br><span class="line"><span class="keyword">delete</span> p;<span class="comment">//用delete释放堆区数据；//类似C语言的free()</span></span><br><span class="line"><span class="comment">//cout &lt;&lt; *p &lt;&lt; endl;已释放，再次访问就访问不到；</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> *arr = <span class="keyword">new</span> <span class="type">int</span>[<span class="number">10</span>];<span class="comment">//在堆区创建数组；</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">arr[i] = i + <span class="number">100</span>;</span><br><span class="line">cout &lt;&lt; arr[i] &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">delete</span>[] arr;<span class="comment">//释放数组要加[]；</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> a = <span class="number">10</span>;<span class="comment">//局部变量，只要是在函数体内的变量都是局部变量；</span></span><br><span class="line"></span><br><span class="line">cout &lt;&lt; (<span class="type">int</span>)&amp;a &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; (<span class="type">int</span>)&amp;b &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> c = <span class="number">15</span>;<span class="comment">//静态变量，存放在全局区；</span></span><br><span class="line">cout &lt;&lt; (<span class="type">int</span>)&amp;c &lt;&lt; endl;<span class="comment">//地址和全局变量很近，在一个区域内；</span></span><br><span class="line">cout &lt;&lt; (<span class="type">int</span>)&amp;<span class="string">&quot;hello world&quot;</span> &lt;&lt; endl;<span class="comment">//常量离全局变量也很近，也在一个区内；</span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> e = <span class="number">25</span>;<span class="comment">//局部常量，存放在栈区；</span></span><br><span class="line">cout &lt;&lt; (<span class="type">int</span>)&amp;d &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; (<span class="type">int</span>)&amp;e &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> *q = <span class="built_in">func</span>();</span><br><span class="line">cout &lt;&lt; *q &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; *q &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; *q &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">delete</span> q;</span><br><span class="line"></span><br><span class="line"><span class="built_in">test01</span>();</span><br><span class="line"><span class="built_in">test02</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="🚩引用"><a href="#🚩引用" class="headerlink" title="🚩引用"></a>🚩引用</h2><blockquote><p>引用相当于给变量起别名。<br>必须初始化，初始化以后不可更改；<br>函数引用时，可以让形参修饰实参，可简化指针；<br>引用的本质：在 C++内部实现的是一个指针常量。</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">swap01</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span><span class="comment">//值传递，实参不会被修改</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> temp = a;</span><br><span class="line">a = b;</span><br><span class="line">b = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">swap02</span><span class="params">(<span class="type">int</span> *a, <span class="type">int</span> *b)</span><span class="comment">//地址传递，实参可以修改</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> temp = *a;</span><br><span class="line">*a = *b;</span><br><span class="line">*b = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">swap03</span><span class="params">(<span class="type">int</span> &amp;a, <span class="type">int</span> &amp;b)</span><span class="comment">//引用传递，实参可以修改</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> temp = a;</span><br><span class="line">a = b;</span><br><span class="line">b = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//不要返回局部变量的引用；</span></span><br><span class="line"><span class="comment">//int&amp; test01()</span></span><br><span class="line"><span class="comment">//&#123;</span></span><br><span class="line"><span class="comment">//int a1 = 10;//局部变量，存放在栈区；</span></span><br><span class="line"><span class="comment">//return a1;//非法操作；</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> &amp;<span class="title">test02</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> a2 = <span class="number">10</span>;<span class="comment">//静态变量，存放在全局区；</span></span><br><span class="line"><span class="keyword">return</span> a2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">showValue</span><span class="params">(<span class="type">const</span> <span class="type">int</span> &amp;val)</span><span class="comment">//const修饰，常量引用，防止修改实参；</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//val = 60;//不能修改val了；</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;val= &quot;</span> &lt;&lt; val &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> &amp;b = a; <span class="comment">//系统自动转化为int *const b = &amp;a;指针常量是指针指向不可更改，所以引用不可更改；</span></span><br><span class="line">cout &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; b &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">b = <span class="number">20</span>;<span class="comment">//发现b是引用，系统自动转为*b = 20; 解引用；</span></span><br><span class="line">cout &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; b &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> m = <span class="number">4</span>;</span><br><span class="line"><span class="type">int</span> n = <span class="number">6</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">swap01</span>(m, n);<span class="comment">//值传递，实参不会被修改</span></span><br><span class="line">cout &lt;&lt; m &lt;&lt; <span class="string">&quot;   &quot;</span> &lt;&lt;n &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="built_in">swap02</span>(&amp;m, &amp;n);<span class="comment">//指针传参要加&amp;，实参可以修改</span></span><br><span class="line">cout &lt;&lt; m &lt;&lt; <span class="string">&quot;   &quot;</span> &lt;&lt; n &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="built_in">swap03</span>(m, n);<span class="comment">//引用传递和值传递一样，只是实参可以修改</span></span><br><span class="line">cout &lt;&lt; m &lt;&lt; <span class="string">&quot;   &quot;</span> &lt;&lt; n &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*int &amp;ref1 = test01();</span></span><br><span class="line"><span class="comment">cout &lt;&lt; ref1 &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">cout &lt;&lt; ref1 &lt;&lt; endl;*/</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> &amp;ref2 = <span class="built_in">test02</span>();</span><br><span class="line">cout &lt;&lt; ref2 &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; ref2 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="built_in">test02</span>() = <span class="number">1000</span>;<span class="comment">//如果函数的返回值是引用，函数调用可以作为左值；</span></span><br><span class="line">cout &lt;&lt; ref2 &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; ref2 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">//常量引用，修饰形参，防止误操作；</span></span><br><span class="line"><span class="type">int</span> d = <span class="number">30</span>;</span><br><span class="line"><span class="type">int</span> &amp;ref3 = d;</span><br><span class="line"><span class="comment">//int &amp;ref3 = 30;//引用必须引用一块合法的内存空间，常量在常量区，不能被引用；</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> &amp;ref4 = <span class="number">30</span>;<span class="comment">//加上const 后，编译器将代码自动修改为int temp = 30; int &amp;ref4 = temp; 只读，不可修改；</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> e = <span class="number">40</span>;</span><br><span class="line"><span class="built_in">showValue</span>(e);</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="函数的默认参数"><a href="#函数的默认参数" class="headerlink" title="函数的默认参数"></a>函数的默认参数</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//函数默认参数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">func</span><span class="params">( <span class="type">int</span> a, <span class="type">int</span> b = <span class="number">20</span>, <span class="type">int</span> c = <span class="number">30</span>)</span><span class="comment">//b和c是默认值；</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> a + b + c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//如果某个位置有了默认值，那从这个位置往后都要有默认值；</span></span><br><span class="line"><span class="comment">//如果函数的声明有了默认参数，那函数的实现就不能再有，声明和实现只能有一个有默认参数；</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func2</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span>)</span><span class="comment">//占位参数；</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;111&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func3</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> = <span class="number">30</span>)</span><span class="comment">//占位参数也可以有默认参数；</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;222&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> f = <span class="built_in">func</span>(<span class="number">10</span>);<span class="comment">//函数加了默认值后，调用时可以省去实参；如果传了实参，就用实参；</span></span><br><span class="line">cout &lt;&lt; f &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="built_in">func2</span>(<span class="number">10</span>, <span class="number">20</span>);</span><br><span class="line"><span class="built_in">func3</span>(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="函数重载"><a href="#函数重载" class="headerlink" title="函数重载"></a>函数重载</h2><blockquote><p>让函数名相同，提高复用性。<br>🚀条件：</p><ol><li>必须在同一个作用域下；</li><li>函数名称相同；</li><li>函数参数类型不同、或者个数不同、或者顺序不同（但是返回值类型可以不同！）</li></ol></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;func的调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span> a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;func(int a)的调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">double</span> a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;func(double a)的调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;func(int a, int b)的调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span> a, <span class="type">double</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;func(int a, double b)的调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">double</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;func(double a, int b)的调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//int func(double a, int b)//函数返回值不可作为函数重载的条件！</span></span><br><span class="line"><span class="comment">//&#123;</span></span><br><span class="line"><span class="comment">//cout &lt;&lt; &quot;func(double a, int b)的调用&quot; &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//-------------------------------------------</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func1</span><span class="params">(<span class="type">int</span> &amp;a)</span><span class="comment">//引用</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;func1(int &amp;a)的调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func1</span><span class="params">(<span class="type">const</span> <span class="type">int</span> &amp;a)</span><span class="comment">//加const可以重载；</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;func1(const int &amp;a)的调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//--------------------------------------------</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func02</span><span class="params">(<span class="type">int</span> a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;func02的调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func02</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b = <span class="number">10</span>)</span><span class="comment">//加默认参数可以重载，尽量避免；</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;func02(a,b)的调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">func</span>();</span><br><span class="line"><span class="built_in">func</span>(<span class="number">3</span>);</span><br><span class="line"><span class="built_in">func</span>(<span class="number">4</span>, <span class="number">5</span>);</span><br><span class="line"><span class="built_in">func</span>(<span class="number">3.14</span>);</span><br><span class="line"><span class="built_in">func</span>(<span class="number">5</span>, <span class="number">7.8</span>);</span><br><span class="line"><span class="built_in">func</span>(<span class="number">5.6</span>, <span class="number">8</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="built_in">func1</span>(a);<span class="comment">//变量，调用不加const的；</span></span><br><span class="line"><span class="built_in">func1</span>(<span class="number">20</span>);<span class="comment">//常量，调用加const的；</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//func2(20);//不能只调一个参数，尽量避免；</span></span><br><span class="line"><span class="built_in">func02</span>(<span class="number">20</span>, <span class="number">30</span>);<span class="comment">//传两个值可以；</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h1><h2 id="相关基础知识"><a href="#相关基础知识" class="headerlink" title="相关基础知识"></a>相关基础知识</h2><p>C++面向对象的三大特性：<code>封装、继承、多态</code>。</p><p>封装的意义：<br>    将属性和行为作为一个整体，写在一起，表现生活中的事物；将属性和行为加以权限控制（public/protected/private）；语法：class 类名{访问权限: 属性/行为};</p><p>class 和 struct 的区别：</p><pre><code>1. 默认的访问权限不同，class 默认为私有，struct 默认为公共；2. 类可以继承，结构体不可以。</code></pre><p>Getter 和 Setter 一般放在头文件中，权限为 public，通过这个方式来 get/set 保护或者私有变量。</p><h1 id="对象特性"><a href="#对象特性" class="headerlink" title="对象特性"></a>对象特性</h1><h2 id="构造、析构与拷贝函数"><a href="#构造、析构与拷贝函数" class="headerlink" title="构造、析构与拷贝函数"></a>构造、析构与拷贝函数</h2><p>对象的初始化和清理：<br><code>构造函数</code>：创建对象时给成员属性赋值，编译器自动调用；<br><code>析构函数</code>：清理，对象销毁前编译器自动调用。</p><p>构造函数分类：<font color="#2DC26B">有参、无参</font>；<font color="#2DC26B">普通、拷贝</font>。</p><blockquote><p>如果用户定义有参构造，C++不再提供默认构造，但是会提供拷贝构造；<br>如果用户定义拷贝构造，C++不再提供默认构造和有参构造。<br><code>拷贝 &gt; 有参 &gt; 无参</code></p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">//构造函数：</span></span><br><span class="line"><span class="comment">//1.没有返回值，不用写void；</span></span><br><span class="line"><span class="comment">//2.函数名与类名相同；</span></span><br><span class="line"><span class="comment">//3.可以有参数，可以发生重载；</span></span><br><span class="line"><span class="comment">//4.创建对象时，会自动调用，只调用一次；</span></span><br><span class="line"><span class="built_in">Person</span>()<span class="comment">//按参数分类，分为有参和无参，无参构造也叫默认构造</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Person的默认构造函数调用 \n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Person</span>(<span class="type">int</span> a)<span class="comment">//有参构造</span></span><br><span class="line">&#123;</span><br><span class="line">age = a;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Person的有参构造函数调用 \n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Person</span>(<span class="type">const</span> Person &amp;p)<span class="comment">//拷贝构造函数，别的对象的属性拷贝进来，但不改变原对象的属性；其他都叫普通构造函数；</span></span><br><span class="line">&#123;</span><br><span class="line">age = p.age; <span class="comment">//别的对象的属性拷贝进来，但不改变原对象的属性；</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Person的拷贝构造函数调用 \n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//析构函数：</span></span><br><span class="line"><span class="comment">//1.没有返回值，不用写void；</span></span><br><span class="line"><span class="comment">//2.函数名与类名相同，前面加~；</span></span><br><span class="line"><span class="comment">//3.可以有参数，可以发生重载；</span></span><br><span class="line"><span class="comment">//4.对象销毁前，会自动调用，只调用一次；</span></span><br><span class="line">~<span class="built_in">Person</span>()</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Person的析构函数调用 \n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">getage</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="type">int</span> age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//调用</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test001</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//括号法</span></span><br><span class="line">Person p0;<span class="comment">//默认构造函数的调用，不要加小括号！！否则Person p0()会被认为是函数的声明！</span></span><br><span class="line"><span class="function">Person <span class="title">p1</span><span class="params">(<span class="number">10</span>)</span></span>;<span class="comment">//有参构造函数的调用；</span></span><br><span class="line"><span class="function">Person <span class="title">p2</span><span class="params">(p1)</span></span>;<span class="comment">//拷贝构造函数的调用；使用一个已经创建完毕的对象来初始化一个新的对象；</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;p1的年龄为：%d \n&quot;</span>, p1.<span class="built_in">getage</span>());</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;p2的年龄为：%d \n&quot;</span>, p2.<span class="built_in">getage</span>());</span><br><span class="line"></span><br><span class="line"><span class="comment">//显示法</span></span><br><span class="line">Person p00;</span><br><span class="line">Person p01 = <span class="built_in">Person</span>(<span class="number">30</span>);<span class="comment">//有参构造;Person(30)叫匿名对象！如果放在等号右侧，那等号左侧就是其对象名；</span></span><br><span class="line"><span class="built_in">Person</span>(<span class="number">40</span>);<span class="comment">//当前行执行结束后，系统会立即回收匿名对象；</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;匿名对象\n&quot;</span>);</span><br><span class="line">Person p02 = <span class="built_in">Person</span>(p01);<span class="comment">//拷贝构造</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;p01的年龄为：%d \n&quot;</span>, p01.<span class="built_in">getage</span>());</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;p02的年龄为：%d \n&quot;</span>, p02.<span class="built_in">getage</span>());</span><br><span class="line"></span><br><span class="line"><span class="comment">//Person(p02);//不要利用拷贝构造函数来初始化匿名对象！编译器会认为Person(p02) == Person p02，就重定义了！</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//隐式转换法</span></span><br><span class="line">Person p3 = <span class="number">25</span>;<span class="comment">//相当于Person p3 = Person(25);有参构造</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;p3的年龄为：%d \n&quot;</span>, p3.<span class="built_in">getage</span>());</span><br><span class="line">Person p4 = p3;<span class="comment">//拷贝构造</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;p4的年龄为：%d \n&quot;</span>, p4.<span class="built_in">getage</span>());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">doWork</span><span class="params">(Person p)</span><span class="comment">//值传递的方式给函数参数传值，可以调用拷贝构造函数</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test002</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Person p;</span><br><span class="line"><span class="built_in">doWork</span>(p);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;p \n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Person <span class="title">doWork2</span><span class="params">()</span><span class="comment">//值方式返回局部对象，可以调用拷贝构造函数</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Person p5;</span><br><span class="line"><span class="keyword">return</span> p5;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test003</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Person p = <span class="built_in">doWork2</span>();</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;doWork2 \n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">test001</span>();</span><br><span class="line"><span class="built_in">test002</span>();</span><br><span class="line"><span class="built_in">test003</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="🚩深拷贝、浅拷贝"><a href="#🚩深拷贝、浅拷贝" class="headerlink" title="🚩深拷贝、浅拷贝"></a>🚩深拷贝、浅拷贝</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person01</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Person01</span>()</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Person01的默认构造函数调用 \n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Person01</span>(<span class="type">int</span> a, <span class="type">int</span> h)</span><br><span class="line">&#123;</span><br><span class="line">m_Age = a;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Person01的有参构造函数调用 \n&quot;</span>);</span><br><span class="line">m_Height = <span class="keyword">new</span> <span class="built_in">int</span>(h);<span class="comment">//创建在堆区，返回的是指针；</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//自己创建一个拷贝构造函数来解决浅拷贝的问题，深拷贝！</span></span><br><span class="line"><span class="built_in">Person01</span>(<span class="type">const</span> Person01 &amp;p)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Person01的拷贝构造函数调用 \n&quot;</span>);</span><br><span class="line">m_Age = p.m_Age;</span><br><span class="line"><span class="comment">//m_Height = p.m_Height;//编译器默认提供的，在堆区会重复释放；</span></span><br><span class="line">m_Height = <span class="keyword">new</span> <span class="built_in">int</span>(*p.m_Height);<span class="comment">//深拷贝，重新开辟一块内存，让m_Height指向这块新的内存！这样就可以进行第二次释放！</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">~<span class="built_in">Person01</span>()</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Person01的析构函数调用 \n&quot;</span>);<span class="comment">//将堆区数据释放；</span></span><br><span class="line"><span class="keyword">if</span> (m_Height != <span class="literal">nullptr</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">delete</span> m_Height;<span class="comment">//手动开辟，手动释放内存；</span></span><br><span class="line">m_Height = <span class="literal">nullptr</span>;<span class="comment">//防止野指针出现，即防止已经释放的内存再次被访问，滞空；</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">getm_age</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> m_Age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> *<span class="title">getHeight</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> m_Height;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="type">int</span> m_Age;</span><br><span class="line"><span class="type">int</span> *m_Height;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02_01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="function">Person01 <span class="title">P1</span><span class="params">(<span class="number">18</span>, <span class="number">175</span>)</span></span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;P1的年龄是: %d, 身高是: %d \n&quot;</span>, P1.<span class="built_in">getm_age</span>(), *P1.<span class="built_in">getHeight</span>());</span><br><span class="line"></span><br><span class="line"><span class="function">Person01 <span class="title">P2</span><span class="params">(P1)</span></span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;P2的年龄是: %d, 身高是: %d \n&quot;</span>, P2.<span class="built_in">getm_age</span>(), *P2.<span class="built_in">getHeight</span>());</span><br><span class="line"><span class="comment">//如果用编译器自己提供的拷贝构造函数，会做浅拷贝操作！</span></span><br><span class="line"><span class="comment">//浅拷贝的问题：堆区的内存重复释放！第二次释放是非法操作！要用深拷贝来解决！</span></span><br><span class="line"><span class="comment">//如果有在堆区开辟的属性，一定要自己提供拷贝构造函数！用深拷贝来防止浅拷贝的问题！</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">test02_01</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="初始化列表"><a href="#初始化列表" class="headerlink" title="初始化列表"></a>初始化列表</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person02</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">//Person02(int a, int b, int c)//有参构造</span></span><br><span class="line"><span class="comment">//&#123;</span></span><br><span class="line"><span class="comment">//m_A = a;</span></span><br><span class="line"><span class="comment">//m_B = b;</span></span><br><span class="line"><span class="comment">//m_C = c;</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//Person02() :m_A(10), m_B(20), m_C(30)//初始化列表</span></span><br><span class="line"><span class="comment">//&#123;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Person02</span>(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> c) :<span class="built_in">m_A</span>(a), <span class="built_in">m_B</span>(b), <span class="built_in">m_C</span>(c)<span class="comment">//初始化列表 可传不同值；注意冒号位置！</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> m_A;</span><br><span class="line"><span class="type">int</span> m_B;</span><br><span class="line"><span class="type">int</span> m_C;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>🚀注意：</p><ol><li><strong>定义顺序</strong>：成员变量的初始化顺序遵循它们在<font color="#2DC26B">类声明中的顺序</font>，而不是初始化列表中的顺序。</li><li><strong>必要情况</strong>：如果成员变量是<font color="#2DC26B">常量 const</font>或者<font color="#2DC26B">没有默认构造函数的类类型</font>，则必须使用初始化列表进行初始化。</li><li><strong>优点</strong>：初始化列表可以<font color="#2DC26B">提高效率</font>，因为它<font color="#2DC26B">避免了构造函数体中的赋值操作</font>，特别是在处理不需要或不能通过默认构造函数创建的复杂对象时。</li><li><strong>执行顺序</strong>：<font color="#2DC26B">基类</font>的构造函数按照它们在类继承列表中声明的顺序依次调用 <code>-&gt;</code><font color="#2DC26B">成员对象</font>的构造函数按照它们在类体中声明的顺序调用 <code>-&gt;</code> 执行构造函数体内的代码。</li><li><strong>使用条件</strong>：仅<font color="#2DC26B">构造函数</font>可以使用初始化列表。</li></ol><p>现在具体解释注意点。<br>第 2 点：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">BaseClass</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">BaseClass</span>() : <span class="built_in">m_Value</span>(<span class="number">0</span>) &#123;&#125;  <span class="comment">// 默认构造函数</span></span><br><span class="line">    <span class="built_in">BaseClass</span>(<span class="type">int</span> value) : <span class="built_in">m_Value</span>(value) &#123;&#125;  <span class="comment">// 有参构造函数</span></span><br><span class="line">    <span class="type">int</span> m_Value;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MyClass</span>(<span class="type">int</span> baseValue, <span class="type">int</span> constVal)</span><br><span class="line">        : <span class="built_in">m_BaseMember</span>(baseValue),  <span class="comment">// 初始化BaseClass类型成员变量</span></span><br><span class="line">          <span class="built_in">m_ConstMember</span>(constVal)   <span class="comment">// 初始化const int类型成员变量</span></span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Base member initialized with: &quot;</span> &lt;&lt; m_BaseMember.m_Value &lt;&lt; endl;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Const member initialized with: &quot;</span> &lt;&lt; m_ConstMember &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    BaseClass m_BaseMember;  <span class="comment">// 类类型成员变量</span></span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> m_ConstMember;  <span class="comment">// const类型成员变量</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">MyClass <span class="title">obj</span><span class="params">(<span class="number">10</span>, <span class="number">20</span>)</span></span>;  <span class="comment">// 创建MyClass对象，测试初始化列表</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第 4 点：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 基类构造函数</span></span><br><span class="line">    <span class="built_in">Base</span>() &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Base class constructor&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Member</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 成员类构造函数</span></span><br><span class="line">    <span class="built_in">Member</span>() &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Member object constructor&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base &#123;</span><br><span class="line">    <span class="comment">// 成员变量初始化使用成员初始化列表</span></span><br><span class="line">    Member obj; </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 派生类构造函数</span></span><br><span class="line">    <span class="built_in">Derived</span>() : <span class="built_in">obj</span>() &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Derived class constructor body&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Derived d; <span class="comment">// 这将触发Derived类的构造过程</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//输出结果应该是这样的顺序：父类-&gt;成员类-&gt;自身构造函数</span></span><br><span class="line"><span class="comment">//Base class constructor</span></span><br><span class="line"><span class="comment">//Member object constructor</span></span><br><span class="line"><span class="comment">//Derived class constructor body</span></span><br></pre></td></tr></table></figure><h2 id="🚩类对象作为成员"><a href="#🚩类对象作为成员" class="headerlink" title="🚩类对象作为成员"></a>🚩类对象作为成员</h2><p>构造函数顺序：<code>父类-&gt;成员类-&gt;自身构造函数</code><br>析构函数顺序：反之。后进先出，析构函数释放的顺序和构造函数相反。</p><p>代码详见“初始化列表—注意—第 4 点”。</p><h2 id="静态成员"><a href="#静态成员" class="headerlink" title="静态成员"></a>静态成员</h2><p>静态成员：就是在成员变量或成员函数前面加上 static</p><p>静态成员变量：</p><ol><li>所有对象<font color="#2DC26B">共享</font>同一份数据，不单独属于某个对象（但这不意味着都是 public 或者说初始化的时候不需要加上作用域）</li><li>在<font color="#2DC26B">编译阶段</font>分配内存（全局区）</li><li><font color="#2DC26B">类内声明，类外初始化</font></li><li>如果静态成员变量是 <code>const</code> 整数类型或 <code>const</code> 枚举类型，可以在类内部直接定义并初始化</li></ol><p>静态成员函数：</p><ol><li>所有对象共享同一个函数</li><li>静态成员函数<font color="#2DC26B">只能访问静态成员变量</font></li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person04</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> m_A;<span class="comment">//静态成员变量，类内声明</span></span><br><span class="line"><span class="type">int</span> m_C;<span class="comment">//非静态成员变量，不可被static void func调用</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">func</span><span class="params">()</span><span class="comment">//静态成员函数</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">m_A = <span class="number">400</span>;<span class="comment">//可调用静态成员变量</span></span><br><span class="line"><span class="comment">//m_C = 200;//非静态成员变量，不可被func调用，因为这个数据是属于某个具体对象的</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;static void func的调用 \n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> m_B;</span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">func1</span><span class="params">()</span><span class="comment">//静态成员函数有访问权限</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;static void func1的调用 \n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> Person04::m_A = <span class="number">100</span>;<span class="comment">//类外初始化，一定要有</span></span><br><span class="line"><span class="type">int</span> Person04::m_B = <span class="number">300</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test_12_01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Person04 p1;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;p1A= %d \n&quot;</span>, p1.m_A);</span><br><span class="line"></span><br><span class="line">Person04 p2;</span><br><span class="line">p2.m_A = <span class="number">200</span>;<span class="comment">//用p2把m_A的值修改</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;p2A= %d \n&quot;</span>, p1.m_A);<span class="comment">//但是还是用p1去访问m_A，结果为200，共享同一份数据</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test_12_02</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//静态成员变量不属于某个对象上，共享同一个函数，所有对象都共享一份数据</span></span><br><span class="line"><span class="comment">//所以有两种访问方式：</span></span><br><span class="line">Person04 p;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;pA= %d \n&quot;</span>, p.m_A);<span class="comment">//1，通过对象进行访问；</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;pA= %d \n&quot;</span>, Person04::m_A);<span class="comment">//2，通过类名进行访问，不需要创建对象；</span></span><br><span class="line"><span class="comment">//printf(&quot;pB= %d \n&quot;, Person04::m_B);//静态成员变量也是有访问权限的，private在类外不可访问；</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test_12_03</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//静态成员函数不属于某个对象上，有两种访问方式：</span></span><br><span class="line">Person04 p;</span><br><span class="line">p.<span class="built_in">func</span>();<span class="comment">//1，通过对象进行访问；</span></span><br><span class="line">Person04::<span class="built_in">func</span>();<span class="comment">//2，通过类名进行访问，不需要创建对象；</span></span><br><span class="line"><span class="comment">//Person04::func1();//静态成员函数有访问权限，private在类外不可访问；</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>🚀注意：</p><ul><li>可以在类内部以 <code>static const int var = 10;</code> 这样的代码直接初始化常量静态成员变量。</li><li>对于其他类型的静态成员（例如 <code>double</code> 或其他类类型），必须在类外如 <code>double MyClass::staticVar = 10;</code> 进行定义和初始化，不能写作 <code>double staticVar = 10;</code>。</li><li>C++11 开始，允许<strong>内联初始化</strong>静态成员变量。<code>inline</code> 关键字允许静态成员变量的定义在一个 <code>.h</code> 文件中（或任何包含它的翻译单元）进行，编译器会在需要时将其复制到多个翻译单元中。这样可以避免多个翻译单元中定义相同的静态成员变量，从而解决了多重定义的问题。代码如下：</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//.h文件</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> staticVar; <span class="comment">// 声明并内联初始化</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// C++11的编译器特性使得这样就可以在使用静态成员的任何翻译单元中，编译器自动定义它</span></span><br><span class="line"><span class="keyword">inline</span> <span class="type">int</span> MyClass::staticVar = <span class="number">10</span>; </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//.cpp文件(非必要，只需要定义一次)</span></span><br><span class="line"><span class="comment">// 使用关键字inline可以在类的声明中直接初始化静态成员，无需在.cpp文件中具体定义</span></span><br><span class="line"><span class="keyword">inline</span> <span class="type">int</span> MyClass::staticVar = <span class="number">10</span>;</span><br></pre></td></tr></table></figure><h2 id="成员变量和成员函数分开储存"><a href="#成员变量和成员函数分开储存" class="headerlink" title="成员变量和成员函数分开储存"></a>成员变量和成员函数分开储存</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">test</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person05</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> m_A = <span class="number">1</span>;<span class="comment">//非静态成员变量，属于类的对象上；</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> m_B;<span class="comment">//静态成员变量，不属于类的对象上；</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123;&#125;;<span class="comment">//非静态成员函数，和变量分开存储的，不属于类的对象上！</span></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">func1</span><span class="params">()</span> </span>&#123;&#125;;<span class="comment">//静态成员函数，不属于类的对象上；</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">int</span> Person05::m_B = <span class="number">0</span>;<span class="comment">//类外初始化；</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test_13_01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">test p;</span><br><span class="line">cout&lt;&lt;<span class="string">&quot;sizeof p=&quot;</span>&lt;&lt;<span class="built_in">sizeof</span>(p)&lt;&lt;endl;</span><br><span class="line"><span class="comment">//空对象占用字节为1，C++编译器会给空对象分配1个字节空间，是为了区分空对象占内存的位置；</span></span><br><span class="line"><span class="comment">//每个空对象也应该有一个独一无二的内存地址；</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test_13_02</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Person05 p;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;sizeof p=&quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(p) &lt;&lt; endl;<span class="comment">//4个字节，因为是非静态成员变量，属于p的属性，int类型；</span></span><br><span class="line"><span class="comment">//仅m_A是p的属性</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="this-指针"><a href="#this-指针" class="headerlink" title="this 指针"></a>this 指针</h2><p>特点：</p><ul><li>当形参和成员变量同名时，解决名称冲突；</li><li>this 指针指向的是被调用的成员函数所属的对象，谁调用就指向谁；</li><li>在类的非静态成员函数中，返回对象本身用 <code>*this</code>；</li><li>不需要定义，直接使用；</li></ul><h2 id="空指针访问成员函数"><a href="#空指针访问成员函数" class="headerlink" title="空指针访问成员函数"></a>空指针访问成员函数</h2><p>空指针可以访问成员函数，但是如果用到 this 指针，需要加以判断保证代码健壮性。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person07</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">showClassName</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;this is person class&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">showPersonAge</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span> == <span class="literal">nullptr</span>)<span class="comment">//如果是空指针就return，避免报错，提高健壮性；</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;age=&quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;m_Age &lt;&lt; endl;<span class="comment">//m_Age和this-&gt;m_Age在这里是等效的；</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> m_Age;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test_15_01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Person07 *p = <span class="literal">nullptr</span>;</span><br><span class="line">p-&gt;<span class="built_in">showClassName</span>();</span><br><span class="line">p-&gt;<span class="built_in">showPersonAge</span>();<span class="comment">//空指针没有对象，访问里面的属性会报错！</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="const-修饰成员函数"><a href="#const-修饰成员函数" class="headerlink" title="const 修饰成员函数"></a>const 修饰成员函数</h2><blockquote><p>常对象 (const object) 无法直接修改属性，除非使用这几个方式：</p><ol><li>将类成员变量声明为 <code>mutable/static</code>, 则对应变量可以修改；</li><li>使用 <code>const_cast</code> 移除 const 限定符。<br>注意，<font color="#2DC26B">无法修改</font>指向常对象的指针或引用。</li></ol></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//常函数//常对象</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person08</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">//this指针本质是指针常量，指针的指向是不可修改的；</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">showPerson</span><span class="params">()</span> <span class="type">const</span><span class="comment">//常函数，相当于const Person08 *const this，修饰的是this的指向，让指向的值也不可修改</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//m_A = 100;//等效于this-&gt;m_A = 100;</span></span><br><span class="line">m_B = <span class="number">200</span>; <span class="comment">//m_B可修改；</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> m_A;</span><br><span class="line"><span class="keyword">mutable</span> <span class="type">int</span> m_B;<span class="comment">//即使在常函数中也可以修改；</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test_16_01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Person08 p;</span><br><span class="line">p.<span class="built_in">showPerson</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test_16_02</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">const</span> Person08 p;<span class="comment">//常对象</span></span><br><span class="line"><span class="comment">//p.m_A = 300;//不可修改</span></span><br><span class="line">p.m_B = <span class="number">400</span>;<span class="comment">//m_B可修改；</span></span><br><span class="line">p.<span class="built_in">showPerson</span>();<span class="comment">//常对象只能调用常函数！</span></span><br><span class="line"><span class="comment">//p.func();//常对象只能调用常函数！因为常函数可以修改属性，但是常对象不能修改！</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>了解：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setValue</span><span class="params">(<span class="type">int</span> v)</span> </span>&#123;</span><br><span class="line">        value = v;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> value;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//指向常对象的指针（const MyClass* const p）都不允许通过指针修改对象的内容</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">modifyValue</span><span class="params">(MyClass* <span class="type">const</span> cptr)</span> </span>&#123;</span><br><span class="line">    cptr-&gt;<span class="built_in">setValue</span>(<span class="number">10</span>); <span class="comment">// 正确：可以使用这个方法去间接改变成员值</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">const</span> MyClass obj;</span><br><span class="line">    <span class="built_in">modifyValue</span>(<span class="built_in">const_cast</span>&lt;MyClass*&gt;(&amp;obj)); <span class="comment">// 使用const_cast移除const限定符</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="🚩友元"><a href="#🚩友元" class="headerlink" title="🚩友元"></a>🚩友元</h2><p>定义：让一个函数或者类，访问另一个类中的<strong>所有成员</strong>。</p><p>🚀注意：</p><ol><li>友元函数一定要<font color="#2DC26B">在类外实现</font>，不然会报错！</li><li>需要先对友元类进行<font color="#2DC26B">前向声明</font> (forward declare，可在类内类外), 然后再声明友元函数。</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Building</span>;<span class="comment">//前向声明，先让编译器知道有个Building类，先在前面声明，不然后面成员函数作友元会报错！</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Goodguy</span><span class="comment">//创建一个好友类；</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Goodguy</span>();<span class="comment">//构造函数声明，赋初值；类外写成员函数；</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">visit</span><span class="params">()</span></span>;<span class="comment">//参观函数声明，访问对象building中的属性；类外写成员函数；</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sleep</span><span class="params">()</span></span>;<span class="comment">//睡觉函数声明，访问对象building中的属性；类外写成员函数；成员函数作友元；</span></span><br><span class="line"><span class="comment">//如果想让sleep访问私有成员而不让visit访问，就需要用到成员函数作友元！</span></span><br><span class="line"><span class="comment">//如果类作友元是所有成员函数都能访问！</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">Building *building;<span class="comment">//指针作成员；</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Building</span><span class="comment">//创建一个建筑物类</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="function"><span class="keyword">friend</span> <span class="type">void</span> <span class="title">goodguy</span><span class="params">(Building &amp;building)</span></span>;<span class="comment">//全局函数作友元，全局函数的声明，前面加friend意思就是这个函数可以访问Building的私有成员；</span></span><br><span class="line"><span class="comment">//friend class Goodguy;//类作友元，类的声明；</span></span><br><span class="line"><span class="function"><span class="keyword">friend</span> <span class="type">void</span> <span class="title">Goodguy::sleep</span><span class="params">()</span></span>;<span class="comment">//成员函数作友元，成员函数的声明；成员函数要加作用域，全局函数不加！</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">//Building()//构造函数，赋初值；类内实现；</span></span><br><span class="line"><span class="comment">//&#123;</span></span><br><span class="line"><span class="comment">//m_SittingRoom = &quot;客厅&quot;;</span></span><br><span class="line"><span class="comment">//m_BedRoom = &quot;卧室&quot;;</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"><span class="built_in">Building</span>();<span class="comment">//构造函数，赋初值</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">string m_SittingRoom;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">string m_BedRoom;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Building::<span class="built_in">Building</span>()<span class="comment">//类外实现构造函数；</span></span><br><span class="line">&#123;</span><br><span class="line">m_SittingRoom = <span class="string">&quot;客厅&quot;</span>;</span><br><span class="line">m_BedRoom = <span class="string">&quot;卧室&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//1，全局函数作友元</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">goodguy</span><span class="params">(Building &amp;building)</span><span class="comment">//全局函数，引用传递</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;01好友正在访问：&quot;</span> &lt;&lt; building.m_SittingRoom &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;01好友正在访问：&quot;</span> &lt;&lt; building.m_BedRoom &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test_01_01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Building b;<span class="comment">//创建Building的对象，这时候就会调用Building构造函数，来赋初值</span></span><br><span class="line"><span class="built_in">goodguy</span>(b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//2，类作友元  //3，成员函数作友元</span></span><br><span class="line">Goodguy::<span class="built_in">Goodguy</span>()<span class="comment">//构造函数定义，赋初值；类外写成员函数；</span></span><br><span class="line">&#123;</span><br><span class="line">building = <span class="keyword">new</span> <span class="built_in">Building</span>();<span class="comment">//在堆区创建一个Building的对象，用building去接收：new Building的时候会调用Building构造函数；</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Goodguy::visit</span><span class="params">()</span><span class="comment">//visit函数定义，类外写成员函数；不用传值，因为同属一个类的成员里有对应变量！</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;02好友正在访问：&quot;</span> &lt;&lt; building-&gt;m_SittingRoom &lt;&lt; endl;<span class="comment">//实际上还是函数访问成员，只不过这个函数是作为类的一个对象；</span></span><br><span class="line"><span class="comment">//cout &lt;&lt; &quot;02好友正在访问：&quot; &lt;&lt; building-&gt;m_BedRoom &lt;&lt; endl;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Goodguy::sleep</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;03好友正在：&quot;</span> &lt;&lt; building-&gt;m_SittingRoom &lt;&lt; <span class="string">&quot;里睡觉&quot;</span> &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;03好友正在：&quot;</span> &lt;&lt; building-&gt;m_BedRoom &lt;&lt; <span class="string">&quot;里睡觉&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test_01_02</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Goodguy g;<span class="comment">//创建Goodguy的对象，这时候就会调用Goodguy构造函数，来赋初值；</span></span><br><span class="line">g.<span class="built_in">visit</span>();<span class="comment">//调用visit函数，来访问Building的成员；</span></span><br><span class="line">g.<span class="built_in">sleep</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="🚩运算符重载"><a href="#🚩运算符重载" class="headerlink" title="🚩运算符重载"></a>🚩运算符重载</h2><h3 id="成员函数重载-号"><a href="#成员函数重载-号" class="headerlink" title="成员函数重载+号"></a>成员函数重载+号</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person01</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">Person01 <span class="keyword">operator</span>+(Person01 &amp;p)</span><br><span class="line">&#123;</span><br><span class="line">Person01 temp;</span><br><span class="line">temp.m_A = <span class="keyword">this</span>-&gt;m_A + p.m_A;</span><br><span class="line">temp.m_B = <span class="keyword">this</span>-&gt;m_B + p.m_B;</span><br><span class="line"><span class="keyword">return</span> temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="type">int</span> m_A;</span><br><span class="line"><span class="type">int</span> m_B;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="全局函数重载-号"><a href="#全局函数重载-号" class="headerlink" title="全局函数重载+号"></a>全局函数重载+号</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Person01 <span class="keyword">operator</span>+(Person01 &amp;p1, Person01 &amp;p2)</span><br><span class="line">&#123;</span><br><span class="line">Person01 temp;</span><br><span class="line">temp.m_A = p1.m_A + p2.m_A;</span><br><span class="line">temp.m_B = p1.m_B + p2.m_B;</span><br><span class="line"><span class="keyword">return</span> temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//运算符重载也可以发生函数重载；</span></span><br><span class="line">Person01 <span class="keyword">operator</span>+(Person01 &amp;p1, <span class="type">int</span> num)</span><br><span class="line">&#123;</span><br><span class="line">Person01 temp;</span><br><span class="line">temp.m_A = p1.m_A + num;</span><br><span class="line">temp.m_B = p1.m_B + num;</span><br><span class="line"><span class="keyword">return</span> temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="全局函数重载左移运算符-lt-lt"><a href="#全局函数重载左移运算符-lt-lt" class="headerlink" title="全局函数重载左移运算符&lt;&lt;"></a>全局函数重载左移运算符&lt;&lt;</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//左移运算符配合友元可以实现输出自定义的数据类型！</span></span><br><span class="line">ostream &amp;<span class="keyword">operator</span>&lt;&lt;(ostream &amp;out, Person01 &amp;p)<span class="comment">//因为cout&lt;&lt;p本质是operator&lt;&lt;(cout, p),简化版本是cout&lt;&lt;p; cout是输出流对象！</span></span><br><span class="line">&#123;</span><br><span class="line">out &lt;&lt; <span class="string">&quot;m_A=&quot;</span> &lt;&lt; p.m_A &lt;&lt; endl;</span><br><span class="line">out &lt;&lt; <span class="string">&quot;m_B=&quot;</span> &lt;&lt; p.m_B &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> out;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test_02_01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Person01 p1;</span><br><span class="line">p1.m_A = <span class="number">10</span>;</span><br><span class="line">p1.m_B = <span class="number">15</span>;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; p1 &lt;&lt; <span class="string">&quot;hello world&quot;</span> &lt;&lt; endl;<span class="comment">//左移运算符重载；</span></span><br><span class="line"></span><br><span class="line">Person01 p2;</span><br><span class="line">p2.m_A = <span class="number">20</span>;</span><br><span class="line">p2.m_B = <span class="number">30</span>;</span><br><span class="line"></span><br><span class="line">Person01 p3 = p1 + p2;<span class="comment">//直接写+号，编译器不认识，要用重载；</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;p3.m_A = &quot;</span> &lt;&lt; p3.m_A &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;p3.m_B = &quot;</span> &lt;&lt; p3.m_B &lt;&lt; endl;</span><br><span class="line"><span class="comment">//成员函数重载本质是Person01 p3 = p1.operator+(p2);</span></span><br><span class="line"><span class="comment">//全局函数重载本质是Person01 p3 = operator+(p1, p2);</span></span><br><span class="line"></span><br><span class="line">Person01 p4 = p1 + <span class="number">100</span>;<span class="comment">//函数重载</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;p4.m_A = &quot;</span> &lt;&lt; p4.m_A &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;p4.m_B = &quot;</span> &lt;&lt; p4.m_B &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="友元函数重载右移运算符-gt-gt"><a href="#友元函数重载右移运算符-gt-gt" class="headerlink" title="友元函数重载右移运算符&gt;&gt;"></a>友元函数重载右移运算符&gt;&gt;</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> value;</span><br><span class="line">    <span class="comment">// 声明友元函数</span></span><br><span class="line">    <span class="keyword">friend</span> istream&amp; <span class="keyword">operator</span>&gt;&gt; (istream&amp; is, MyClass&amp; obj);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 友元函数定义</span></span><br><span class="line">istream&amp; <span class="keyword">operator</span>&gt;&gt; (istream&amp; is, MyClass&amp; obj) &#123;</span><br><span class="line">    is &gt;&gt; obj.value; <span class="comment">// 从输入流读取数据到obj的成员变量</span></span><br><span class="line">    <span class="keyword">return</span> is;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="重载递增运算符"><a href="#重载递增运算符" class="headerlink" title="重载递增运算符++"></a>重载递增运算符++</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">myint</span><span class="comment">//自定义整型</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">friend</span> ostream &amp;<span class="keyword">operator</span>&lt;&lt;(ostream &amp;cout, myint m);<span class="comment">//用友元访问private成员；</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">myint</span>()</span><br><span class="line">&#123;</span><br><span class="line">m_Num = <span class="number">0</span>;<span class="comment">//用构造函数初始化数据；</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">myint &amp;<span class="keyword">operator</span>++()<span class="comment">//重载前置++运算符，用成员函数；要返回引用！不然会调用拷贝构造函数复制一份新的对象！</span></span><br><span class="line">&#123;</span><br><span class="line">m_Num++;<span class="comment">//先进行++运算；</span></span><br><span class="line"><span class="keyword">return</span> *<span class="keyword">this</span>;<span class="comment">//再返回自身；this指针的用法之一，非静态成员函数返回对象本身；</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">myint <span class="keyword">operator</span>++(<span class="type">int</span>)<span class="comment">//重载后置++运算符，用成员函数；int为占位参数！可用于区分前置和后置递增！后置要返回值，不能返回引用！</span></span><br><span class="line">&#123;</span><br><span class="line">myint temp = *<span class="keyword">this</span>;<span class="comment">//先记录当时的结果；</span></span><br><span class="line">m_Num++;<span class="comment">//再递增；</span></span><br><span class="line"><span class="keyword">return</span> temp;<span class="comment">//再将记录的结果返回；</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">myint &amp;<span class="keyword">operator</span>--()<span class="comment">//重载前置--运算符</span></span><br><span class="line">&#123;</span><br><span class="line">m_Num--;</span><br><span class="line"><span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">myint <span class="keyword">operator</span>--(<span class="type">int</span>)<span class="comment">//重载后置--运算符</span></span><br><span class="line">&#123;</span><br><span class="line">myint temp = *<span class="keyword">this</span>;</span><br><span class="line">m_Num--;</span><br><span class="line"><span class="keyword">return</span> temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="type">int</span> m_Num;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">ostream &amp;<span class="keyword">operator</span>&lt;&lt;(ostream &amp;cout, myint m)<span class="comment">//全局函数重载左移运算符</span></span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;数据的值是：&quot;</span> &lt;&lt; m.m_Num;</span><br><span class="line"><span class="keyword">return</span> cout;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test_02_02</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">myint newint;</span><br><span class="line">cout &lt;&lt; newint &lt;&lt; endl;<span class="comment">//因为是打印自定义的整型，所以要重载&lt;&lt;；</span></span><br><span class="line">cout &lt;&lt; ++newint &lt;&lt; endl;<span class="comment">//需要重载前置++；</span></span><br><span class="line">cout &lt;&lt; ++(++newint) &lt;&lt; endl;<span class="comment">//用引用返回，就能对一个对象一直++；</span></span><br><span class="line">cout &lt;&lt; newint &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test_02_03</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">myint newint;</span><br><span class="line">cout &lt;&lt; newint &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; newint++ &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; newint &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test_02_04</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">myint newint;</span><br><span class="line">cout &lt;&lt; newint &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; --newint &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; --(--newint) &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; newint &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test_02_05</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">myint newint;</span><br><span class="line">cout &lt;&lt; newint &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; newint-- &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; newint &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="重载赋值运算符"><a href="#重载赋值运算符" class="headerlink" title="重载赋值运算符="></a>重载赋值运算符=</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//C++编译器至少给一个类添加4个函数，</span></span><br><span class="line"><span class="comment">//默认构造函数，无参，函数体为空；</span></span><br><span class="line"><span class="comment">//默认析构函数，无参，函数体为空；</span></span><br><span class="line"><span class="comment">//默认拷贝构造函数，对属性进行值拷贝；</span></span><br><span class="line"><span class="comment">//赋值运算符operator=，对属性进行值拷贝；</span></span><br><span class="line"><span class="comment">//如果类中有属性指向堆区，赋值操作也会出现深浅拷贝的问题！</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person02</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Person02</span>(<span class="type">int</span> age)</span><br><span class="line">&#123;</span><br><span class="line">m_Age = <span class="keyword">new</span> <span class="built_in">int</span>(age);<span class="comment">//在堆区，要程序员手动开辟和释放，释放的时机是在析构函数中；</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">~<span class="built_in">Person02</span>()</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (m_Age != <span class="literal">nullptr</span>)<span class="comment">//释放堆区的数据；如果用默认的赋值运算会造成浅拷贝，所以要重载=，用深拷贝；</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">delete</span> m_Age;</span><br><span class="line">m_Age = <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Person02 &amp;<span class="keyword">operator</span>=(Person02 &amp;p)<span class="comment">//重载=运算符；返回引用，可返回自身，可实现链式编程；</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//编译器默认：m_Age = p.m_Age;这样是浅拷贝；</span></span><br><span class="line"><span class="comment">//应该先判断是否有属性在堆区，如果有，应该释放干净！然后再深拷贝！</span></span><br><span class="line"><span class="keyword">if</span> (m_Age != <span class="literal">nullptr</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">delete</span> m_Age;</span><br><span class="line">m_Age = <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">m_Age = <span class="keyword">new</span> <span class="built_in">int</span>(*p.m_Age);<span class="comment">//深拷贝！重新开辟一块堆区空间！</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> *<span class="keyword">this</span>;<span class="comment">//返回自身；</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> *m_Age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test_02_06</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="function">Person02 <span class="title">P1</span><span class="params">(<span class="number">18</span>)</span></span>;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;P1年龄是：&quot;</span> &lt;&lt; *P1.m_Age &lt;&lt; endl;</span><br><span class="line"><span class="function">Person02 <span class="title">P2</span><span class="params">(<span class="number">20</span>)</span></span>;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;P2年龄是：&quot;</span> &lt;&lt; *P2.m_Age &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">P2 = P1;<span class="comment">//将P1的所有数据赋值给P2；</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;P1年龄是：&quot;</span> &lt;&lt; *P1.m_Age &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;P2年龄是：&quot;</span> &lt;&lt; *P2.m_Age &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="function">Person02 <span class="title">P3</span><span class="params">(<span class="number">30</span>)</span></span>;</span><br><span class="line">P3 = P2 = P1;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;P3年龄是：&quot;</span> &lt;&lt; *P3.m_Age &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="重载关系运算符"><a href="#重载关系运算符" class="headerlink" title="重载关系运算符"></a>重载关系运算符</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//让两个自定义类型对象进行比较</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person03</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Person03</span>(string name, <span class="type">int</span> age)</span><br><span class="line">&#123;</span><br><span class="line">m_Name = name;</span><br><span class="line">m_Age = age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="keyword">operator</span>==(Person03 &amp;p)<span class="comment">//重载==</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>-&gt;m_Name == p.m_Name &amp;&amp; <span class="keyword">this</span>-&gt;m_Age == p.m_Age)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="keyword">operator</span>!=(Person03 &amp;p)<span class="comment">//重载!=</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>-&gt;m_Name == p.m_Name &amp;&amp; <span class="keyword">this</span>-&gt;m_Age == p.m_Age)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="keyword">operator</span>&lt;(Person03 &amp;p)<span class="comment">//重载&lt;</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>-&gt;m_Age &lt; p.m_Age)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="keyword">operator</span>&gt;(Person03 &amp;p)<span class="comment">//重载&gt;</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>-&gt;m_Age &gt; p.m_Age)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">string m_Name;</span><br><span class="line"><span class="type">int</span> m_Age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test_02_07</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="function">Person03 <span class="title">p1</span><span class="params">(<span class="string">&quot;Tom&quot;</span>, <span class="number">18</span>)</span></span>;</span><br><span class="line"><span class="function">Person03 <span class="title">p2</span><span class="params">(<span class="string">&quot;Jerry&quot;</span>, <span class="number">18</span>)</span></span>;</span><br><span class="line"><span class="keyword">if</span> (p1 == p2)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;p1和p2相等&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(p1 != p2)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;p1和p2不等&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test_02_08</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="function">Person03 <span class="title">p3</span><span class="params">(<span class="string">&quot;Vettel&quot;</span>, <span class="number">35</span>)</span></span>;</span><br><span class="line"><span class="function">Person03 <span class="title">p4</span><span class="params">(<span class="string">&quot;Kimi&quot;</span>, <span class="number">40</span>)</span></span>;</span><br><span class="line"><span class="keyword">if</span> (p3 &lt; p4)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;p3比p4小&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (p3 &gt; p4)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;p3比p4大&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="重载函数调用运算符"><a href="#重载函数调用运算符" class="headerlink" title="重载函数调用运算符 ()"></a>重载函数调用运算符 ()</h3><p>也叫做仿函数。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//非常灵活，没有固定写法</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyPrint</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(string test)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; test &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test_02_09</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">MyPrint print;</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;hello world&quot;</span>);<span class="comment">//非常类似函数调用，也叫仿函数</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyAdd</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> num1, <span class="type">int</span> num2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> num1 + num2;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test_02_10</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">MyAdd add;</span><br><span class="line"><span class="type">int</span> ret = <span class="built_in">add</span>(<span class="number">100</span>, <span class="number">200</span>);<span class="comment">//仿函数</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;ret=&quot;</span> &lt;&lt; ret &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="built_in">MyAdd</span>()(<span class="number">200</span>, <span class="number">300</span>) &lt;&lt; endl;<span class="comment">//匿名函数对象</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="🤔总结"><a href="#🤔总结" class="headerlink" title="🤔总结"></a>🤔总结</h3><div class="table-container"><table><thead><tr><th>运算符</th><th>说明</th><th>友元函数重载</th><th>全局函数重载</th><th>成员函数重载</th></tr></thead><tbody><tr><td>+</td><td>一元加</td><td>否</td><td>✅</td><td>否</td></tr><tr><td>-</td><td>一元减</td><td>否</td><td>✅</td><td>否</td></tr><tr><td>!</td><td>逻辑非</td><td>✅</td><td>✅</td><td>✅</td></tr><tr><td>+ +</td><td>自增</td><td>否</td><td>✅</td><td>✅</td></tr><tr><td>- -</td><td>自减</td><td>否</td><td>✅</td><td>✅</td></tr><tr><td>=</td><td>赋值</td><td>✅</td><td>否</td><td>✅</td></tr><tr><td>*</td><td>解引用</td><td>否</td><td>否</td><td>✅</td></tr><tr><td>&amp;</td><td>取地址</td><td>否</td><td>否</td><td>✅</td></tr><tr><td>[ ]</td><td>索引/下标</td><td>✅</td><td>✅</td><td>✅</td></tr><tr><td>-&gt;</td><td>箭头</td><td>否</td><td>否</td><td>✅</td></tr><tr><td>( )</td><td>类型转换</td><td>✅</td><td>✅</td><td>✅</td></tr><tr><td>&lt;&lt;</td><td>左移</td><td>✅</td><td>✅</td><td>否</td></tr><tr><td>&gt;&gt;</td><td>右移</td><td>✅</td><td>✅</td><td>否</td></tr><tr><td>+, -, *, /</td><td>二元加、减、乘、除等</td><td>✅</td><td>✅</td><td>否（构造函数可以部分实现这些）</td></tr><tr><td>==, !=</td><td>比较</td><td>✅</td><td>✅</td><td>✅</td></tr><tr><td>&lt;, &gt;, &lt;=, &gt;=</td><td>比较</td><td>✅</td><td>✅</td><td>✅</td></tr><tr><td>++(作为后缀)</td><td>自增后缀</td><td>否</td><td>✅</td><td>✅</td></tr><tr><td>—(作为后缀)</td><td>自减后缀</td><td>否</td><td>✅</td><td>✅</td></tr></tbody></table></div><p>🚀注意：</p><ul><li>一元运算符（如 <code>+</code>, <code>-</code>, <code>!</code>, <code>++</code>, <code>--</code>）<font color="#2DC26B">不通过成员函数</font>重载，因为它们没有足够的参数来使得它们成为成员函数。(+a)</li><li>二元运算符可以使用<font color="#2DC26B">任意类型</font>的组合进行重载，只需要符合运算的逻辑，并且可以作为友元函数或全局函数，也可以作为成员函数。(a+b)</li><li>三位运算符和一些特定情性需要特殊注意，比如赋值运算符 <code>=</code> 和下标运算符 <code>[ ]</code> 通常通过<font color="#2DC26B">成员函数</font>重载。</li><li>构造函数用做类型转换，它实际上重载了转换运算符 <code>()</code>。</li><li>对于某些特殊的运算符，如赋值运算符和下标运算符，常常会通过<font color="#2DC26B">成员函数</font>的方式来重载。</li></ul><hr><h1 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h1><p>类与类上下级之间有共性和特性，使用继承可以减少很多重复代码。</p><h2 id="继承中的构造和析构顺序，同名成员属性、同名静态成员的处理"><a href="#继承中的构造和析构顺序，同名成员属性、同名静态成员的处理" class="headerlink" title="继承中的构造和析构顺序，同名成员属性、同名静态成员的处理"></a>继承中的构造和析构顺序，同名成员属性、同名静态成员的处理</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base1</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Base1</span>()</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Base1的构造函数&quot;</span> &lt;&lt; endl;</span><br><span class="line">m_F = <span class="number">100</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">~<span class="built_in">Base1</span>()</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Base1的析构函数&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Base1下成员函数func()调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span> a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Base1下成员函数func(int a)调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">func1</span><span class="params">()</span><span class="comment">//静态成员函数</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Base1下静态成员函数func1()调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> m_F;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> m_G;<span class="comment">//静态成员变量，编译阶段分配内存，所有对象共享同一份数据，类内声明类外初始化</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">int</span> Base1::m_G = <span class="number">50</span>;<span class="comment">//类外初始化</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son4</span> : <span class="keyword">public</span> Base1</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Son4</span>()</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Son4的构造函数&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">~<span class="built_in">Son4</span>()</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Son4的析构函数&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test_03_07</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//Base1 b;</span></span><br><span class="line">Son4 s;<span class="comment">//先构造父类，再构造子类，析构与构造相反！先进后出！</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son5</span> :<span class="keyword">public</span> Base1</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Son5</span>()</span><br><span class="line">&#123;</span><br><span class="line">m_F = <span class="number">200</span>; <span class="comment">//和父类成员变量同名；</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Son5下成员函数func()调用&quot;</span> &lt;&lt; endl;<span class="comment">//和父类成员函数同名；</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">func1</span><span class="params">()</span><span class="comment">//静态成员函数</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Son5下静态成员函数func1()调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> m_F;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> m_G;<span class="comment">//和父类静态成员变量同名；</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">int</span> Son5::m_G = <span class="number">60</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test_03_08</span><span class="params">()</span><span class="comment">//同名成员变量访问方式</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Son5 s;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;子类 Son5下 m_F=&quot;</span> &lt;&lt; s.m_F &lt;&lt; endl;<span class="comment">//直接访问是访问子类的成员</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;父类 Base1下 m_F=&quot;</span> &lt;&lt; s.Base1::m_F &lt;&lt; endl;<span class="comment">//在s.后面加上Base1作用域，就访问父类中的同名成员</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test_03_09</span><span class="params">()</span><span class="comment">//同名成员函数调用方式</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Son5 s;</span><br><span class="line">s.<span class="built_in">func</span>();<span class="comment">//直接调用是调用子类的成员函数</span></span><br><span class="line">s.Base1::<span class="built_in">func</span>();<span class="comment">//在s.后面加上Base1作用域，就调用父类中的同名函数</span></span><br><span class="line">s.Base1::<span class="built_in">func</span>(<span class="number">20</span>);<span class="comment">//调用父类中重载的同名函数</span></span><br><span class="line"><span class="comment">//如果子类中出现父类同名的成员函数，会隐藏掉父类中所有的同名成员函数，包括所有重载的；对静态成员函数也适用！</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test_03_10</span><span class="params">()</span><span class="comment">//同名静态成员变量访问方式</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//通过创建对象来访问静态变量；</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;通过创建对象来访问静态变量&quot;</span> &lt;&lt; endl;</span><br><span class="line">Son5 s;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;子类 Son5下 m_G=&quot;</span> &lt;&lt; s.m_G &lt;&lt; endl;<span class="comment">//直接访问就是访问子类的成员；</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;父类 Base1下 m_G=&quot;</span> &lt;&lt; s.Base1::m_G &lt;&lt; endl;<span class="comment">//在s.后面加上Base1作用域，就访问父类中的同名成员；</span></span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">//不创建对象，通过类名来访问静态变量，因为是共享的；</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;通过类名来访问静态变量&quot;</span> &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;子类 Son5下 m_G=&quot;</span> &lt;&lt; Son5::m_G &lt;&lt; endl;<span class="comment">//这里::是通过类名访问，不是作用域</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;父类 Base1下 m_G=&quot;</span> &lt;&lt; Son5::Base1::m_G &lt;&lt; endl;<span class="comment">//相当于Son5::(Base1::m_G)，第一个::是通过类名访问，第二个::是父类作用域</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test_03_11</span><span class="params">()</span><span class="comment">//同名静态成员函数调用方式</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//通过创建对象来访问静态成员函数；</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;通过创建对象来访问静态成员函数&quot;</span> &lt;&lt; endl;</span><br><span class="line">Son5 s;</span><br><span class="line">s.<span class="built_in">func1</span>();<span class="comment">//直接调用是调用子类的成员函数</span></span><br><span class="line">s.Base1::<span class="built_in">func1</span>();<span class="comment">//父类静态成员函数调用</span></span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">//不创建对象，通过类名来访问静态成员函数，因为是共享的；</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;通过类名来访问静态成员函数&quot;</span> &lt;&lt; endl;</span><br><span class="line">Son5::<span class="built_in">func1</span>();</span><br><span class="line">Son5::Base1::<span class="built_in">func1</span>(); <span class="comment">//相当于Son5::(Base1::func1());</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//C++允许一个类继承多个父类，但可能会引发父类中有同名成员的问题，因此实际开发中不建议用；</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base01</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Base01</span>()</span><br><span class="line">&#123;</span><br><span class="line">m_A1 = <span class="number">100</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> m_A1;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base02</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Base02</span>()</span><br><span class="line">&#123;</span><br><span class="line">m_B1 = <span class="number">100</span>;</span><br><span class="line">m_A1 = <span class="number">700</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> m_B1;</span><br><span class="line"><span class="type">int</span> m_A1;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son06</span> : <span class="keyword">public</span> Base01, <span class="keyword">public</span> Base02<span class="comment">//同时继承Base01和Base02，中间用逗号隔开</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Son06</span>()</span><br><span class="line">&#123;</span><br><span class="line">m_C1 = <span class="number">300</span>;</span><br><span class="line">m_D1 = <span class="number">400</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> m_C1;</span><br><span class="line"><span class="type">int</span> m_D1;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test_03_12</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Son06 s;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;sizeof Son06 =&quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(s) &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Base01 m_A1=&quot;</span> &lt;&lt; s.Base01::m_A1 &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Base02 m_A1=&quot;</span> &lt;&lt; s.Base02::m_A1 &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="菱形继承"><a href="#菱形继承" class="headerlink" title="菱形继承"></a>菱形继承</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//也叫钻石继承，一个父类有两个子类，然后再有一个子类继承了这两个子类；</span></span><br><span class="line"><span class="comment">//以下代码使用虚继承解决菱形继承中的多重数据成员问题</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span><span class="comment">//动物</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="type">int</span> m_Age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Sheep</span> : <span class="keyword">virtual</span> <span class="keyword">public</span> Animal<span class="comment">//羊，加上virtual，虚继承！Animal称为虚其类</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Camel</span> : <span class="keyword">virtual</span> <span class="keyword">public</span> Animal<span class="comment">//驼</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Alpaca</span> : <span class="keyword">public</span> Sheep, <span class="keyword">public</span> Camel<span class="comment">//羊驼</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test_03_13</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Alpaca al;</span><br><span class="line">al.Sheep::m_Age = <span class="number">3</span>;</span><br><span class="line">al.Camel::m_Age = <span class="number">5</span>;<span class="comment">//两个父类相同名称成员，要加作用域区分</span></span><br><span class="line"><span class="comment">//菱形继承会导致资源浪费，需要用到虚继承！虚继承后只有一份数据！</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Sheep age=&quot;</span> &lt;&lt; al.Sheep::m_Age &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Camel age=&quot;</span> &lt;&lt; al.Camel::m_Age &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Alpaca age=&quot;</span> &lt;&lt; al.m_Age &lt;&lt; endl;<span class="comment">//虚继承不会出现不明确</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>菱形继承的弊端:</p><ol><li><strong>二义性</strong>：当基类中的两个子类都重写了基类的某个成员时，由此产生的最子类在选择要访问哪个版本会引发二义性。</li><li><strong>内存冗余</strong>：两个子类分别继承了自身的副本基类，增加了内存占用。</li><li><strong>构造和析构的复杂性</strong>：成员的构造和析构可能变得复杂，需要多个构造函数和析构函数来处理不同继承链的初始化和清理。</li></ol><p>😊改进方案：</p><ol><li><strong>虚继承</strong>：通过使用 <code>virtual</code> 关键字在基类继承中，可以指定共享的基类为虚基类，从而避免每个派生类存储独立的基类副本。</li><li><strong>多重继承的替代方案</strong>：考虑使用<font color="#2DC26B">组合</font>而非继承，或者使用<font color="#2DC26B">接口类</font>解决问题。</li><li><strong>设计审查</strong>：在决定使用多重继承时，仔细审查设计，以确保没有过度耦合。</li></ol><p>第一点虚继承代码如上，下面给出第二点的代码 (推荐)：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 基类 Animal</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> m_Age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 子类 Sheep，组合了 Animal 而不是继承</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Sheep</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Animal animal;  <span class="comment">// Sheep 拥有一个 Animal 属性</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Sheep</span>(<span class="type">int</span> age) : <span class="built_in">animal</span>(age) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setAge</span><span class="params">(<span class="type">int</span> age)</span> </span>&#123;</span><br><span class="line">        animal.m_Age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getAge</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> animal.m_Age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 子类 Camel，同样组合 Animal</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Camel</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Animal animal; <span class="comment">// Camel 也拥有一个 Animal 属性</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Camel</span>(<span class="type">int</span> age) : <span class="built_in">animal</span>(age) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setAge</span><span class="params">(<span class="type">int</span> age)</span> </span>&#123;</span><br><span class="line">        animal.m_Age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getAge</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> animal.m_Age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 复合动物类 Alpaca，它组合了 Sheep 和 Camel</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Alpaca</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Sheep sheep;</span><br><span class="line">    Camel camel;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Alpaca</span>(<span class="type">int</span> sheepAge, <span class="type">int</span> camelAge) : <span class="built_in">sheep</span>(sheepAge), <span class="built_in">camel</span>(camelAge) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getSheepAge</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sheep.<span class="built_in">getAge</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getCamelAge</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> camel.<span class="built_in">getAge</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setSheepAge</span><span class="params">(<span class="type">int</span> age)</span> </span>&#123;</span><br><span class="line">        sheep.<span class="built_in">setAge</span>(age);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setCamelAge</span><span class="params">(<span class="type">int</span> age)</span> </span>&#123;</span><br><span class="line">        camel.<span class="built_in">setAge</span>(age);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">Alpaca <span class="title">al</span><span class="params">(<span class="number">3</span>, <span class="number">5</span>)</span></span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Sheep age=&quot;</span> &lt;&lt; al.<span class="built_in">getSheepAge</span>() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Camel age=&quot;</span> &lt;&lt; al.<span class="built_in">getCamelAge</span>() &lt;&lt; endl;</span><br><span class="line">    al.<span class="built_in">setSheepAge</span>(<span class="number">4</span>);</span><br><span class="line">    al.<span class="built_in">setCamelAge</span>(<span class="number">6</span>);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Updated Sheep age=&quot;</span> &lt;&lt; al.<span class="built_in">getSheepAge</span>() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Updated Camel age=&quot;</span> &lt;&lt; al.<span class="built_in">getCamelAge</span>() &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><hr><h1 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h1><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p><strong>静态多态</strong>：函数重载、运算符重载。函数地址早绑定：编译阶段确定函数地址。<br><strong>动态多态</strong>：派生类和虚函数实现运行时的多态。函数地址晚绑定：运行阶段确定函数地址。</p><p>💭动态多态的满足条件：</p><ol><li>有继承关系；</li><li>子类<font color="#2DC26B">重写</font>父类的虚函数，不是重载，是完全相同的函数。</li></ol><p>动态多态的使用：父类的指针或者引用指向子类的对象。</p><p>🚀重写(overload)和重载(override)的区别:</p><ul><li><strong>范围和作用域</strong>：重写发生在<font color="#2DC26B">派生类与其基类</font>之间，需在不同的类中定义；而重载发生在同一个类或同一个作用域中，涉及多个具有相同名称但参数不同的函数。</li><li><strong>参数列表</strong>：重写要求派生类中重写的函数与基类中的虚函数<font color="#2DC26B">参数列表完全相同，以实现真正的函数替代</font>；重载的函数则有不同参数列表，根据参数的类型、数量、顺序来区分。</li><li><strong>关键字<code>virtual</code></strong>：进行重写的基类函数必须有<code>virtual</code>关键字，以确保它能够接收动态绑定（Runtime Polymorphism）；而重载则不强制要求<code>virtual</code>关键字。 </li><li><strong>返回类型</strong>：尽管返回类型相同可以作为重写和重载的一种情况，但重载更侧重于参数的不同，不同的返回类型并不影响函数的重载关系。</li><li><strong>访问级别</strong>：在重写中，派生类的函数<font color="#2DC26B">不能</font>有比基类中相应函数更严格的访问控制（如基类方法为<code>public</code>，而派生类方法为<code>private</code>）。 </li><li><strong>概念上的区别</strong>：重写实现多态性（Polymorphism），一个基类引用或指针可以指向不同派生类的对象，并调用相应的重写函数；重载允许编译时基于参数列表使用函数名称来区分多个函数。 </li><li><strong>隐藏（Hiding）</strong>：与重写和重载不同，在隐藏情况下基类函数被派生类同名函数盖掉，即使基类函数为<code>virtual</code>，如果派生类函数参数列表不同也不构成重写，而是隐藏。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span><span class="comment">//动物类</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">//void speak()</span></span><br><span class="line"><span class="comment">//&#123;</span></span><br><span class="line"><span class="comment">//cout &lt;&lt; &quot;动物在说话&quot; &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">speak</span><span class="params">()</span><span class="comment">//这样可以让地址晚绑定！</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;动物在说话&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Cat</span> : <span class="keyword">public</span> Animal<span class="comment">//猫类</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">speak</span><span class="params">()</span><span class="comment">//函数重写，可加也可不加virtual</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;猫在说话&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span> : <span class="keyword">public</span> Animal<span class="comment">//狗类</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">speak</span><span class="params">()</span><span class="comment">//函数重写，可加也可不加virtual</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;狗在说话&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">doSpeak</span><span class="params">(Animal &amp;animal)</span><span class="comment">//执行说话的函数//父类的引用可以直接指向子类的对象！Animal &amp;animal = c或者d；</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">animal.<span class="built_in">speak</span>();<span class="comment">//之前是地址早绑定，编译阶段就确定了函数地址！</span></span><br><span class="line"><span class="comment">//如果要让猫说话，就要让地址在运行阶段才绑定！要在父类函数名前加virtual！</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test04_01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Cat c;</span><br><span class="line"><span class="built_in">doSpeak</span>(c);</span><br><span class="line"></span><br><span class="line">Dog d;</span><br><span class="line"><span class="built_in">doSpeak</span>(d);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="🚩纯虚函数与抽象类"><a href="#🚩纯虚函数与抽象类" class="headerlink" title="🚩纯虚函数与抽象类"></a>🚩纯虚函数与抽象类</h2><p>父类中的虚函数没用时，可以写成纯虚函数，因为主要都是调用子类重写的函数。<font color="#2DC26B">有纯虚函数的类称为抽象类</font>。C++中常使用纯虚函数和抽象类来实现接口。</p><p>语法：virtual 返回值 函数名(参数列表) = 0;<br>特点1：<font color="#2DC26B">无法实例化</font>对象；<br>特点2：子类<font color="#2DC26B">必须重写抽象类中的纯虚函数</font>，否则也属于抽象类！<br>多态使用的条件：父类的<font color="#2DC26B">指针或者引用</font>指向子类对象。</p><p><strong>抽象类特点</strong>：</p><ul><li>不能直接被实例化。</li><li><font color="#2DC26B">可以</font>拥有成员变量。</li><li>可以拥有普通成员函数以及构造函数和析构函数。</li><li>用作基类，为派生类提供共同的接口。</li><li><font color="#2DC26B">必须有纯虚函数</font>。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span><span class="comment">//抽象类</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">func</span><span class="params">()</span> </span>= <span class="number">0</span>;<span class="comment">//纯虚函数</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son</span> : <span class="keyword">public</span> Base</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">func</span><span class="params">()</span><span class="comment">//重写抽象类中的纯虚函数，不然不能创建对象！但重写不是=0，而是要有实现！</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;func函数调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125; </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test04_02</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//Base b;//不可实例化对象</span></span><br><span class="line"><span class="comment">//new Base;//堆区也不可实例化对象</span></span><br><span class="line">Son s;<span class="comment">//可以实例化对象</span></span><br><span class="line">Base *p = <span class="keyword">new</span> <span class="built_in">Son</span>();<span class="comment">//堆区数据，手动开辟，手动释放！//多态使用的条件：父类的指针或者引用指向子类对象！</span></span><br><span class="line">p-&gt;<span class="built_in">func</span>();</span><br><span class="line"><span class="keyword">delete</span> p;<span class="comment">//手动释放！</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>🤔思考：如果 Base 并不是抽象类，即并没有纯虚函数，此时 <code>func ()</code> 的代码为：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;父类&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>输出结果依然为：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">func函数调用</span><br></pre></td></tr></table></figure><br>分析函数执行顺序：（不包括 <code>Son s</code> 的情况下）</p><ol><li>基类构造函数 <code>Base()</code></li><li>派生类构造函数 <code>Son()</code></li><li>派生类重写的函数 <code>Son::func()</code></li><li>派生类析构函数 <code>~Base()</code></li><li>基类析构函数 <code>~Son()</code><br>由此可见，即使 Base 不是抽象类，p-&gt;func() 仍然只调用子类对象的对应函数。结果和 <code>Son s; s.func()</code> 的输出结果一致。</li></ol><p>进行验证：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Base</span>() &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Base constructor called.&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Base func called.&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Base</span>() &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Base destructor called.&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son</span> : <span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Son</span>() &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Son constructor called.&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Son func called.&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">Son</span>() <span class="keyword">override</span> &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Son destructor called.&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test04_02</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Base* p = <span class="keyword">new</span> <span class="built_in">Son</span>();</span><br><span class="line">    p-&gt;<span class="built_in">func</span>();</span><br><span class="line">    <span class="keyword">delete</span> p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">test04_02</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="🚩虚析构与纯虚析构"><a href="#🚩虚析构与纯虚析构" class="headerlink" title="🚩虚析构与纯虚析构"></a>🚩虚析构与纯虚析构</h2><p>如果子类中有属性开辟到堆区，那么父类指针在释放时无法调用到子类的析构代码。<br>💡解决方法：将<font color="#2DC26B">父类</font>中的析构函数写成<font color="#2DC26B">虚析构或纯虚析构</font>函数。</p><p>💭虚析构与纯虚析构共性：<br>1，可以解决<font color="#2DC26B">父类指针释放子类的堆区对象</font>；<br>2，都需要有<font color="#2DC26B">具体的函数实现</font>。</p><p>💭虚析构与纯虚析构区别：纯虚析构，该类属于抽象类，<font color="#2DC26B">无法实例化</font>对象。<br>如果子类中没有堆区数据（new），可以不写虚析构。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Animal1</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Animal1</span>()</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Animal1构造函数调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//virtual ~Animal1()//虚析构</span></span><br><span class="line"><span class="comment">//&#123;</span></span><br><span class="line"><span class="comment">//cout &lt;&lt; &quot;Animal1析构函数调用&quot; &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"><span class="keyword">virtual</span> ~<span class="built_in">Animal1</span>() = <span class="number">0</span>;<span class="comment">//纯虚析构</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">speak</span><span class="params">()</span> </span>= <span class="number">0</span>;<span class="comment">//纯虚函数；</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Animal1::~<span class="built_in">Animal1</span>()<span class="comment">//纯虚析构函数一定要有具体实现函数</span></span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Animal1纯虚析构函数调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Lion</span> : <span class="keyword">public</span> Animal1</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Lion</span>(string name)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Lion构造函数调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">m_Name = <span class="keyword">new</span> <span class="built_in">string</span>(name);<span class="comment">//堆区</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">speak</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; *m_Name &lt;&lt; <span class="string">&quot;狮子在说话&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">~<span class="built_in">Lion</span>()</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (m_Name != <span class="literal">nullptr</span>)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Lion析构函数调用&quot;</span> &lt;&lt; endl;<span class="comment">//父类用虚析构，子类的虚析构才能被调用。现在可以使用虚析构函数释放掉堆区内存了</span></span><br><span class="line"><span class="keyword">delete</span> m_Name;</span><br><span class="line">m_Name = <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">string *m_Name;<span class="comment">//指针；</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test04_03</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Animal1 *p = <span class="keyword">new</span> <span class="built_in">Lion</span>(<span class="string">&quot;Simba&quot;</span>);</span><br><span class="line">p-&gt;<span class="built_in">speak</span>();</span><br><span class="line"><span class="keyword">delete</span> p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出结果：</span></span><br><span class="line"><span class="comment">//Animal1构造函数调用</span></span><br><span class="line"><span class="comment">//Lion构造函数调用</span></span><br><span class="line"><span class="comment">//Simba狮子在说话</span></span><br><span class="line"><span class="comment">//Lion析构函数调用</span></span><br><span class="line"><span class="comment">//Animal1纯虚析构函数调用</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">C++基础：面向对象</summary>
    
    
    
    <category term="C++语言基础" scheme="https://sumikiru.top/categories/C-%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="C++" scheme="https://sumikiru.top/tags/C/"/>
    
    <category term="面向对象" scheme="https://sumikiru.top/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
    
  </entry>
  
  <entry>
    <title>语言基础1.指针与结构体</title>
    <link href="https://sumikiru.top/posts/685aa201.html"/>
    <id>https://sumikiru.top/posts/685aa201.html</id>
    <published>2024-07-28T13:18:39.000Z</published>
    <updated>2025-02-06T14:42:00.320Z</updated>
    
    <content type="html"><![CDATA[<h1 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h1><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span> </span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std; </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123; </span><br><span class="line"><span class="comment">//指针就是地址，取*操作了就是值 </span></span><br><span class="line"><span class="comment">//定义指针： </span></span><br><span class="line"><span class="type">int</span> a = <span class="number">10</span>; </span><br><span class="line"><span class="type">int</span> * p;<span class="comment">//语法：数据类型 * 指针变量名；通常用p表示指针； </span></span><br><span class="line">p = &amp;a;<span class="comment">//&amp;a为取a的地址，让指针p记录变量a的地址； </span></span><br><span class="line"><span class="comment">//也可以写成：</span></span><br><span class="line"><span class="type">int</span> *p = &amp;a;<span class="comment">//也就是让指针p指向a的地址； </span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;a的地址是：&quot;</span> &lt;&lt; &amp;a &lt;&lt; endl; </span><br><span class="line">cout &lt;&lt; <span class="string">&quot;指针p是：&quot;</span> &lt;&lt; p &lt;&lt; endl; </span><br><span class="line"></span><br><span class="line"><span class="comment">//指针使用： </span></span><br><span class="line"><span class="comment">//通过“解引用”的方式找到指针指向的内存，取*操作； </span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;*p=&quot;</span> &lt;&lt; *p &lt;&lt; endl; <span class="comment">//指针前加*表示解引用，找到指针指向的内存中的数据；这里为对内存进行读取； </span></span><br><span class="line">*p = <span class="number">1000</span>;<span class="comment">//这里为对内存进行修改，让指针指向内存为1000的位置； </span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;a=&quot;</span> &lt;&lt; a &lt;&lt; endl; </span><br><span class="line">cout &lt;&lt; <span class="string">&quot;p=&quot;</span> &lt;&lt; p &lt;&lt; endl; </span><br><span class="line">cout &lt;&lt; <span class="string">&quot;*p=&quot;</span> &lt;&lt; *p &lt;&lt; endl; </span><br><span class="line"></span><br><span class="line"><span class="comment">//指针占用的空间： </span></span><br><span class="line"><span class="type">int</span> b = <span class="number">5</span>; </span><br><span class="line"><span class="comment">//int * p1; </span></span><br><span class="line"><span class="comment">//p1 = &amp;b; </span></span><br><span class="line"><span class="type">int</span> * p1 = &amp;b;<span class="comment">//直接让指针指向b的地址； </span></span><br><span class="line">cout &lt;&lt; <span class="built_in">sizeof</span>(p1) &lt;&lt; endl;<span class="comment">//32位系统占用4个字节，64位为8个字节,不管什么数据类型； </span></span><br><span class="line">cout &lt;&lt; <span class="built_in">sizeof</span>(<span class="type">int</span>*) &lt;&lt; endl;<span class="comment">//等价于上一行； </span></span><br><span class="line">cout &lt;&lt; <span class="built_in">sizeof</span>(<span class="type">float</span>*) &lt;&lt; endl; </span><br><span class="line">cout &lt;&lt; <span class="built_in">sizeof</span>(<span class="type">double</span>*) &lt;&lt; endl; </span><br><span class="line">cout &lt;&lt; <span class="built_in">sizeof</span>(<span class="type">char</span>*) &lt;&lt; endl; </span><br><span class="line"></span><br><span class="line"><span class="comment">//空指针：指向内存中编号为0的变量； </span></span><br><span class="line"><span class="comment">//用途：初始化指针变量； </span></span><br><span class="line"><span class="comment">//空指针指向的内存不可访问！因为0-255之间的内存编号是系统占用的，不可更改！</span></span><br><span class="line"><span class="comment">//int *p2 = NULL; //错误</span></span><br><span class="line"><span class="type">int</span> *p2 = <span class="literal">nullptr</span>; <span class="comment">//正确，是空指针</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//野指针：指向非法的内存空间； </span></span><br><span class="line"><span class="type">int</span> *p3 = (<span class="type">int</span> *)<span class="number">0x1100</span>;<span class="comment">//不是自己申请的内存空间，不要去访问！ </span></span><br><span class="line"><span class="comment">//cout &lt;&lt; *p3 &lt;&lt; endl; </span></span><br><span class="line"></span><br><span class="line"><span class="comment">//const指针：看const后面跟着是什么； </span></span><br><span class="line"><span class="comment">//const修饰指针： </span></span><br><span class="line"><span class="type">int</span> a1 = <span class="number">4</span>; </span><br><span class="line"><span class="type">int</span> a2 = <span class="number">9</span>; </span><br><span class="line"><span class="type">const</span> <span class="type">int</span> *p4 = &amp;a1;<span class="comment">//常量指针，指针指向的值不可以改，而指向的位置可以改； </span></span><br><span class="line"><span class="comment">//*p4 = 10;错误！ </span></span><br><span class="line">p4 = &amp;a2;<span class="comment">//正确，可以改！ </span></span><br><span class="line"></span><br><span class="line"><span class="comment">//const修饰常量： </span></span><br><span class="line"><span class="type">int</span> * <span class="type">const</span> p5 = &amp;a1;<span class="comment">//指针常量，指针指向的值可以改，而指向的位置不可以改； </span></span><br><span class="line">*p5 = <span class="number">10</span>;<span class="comment">//正确，可以改！ </span></span><br><span class="line"><span class="comment">//p5 = &amp;a2;错误！ </span></span><br><span class="line"></span><br><span class="line"><span class="comment">//const修饰指针和常量： </span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> * <span class="type">const</span> p6 = &amp;a1;<span class="comment">//指针指向的值和指向的位置都不可以改！ </span></span><br><span class="line"><span class="comment">//*p6 = 7;错误！ </span></span><br><span class="line"><span class="comment">//p6 = &amp;a2;错误！ </span></span><br><span class="line"></span><br><span class="line"><span class="comment">//指针和数组，用指针访问数组中的元素 </span></span><br><span class="line"><span class="type">int</span> arr[<span class="number">10</span>] = &#123; <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span> &#125;; </span><br><span class="line"><span class="type">int</span> *p7 = arr;<span class="comment">//arr就是数组的首地址； </span></span><br><span class="line">cout &lt;&lt; *p7 &lt;&lt; endl;<span class="comment">//解引用，取*操作，用指针访问第一个元素； </span></span><br><span class="line">p7++;<span class="comment">//让指针向右偏移4个字节； </span></span><br><span class="line">cout &lt;&lt; *p7 &lt;&lt; endl;<span class="comment">//访问第二个元素； </span></span><br><span class="line"><span class="type">int</span> *p8 = arr;<span class="comment">//用指针访问所有元素； </span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123; </span><br><span class="line"><span class="comment">//cout &lt;&lt; arr[i] &lt;&lt; endl;不用指针访问每个元素； </span></span><br><span class="line">cout &lt;&lt; *p8 &lt;&lt; endl; </span><br><span class="line">p8++;<span class="comment">//指针后移一位 </span></span><br><span class="line">&#125; </span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>); </span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>💭注：<code>nullptr</code> 是在C++11引入的一个特殊的字面值，用来安全高效地表示空指针，避免了C语言风格中将 <code>NULL</code> 或 <code>0</code> 用作空指针时可能出现的错误。在 <code>int *p2 = nullptr;</code> 这行代码中，<code>p2</code> 被初始化为指向空对象的指针。这在编程中是一种常见的做法，确保指针在未被正确初始化之前不会访问任何对象，可以避免运行时错误。<code>nullptr</code> 与 <code>NULL</code> 不同，<code>NULL</code> 通常被定义为 <code>0</code> 的宏，而 <code>nullptr</code> 是精确的空指针。</p><blockquote><p><code>const</code> 在 <code>*</code> 的位置：左定值，右定向。</p></blockquote><h2 id="函数的地址传递"><a href="#函数的地址传递" class="headerlink" title="函数的地址传递"></a>函数的地址传递</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span> </span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(<span class="type">int</span> *p1, <span class="type">int</span> *p2)</span><span class="comment">//地址传递，用指针接收传入的地址； </span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line"><span class="type">int</span> temp = *p1; </span><br><span class="line">*p1 = *p2; </span><br><span class="line">*p2 = temp; </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line"><span class="type">int</span> a = <span class="number">10</span>; </span><br><span class="line"><span class="type">int</span> b = <span class="number">20</span>; </span><br><span class="line"><span class="built_in">swap</span>(&amp;a, &amp;b);<span class="comment">//把a和b的地址传入函数，函数中用指针接收地址； </span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;a=&quot;</span> &lt;&lt; a &lt;&lt; endl; </span><br><span class="line">cout &lt;&lt; <span class="string">&quot;b=&quot;</span> &lt;&lt; b &lt;&lt; endl; </span><br><span class="line"><span class="comment">//地址传递可以修改实参！而值传递不能！ </span></span><br><span class="line"><span class="comment">//如果不想实参被修改，函数的参数列表可以写成const；如果想要修改，可以用地址传递，或者引用传递（后续介绍）； </span></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>); </span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="结构体"><a href="#结构体" class="headerlink" title="结构体"></a>结构体</h1><h2 id="基本概念-1"><a href="#基本概念-1" class="headerlink" title="基本概念"></a>基本概念</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Student</span><span class="comment">//定义的时候不可以省略掉struct! 一般定义在main函数之前或头文件里；</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//成员列表</span></span><br><span class="line">string name;</span><br><span class="line"><span class="type">int</span> age;</span><br><span class="line"><span class="type">int</span> score;</span><br><span class="line">&#125;S3;<span class="comment">//顺便直接创建变量；</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">C++基础：指针与结构体</summary>
    
    
    
    <category term="C++语言基础" scheme="https://sumikiru.top/categories/C-%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="C++" scheme="https://sumikiru.top/tags/C/"/>
    
    <category term="指针" scheme="https://sumikiru.top/tags/%E6%8C%87%E9%92%88/"/>
    
    <category term="结构体" scheme="https://sumikiru.top/tags/%E7%BB%93%E6%9E%84%E4%BD%93/"/>
    
  </entry>
  
  <entry>
    <title>7.贪心算法篇</title>
    <link href="https://sumikiru.top/posts/dc2082d.html"/>
    <id>https://sumikiru.top/posts/dc2082d.html</id>
    <published>2024-07-27T21:27:16.000Z</published>
    <updated>2025-02-06T14:42:00.324Z</updated>
    
    
    <summary type="html">贪心算法部分</summary>
    
    
    
    <category term="leetcode刷题笔记" scheme="https://sumikiru.top/categories/leetcode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="C++" scheme="https://sumikiru.top/tags/C/"/>
    
    <category term="leetcode" scheme="https://sumikiru.top/tags/leetcode/"/>
    
    <category term="贪心" scheme="https://sumikiru.top/tags/%E8%B4%AA%E5%BF%83/"/>
    
  </entry>
  
  <entry>
    <title>6.1哈希表篇(2)</title>
    <link href="https://sumikiru.top/posts/6f36f465.html"/>
    <id>https://sumikiru.top/posts/6f36f465.html</id>
    <published>2024-07-14T17:27:36.000Z</published>
    <updated>2025-02-06T14:42:00.324Z</updated>
    
    <content type="html"><![CDATA[<h1 id="3-哈希表与统计"><a href="#3-哈希表与统计" class="headerlink" title="3.哈希表与统计"></a>3.哈希表与统计</h1><h2 id="3-1-最长和谐子序列：594"><a href="#3-1-最长和谐子序列：594" class="headerlink" title="3-1.最长和谐子序列：594"></a>3-1.最长和谐子序列：594</h2><p>法一：排序+滑动窗口</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findLHS</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());</span><br><span class="line">        <span class="type">int</span> left = <span class="number">0</span>, right = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right &amp;&amp; right &lt;= nums.<span class="built_in">size</span>() - <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">abs</span>(nums[right] - nums[left]) == <span class="number">1</span>) &#123;</span><br><span class="line">                ans = <span class="built_in">max</span>(right - left + <span class="number">1</span>, ans);</span><br><span class="line">                right++;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">abs</span>(nums[right] - nums[left]) &lt; <span class="number">1</span>) &#123;</span><br><span class="line">                right++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                left++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>法二：哈希表</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findLHS</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; cnt;</span><br><span class="line">        <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> num : nums) &#123;</span><br><span class="line">            cnt[num]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> [key, val] : cnt) &#123;</span><br><span class="line">            <span class="keyword">if</span> (cnt.<span class="built_in">count</span>(key + <span class="number">1</span>)) &#123;</span><br><span class="line">                ans = <span class="built_in">max</span>(ans, val + cnt[key + <span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="3-2-两个数组的交集II：350"><a href="#3-2-两个数组的交集II：350" class="headerlink" title="3-2.两个数组的交集II：350"></a>3-2.两个数组的交集II：350</h2><p>两个数组的交集:349，详见《6.0哈希表篇1-2》</p><p>法一：哈希表(最优解)</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">intersect</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums1, vector&lt;<span class="type">int</span>&gt;&amp; nums2)</span> </span>&#123;</span><br><span class="line">        unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; mp;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> num : nums1) &#123;</span><br><span class="line">            mp[num]++;</span><br><span class="line">        &#125;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> num : nums2) &#123;</span><br><span class="line">            <span class="keyword">if</span> (mp.<span class="built_in">count</span>(num) &amp;&amp; mp[num]) &#123;</span><br><span class="line">                mp[num]--;</span><br><span class="line">                res.<span class="built_in">emplace_back</span>(num);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>法二：排序+双指针</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">intersect</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums1, vector&lt;<span class="type">int</span>&gt;&amp; nums2)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">sort</span>(nums1.<span class="built_in">begin</span>(), nums1.<span class="built_in">end</span>());</span><br><span class="line">        <span class="built_in">sort</span>(nums2.<span class="built_in">begin</span>(), nums2.<span class="built_in">end</span>());</span><br><span class="line">        <span class="type">int</span> index1 = <span class="number">0</span>, index2 = <span class="number">0</span>;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">        <span class="keyword">while</span> (index1 &lt; nums1.<span class="built_in">size</span>() &amp;&amp; index2 &lt; nums2.<span class="built_in">size</span>()) &#123;</span><br><span class="line">            <span class="type">int</span> num1 = nums1[index1], num2 = nums2[index2];</span><br><span class="line">            <span class="keyword">if</span> (num1 == num2) &#123;</span><br><span class="line">                res.<span class="built_in">emplace_back</span>(num1);</span><br><span class="line">                index1++;</span><br><span class="line">                index2++;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (num1 &lt; num2) &#123;</span><br><span class="line">                index1++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                index2++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><pre><code>如果$&#123;nums&#125;_2$的元素存储在磁盘上，磁盘内存是有限的，并且你**不能一次加载所有的元素到内存中**。那么就无法高效地对$&#123;nums&#125;_2$进行排序，因此推荐使用方法一而不是方法二。在方法一中，$&#123;nums&#125;_2$只关系到查询操作，因此每次读取$&#123;nums&#125;_2$中的一部分数据，并进行处理即可。</code></pre><h2 id="3-3-砖墙：554"><a href="#3-3-砖墙：554" class="headerlink" title="3-3.砖墙：554"></a>3-3.砖墙：554</h2><p>哈希表</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">leastBricks</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; wall)</span> </span>&#123;</span><br><span class="line">        unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; mp;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; widths : wall) &#123;</span><br><span class="line">            <span class="type">int</span> n = widths.<span class="built_in">size</span>();</span><br><span class="line">            <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i++) &#123;</span><br><span class="line">                sum += widths[i];</span><br><span class="line">                mp[sum]++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> maxCnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; [_, value] : mp) &#123;</span><br><span class="line">            maxCnt = <span class="built_in">max</span>(maxCnt, value);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> wall.<span class="built_in">size</span>() - maxCnt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="3-4-在系统中查找重复文件：609"><a href="#3-4-在系统中查找重复文件：609" class="headerlink" title="3-4.在系统中查找重复文件：609"></a>3-4.在系统中查找重复文件：609</h2><p>法一：哈希表</p><pre><code>麻烦之处在于，不只是`&quot;root/a 1.txt(abcd)&quot;`一种格式，还可能是`&quot;root/a 1.txt(abcd) 2.txt(efgh)&quot;`。思路简单，但是写起来复杂。</code></pre><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;string&gt;&gt; <span class="built_in">findDuplicate</span>(vector&lt;string&gt;&amp; paths) &#123;</span><br><span class="line">        unordered_map&lt;string, vector&lt;string&gt;&gt; t;</span><br><span class="line">        <span class="keyword">auto</span> help = [](string s) -&gt; pair&lt;string, string&gt; &#123;</span><br><span class="line">            string name, content;</span><br><span class="line">            <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(; i&lt;s.<span class="built_in">size</span>() &amp;&amp; s[i] != <span class="string">&#x27;(&#x27;</span>; i++)&#123;</span><br><span class="line">                name += s[i];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span>(i++; i&lt;s.<span class="built_in">size</span>() &amp;&amp; s[i] != <span class="string">&#x27;)&#x27;</span>; i++)&#123;</span><br><span class="line">                content += s[i];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> &#123;name, content&#125;;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> path : paths)&#123;</span><br><span class="line">            string p;</span><br><span class="line">            <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span>(path[i] != <span class="string">&#x27; &#x27;</span>)&#123;</span><br><span class="line">                p += path[i];</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            string tmp;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> l=i, r=i+<span class="number">1</span>; r &lt; path.<span class="built_in">size</span>(); r++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(path[r] == <span class="string">&#x27; &#x27;</span> || r == path.<span class="built_in">size</span>() - <span class="number">1</span>)&#123;</span><br><span class="line">                    <span class="keyword">auto</span> [name, content] = <span class="built_in">help</span>(path.<span class="built_in">substr</span>(l+<span class="number">1</span>, r-l));</span><br><span class="line">                    t[content].<span class="built_in">push_back</span>(p+<span class="string">&#x27;/&#x27;</span>+name);</span><br><span class="line">                    l = r;</span><br><span class="line">                    tmp.<span class="built_in">clear</span>();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        vector&lt;vector&lt;string&gt;&gt; ans;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;[_, names] : t)&#123;</span><br><span class="line">            <span class="keyword">if</span>(names.<span class="built_in">size</span>() &gt; <span class="number">1</span>)</span><br><span class="line">                ans.<span class="built_in">emplace_back</span>(names);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>法二：istringstream</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;string&gt;&gt; <span class="built_in">findDuplicate</span>(vector&lt;string&gt;&amp; paths) &#123;</span><br><span class="line">        vector&lt;vector&lt;string&gt;&gt; ans;</span><br><span class="line">        unordered_map&lt;string, vector&lt;string&gt;&gt; um;   <span class="comment">//文件内容-&gt;文件路径</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> string&amp; path: paths) &#123;</span><br><span class="line">            <span class="function">istringstream <span class="title">iss</span><span class="params">(path)</span></span>;</span><br><span class="line">            string dir, tmp;</span><br><span class="line">            iss &gt;&gt; dir;</span><br><span class="line">            <span class="keyword">while</span> (iss &gt;&gt; tmp) &#123;</span><br><span class="line">                string key, val;</span><br><span class="line">                <span class="built_in">getKeyAndVal</span>(key, val, tmp, dir);</span><br><span class="line">                um[key].<span class="built_in">push_back</span>(val);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; p: um) &#123;</span><br><span class="line">            <span class="keyword">if</span> (p.second.<span class="built_in">size</span>() &gt; <span class="number">1</span>) &#123;</span><br><span class="line">                ans.<span class="built_in">push_back</span>(p.second);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">getKeyAndVal</span><span class="params">(string&amp; key, string&amp; val, <span class="type">const</span> string&amp; tmp, <span class="type">const</span> string&amp; dir)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (tmp[i] != <span class="string">&#x27;(&#x27;</span>) ++i;</span><br><span class="line">        val = dir + <span class="string">&quot;/&quot;</span> + tmp.<span class="built_in">substr</span>(<span class="number">0</span>, i);</span><br><span class="line">        <span class="type">int</span> j = i + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (tmp[j] != <span class="string">&#x27;)&#x27;</span>) ++j;</span><br><span class="line">        key = tmp.<span class="built_in">substr</span>(i + <span class="number">1</span>, j - i - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="关于stringstream"><a href="#关于stringstream" class="headerlink" title="关于stringstream"></a>关于stringstream</h2><pre><code>istringstream是继承于istream，ostringstream是继承于ostream，而他们使用的缓冲区类是stringbuf。二者详细说明：[istringstream及ostringstream超详细说明--知乎](https://zhuanlan.zhihu.com/p/367869633)</code></pre><p><img src="https://s2.loli.net/2024/04/07/eMHJ6g4Wcxmld8u.png" alt=""></p><pre><code>stringstream样例：[C++中stringstream样例-博客园](https://www.cnblogs.com/zhang-qc/p/9048977.html)在这段代码中，`istringstream` 用于从字符串中提取数据。针对每个 `path`，它创建了一个 `istringstream` 对象，然后使用 `iss &gt;&gt; dir` 语句提取第一个字符串（目录信息），之后使用 `iss &gt;&gt; tmp` 循环提取后续的字符串。</code></pre><p>优势：</p><ol><li><p><strong>方便的输入流操作</strong>：<code>istringstream</code> 提供了与标准输入输出流 <code>cin</code> 和 <code>cout</code> 相似的接口来处理字符串。</p></li><li><p><strong>轻量级</strong>：<code>istringstream</code> 是基于内存的输入流，因此操作速度快。</p></li><li><p><strong>可重复使用</strong>：可以重复使用 <code>istringstream</code> 对不同的字符串进行解析，而无需重新初始化。</p></li><li><p><strong>数据类型转换</strong>：<code>istringstream</code> 提供了可以轻松将不同类型数据从字符串中提取出来的方法。</p></li><li><p><strong>适用于分词</strong>：适用于从输入的字符串中提取单词或数据。可以使用 <code>&gt;&gt;</code> 操作符来<u>按空格等分隔符将字符串分词</u>。</p><p> 总之，<code>istringstream</code> 提供了一种方便、高效的方式来处理从字符串中提取数据，使得对文本进行解析和处理变得更加容易。在需要将字符串按照空格分割为各个部分并记录下对应值时，可以起到类似其他语言中<code>split(&#39; &#39;)</code>的作用。</p></li></ol><h2 id="3-5-四数相加II：454"><a href="#3-5-四数相加II：454" class="headerlink" title="3-5.四数相加II：454"></a>3-5.四数相加II：454</h2><p>💬难在思路: 分治+哈希表</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">fourSumCount</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums1, vector&lt;<span class="type">int</span>&gt;&amp; nums2, vector&lt;<span class="type">int</span>&gt;&amp; nums3, vector&lt;<span class="type">int</span>&gt;&amp; nums4)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; mp; <span class="comment">//累加和-&gt;组合数</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span>&amp; a : nums1) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span>&amp; b : nums2) &#123;</span><br><span class="line">                mp[a + b]++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span>&amp; c : nums3) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span>&amp; d : nums4) &#123;</span><br><span class="line">                <span class="keyword">if</span> (mp.<span class="built_in">count</span>(-c - d)) &#123;</span><br><span class="line">                    ans += mp[-c - d]; <span class="comment">// 不能只加一次，可能多种情况</span></span><br><span class="line">                    <span class="comment">// 同时不应再改变mp[-c-d]的值</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><pre><code>三数之和：15,四数之和：18。这两题最优解为双指针，而不是哈希表。有时候哈希表时空开销太大时，双指针往往能很好地解决。</code></pre><h2 id="3-6-多数元素：169"><a href="#3-6-多数元素：169" class="headerlink" title="3-6.多数元素：169"></a>3-6.多数元素：169</h2><p>法一：哈希表(27ms,27.3MB)✅</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">majorityElement</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; counts;</span><br><span class="line">        <span class="type">int</span> majority = <span class="number">0</span>, cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> num : nums) &#123;</span><br><span class="line">            ++counts[num];</span><br><span class="line">            <span class="keyword">if</span> (counts[num] &gt; cnt) &#123;</span><br><span class="line">                majority = num;</span><br><span class="line">                cnt = counts[num];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> majority;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>法二：排序+取众数(20ms,27.2MB)</p><blockquote><p>这里的”多数元素”出现次数超过总次数的一半，所以必定是众数，并且排序后位于中间的数一定是众数（数学思维）。</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">majorityElement</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">return</span> nums[nums.<span class="built_in">size</span>() / <span class="number">2</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>虽然时间复杂度比法一高，但实际运行时间会更小。使用堆排序可以进一步减小空间开销。</p><p>法三：随机数(了解)</p><p>最坏时间复杂度为$O(\infty)$，可能一直找不到众数。用<code>rand()</code>生成随机数。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">majorityElement</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="type">int</span> candidate = nums[<span class="built_in">rand</span>() % nums.<span class="built_in">size</span>()];</span><br><span class="line">            <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> num : nums)</span><br><span class="line">                <span class="keyword">if</span> (num == candidate)</span><br><span class="line">                    ++count;</span><br><span class="line">            <span class="keyword">if</span> (count &gt; nums.<span class="built_in">size</span>() / <span class="number">2</span>)</span><br><span class="line">                <span class="keyword">return</span> candidate;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>法四：分治(24ms,26MB)</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">count_in_range</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target, <span class="type">int</span> lo, <span class="type">int</span> hi)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = lo; i &lt;= hi; ++i)</span><br><span class="line">            <span class="keyword">if</span> (nums[i] == target)</span><br><span class="line">                ++count;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">majority_element_rec</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> lo, <span class="type">int</span> hi)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (lo == hi)</span><br><span class="line">            <span class="keyword">return</span> nums[lo];</span><br><span class="line">        <span class="type">int</span> mid = (lo + hi) / <span class="number">2</span>;</span><br><span class="line">        <span class="type">int</span> left_majority = <span class="built_in">majority_element_rec</span>(nums, lo, mid);</span><br><span class="line">        <span class="type">int</span> right_majority = <span class="built_in">majority_element_rec</span>(nums, mid + <span class="number">1</span>, hi);</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">count_in_range</span>(nums, left_majority, lo, hi) &gt; (hi - lo + <span class="number">1</span>) / <span class="number">2</span>)</span><br><span class="line">            <span class="keyword">return</span> left_majority;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">count_in_range</span>(nums, right_majority, lo, hi) &gt; (hi - lo + <span class="number">1</span>) / <span class="number">2</span>)</span><br><span class="line">            <span class="keyword">return</span> right_majority;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">majorityElement</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">majority_element_rec</span>(nums, <span class="number">0</span>, nums.<span class="built_in">size</span>() - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>法五：Boyer-Moore投票算法(17ms,26.1MB)✅</p><p>详见<a href="https://leetcode.cn/problems/majority-element/solutions/1/169-duo-shu-yuan-su-mo-er-tou-piao-qing-ledrh/">本题摩尔投票清晰图解</a>。核心思想为对拼消耗，如果元素出现次数不超过一半，则该方法失效，这时候就需要用到其泛化版———Misra-Gries算法。</p><p><a href="https://www.zhihu.com/question/49973163/answer/3202021480">如何理解摩尔投票算法？—力扣</a></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">majorityElement</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> x = <span class="number">0</span>, votes = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> num : nums)&#123;</span><br><span class="line">            <span class="keyword">if</span> (votes == <span class="number">0</span>) x = num;</span><br><span class="line">            votes += num == x ? <span class="number">1</span> : <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="拓展-多数元素II：229"><a href="#拓展-多数元素II：229" class="headerlink" title="拓展.多数元素II：229"></a>拓展.多数元素II：229</h3><p>法一：哈希表</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">majorityElement</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; counts;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; ans;</span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; num : nums) &#123;</span><br><span class="line">            counts[num]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; cnt : counts) &#123;</span><br><span class="line">            <span class="keyword">if</span> (cnt.second &gt; n / <span class="number">3</span>) &#123;</span><br><span class="line">                ans.<span class="built_in">push_back</span>(cnt.first);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>法二：摩尔投票法✅</p><blockquote><p>出现次数超过$\lfloor\frac{n}{2}\rfloor$的最多只能有一个，出现次数超过$\lfloor\frac{n}{3}\rfloor$的最多只能有两个。</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">majorityElement</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; ans;</span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="comment">// 临时元素1和2，对应投票votes1和votes2</span></span><br><span class="line">        <span class="type">int</span> element1 = <span class="number">0</span>, element2 = <span class="number">0</span>, votes1 = <span class="number">0</span>, votes2 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; num : nums) &#123;</span><br><span class="line">            <span class="keyword">if</span> (votes1 &gt; <span class="number">0</span> &amp;&amp; num == element1) &#123;</span><br><span class="line">                <span class="comment">// 如果该元素为第一个元素，则计数加1</span></span><br><span class="line">                votes1++;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (votes2 &amp;&amp; num == element2) &#123;</span><br><span class="line">                <span class="comment">// 如果该元素为第二个元素，则计数加1</span></span><br><span class="line">                votes2++;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (votes1 == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// 选择第一个元素</span></span><br><span class="line">                element1 = num;</span><br><span class="line">                votes1++;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (votes2 == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// 选择第二个元素</span></span><br><span class="line">                element2 = num;</span><br><span class="line">                votes2++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 如果三个元素均不相同，则相互抵消1次</span></span><br><span class="line">                votes1--;</span><br><span class="line">                votes2--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> cnt1 = <span class="number">0</span>, cnt2 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; num : nums) &#123;</span><br><span class="line">            <span class="keyword">if</span> (votes1 &gt; <span class="number">0</span> &amp;&amp; num == element1) &#123;</span><br><span class="line">                cnt1++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (votes2 &gt; <span class="number">0</span> &amp;&amp; num == element2) &#123;</span><br><span class="line">                cnt2++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 检测元素出现的次数是否满足要求,因为不一定是存在两个数</span></span><br><span class="line">        <span class="keyword">if</span> (votes1 &gt; <span class="number">0</span> &amp;&amp; cnt1 &gt; n / <span class="number">3</span>) &#123;</span><br><span class="line">            ans.<span class="built_in">push_back</span>(element1);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (votes2 &gt; <span class="number">0</span> &amp;&amp; cnt2 &gt; n / <span class="number">3</span>) &#123;</span><br><span class="line">            ans.<span class="built_in">push_back</span>(element2);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>同理，可以使用该代码解决$\lfloor\frac{n}{m}\rfloor$的情况，只需要让备选element和votes的数目为$m-1$即可。</p><hr><h1 id="4-哈希表与前缀和-难理解"><a href="#4-哈希表与前缀和-难理解" class="headerlink" title="4.哈希表与前缀和(难理解)"></a>4.哈希表与前缀和(难理解)</h1><p>前缀思想推荐文章<a href="https://leetcode.cn/problems/continuous-subarray-sum/solutions/562196/de-liao-wo-ba-qian-zhui-he-miao-de-gan-g-c8kp/">【动画模拟】一文秒杀七道题—力扣（LeetCode）</a>,包括前缀和/奇数/积…</p><p><img src="https://s2.loli.net/2024/04/13/3PrTOI5fg9Czw6J.png" alt=""></p><h2 id="4-1-和为K的子数组：560"><a href="#4-1-和为K的子数组：560" class="headerlink" title="4-1.和为K的子数组：560"></a>4-1.和为K的子数组：560</h2><p>法一：枚举(超时)</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">subarraySum</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> right = <span class="number">0</span>; right &lt; nums.<span class="built_in">size</span>(); right++) &#123;</span><br><span class="line">            <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> left = right; left &gt;= <span class="number">0</span>; left--) &#123;</span><br><span class="line">                sum += nums[left];</span><br><span class="line">                <span class="keyword">if</span> (sum == k) &#123;</span><br><span class="line">                    ans++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><p>该题用滑动窗口难以实现，因为存在负数。比如[-2,-1,0,1,2]，k=0。单纯的滑动窗口会使得漏掉[-1,0,1]。转而用动态规划，又容易导致内存溢出。</p></blockquote><p>法二：前缀和+哈希表优化</p><p><img src="https://s2.loli.net/2024/04/13/m1bqx9fNwlX4Ku8.png" alt=""></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">subarraySum</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; mp;<span class="comment">//前缀和，出现次数</span></span><br><span class="line">        mp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> pre = <span class="number">0</span>, ans = <span class="number">0</span>; <span class="comment">// pre记录前缀和</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; num : nums) &#123;</span><br><span class="line">            pre += num;</span><br><span class="line">            <span class="keyword">if</span> (mp.<span class="built_in">find</span>(pre - k) != mp.<span class="built_in">end</span>()) &#123;</span><br><span class="line">                ans += mp[pre - k];</span><br><span class="line">            &#125;</span><br><span class="line">            mp[pre]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>推导和图解详见官方题解。</p><h2 id="4-2-连续的子数组和：523"><a href="#4-2-连续的子数组和：523" class="headerlink" title="4-2.连续的子数组和：523"></a>4-2.连续的子数组和：523</h2><p>前缀和＋哈希表,本题综合性较强。</p><p>详细解答<a href="https://leetcode.cn/problems/continuous-subarray-sum/solutions/808246/gong-shui-san-xie-tuo-zhan-wei-qiu-fang-1juse/">【宫水三叶】拓展到求方案数问题—LeetCode</a></p><p><img src="https://s2.loli.net/2024/04/13/8kMtUX4nupvZQ6z.png" alt=""></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">checkSubarraySum</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span> (n &lt; <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; mp;<span class="comment">//&lt;前缀和%k,索引&gt;</span></span><br><span class="line">        mp[<span class="number">0</span>] = <span class="number">-1</span>;<span class="comment">//因为元素均为非负数，所以前缀和不可能为0，即对应索引为-1无效值</span></span><br><span class="line">        <span class="type">int</span> presum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            presum = (presum + nums[i]) % k;</span><br><span class="line">            <span class="keyword">if</span> (mp.<span class="built_in">count</span>(presum)) &#123;</span><br><span class="line">                <span class="type">int</span> preIdx = mp[presum];</span><br><span class="line">                <span class="keyword">if</span> (i - preIdx &gt;= <span class="number">2</span>) &#123;<span class="comment">//子数组长度至少为2</span></span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                mp[presum] = i;<span class="comment">//注意记录的是索引而不是次数，因为需要比较i-preIdx是否&gt;=2</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>拓展：如果说还要记录下子数组长度，可以使用<code>unordered_map&lt;int,pair&lt;int,int&gt;&gt;mp;//&lt;前缀和%k,pair&lt;索引，长度&gt;&gt;</code>。</p><h2 id="4-3-连续数组：525"><a href="#4-3-连续数组：525" class="headerlink" title="4-3.连续数组：525"></a>4-3.连续数组：525</h2><p>前缀和+哈希表</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findMaxLength</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; mp;</span><br><span class="line">        mp[<span class="number">0</span>] = <span class="number">-1</span>;                 <span class="comment">// 记录索引而非次数</span></span><br><span class="line">        <span class="type">int</span> presum = <span class="number">0</span>, maxLen = <span class="number">0</span>; <span class="comment">// presum记录0/1交替的长度</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="comment">// 在这里可以将1视作1,0视作-1，交替的和就是presum前缀和</span></span><br><span class="line">            <span class="keyword">if</span> (nums[i]) &#123;</span><br><span class="line">                presum++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                presum--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 问题转化为：如何求得最长一段区间和为0的子数组,所以这里的k==0</span></span><br><span class="line">            <span class="keyword">if</span> (mp.<span class="built_in">count</span>(presum)) &#123;</span><br><span class="line">                <span class="type">int</span> preIdx = mp[presum];</span><br><span class="line">                maxLen = <span class="built_in">max</span>(maxLen, i - preIdx);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                mp[presum] = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxLen;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">哈希表部分</summary>
    
    
    
    <category term="leetcode刷题笔记" scheme="https://sumikiru.top/categories/leetcode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="C++" scheme="https://sumikiru.top/tags/C/"/>
    
    <category term="leetcode" scheme="https://sumikiru.top/tags/leetcode/"/>
    
    <category term="哈希表" scheme="https://sumikiru.top/tags/%E5%93%88%E5%B8%8C%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>6.0哈希表篇</title>
    <link href="https://sumikiru.top/posts/5d437c4b.html"/>
    <id>https://sumikiru.top/posts/5d437c4b.html</id>
    <published>2024-06-27T17:08:19.000Z</published>
    <updated>2025-02-06T14:42:00.324Z</updated>
    
    <content type="html"><![CDATA[<h1 id="关于哈希表"><a href="#关于哈希表" class="headerlink" title="关于哈希表"></a>关于哈希表</h1><p><a href="https://zhuanlan.zhihu.com/p/535427115">一文看懂使用C++ STL 中的哈希表—知乎</a></p><h1 id="1-哈希表的查找、插入及删除"><a href="#1-哈希表的查找、插入及删除" class="headerlink" title="1.哈希表的查找、插入及删除"></a>1.哈希表的查找、插入及删除</h1><h2 id="1-1-存在重复元素：217"><a href="#1-1-存在重复元素：217" class="headerlink" title="1-1.存在重复元素：217"></a>1-1.存在重复元素：217</h2><p>法一：排序</p><p><code>sort()</code>的时间复杂度是$O(NlogN)$,空间复杂度为$O(logN)$，因为排序过程中需要递归调用栈空间。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">containsDuplicate</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>() - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] == nums[i + <span class="number">1</span>]) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>法二：哈希表</p><p>时间和空间复杂度均为$O(N)$，set的find()时间复杂度是$O(1)$</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">containsDuplicate</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        unordered_set&lt;<span class="type">int</span>&gt; s;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> x : nums) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s.<span class="built_in">find</span>(x) != s.<span class="built_in">end</span>()) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            s.<span class="built_in">insert</span>(x);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>​    但该题实际上排序比哈希表的执行用时和消耗内存更小，所以时间复杂度不是唯一。哈希表要计算哈希值等，可以理解哈希表时间复杂度常数项比较大。常数不一样，hashset的常数开销大，所以对于非大量的数据来说，常数效应覆盖了时间复杂度的差距。如果把数据量放大，那么随着数据量的增加，hashset方式的时间是线性增加，sort是非线性增加，到一个阈值，则hashset的低时间复杂度的优势才能发挥出来。</p><h2 id="1-2-两个数组的交集：349"><a href="#1-2-两个数组的交集：349" class="headerlink" title="1-2.两个数组的交集：349"></a>1-2.两个数组的交集：349</h2><p>法一：哈希表</p><blockquote><p>如果使用哈希集合存储元素，则可以在 $O(1)$ 的时间内判断一个元素是否在集合中，从而降低时间复杂度。</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">getSets</span><span class="params">(unordered_set&lt;<span class="type">int</span>&gt;&amp; set1, unordered_set&lt;<span class="type">int</span>&gt;&amp; set2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (set1.<span class="built_in">size</span>() &lt; set2.<span class="built_in">size</span>()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">getSets</span>(set2, set1);</span><br><span class="line">        &#125;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; ans;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; num : set1) &#123;</span><br><span class="line">            <span class="keyword">if</span> (set2.<span class="built_in">count</span>(num)) &#123; <span class="comment">// set1中的num，set2也有</span></span><br><span class="line">                ans.<span class="built_in">push_back</span>(num);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">intersection</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums1, vector&lt;<span class="type">int</span>&gt;&amp; nums2)</span> </span>&#123;</span><br><span class="line">        unordered_set&lt;<span class="type">int</span>&gt; set1, set2;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span>&amp; x : nums1) &#123;</span><br><span class="line">            set1.<span class="built_in">insert</span>(x);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span>&amp; x : nums2) &#123;</span><br><span class="line">            set2.<span class="built_in">insert</span>(x);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">getSets</span>(set1, set2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>法二：排序+双指针</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">intersection</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums1, vector&lt;<span class="type">int</span>&gt;&amp; nums2)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">sort</span>(nums1.<span class="built_in">begin</span>(), nums1.<span class="built_in">end</span>());</span><br><span class="line">        <span class="built_in">sort</span>(nums2.<span class="built_in">begin</span>(), nums2.<span class="built_in">end</span>());</span><br><span class="line">        <span class="type">int</span> index1 = <span class="number">0</span>, index2 = <span class="number">0</span>;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; ans;</span><br><span class="line">        <span class="keyword">while</span> (index1 &lt; nums1.<span class="built_in">size</span>() &amp;&amp; index2 &lt; nums2.<span class="built_in">size</span>()) &#123;</span><br><span class="line">            <span class="type">int</span> num1 = nums1[index1], num2 = nums2[index2];</span><br><span class="line">            <span class="keyword">if</span> (num1 == num2) &#123;</span><br><span class="line">                <span class="comment">// 确保加入的元素是唯一的</span></span><br><span class="line">                <span class="keyword">if</span> (!ans.<span class="built_in">size</span>() || num1 != ans.<span class="built_in">back</span>()) &#123;</span><br><span class="line">                    ans.<span class="built_in">emplace_back</span>(num1);</span><br><span class="line">                &#125;</span><br><span class="line">                ++index1;</span><br><span class="line">                ++index2;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (num1 &lt; num2) &#123;</span><br><span class="line">                ++index1;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                ++index2;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>法三：直接使用set,省去排序的步骤。效率和法一差不多</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">intersection</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums1, vector&lt;<span class="type">int</span>&gt;&amp; nums2)</span> </span>&#123;</span><br><span class="line">        set&lt;<span class="type">int</span>&gt; s;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; num : nums1) &#123;</span><br><span class="line">            s.<span class="built_in">insert</span>(num);</span><br><span class="line">        &#125;</span><br><span class="line">        set&lt;<span class="type">int</span>&gt; intersectionSet;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; num : nums2) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s.<span class="built_in">find</span>(num) != s.<span class="built_in">end</span>()) &#123;</span><br><span class="line">                <span class="keyword">if</span> (intersectionSet.<span class="built_in">find</span>(num) == intersectionSet.<span class="built_in">end</span>()) &#123; </span><br><span class="line">                    intersectionSet.<span class="built_in">insert</span>(num);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; ans;</span><br><span class="line">        <span class="keyword">for</span> (set&lt;<span class="type">int</span>&gt;::iterator it = intersectionSet.<span class="built_in">begin</span>();</span><br><span class="line">             it != intersectionSet.<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line">            ans.<span class="built_in">push_back</span>(*it);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="1-3-最长连续序列：128"><a href="#1-3-最长连续序列：128" class="headerlink" title="1-3.最长连续序列：128"></a>1-3.最长连续序列：128</h2><p>法一：哈希表(该题也可以直接用set)</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">longestConsecutive</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        unordered_set&lt;<span class="type">int</span>&gt; s;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span>&amp; num : nums) &#123;</span><br><span class="line">            s.<span class="built_in">insert</span>(num);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; num : s) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!s.<span class="built_in">count</span>(num - <span class="number">1</span>)) &#123; <span class="comment">// 不存在num的前一个数字，重置</span></span><br><span class="line">                <span class="type">int</span> currentNum = num, currentCount = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">while</span> (s.<span class="built_in">count</span>(currentNum + <span class="number">1</span>)) &#123;</span><br><span class="line">                    currentCount++;</span><br><span class="line">                    currentNum++;</span><br><span class="line">                &#125;</span><br><span class="line">                count = <span class="built_in">max</span>(count, currentCount);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><pre><code>注意第9行，如果写作`int&amp; num:s`则会报错，而使用`const int&amp; num:s`/`auto&amp; num:s`/`const auto&amp; num:s`/`auto&amp;&amp; num:s`则不会报错。因为前者将尝试以非const引用的方式访问容器中的元素，而unordered_set中的元素是&lt;mark&gt;只读&lt;/mark&gt;的。Q:但是为什么`int&amp; num:s`不正确，而`auto&amp; num:s`就可以呢？A:可参见[C++中的auto关键字](https://zhuanlan.zhihu.com/p/390608866)，这里auto就相当于T，而这里T相当于是const int.</code></pre><h2 id="1-4-快乐数：202"><a href="#1-4-快乐数：202" class="headerlink" title="1-4.快乐数：202"></a>1-4.快乐数：202</h2><p>法一：哈希表</p><p>需要注意一点：如何解决无限循环这一问题。记录下每次的平方和，当出现重复则说明进入无限循环。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isHappy</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        unordered_set&lt;<span class="type">int</span>&gt; numbers;</span><br><span class="line">        <span class="keyword">while</span> (!numbers.<span class="built_in">count</span>(n)) &#123; <span class="comment">// n没有出现在平方和记录中过</span></span><br><span class="line">            <span class="type">int</span> num = n;</span><br><span class="line">            numbers.<span class="built_in">insert</span>(num);</span><br><span class="line">            n = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (num) &#123;</span><br><span class="line">                <span class="type">int</span> i = num % <span class="number">10</span>;</span><br><span class="line">                num /= <span class="number">10</span>;</span><br><span class="line">                n += i * i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> n == <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>法二：快慢指针（空间复杂度更低，时间复杂度相同，但是实际速度更慢一点）</p><blockquote><p>每次获取下一个平方和的操作，可以认为是在构造一个隐式链表的下一个节点。检测是否进入循环，相当于检测一个链表是否有环，因此可以使用Floyd循环查找算法。</p></blockquote><p>slow每次前进一个节点，fast每次前进两次，这样它们最终将在循环中相遇，while循环中止条件其一即为<code>slow==fast</code>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getNext</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (n) &#123;</span><br><span class="line">            <span class="type">int</span> i = n % <span class="number">10</span>;</span><br><span class="line">            n /= <span class="number">10</span>;</span><br><span class="line">            sum += i * i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isHappy</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> slow = n, fast = <span class="built_in">getNext</span>(n);</span><br><span class="line">        <span class="keyword">while</span> (fast != <span class="number">1</span> &amp;&amp; slow != fast) &#123;</span><br><span class="line">            slow = <span class="built_in">getNext</span>(slow);</span><br><span class="line">            fast = <span class="built_in">getNext</span>(<span class="built_in">getNext</span>(fast));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> fast == <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="1-5-键盘行：500"><a href="#1-5-键盘行：500" class="headerlink" title="1-5.键盘行：500"></a>1-5.键盘行：500</h2><p>法一：遍历</p><p>键盘字母转换为行号。2ms,7.82MB。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;string&gt; <span class="title">findWords</span><span class="params">(vector&lt;string&gt;&amp; words)</span> </span>&#123;</span><br><span class="line">        vector&lt;string&gt; ans;</span><br><span class="line">        string rowIdx = <span class="string">&quot;12210111011122000010020202&quot;</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> &amp; word : words) &#123;</span><br><span class="line">            <span class="type">bool</span> isValid = <span class="literal">true</span>;</span><br><span class="line">            <span class="type">char</span> idx = rowIdx[<span class="built_in">tolower</span>(word[<span class="number">0</span>]) - <span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; word.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">                <span class="keyword">if</span>(rowIdx[<span class="built_in">tolower</span>(word[i]) - <span class="string">&#x27;a&#x27;</span>] != idx) &#123;</span><br><span class="line">                    isValid = <span class="literal">false</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (isValid) &#123;</span><br><span class="line">                ans.<span class="built_in">emplace_back</span>(word);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>法二：哈希表</p><p>4ms,8MB</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;string&gt; <span class="title">findWords</span><span class="params">(vector&lt;string&gt;&amp; words)</span> </span>&#123;</span><br><span class="line">        unordered_set&lt;<span class="type">char</span>&gt; s&#123;<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;s&#x27;</span>, <span class="string">&#x27;d&#x27;</span>, <span class="string">&#x27;f&#x27;</span>, <span class="string">&#x27;g&#x27;</span>, <span class="string">&#x27;h&#x27;</span>, <span class="string">&#x27;j&#x27;</span>, <span class="string">&#x27;k&#x27;</span>, <span class="string">&#x27;l&#x27;</span>&#125;;</span><br><span class="line">        unordered_set&lt;<span class="type">char</span>&gt; s2&#123;<span class="string">&#x27;q&#x27;</span>, <span class="string">&#x27;w&#x27;</span>, <span class="string">&#x27;e&#x27;</span>, <span class="string">&#x27;r&#x27;</span>, <span class="string">&#x27;t&#x27;</span>, <span class="string">&#x27;y&#x27;</span>, <span class="string">&#x27;u&#x27;</span>, <span class="string">&#x27;i&#x27;</span>, <span class="string">&#x27;o&#x27;</span>, <span class="string">&#x27;p&#x27;</span>&#125;;</span><br><span class="line">        unordered_set&lt;<span class="type">char</span>&gt; s3&#123;<span class="string">&#x27;z&#x27;</span>, <span class="string">&#x27;x&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;v&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;n&#x27;</span>, <span class="string">&#x27;m&#x27;</span>&#125;;</span><br><span class="line">        <span class="type">int</span> n = words.<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;string&gt; ans;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; word : words) &#123;</span><br><span class="line">            <span class="type">bool</span> inS1 = <span class="literal">true</span>, inS2 = <span class="literal">true</span>, inS3 = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; c : word) &#123;</span><br><span class="line">                <span class="type">char</span> ch = <span class="built_in">tolower</span>(c); <span class="comment">// 记得转换成小写,注意tolower()返回的是int值</span></span><br><span class="line">                <span class="comment">// 或者写作auto ch = char(tolower(c));</span></span><br><span class="line">                <span class="keyword">if</span> (inS1 &amp;&amp; (s.<span class="built_in">find</span>(ch) == s.<span class="built_in">end</span>())) &#123;</span><br><span class="line">                    inS1 = <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (inS2 &amp;&amp; (s2.<span class="built_in">find</span>(ch) == s2.<span class="built_in">end</span>())) &#123;</span><br><span class="line">                    inS2 = <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (inS3 &amp;&amp; (s3.<span class="built_in">find</span>(ch) == s3.<span class="built_in">end</span>())) &#123;</span><br><span class="line">                    inS3 = <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (inS1 || inS2 || inS3) &#123;</span><br><span class="line">                ans.<span class="built_in">push_back</span>(word);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>法三：正则</p><p>41ms,20.8MB</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isValid</span><span class="params">(string&amp; word)</span> </span>&#123;</span><br><span class="line">        <span class="function">std::regex <span class="title">pattern</span><span class="params">(<span class="string">&quot;^[QqWwEeRrTtYyUuIiOoPp]*$|^[AaSsDdFfGgHhJjKkLl]*$|^[ZzXxCcVvBbNnMm]*$&quot;</span>)</span></span>;</span><br><span class="line">        <span class="keyword">if</span> (std::<span class="built_in">regex_match</span>(word, pattern)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">vector&lt;string&gt; <span class="title">findWords</span><span class="params">(vector&lt;string&gt;&amp; words)</span> </span>&#123;</span><br><span class="line">        vector&lt;string&gt; ans;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; word : words) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">isValid</span>(word)) &#123;</span><br><span class="line">                ans.<span class="built_in">emplace_back</span>(word);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2024/03/28/86NXqkOvRoCaFux.png" alt="chrome_oAb79KjUWh"></p><h2 id="1-6-单词规律：290"><a href="#1-6-单词规律：290" class="headerlink" title="1-6.单词规律：290"></a>1-6.单词规律：290</h2><p>由于要记录string和char，所以需要使用map而不是set.</p><p>注意：pattern=”abba”,s=”dog dog dog dog”时，应该输出false.所以不止要记录char-&gt;string,还要记录string-&gt;char.</p><p>pattern=”aaa”,s=”aa aa aa aa”时，应该输出false.所以最终不能单纯返回true,而是返回长度比较。</p><p>官方解答：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">wordPattern</span><span class="params">(string pattern, string str)</span> </span>&#123;</span><br><span class="line">        unordered_map&lt;string, <span class="type">char</span>&gt; str2ch;</span><br><span class="line">        unordered_map&lt;<span class="type">char</span>, string&gt; ch2str;</span><br><span class="line">        <span class="type">int</span> m = str.<span class="built_in">length</span>();</span><br><span class="line">        <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> ch : pattern) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i &gt;= m) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">int</span> j = i;</span><br><span class="line">            <span class="keyword">while</span> (j &lt; m &amp;&amp; str[j] != <span class="string">&#x27; &#x27;</span>) j++;</span><br><span class="line">            <span class="type">const</span> string &amp;tmp = str.<span class="built_in">substr</span>(i, j - i);</span><br><span class="line">            <span class="keyword">if</span> (str2ch.<span class="built_in">count</span>(tmp) &amp;&amp; str2ch[tmp] != ch) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (ch2str.<span class="built_in">count</span>(ch) &amp;&amp; ch2str[ch] != tmp) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            str2ch[tmp] = ch;</span><br><span class="line">            ch2str[ch] = tmp;</span><br><span class="line">            i = j + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> i &gt;= m;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>类似题：同构字符串205（更简单，因为都是一对一字符且无空格）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isIsomorphic</span><span class="params">(string s, string t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (s.<span class="built_in">length</span>() != t.<span class="built_in">length</span>()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        unordered_map&lt;<span class="type">char</span>, <span class="type">char</span>&gt; s2t;</span><br><span class="line">        unordered_map&lt;<span class="type">char</span>, <span class="type">char</span>&gt; t2s;</span><br><span class="line">        <span class="type">int</span> n = s.<span class="built_in">length</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="type">char</span> ch = s[i], ch2 = t[i];</span><br><span class="line">            <span class="keyword">if</span> (s2t.<span class="built_in">count</span>(ch) &amp;&amp; s2t[ch] != ch2) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (t2s.<span class="built_in">count</span>(ch2) &amp;&amp; t2s[ch2] != ch) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            s2t[ch] = ch2;</span><br><span class="line">            t2s[ch2] = ch;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="1-7-数组中的k-diff数对：532"><a href="#1-7-数组中的k-diff数对：532" class="headerlink" title="1-7.数组中的k-diff数对：532"></a>1-7.数组中的k-diff数对：532</h2><p>法一：哈希表</p><p>res放入的是每次数对中较小的那个数，unordered_set可以起到去重的一个作用，这样可以很容易地处理k=0时的情况。multiset记录nums/常数res记录最终答案，都在处理k=0时比较复杂。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findPairs</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        unordered_set&lt;<span class="type">int</span>&gt; visited;</span><br><span class="line">        unordered_set&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> num : nums) &#123;</span><br><span class="line">            <span class="keyword">if</span> (visited.<span class="built_in">count</span>(num - k)) &#123;</span><br><span class="line">                res.<span class="built_in">emplace</span>(num - k);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (visited.<span class="built_in">count</span>(num + k)) &#123;</span><br><span class="line">                res.<span class="built_in">emplace</span>(num);</span><br><span class="line">            &#125;</span><br><span class="line">            visited.<span class="built_in">emplace</span>(num);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res.<span class="built_in">size</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>法二：数组排序+双指针</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findPairs</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());</span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">size</span>(), res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>; i &lt; n &amp;&amp; j &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i == <span class="number">0</span> || nums[i - <span class="number">1</span>] != nums[i]) &#123;</span><br><span class="line">                <span class="keyword">while</span> (j &lt; n &amp;&amp; (nums[j] &lt; nums[i] + k || j &lt;= i)) &#123;</span><br><span class="line">                    j++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (j &lt; n &amp;&amp; nums[j] == nums[i] + k) &#123;</span><br><span class="line">                    res++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="1-8-统计重复个数：466（困难）"><a href="#1-8-统计重复个数：466（困难）" class="headerlink" title="1-8.统计重复个数：466（困难）"></a>1-8.统计重复个数：466（困难）</h2><p>法一：暴力法（超时）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getMaxRepetitions</span><span class="params">(string s1, <span class="type">int</span> n1, string s2, <span class="type">int</span> n2)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> index = <span class="number">0</span>, repeat_count = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> s1_size = s1.<span class="built_in">size</span>(), s2_size = s2.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n1; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; s1_size; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (s1[j] == s2[index]) &#123;</span><br><span class="line">                    index++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (index == s2_size) &#123;</span><br><span class="line">                    index = <span class="number">0</span>;</span><br><span class="line">                    repeat_count++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> repeat_count / n2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>法二：找出循环节</p><p>详见官方视频讲解。使用<code>unordered_map&lt;int,pair&lt;int,int&gt;&gt;&gt;</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getMaxRepetitions</span><span class="params">(string s1, <span class="type">int</span> n1, string s2, <span class="type">int</span> n2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n1 == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> s1cnt = <span class="number">0</span>, index = <span class="number">0</span>, s2cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// recall 是我们用来找循环节的变量，它是一个哈希映射</span></span><br><span class="line">        <span class="comment">// 我们如何找循环节？假设我们遍历了 s1cnt 个 s1，此时匹配到了第 s2cnt 个 s2 中的第 index 个字符</span></span><br><span class="line">        <span class="comment">// 如果我们之前遍历了 s1cnt&#x27; 个 s1 时，匹配到的是第 s2cnt&#x27; 个 s2 中同样的第 index 个字符，那么就有循环节了</span></span><br><span class="line">        <span class="comment">// 我们用 (s1cnt&#x27;, s2cnt&#x27;, index) 和 (s1cnt, s2cnt, index) 表示两次包含相同 index 的匹配结果</span></span><br><span class="line">        <span class="comment">// 那么哈希映射中的键就是 index，值就是 (s1cnt&#x27;, s2cnt&#x27;) 这个二元组</span></span><br><span class="line">        <span class="comment">// 循环节就是；</span></span><br><span class="line">        <span class="comment">//    - 前 s1cnt&#x27; 个 s1 包含了 s2cnt&#x27; 个 s2</span></span><br><span class="line">        <span class="comment">//    - 以后的每 (s1cnt - s1cnt&#x27;) 个 s1 包含了 (s2cnt - s2cnt&#x27;) 个 s2</span></span><br><span class="line">        <span class="comment">// 那么还会剩下 (n1 - s1cnt&#x27;) % (s1cnt - s1cnt&#x27;) 个 s1, 我们对这些与 s2 进行暴力匹配</span></span><br><span class="line">        <span class="comment">// 注意 s2 要从第 index 个字符开始匹配</span></span><br><span class="line">        unordered_map&lt;<span class="type">int</span>, pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt; recall;</span><br><span class="line">        pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; pre_loop, in_loop;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="comment">// 我们多遍历一个 s1，看看能不能找到循环节</span></span><br><span class="line">            ++s1cnt;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">char</span> ch: s1) &#123;</span><br><span class="line">                <span class="keyword">if</span> (ch == s2[index]) &#123;</span><br><span class="line">                    index += <span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">if</span> (index == s2.<span class="built_in">size</span>()) &#123;</span><br><span class="line">                        ++s2cnt;</span><br><span class="line">                        index = <span class="number">0</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 还没有找到循环节，所有的 s1 就用完了</span></span><br><span class="line">            <span class="keyword">if</span> (s1cnt == n1) &#123;</span><br><span class="line">                <span class="keyword">return</span> s2cnt / n2;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 出现了之前的 index，表示找到了循环节</span></span><br><span class="line">            <span class="keyword">if</span> (recall.<span class="built_in">count</span>(index)) &#123;</span><br><span class="line">                <span class="keyword">auto</span> [s1cnt_prime, s2cnt_prime] = recall[index];</span><br><span class="line">                <span class="comment">// 前 s1cnt&#x27; 个 s1 包含了 s2cnt&#x27; 个 s2</span></span><br><span class="line">                pre_loop = &#123;s1cnt_prime, s2cnt_prime&#125;;</span><br><span class="line">                <span class="comment">// 以后的每 (s1cnt - s1cnt&#x27;) 个 s1 包含了 (s2cnt - s2cnt&#x27;) 个 s2</span></span><br><span class="line">                in_loop = &#123;s1cnt - s1cnt_prime, s2cnt - s2cnt_prime&#125;;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                recall[index] = &#123;s1cnt, s2cnt&#125;;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// ans 存储的是 S1 包含的 s2 的数量，考虑的之前的 pre_loop 和 in_loop</span></span><br><span class="line">        <span class="type">int</span> ans = pre_loop.second + (n1 - pre_loop.first) / in_loop.first * in_loop.second;</span><br><span class="line">        <span class="comment">// S1 的末尾还剩下一些 s1，我们暴力进行匹配</span></span><br><span class="line">        <span class="type">int</span> rest = (n1 - pre_loop.first) % in_loop.first;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; rest; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">char</span> ch: s1) &#123;</span><br><span class="line">                <span class="keyword">if</span> (ch == s2[index]) &#123;</span><br><span class="line">                    ++index;</span><br><span class="line">                    <span class="keyword">if</span> (index == s2.<span class="built_in">size</span>()) &#123;</span><br><span class="line">                        ++ans;</span><br><span class="line">                        index = <span class="number">0</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// S1 包含 ans 个 s2，那么就包含 ans / n2 个 S2</span></span><br><span class="line">        <span class="keyword">return</span> ans / n2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="1-9-随机链表的复制：138"><a href="#1-9-随机链表的复制：138" class="headerlink" title="1-9.随机链表的复制：138"></a>1-9.随机链表的复制：138</h2><p>注意题干要求，返回的是原链表的深拷贝，不能直接<code>return head;</code></p><blockquote><p>深拷贝与浅拷贝的区别：</p><pre><code>当出现类的等号赋值时，会调用拷贝函数，在未定义显示拷贝构造函数的情况下，系统会调用**默认的拷贝函数－即浅拷贝**，它能够完成成员的一一复制。当数据成员中&lt;u&gt;没有指针&lt;/u&gt;时，浅拷贝是可行的。但当数据成员中有指针时，如果采用简单的浅拷贝，则两类中的两个指针指向同一个地址，当对象快要结束时，会调用两次析构函数，而导致**野指针**的问题。所以，这时必需采用深拷贝。深拷贝与浅拷贝之间的区别就在于深拷贝会在堆内存中**另外申请空间来存储数据**，从而也就解决来野指针的问题。简而言之，当数据成员中**有指针**时，必须要用深拷贝更加安全。</code></pre></blockquote><p>法一：回溯+哈希表+递归</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">// Definition for a Node.</span></span><br><span class="line"><span class="comment">class Node &#123;</span></span><br><span class="line"><span class="comment">public:</span></span><br><span class="line"><span class="comment">    int val;</span></span><br><span class="line"><span class="comment">    Node* next;</span></span><br><span class="line"><span class="comment">    Node* random;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    Node(int _val) &#123;</span></span><br><span class="line"><span class="comment">        val = _val;</span></span><br><span class="line"><span class="comment">        next = NULL;</span></span><br><span class="line"><span class="comment">        random = NULL;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    unordered_map&lt;Node*, Node*&gt; cachedNode;</span><br><span class="line">    <span class="function">Node* <span class="title">copyRandomList</span><span class="params">(Node* head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!cachedNode.<span class="built_in">count</span>(head)) &#123;</span><br><span class="line">            Node* temp = <span class="keyword">new</span> <span class="built_in">Node</span>(head-&gt;val);</span><br><span class="line">            cachedNode[head] = temp;</span><br><span class="line">            temp-&gt;next = <span class="built_in">copyRandomList</span>(head-&gt;next);</span><br><span class="line">            temp-&gt;random = <span class="built_in">copyRandomList</span>(head-&gt;random);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cachedNode[head];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>法二：迭代+节点拆分</p><p>详见官方图解。简而言之是将A-&gt;B-&gt;C拆分为A-&gt;A’-&gt;B-&gt;B’-&gt;C-&gt;C’，再变成A’-&gt;B’-&gt;C’。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">Node* <span class="title">copyRandomList</span><span class="params">(Node* head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (Node* node = head; node != <span class="literal">nullptr</span>; node = node-&gt;next-&gt;next) &#123;</span><br><span class="line">            Node* temp = <span class="keyword">new</span> <span class="built_in">Node</span>(node-&gt;val);</span><br><span class="line">            temp-&gt;next = node-&gt;next;</span><br><span class="line">            node-&gt;next = temp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (Node* node = head; node != <span class="literal">nullptr</span>; node = node-&gt;next-&gt;next) &#123;</span><br><span class="line">            Node* temp = node-&gt;next;</span><br><span class="line">            temp-&gt;random = node-&gt;random ? node-&gt;random-&gt;next : <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Node* headNew = head-&gt;next;</span><br><span class="line">        <span class="keyword">for</span> (Node* node = head; node; node = node-&gt;next) &#123;</span><br><span class="line">            Node* temp = node-&gt;next;</span><br><span class="line">            node-&gt;next = node-&gt;next-&gt;next;</span><br><span class="line">            temp-&gt;next = temp-&gt;next ? temp-&gt;next-&gt;next : <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> headNew;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="1-10-分数到小数：166"><a href="#1-10-分数到小数：166" class="headerlink" title="1-10.分数到小数：166"></a>1-10.分数到小数：166</h2><p>参考《2.1字符串篇(2)》。进阶：<a href="https://leetcode.cn/problems/fraction-to-recurring-decimal/solutions/2486619/wu-xu-ha-xi-gua-yong-yu-ren-yi-jin-zhi-d-0cv7/">无需哈希 + 适用于任意进制的分数到小数—leetcode</a></p><hr><h1 id="2-哈希表与索引"><a href="#2-哈希表与索引" class="headerlink" title="2.哈希表与索引"></a>2.哈希表与索引</h1><h2 id="2-1-两数之和：1"><a href="#2-1-两数之和：1" class="headerlink" title="2-1.两数之和：1"></a>2-1.两数之和：1</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">twoSum</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; hashtable;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="keyword">auto</span> it = hashtable.<span class="built_in">find</span>(target - nums[i]);</span><br><span class="line">            <span class="keyword">if</span> (it != hashtable.<span class="built_in">end</span>()) &#123;</span><br><span class="line">                <span class="keyword">return</span> &#123;it-&gt;second, i&#125;;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 没有找到，则插入该数字</span></span><br><span class="line">            hashtable[nums[i]] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> &#123;&#125;; <span class="comment">// 必须要有一个返回内容</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><p>哈希表的find()函数返回的是迭代器类型。</p></blockquote><h2 id="2-2-两数之和II—输入有序数组：167"><a href="#2-2-两数之和II—输入有序数组：167" class="headerlink" title="2-2.两数之和II—输入有序数组：167"></a>2-2.两数之和II—输入有序数组：167</h2><p>该题要求空间复杂度为$O(1)$，所以不能使用哈希表。</p><p>法一：二分查找</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">twoSum</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; numbers, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; numbers.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            <span class="type">int</span> low = i + <span class="number">1</span>, high = numbers.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span> (low &lt;= high) &#123;</span><br><span class="line">                <span class="type">int</span> mid = (high - low) / <span class="number">2</span> + low;</span><br><span class="line">                <span class="keyword">if</span> (numbers[mid] == target - numbers[i]) &#123;</span><br><span class="line">                    <span class="keyword">return</span> &#123;i + <span class="number">1</span>, mid + <span class="number">1</span>&#125;;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (numbers[mid] &gt; target - numbers[i]) &#123;</span><br><span class="line">                    high = mid - <span class="number">1</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    low = mid + <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> &#123;<span class="number">-1</span>, <span class="number">-1</span>&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>法二：双指针（最优）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">twoSum</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; numbers, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> low = <span class="number">0</span>, high = numbers.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (numbers[low] + numbers[high] != target &amp;&amp; low &lt; high) &#123;</span><br><span class="line">            <span class="keyword">if</span> (numbers[low] + numbers[high] &lt; target) &#123;</span><br><span class="line">                low++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                high--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> &#123;low + <span class="number">1</span>, high + <span class="number">1</span>&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="2-3-存在重复元素II：219"><a href="#2-3-存在重复元素II：219" class="headerlink" title="2-3.存在重复元素II：219"></a>2-3.存在重复元素II：219</h2><p>法一：哈希表</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">containsNearbyDuplicate</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; index; <span class="comment">//&lt;值num，索引i&gt;</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (index.<span class="built_in">count</span>(nums[i]) &amp;&amp; i - index[nums[i]] &lt;= k) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            index[nums[i]] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>法二：滑动窗口</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">containsNearbyDuplicate</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        unordered_set&lt;<span class="type">int</span>&gt; s;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i &gt; k) &#123;</span><br><span class="line">                s.<span class="built_in">erase</span>(nums[i - k - <span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (s.<span class="built_in">count</span>(nums[i])) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            s.<span class="built_in">emplace</span>(nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="2-4-存在重复元素III：220（困难）"><a href="#2-4-存在重复元素III：220（困难）" class="headerlink" title="2-4.存在重复元素III：220（困难）"></a>2-4.存在重复元素III：220（困难）</h2><p>法一：滑动窗口+有序集合</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">containsNearbyAlmostDuplicate</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> indexDiff, <span class="type">int</span> valueDiff)</span> </span>&#123;</span><br><span class="line">        set&lt;<span class="type">int</span>&gt; s;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="type">int</span> leftBoundary = <span class="built_in">max</span>(nums[i], INT_MIN + valueDiff) - valueDiff;</span><br><span class="line">            <span class="type">int</span> rightBoundary = <span class="built_in">min</span>(nums[i], INT_MAX - valueDiff) + valueDiff;</span><br><span class="line">            <span class="keyword">auto</span> it = s.<span class="built_in">lower_bound</span>(leftBoundary);</span><br><span class="line">            <span class="keyword">if</span> (it != s.<span class="built_in">end</span>() &amp;&amp; *it &lt;= rightBoundary) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            s.<span class="built_in">insert</span>(nums[i]);</span><br><span class="line">            <span class="keyword">if</span> (i &gt;= indexDiff) &#123;</span><br><span class="line">                s.<span class="built_in">erase</span>(nums[i - indexDiff]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><pre><code>`s.lower_bound(leftBoundary)`将返回第一个&gt;=leftBoundary的元素的迭代器，如果未找到，则返回一个指向末尾的迭代器。</code></pre><p>法二：滑动窗口+哈希表+桶排序（最优解）</p><pre><code>使用set时，插入或者删除一次元素的时间复杂度为$O(log(min(n,IndexDiff)))$，哈希表＋桶排序则为$O(1)$。</code></pre><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getIndex</span><span class="params">(<span class="type">int</span> x, <span class="type">long</span> w)</span> </span>&#123; </span><br><span class="line">        <span class="keyword">return</span> x &lt; <span class="number">0</span> ? (x + <span class="number">1ll</span>) / w - <span class="number">1</span> : x / w; </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">containsNearbyAlmostDuplicate</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> indexDiff, <span class="type">int</span> valueDiff)</span> </span>&#123;</span><br><span class="line">        unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; mp;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="type">long</span> x = nums[i]; <span class="comment">// long存储避免溢出</span></span><br><span class="line">            <span class="type">int</span> index = <span class="built_in">getIndex</span>(x, valueDiff + <span class="number">1ll</span>);</span><br><span class="line">            <span class="keyword">if</span> (mp.<span class="built_in">count</span>(index) ||</span><br><span class="line">                mp.<span class="built_in">count</span>(index - <span class="number">1</span>) &amp;&amp; <span class="built_in">abs</span>(x - mp[index - <span class="number">1</span>]) &lt;= valueDiff ||</span><br><span class="line">                mp.<span class="built_in">count</span>(index + <span class="number">1</span>) &amp;&amp; <span class="built_in">abs</span>(x - mp[index + <span class="number">1</span>]) &lt;= valueDiff) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            mp[index] = x;</span><br><span class="line">            <span class="keyword">if</span> (i &gt;= indexDiff) &#123;</span><br><span class="line">                mp.<span class="built_in">erase</span>(<span class="built_in">getIndex</span>(nums[i - indexDiff], valueDiff + <span class="number">1ll</span>));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">哈希表部分</summary>
    
    
    
    <category term="leetcode刷题笔记" scheme="https://sumikiru.top/categories/leetcode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="C++" scheme="https://sumikiru.top/tags/C/"/>
    
    <category term="leetcode" scheme="https://sumikiru.top/tags/leetcode/"/>
    
    <category term="哈希表" scheme="https://sumikiru.top/tags/%E5%93%88%E5%B8%8C%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>5.链表篇</title>
    <link href="https://sumikiru.top/posts/f83528c7.html"/>
    <id>https://sumikiru.top/posts/f83528c7.html</id>
    <published>2024-05-29T15:15:38.000Z</published>
    <updated>2025-02-06T14:42:00.324Z</updated>
    
    <content type="html"><![CDATA[<h1 id="关于链表"><a href="#关于链表" class="headerlink" title="关于链表"></a>关于链表</h1><p>各种方法的详细实现：<a href="https://zhuanlan.zhihu.com/p/136177205">链表的基本实现—知乎</a></p><p>理论基础：<a href="https://programmercarl.com/%E9%93%BE%E8%A1%A8%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80.html#%E9%93%BE%E8%A1%A8%E7%9A%84%E7%B1%BB%E5%9E%8B">链表—代码随想录</a></p><p>单链表：</p><h5 id="1-构建单链表"><a href="#1-构建单链表" class="headerlink" title="(1)构建单链表"></a>(1)构建单链表</h5><p><img src="https://s2.loli.net/2024/03/18/WMjm4zDaEThZYCe.png" alt="firefox_BIFDvSSmwv"></p><blockquote><p>注：<a href="https://zhuanlan.zhihu.com/p/360838187">单链表、循环链表、双链表的表示与实现—知乎</a></p><p><img src="C:\Users\huangjiakun\Pictures\ShareX\Screenshots\2024-03\firefox_MoglKjc02n.png" alt="firefox_MoglKjc02n"></p><p>双链表，循环链表原理：</p><p><img src="https://s2.loli.net/2024/03/18/te68uaFDYIHikJK.png" alt="firefox_paniklnKLw"></p><p><img title="" src="https://s2.loli.net/2024/03/18/BHoimFhuCv2aPEf.png" alt="firefox_qID1ULZZiK" width="307"></p></blockquote><p>定义并实现一个带表头结点的通用单链表类LinkList,该单链表类可以适用于整数、实数和字符数据等。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Node</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Node&lt;T&gt; *next;</span><br><span class="line">    Node&lt;T&gt; *prev;</span><br><span class="line">    T data;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">List</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">List</span>();<span class="comment">//默认构造函数</span></span><br><span class="line">    <span class="built_in">List</span>(<span class="type">const</span> List&amp; ln);<span class="comment">//拷贝构造函数</span></span><br><span class="line">    ~<span class="built_in">List</span>();<span class="comment">//析构函数</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(T e)</span></span>;<span class="comment">//向链表添加数据</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">ascSort</span><span class="params">()</span></span>;<span class="comment">//升序排序</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">remove</span><span class="params">(T index)</span></span>;<span class="comment">//移除某个结点</span></span><br><span class="line">    <span class="function">T <span class="title">find</span><span class="params">(<span class="type">int</span> index)</span></span>;<span class="comment">//查找结点</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isEmpty</span><span class="params">()</span></span>;<span class="comment">//判断是否为空</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">size</span><span class="params">()</span></span>;<span class="comment">//链表长度</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">show</span><span class="params">()</span></span>;<span class="comment">//显示链表</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">resShow</span><span class="params">()</span></span>;<span class="comment">//链表反向显示</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">removeAll</span><span class="params">()</span></span>;<span class="comment">//删除全部结点</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Node&lt;T&gt; *head;</span><br><span class="line">    Node&lt;T&gt; *tail;</span><br><span class="line">    <span class="type">int</span> length;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>定义单链表结构。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 单链表</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">ListNode</span> &#123;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    ListNode* next;</span><br><span class="line">    <span class="built_in">ListNode</span>() : <span class="built_in">val</span>(<span class="number">0</span>), <span class="built_in">next</span>(<span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line">    <span class="built_in">ListNode</span>(<span class="type">int</span> x) : <span class="built_in">val</span>(x), <span class="built_in">next</span>(<span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line">    <span class="built_in">ListNode</span>(<span class="type">int</span> x, ListNode* next) : <span class="built_in">val</span>(x), <span class="built_in">next</span>(next) &#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2024/03/18/EhoWkd7a1cDKniT.png" alt="firefox_1qQZVGZHEf"></p><h5 id="2-构造函数"><a href="#2-构造函数" class="headerlink" title="(2)构造函数"></a>(2)构造函数</h5><p>默认构造函数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">List&lt;T&gt;::<span class="built_in">List</span>()</span><br><span class="line">&#123;</span><br><span class="line">    head = <span class="keyword">new</span> Node&lt;T&gt;;</span><br><span class="line">    tail = <span class="keyword">new</span> Node&lt;T&gt;;</span><br><span class="line">    head-&gt;next = tail;</span><br><span class="line">    head-&gt;prev = <span class="literal">nullptr</span>;</span><br><span class="line">    tail-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">    tail-&gt;prev = head;</span><br><span class="line">    length = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>拷贝构造函数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">List&lt;T&gt;::<span class="built_in">List</span>(<span class="type">const</span> List &amp;ln)</span><br><span class="line">&#123;</span><br><span class="line">    head = <span class="keyword">new</span> Node&lt;T&gt;;</span><br><span class="line">    head-&gt;prev = <span class="literal">nullptr</span>;</span><br><span class="line">    tail = <span class="keyword">new</span> Node&lt;T&gt;;</span><br><span class="line">    head-&gt;next = tail;</span><br><span class="line">    tail-&gt;prev = head;</span><br><span class="line">    length = <span class="number">0</span>;</span><br><span class="line">    Node&lt;T&gt;* temp = ln.head;</span><br><span class="line">    <span class="keyword">while</span> (temp-&gt;next != ln.tail)</span><br><span class="line">    &#123;</span><br><span class="line">        temp = temp-&gt;next;</span><br><span class="line">        tail-&gt;data = temp-&gt;data;</span><br><span class="line">        Node&lt;T&gt; *p = <span class="keyword">new</span> Node&lt;T&gt;;</span><br><span class="line">        p-&gt;prev = tail;</span><br><span class="line">        tail-&gt;next = p;</span><br><span class="line">        tail = p;</span><br><span class="line">        length++;</span><br><span class="line">    &#125;</span><br><span class="line">    tail-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="3-增：向链表添加数据-添加结点"><a href="#3-增：向链表添加数据-添加结点" class="headerlink" title="(3)增：向链表添加数据(添加结点)"></a>(3)增：向链表添加数据(添加结点)</h5><p><img src="https://s2.loli.net/2024/03/18/i8vzp4xsoSYVDQB.png" alt="firefox_DUiQ0BKvOa"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">void</span> List&lt;T&gt;::<span class="built_in">add</span>(T e)</span><br><span class="line">&#123;</span><br><span class="line">    Node&lt;T&gt;* temp = <span class="keyword">this</span>-&gt;tail;</span><br><span class="line">    tail-&gt;data = e;</span><br><span class="line">    tail-&gt;next = <span class="keyword">new</span> Node&lt;T&gt;;</span><br><span class="line">    Node&lt;T&gt; *p = tail;</span><br><span class="line">    tail = tail-&gt;next;</span><br><span class="line">    tail-&gt;prev = p;</span><br><span class="line">    tail-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">    length++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="4-查：查找结点"><a href="#4-查：查找结点" class="headerlink" title="(4)查：查找结点"></a>(4)查：查找结点</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">T List&lt;T&gt;::<span class="built_in">find</span>(<span class="type">int</span> index)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (length == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;List is empty&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (index &gt;= length)</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Out of bounds&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> x = <span class="number">0</span>;</span><br><span class="line">    T data;</span><br><span class="line">    Node&lt;T&gt; *p;</span><br><span class="line">    <span class="keyword">if</span> (index &lt; length / <span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        p = head-&gt;next;</span><br><span class="line">        <span class="keyword">while</span> (p-&gt;next != <span class="literal">nullptr</span> &amp;&amp; x++ != index)</span><br><span class="line">        &#123;</span><br><span class="line">            p = p-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        p = tail-&gt;prev;</span><br><span class="line">        <span class="keyword">while</span> (p-&gt;prev != <span class="literal">nullptr</span> &amp;&amp; x++ != index)</span><br><span class="line">        &#123;</span><br><span class="line">            p = p-&gt;prev;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> p-&gt;data;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="5-删：删除结点"><a href="#5-删：删除结点" class="headerlink" title="(5)删：删除结点"></a>(5)删：删除结点</h5><p><img src="https://s2.loli.net/2024/03/18/r6Y9Jvz1OqPSHB8.png" alt="firefox_uXUFIzsll9"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">void</span> List&lt;T&gt;::<span class="built_in">remove</span>(T index)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (length == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;List is empty&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Node&lt;T&gt; *p = head;</span><br><span class="line">    <span class="keyword">while</span> (p-&gt;next != <span class="literal">nullptr</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">        <span class="keyword">if</span> (p-&gt;data == index)</span><br><span class="line">        &#123;</span><br><span class="line">            Node&lt;T&gt; *temp = p-&gt;prev;</span><br><span class="line">            temp-&gt;next = p-&gt;next;</span><br><span class="line">            p-&gt;next-&gt;prev = temp;</span><br><span class="line">            <span class="keyword">delete</span> p;</span><br><span class="line">            length--;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="6-删除所有结点"><a href="#6-删除所有结点" class="headerlink" title="(6)删除所有结点"></a>(6)删除所有结点</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">void</span> List&lt;T&gt;::<span class="built_in">removeAll</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (length == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Node&lt;T&gt; *p = head-&gt;next;</span><br><span class="line">    <span class="keyword">while</span> (p != tail)</span><br><span class="line">    &#123;</span><br><span class="line">        Node&lt;T&gt;* temp = p;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">        <span class="keyword">delete</span> temp;</span><br><span class="line">    &#125;</span><br><span class="line">    head-&gt;next = tail;</span><br><span class="line">    tail-&gt;prev = head;</span><br><span class="line">    length = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="7-升序排序"><a href="#7-升序排序" class="headerlink" title="(7)升序排序"></a>(7)升序排序</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">void</span> List&lt;T&gt;::<span class="built_in">ascSort</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (length &lt;= <span class="number">1</span>) <span class="keyword">return</span>;</span><br><span class="line">    Node&lt;T&gt; *p = head-&gt;next;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; length - <span class="number">1</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        Node&lt;T&gt; *q = p-&gt;next;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = i + <span class="number">1</span>; j &lt; length; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (p-&gt;data &gt; q-&gt;data)</span><br><span class="line">            &#123;</span><br><span class="line">                T temp = q-&gt;data;</span><br><span class="line">                q-&gt;data = p-&gt;data;</span><br><span class="line">                p-&gt;data = temp;</span><br><span class="line">            &#125;</span><br><span class="line">            q = q-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="8-判断是否为空"><a href="#8-判断是否为空" class="headerlink" title="(8)判断是否为空"></a>(8)判断是否为空</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">bool</span> List&lt;T&gt;::<span class="built_in">isEmpty</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> length == <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="9-获取链表长度"><a href="#9-获取链表长度" class="headerlink" title="(9)获取链表长度"></a>(9)获取链表长度</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">int</span> List&lt;T&gt;::<span class="built_in">size</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> length;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="10-输出链表"><a href="#10-输出链表" class="headerlink" title="(10)输出链表"></a>(10)输出链表</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">void</span> List&lt;T&gt;::<span class="built_in">show</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (length == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;List is empty&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Node&lt;T&gt; *p = head-&gt;next;</span><br><span class="line">    <span class="keyword">while</span> (p != tail)</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; p-&gt;data &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="11-反向输出链表"><a href="#11-反向输出链表" class="headerlink" title="(11)反向输出链表"></a>(11)反向输出链表</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">void</span> List&lt;T&gt;::<span class="built_in">resShow</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (length == <span class="number">0</span>)<span class="keyword">return</span>;</span><br><span class="line">    Node&lt;T&gt; *p = tail-&gt;prev;</span><br><span class="line">    <span class="keyword">while</span> (p != head)</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; p-&gt;data &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        p = p-&gt;prev;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="12-析构函数"><a href="#12-析构函数" class="headerlink" title="(12)析构函数"></a>(12)析构函数</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">List&lt;T&gt;::~<span class="built_in">List</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (length == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">delete</span> head;</span><br><span class="line">        <span class="keyword">delete</span> tail;</span><br><span class="line">        head = <span class="literal">nullptr</span>;</span><br><span class="line">        tail = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (head-&gt;next != <span class="literal">nullptr</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        Node&lt;T&gt; *temp = head;</span><br><span class="line">        head = head-&gt;next;</span><br><span class="line">        <span class="keyword">delete</span> temp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">delete</span> head;</span><br><span class="line">    head = <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="1-链表的删除"><a href="#1-链表的删除" class="headerlink" title="1.链表的删除"></a>1.链表的删除</h1><h4 id="1-1-移除链表元素：203"><a href="#1-1-移除链表元素：203" class="headerlink" title="1-1.移除链表元素：203"></a>1-1.移除链表元素：203</h4><p>法一：递归</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">removeElements</span><span class="params">(ListNode* head, <span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="literal">nullptr</span>) &#123;  <span class="comment">//递归终止条件:当前结点为空</span></span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line">        head-&gt;next = <span class="built_in">removeElements</span>(head-&gt;next, val);</span><br><span class="line">        <span class="keyword">return</span> head-&gt;val == val ? head-&gt;next : head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>法二：迭代</p><p>哑节点dummyHead，用来放置在head的前面(<code>dummyHead-&gt;next = head</code>)，用来解决头节点head可能被删除的情况。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">removeElements</span><span class="params">(ListNode* head, <span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">        ListNode* DummyHead = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">0</span>, head);</span><br><span class="line">        ListNode* temp = DummyHead; <span class="comment">// 对应当前节点的临时节点</span></span><br><span class="line">        <span class="keyword">while</span> (temp-&gt;next) &#123;</span><br><span class="line">            <span class="keyword">if</span> (temp-&gt;next-&gt;val == val) &#123;</span><br><span class="line">                temp-&gt;next = temp-&gt;next-&gt;next;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                temp = temp-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> DummyHead-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="1-2-删除链表中的节点：237"><a href="#1-2-删除链表中的节点：237" class="headerlink" title="1-2.删除链表中的节点：237"></a>1-2.删除链表中的节点：237</h4><pre><code>删除链表中的节点的常见的方法是定位到待删除节点的上一个节点，修改上一个节点的 next 指针，使其指向待删除节点的下一个节点，即可完成删除操作。而这道题中，无法定位到该节点的上一个节点，因此需要换一种方式。</code></pre><p>和下一节点交换：(将要删除节点的值变为其next节点，然后将next节点删除)</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">deleteNode</span><span class="params">(ListNode* node)</span> </span>&#123;</span><br><span class="line">        node-&gt;val = node-&gt;next-&gt;val;</span><br><span class="line">        node-&gt;next = node-&gt;next-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="1-3-删除链表的第N个节点：19"><a href="#1-3-删除链表的第N个节点：19" class="headerlink" title="1-3.删除链表的第N个节点：19"></a>1-3.删除链表的第N个节点：19</h4><p>法一：先获取长度，然后定位到倒数第N个节点。</p><p>错解：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">removeNthFromEnd</span><span class="params">(ListNode* head, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 获取链表长度</span></span><br><span class="line">        <span class="type">int</span> length = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (head) &#123;</span><br><span class="line">            ++length;</span><br><span class="line">            head = head-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 定位节点并删除</span></span><br><span class="line">        ListNode* DummyHead = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">0</span>, head);</span><br><span class="line">        ListNode* temp = DummyHead; <span class="comment">// 第0个节点i=0</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; length + <span class="number">1</span> - n;</span><br><span class="line">             i++) &#123; <span class="comment">// 遍历倒数第N+1个节点前面的所有节点,注意i初始值为1</span></span><br><span class="line">            temp = temp-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        temp-&gt;next = temp-&gt;next-&gt;next;</span><br><span class="line">        ListNode* ans = DummyHead-&gt;next;</span><br><span class="line">        <span class="keyword">delete</span> DummyHead;</span><br><span class="line">        <span class="keyword">return</span> ans; <span class="comment">// 不能直接返回head,因为之前的head可能是要删除的那个节点</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>原因：在获取长度时，head已经发生了改变，因此之后的DummyHead节点就出了问题，正确解法应该是将获取链表长度单独封装为一个函数，或者是提前定义好DummyHead。</p><p>正解：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">removeNthFromEnd</span><span class="params">(ListNode* head, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        ListNode* DummyHead = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">0</span>, head); <span class="comment">// 改动</span></span><br><span class="line">        <span class="comment">// 获取链表长度</span></span><br><span class="line">        <span class="type">int</span> length = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (head) &#123;</span><br><span class="line">            ++length;</span><br><span class="line">            head = head-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 定位节点并删除</span></span><br><span class="line">        ListNode* temp = DummyHead; <span class="comment">// 第0个节点i=0</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; length + <span class="number">1</span> - n;</span><br><span class="line">             i++) &#123; <span class="comment">// 遍历倒数第N+1个节点前面的所有节点,注意i初始值为1</span></span><br><span class="line">            temp = temp-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        temp-&gt;next = temp-&gt;next-&gt;next;</span><br><span class="line">        ListNode* ans = DummyHead-&gt;next;</span><br><span class="line">        <span class="keyword">delete</span> DummyHead;</span><br><span class="line">        <span class="keyword">return</span> ans; <span class="comment">// 不能直接返回head,因为之前的head可能是要删除的那个节点</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>法二：栈(次优解，需要额外空间)</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">removeNthFromEnd</span><span class="params">(ListNode* head, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        ListNode* DummyHead = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">0</span>, head);</span><br><span class="line">        stack&lt;ListNode*&gt; stk;</span><br><span class="line">        ListNode* temp = DummyHead;</span><br><span class="line">        <span class="keyword">while</span> (temp) &#123;</span><br><span class="line">            stk.<span class="built_in">push</span>(temp);</span><br><span class="line">            temp = temp-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            stk.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode* prev = stk.<span class="built_in">top</span>();</span><br><span class="line">        prev-&gt;next = prev-&gt;next-&gt;next;</span><br><span class="line">        ListNode* ans = DummyHead-&gt;next; <span class="comment">// 不能直接用head</span></span><br><span class="line">        <span class="keyword">delete</span> DummyHead;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>法三：双指针</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">removeNthFromEnd</span><span class="params">(ListNode* head, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        ListNode* DummyHead = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">0</span>, head);</span><br><span class="line">        ListNode* first = head;</span><br><span class="line">        ListNode* second = DummyHead;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            first = first-&gt;next; <span class="comment">// 让first到达第N+1个节点位置</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (first) &#123;</span><br><span class="line">            first = first-&gt;next;</span><br><span class="line">            second = second-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 现在second即为倒数第N个节点的前一个节点，现在更改其指向</span></span><br><span class="line">        second-&gt;next = second-&gt;next-&gt;next;</span><br><span class="line">        ListNode* ans = DummyHead-&gt;next;</span><br><span class="line">        <span class="keyword">delete</span> DummyHead;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="2-链表的遍历"><a href="#2-链表的遍历" class="headerlink" title="2.链表的遍历"></a>2.链表的遍历</h1><h4 id="2-1-双链表—扁平化多级双向链表：430"><a href="#2-1-双链表—扁平化多级双向链表：430" class="headerlink" title="2-1.双链表—扁平化多级双向链表：430"></a>2-1.双链表—扁平化多级双向链表：430</h4><p>法一：深度优先搜索(dfs)</p><p><img src="https://s2.loli.net/2024/03/20/pk6GJyB3iNE1ZfF.png" alt="firefox_iyrVl6hRKd"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">// Definition for a Node.</span></span><br><span class="line"><span class="comment">class Node &#123;</span></span><br><span class="line"><span class="comment">public:</span></span><br><span class="line"><span class="comment">    int val;</span></span><br><span class="line"><span class="comment">    Node* prev;</span></span><br><span class="line"><span class="comment">    Node* next;</span></span><br><span class="line"><span class="comment">    Node* child;</span></span><br><span class="line"><span class="comment">&#125;;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">Node* <span class="title">dfs</span><span class="params">(Node* node)</span> </span>&#123;</span><br><span class="line">        Node* last = <span class="literal">nullptr</span>; <span class="comment">// 记录链表最后一个节点</span></span><br><span class="line">        <span class="keyword">while</span> (node) &#123;</span><br><span class="line">            Node* next = node-&gt;next; <span class="comment">// 记录下一个节点，不能一直用node-&gt;next代替</span></span><br><span class="line">            <span class="comment">// 如果链表最后一个节点</span></span><br><span class="line">            <span class="keyword">if</span> (node-&gt;child) &#123;</span><br><span class="line">                Node* child_last = <span class="built_in">dfs</span>(node-&gt;child);</span><br><span class="line">                <span class="comment">// 将node与child相连</span></span><br><span class="line">                node-&gt;next = node-&gt;child;</span><br><span class="line">                node-&gt;child-&gt;prev = node;</span><br><span class="line">                <span class="comment">// 若node-&gt;next不为空，就将last与next相连</span></span><br><span class="line">                <span class="keyword">if</span> (next) &#123;</span><br><span class="line">                    child_last-&gt;next = next;</span><br><span class="line">                    next-&gt;prev = child_last;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 置child为空</span></span><br><span class="line">                node-&gt;child = <span class="literal">nullptr</span>;</span><br><span class="line">                last = child_last;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                last = node;</span><br><span class="line">            &#125;</span><br><span class="line">            node = node-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> last;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">Node* <span class="title">flatten</span><span class="params">(Node* head)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">dfs</span>(head);</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="3-链表的旋转与反转"><a href="#3-链表的旋转与反转" class="headerlink" title="3.链表的旋转与反转"></a>3.链表的旋转与反转</h1><h4 id="3-1-旋转链表：61"><a href="#3-1-旋转链表：61" class="headerlink" title="3-1.旋转链表：61"></a>3-1.旋转链表：61</h4><p>法一：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">rotateRight</span><span class="params">(ListNode* head, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (k == <span class="number">0</span> || head == <span class="literal">nullptr</span> || head-&gt;next == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> len = <span class="number">1</span>;</span><br><span class="line">        ListNode* it = head;</span><br><span class="line">        <span class="keyword">while</span> (it-&gt;next) &#123;</span><br><span class="line">            it = it-&gt;next;</span><br><span class="line">            len++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// len记录链表长度，it现在为最后一个节点</span></span><br><span class="line">        <span class="type">int</span> n = len - k % len; <span class="comment">// 实际上只需要移动的距离</span></span><br><span class="line">        <span class="keyword">if</span> (n == len) &#123;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line">        it-&gt;next = head;</span><br><span class="line">        <span class="keyword">while</span> (n--) &#123;</span><br><span class="line">            <span class="comment">// 找到倒数第n个节点，并让其作为头节点</span></span><br><span class="line">            it = it-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 现在it为倒数第n+1个节点，用ans记录下最终的头节点</span></span><br><span class="line">        ListNode* ans = it-&gt;next;</span><br><span class="line">        it-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="3-2-两两交换链表中的节点：24"><a href="#3-2-两两交换链表中的节点：24" class="headerlink" title="3-2.两两交换链表中的节点：24"></a>3-2.两两交换链表中的节点：24</h4><p>法一：递归</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">swapPairs</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="literal">nullptr</span> || head-&gt;next == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode* temp = head-&gt;next;</span><br><span class="line">        head-&gt;next = <span class="built_in">swapPairs</span>(temp-&gt;next);</span><br><span class="line">        temp-&gt;next = head;</span><br><span class="line">        <span class="keyword">return</span> temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>法二：迭代</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">swapPairs</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        ListNode* DummyHead = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">0</span>, head);</span><br><span class="line">        ListNode* temp = DummyHead;</span><br><span class="line">        <span class="keyword">while</span> (temp-&gt;next &amp;&amp; temp-&gt;next-&gt;next) &#123;</span><br><span class="line">            ListNode* node1 = temp-&gt;next;</span><br><span class="line">            ListNode* node2 = temp-&gt;next-&gt;next;</span><br><span class="line">            <span class="comment">// 以temp作为中介</span></span><br><span class="line">            temp-&gt;next = node2;</span><br><span class="line">            node1-&gt;next = node2-&gt;next;</span><br><span class="line">            node2-&gt;next = node1;</span><br><span class="line">            temp = node1; <span class="comment">// 更新temp为下一组的&quot;DummyHead&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">        ListNode* ans = DummyHead-&gt;next;</span><br><span class="line">        <span class="keyword">delete</span> DummyHead;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="3-3-反转链表：206"><a href="#3-3-反转链表：206" class="headerlink" title="3-3.反转链表：206"></a>3-3.反转链表：206</h4><p>法一：迭代</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">reverseList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        ListNode* temp = head;</span><br><span class="line">        ListNode* prev = <span class="literal">nullptr</span>; <span class="comment">// temp的前一个节点</span></span><br><span class="line">        <span class="keyword">while</span> (temp) &#123;</span><br><span class="line">            ListNode* next = temp-&gt;next; <span class="comment">// temp的后一个节点</span></span><br><span class="line">            <span class="comment">// 记录节点依次后移</span></span><br><span class="line">            temp-&gt;next = prev;</span><br><span class="line">            prev = temp;</span><br><span class="line">            temp = next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> prev;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>法二：递归</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">reverseList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!head || !head-&gt;next) &#123;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode* newHead = <span class="built_in">reverseList</span>(head-&gt;next);</span><br><span class="line">        head-&gt;next-&gt;next = head;</span><br><span class="line">        head-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">return</span> newHead;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="3-4-反转链表II：92"><a href="#3-4-反转链表II：92" class="headerlink" title="3-4.反转链表II：92"></a>3-4.反转链表II：92</h4><blockquote><p>最简单的操作当然是直接修改各个节点的值。</p></blockquote><p>法一：遍历两次</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">reverseLinkedList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 也可以使用递归反转一个链表</span></span><br><span class="line">        ListNode* pre = <span class="literal">nullptr</span>;</span><br><span class="line">        ListNode* cur = head;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (cur != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            ListNode* next = cur-&gt;next;</span><br><span class="line">            cur-&gt;next = pre;</span><br><span class="line">            pre = cur;</span><br><span class="line">            cur = next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">reverseBetween</span><span class="params">(ListNode* head, <span class="type">int</span> left, <span class="type">int</span> right)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 因为头节点有可能发生变化，使用虚拟头节点可以避免复杂的分类讨论</span></span><br><span class="line">        ListNode* dummyNode = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">-1</span>);</span><br><span class="line">        dummyNode-&gt;next = head;</span><br><span class="line"></span><br><span class="line">        ListNode* pre = dummyNode;</span><br><span class="line">        <span class="comment">// 第 1 步：从虚拟头节点走 left - 1 步，来到 left 节点的前一个节点</span></span><br><span class="line">        <span class="comment">// 建议写在 for 循环里，语义清晰</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; left - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            pre = pre-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 第 2 步：从 pre 再走 right - left + 1 步，来到 right 节点</span></span><br><span class="line">        ListNode* rightNode = pre;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; right - left + <span class="number">1</span>; i++) &#123;</span><br><span class="line">            rightNode = rightNode-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 第 3 步：切断出一个子链表（截取链表）</span></span><br><span class="line">        ListNode* leftNode = pre-&gt;next;</span><br><span class="line">        ListNode* curr = rightNode-&gt;next;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 注意：切断链接</span></span><br><span class="line">        pre-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">        rightNode-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 第 4 步：同第 206 题，反转链表的子区间</span></span><br><span class="line">        <span class="built_in">reverseLinkedList</span>(leftNode);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 第 5 步：接回到原来的链表中</span></span><br><span class="line">        pre-&gt;next = rightNode;</span><br><span class="line">        leftNode-&gt;next = curr;</span><br><span class="line">        <span class="keyword">return</span> dummyNode-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><p>值得注意的是第3步，以一种巧妙的方式截取出了子链表，从而使问题简化到问题3-3的情形。</p></blockquote><p>法二：只遍历一次(最优解)：头插法</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">reverseBetween</span><span class="params">(ListNode* head, <span class="type">int</span> left, <span class="type">int</span> right)</span> </span>&#123;</span><br><span class="line">        ListNode* DummyHead=<span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">-1</span>,head);</span><br><span class="line">        ListNode* prev=DummyHead;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;left<span class="number">-1</span>;i++)&#123;</span><br><span class="line">            prev=prev-&gt;next;<span class="comment">//让prev来到left节点的前一个节点</span></span><br><span class="line">        &#125;</span><br><span class="line">        ListNode* curr=prev-&gt;next;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=left;i&lt;right;i++)&#123;</span><br><span class="line">            <span class="comment">//每次让当前的目标节点curr置后,next变为子链表首位</span></span><br><span class="line">            <span class="comment">//prev-&gt;...-&gt;curr-&gt;next...变为prev-&gt;...-&gt;next-&gt;curr...,详见官方图解</span></span><br><span class="line">            ListNode* next=curr-&gt;next;</span><br><span class="line">            curr-&gt;next=next-&gt;next;</span><br><span class="line">            next-&gt;next=prev-&gt;next;</span><br><span class="line">            prev-&gt;next=next;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode* ans=DummyHead-&gt;next;</span><br><span class="line">        <span class="keyword">delete</span> DummyHead;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>总结：解决反转链表这一类问题，要善用prev,curr,next链表节点，以及DummyHead。</p><h4 id="3-5-K个一组反转链表：25（困难）"><a href="#3-5-K个一组反转链表：25（困难）" class="headerlink" title="3-5.K个一组反转链表：25（困难）"></a>3-5.K个一组反转链表：25（困难）</h4><p>myReverse()类比3-4头插法中的reverseBetween()，前者是已知头节点和尾节点，后者是知道头节点、起始位置left和终止位置right.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 翻转一个子链表，并且返回新的头与尾</span></span><br><span class="line">    <span class="function">pair&lt;ListNode*, ListNode*&gt; <span class="title">myReverse</span><span class="params">(ListNode* head, ListNode* tail)</span> </span>&#123;</span><br><span class="line">        ListNode* pre = tail-&gt;next;</span><br><span class="line">        ListNode* p = head;</span><br><span class="line">        <span class="keyword">while</span> (pre != tail) &#123;</span><br><span class="line">            ListNode* nex = p-&gt;next;</span><br><span class="line">            p-&gt;next = pre;</span><br><span class="line">            pre = p;</span><br><span class="line">            p = nex;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> &#123;tail, head&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">ListNode* <span class="title">reverseKGroup</span><span class="params">(ListNode* head, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        ListNode* DummyHead = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">-1</span>, head);</span><br><span class="line">        ListNode* prev = DummyHead;</span><br><span class="line">        <span class="keyword">while</span> (head) &#123;</span><br><span class="line">            ListNode* tail = prev;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = k; i &gt; <span class="number">0</span>; i--) &#123; <span class="comment">// 这里不能使用while(k--),因为会改变k的值,影响到下一次循环</span></span><br><span class="line">                tail = tail-&gt;next;</span><br><span class="line">                <span class="keyword">if</span> (tail == <span class="literal">nullptr</span>) &#123; <span class="comment">// 已经到达末尾</span></span><br><span class="line">                    ListNode* ans = DummyHead-&gt;next;</span><br><span class="line">                    <span class="keyword">delete</span> DummyHead;</span><br><span class="line">                    <span class="keyword">return</span> ans;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 循环结束后，tail为当前要反转子链表的最后一个节点</span></span><br><span class="line">            <span class="comment">// prev为反转子链表的第一个节点之前的那一个节点</span></span><br><span class="line">            ListNode* next = tail-&gt;next;</span><br><span class="line">            <span class="comment">// 反转子链表</span></span><br><span class="line">            pair&lt;ListNode*, ListNode*&gt; result = <span class="built_in">myReverse</span>(head, tail);</span><br><span class="line">            head = result.first;</span><br><span class="line">            tail = result.second;</span><br><span class="line">            <span class="comment">// 把子链表重新接回原链表</span></span><br><span class="line">            prev-&gt;next = head;</span><br><span class="line">            tail-&gt;next = next;</span><br><span class="line">            prev = tail;</span><br><span class="line">            head = tail-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode* ans = DummyHead-&gt;next;</span><br><span class="line">        <span class="keyword">delete</span> DummyHead;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>官方题解：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 翻转一个子链表，并且返回新的头与尾</span></span><br><span class="line">    <span class="function">pair&lt;ListNode*, ListNode*&gt; <span class="title">myReverse</span><span class="params">(ListNode* head, ListNode* tail)</span> </span>&#123;</span><br><span class="line">        ListNode* prev = tail-&gt;next;</span><br><span class="line">        ListNode* p = head;</span><br><span class="line">        <span class="keyword">while</span> (prev != tail) &#123;</span><br><span class="line">            ListNode* nex = p-&gt;next;</span><br><span class="line">            p-&gt;next = prev;</span><br><span class="line">            prev = p;</span><br><span class="line">            p = nex;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> &#123;tail, head&#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">ListNode* <span class="title">reverseKGroup</span><span class="params">(ListNode* head, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        ListNode* hair = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">        hair-&gt;next = head;</span><br><span class="line">        ListNode* pre = hair;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (head) &#123;</span><br><span class="line">            ListNode* tail = pre;</span><br><span class="line">            <span class="comment">// 查看剩余部分长度是否大于等于 k</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; k; ++i) &#123;</span><br><span class="line">                tail = tail-&gt;next;</span><br><span class="line">                <span class="keyword">if</span> (!tail) &#123;</span><br><span class="line">                    <span class="keyword">return</span> hair-&gt;next;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            ListNode* nex = tail-&gt;next;</span><br><span class="line">            <span class="comment">// 这里是 C++17 的写法，也可以写成</span></span><br><span class="line">            <span class="comment">// pair&lt;ListNode*, ListNode*&gt; result = myReverse(head, tail);</span></span><br><span class="line">            <span class="comment">// head = result.first;</span></span><br><span class="line">            <span class="comment">// tail = result.second;</span></span><br><span class="line">            <span class="built_in">tie</span>(head, tail) = <span class="built_in">myReverse</span>(head, tail);</span><br><span class="line">            <span class="comment">// 把子链表重新接回原链表</span></span><br><span class="line">            pre-&gt;next = head;</span><br><span class="line">            tail-&gt;next = nex;</span><br><span class="line">            pre = tail;</span><br><span class="line">            head = tail-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> hair-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>图解：<a href="https://leetcode.cn/problems/reverse-nodes-in-k-group/solutions/1/di-gui-java-by-reedfan-2/">力扣（LeetCode）—reedfan</a></p><p><img src="https://s2.loli.net/2024/03/23/KFI7V3HMYPnWix9.png" alt="firefox_hd33huMeCd"></p><h1 id="4-链表高精度加法"><a href="#4-链表高精度加法" class="headerlink" title="4.链表高精度加法"></a>4.链表高精度加法</h1><h4 id="4-1-两数相加：2"><a href="#4-1-两数相加：2" class="headerlink" title="4-1.两数相加：2"></a>4-1.两数相加：2</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">addTwoNumbers</span><span class="params">(ListNode* l1, ListNode* l2)</span> </span>&#123;</span><br><span class="line">        ListNode* ans = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">        ListNode* head = ans;</span><br><span class="line">        <span class="type">int</span> value = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (l1 || l2) &#123;</span><br><span class="line">            <span class="type">int</span> val1 = l1 ? l1-&gt;val : <span class="number">0</span>;</span><br><span class="line">            <span class="type">int</span> val2 = l2 ? l2-&gt;val : <span class="number">0</span>;</span><br><span class="line">            value += val1 + val2;</span><br><span class="line">            ans-&gt;val = value % <span class="number">10</span>;</span><br><span class="line">            value /= <span class="number">10</span>;</span><br><span class="line">            <span class="keyword">if</span> (l1) &#123;</span><br><span class="line">                l1 = l1-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (l2) &#123;</span><br><span class="line">                l2 = l2-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (l1 || l2) &#123;</span><br><span class="line">                ans-&gt;next = <span class="keyword">new</span> <span class="built_in">ListNode</span>(value);</span><br><span class="line">                ans = ans-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (value) &#123;</span><br><span class="line">            ans-&gt;next = <span class="keyword">new</span> <span class="built_in">ListNode</span>(value);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>关键在于第7-9行的处理，这样可以尽可能简化代码。这里给出对比：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">addTwoNumbers</span><span class="params">(ListNode l1, ListNode l2)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> pre = <span class="number">0</span>; <span class="comment">//进位</span></span><br><span class="line">        ListNode res = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">-1</span>);</span><br><span class="line">        ListNode p = res;</span><br><span class="line">        <span class="keyword">while</span> (l1 != null &amp;&amp; l2 != null) &#123;</span><br><span class="line">            <span class="type">int</span> cur = l1.val + l2.val + pre;</span><br><span class="line">            <span class="keyword">if</span> (cur &gt;= <span class="number">10</span>) &#123; <span class="comment">// 进位</span></span><br><span class="line">                pre = <span class="number">1</span>;</span><br><span class="line">                cur %= <span class="number">10</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                pre = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            p.next = <span class="keyword">new</span> <span class="built_in">ListNode</span>(cur);</span><br><span class="line">            p = p.next;</span><br><span class="line">            l1 = l1.next;</span><br><span class="line">            l2 = l2.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (l1 != null) &#123;</span><br><span class="line">            <span class="type">int</span> cur = l1.val + pre;</span><br><span class="line">            <span class="keyword">if</span> (cur &gt;= <span class="number">10</span>) &#123; <span class="comment">// 进位</span></span><br><span class="line">                pre = <span class="number">1</span>;</span><br><span class="line">                cur %= <span class="number">10</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                pre = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            p.next = <span class="keyword">new</span> <span class="built_in">ListNode</span>(cur);</span><br><span class="line">            p = p.next;</span><br><span class="line">            l1 = l1.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (l2 != null) &#123;</span><br><span class="line">            <span class="type">int</span> cur = l2.val + pre;</span><br><span class="line">            <span class="keyword">if</span> (cur &gt;= <span class="number">10</span>) &#123; <span class="comment">// 进位</span></span><br><span class="line">                pre = <span class="number">1</span>;</span><br><span class="line">                cur %= <span class="number">10</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                pre = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            p.next = <span class="keyword">new</span> <span class="built_in">ListNode</span>(cur);</span><br><span class="line">            p = p.next;</span><br><span class="line">            l2 = l2.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (pre == <span class="number">1</span>) &#123;</span><br><span class="line">            p.next = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-2-两数相加II：445"><a href="#4-2-两数相加II：445" class="headerlink" title="4-2.两数相加II：445"></a>4-2.两数相加II：445</h4><p>法一：先反转链表，再相加</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">addListNodes</span><span class="params">(ListNode* l1, ListNode* l2)</span> </span>&#123;</span><br><span class="line">        ListNode* dummy = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">        ListNode* current = dummy;</span><br><span class="line">        <span class="type">int</span> carry = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (l1 || l2 || carry) &#123;</span><br><span class="line">            <span class="type">int</span> sum = (l1 ? l1-&gt;val : <span class="number">0</span>) + (l2 ? l2-&gt;val : <span class="number">0</span>) + carry;</span><br><span class="line">            carry = sum / <span class="number">10</span>;</span><br><span class="line">            current-&gt;next = <span class="keyword">new</span> <span class="built_in">ListNode</span>(sum % <span class="number">10</span>);</span><br><span class="line">            current = current-&gt;next;</span><br><span class="line">            <span class="keyword">if</span> (l1) &#123;</span><br><span class="line">                l1 = l1-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (l2) &#123;</span><br><span class="line">                l2 = l2-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dummy-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">ListNode* <span class="title">reverseList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        ListNode* curr = head;</span><br><span class="line">        ListNode* prev = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">while</span> (curr) &#123;</span><br><span class="line">            ListNode* next = curr-&gt;next;</span><br><span class="line">            curr-&gt;next = prev;</span><br><span class="line">            prev = curr;</span><br><span class="line">            curr = next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> prev;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">ListNode* <span class="title">addTwoNumbers</span><span class="params">(ListNode* l1, ListNode* l2)</span> </span>&#123;</span><br><span class="line">        l1 = <span class="built_in">reverseList</span>(l1);</span><br><span class="line">        l2 = <span class="built_in">reverseList</span>(l2);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">reverseList</span>(<span class="built_in">addListNodes</span>(l1, l2));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>法二：用栈/数组(练习意义不大,但是最优解)</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">addTwoNumbers</span><span class="params">(ListNode* l1, ListNode* l2)</span> </span>&#123;</span><br><span class="line">        stack&lt;<span class="type">int</span>&gt; s1, s2;</span><br><span class="line">        <span class="keyword">while</span> (l1) &#123;</span><br><span class="line">            s1.<span class="built_in">push</span>(l1 -&gt; val);</span><br><span class="line">            l1 = l1 -&gt; next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (l2) &#123;</span><br><span class="line">            s2.<span class="built_in">push</span>(l2 -&gt; val);</span><br><span class="line">            l2 = l2 -&gt; next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> carry = <span class="number">0</span>;</span><br><span class="line">        ListNode* ans = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">while</span> (!s1.<span class="built_in">empty</span>() <span class="keyword">or</span> !s2.<span class="built_in">empty</span>() <span class="keyword">or</span> carry != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="type">int</span> a = s1.<span class="built_in">empty</span>() ? <span class="number">0</span> : s1.<span class="built_in">top</span>();</span><br><span class="line">            <span class="type">int</span> b = s2.<span class="built_in">empty</span>() ? <span class="number">0</span> : s2.<span class="built_in">top</span>();</span><br><span class="line">            <span class="keyword">if</span> (!s1.<span class="built_in">empty</span>()) s1.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">if</span> (!s2.<span class="built_in">empty</span>()) s2.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="type">int</span> cur = a + b + carry;</span><br><span class="line">            carry = cur / <span class="number">10</span>;</span><br><span class="line">            cur %= <span class="number">10</span>;</span><br><span class="line">            <span class="keyword">auto</span> curnode = <span class="keyword">new</span> <span class="built_in">ListNode</span>(cur);</span><br><span class="line">            curnode -&gt; next = ans;</span><br><span class="line">            ans = curnode;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="5-链表的合并"><a href="#5-链表的合并" class="headerlink" title="5.链表的合并"></a>5.链表的合并</h1><h4 id="5-1-合成两个有序链表：21"><a href="#5-1-合成两个有序链表：21" class="headerlink" title="5-1.合成两个有序链表：21"></a>5-1.合成两个有序链表：21</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">mergeTwoLists</span><span class="params">(ListNode* list1, ListNode* list2)</span> </span>&#123;</span><br><span class="line">        ListNode* DummyHead = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">        ListNode* curr = DummyHead;</span><br><span class="line">        <span class="type">int</span> value = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (list1 &amp;&amp; list2) &#123;</span><br><span class="line">            value = <span class="built_in">min</span>(list1-&gt;val, list2-&gt;val);</span><br><span class="line">            curr-&gt;next = <span class="keyword">new</span> <span class="built_in">ListNode</span>(value);</span><br><span class="line">            curr = curr-&gt;next; <span class="comment">// 记得更新curr</span></span><br><span class="line">            <span class="keyword">if</span> (list1-&gt;val &lt;= list2-&gt;val) &#123;</span><br><span class="line">                list1 = list1-&gt;next;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                list2 = list2-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (list1 || list2) &#123;</span><br><span class="line">            curr-&gt;next = list1 ? list1 : list2;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ListNode* ans = DummyHead-&gt;next;</span><br><span class="line">        <span class="keyword">delete</span> DummyHead;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="5-2-合并K个升序链表：23（困难）"><a href="#5-2-合并K个升序链表：23（困难）" class="headerlink" title="5-2.合并K个升序链表：23（困难）"></a>5-2.合并K个升序链表：23（困难）</h4><h6 id="法一：分治合并（最优解）"><a href="#法一：分治合并（最优解）" class="headerlink" title="法一：分治合并（最优解）"></a>法一：分治合并（最优解）</h6><p>两个一组进行合并</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">mergeTwoLists</span><span class="params">(ListNode* a, ListNode* b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> ((!a) || (!b))</span><br><span class="line">            <span class="keyword">return</span> a ? a : b;</span><br><span class="line">        ListNode head, *tail = &amp;head, *aPtr = a, *bPtr = b;</span><br><span class="line">        <span class="keyword">while</span> (aPtr &amp;&amp; bPtr) &#123;</span><br><span class="line">            <span class="keyword">if</span> (aPtr-&gt;val &lt; bPtr-&gt;val) &#123;</span><br><span class="line">                tail-&gt;next = aPtr;</span><br><span class="line">                aPtr = aPtr-&gt;next;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                tail-&gt;next = bPtr;</span><br><span class="line">                bPtr = bPtr-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            tail = tail-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        tail-&gt;next = (aPtr ? aPtr : bPtr);</span><br><span class="line">        <span class="keyword">return</span> head.next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">ListNode* <span class="title">merge</span><span class="params">(vector&lt;ListNode*&gt;&amp; lists, <span class="type">int</span> left, <span class="type">int</span> right)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (left == right) &#123;</span><br><span class="line">            <span class="keyword">return</span> lists[left];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (left &gt; right) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> mid = (left + right) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">mergeTwoLists</span>(<span class="built_in">merge</span>(lists, left, mid), <span class="built_in">merge</span>(lists, mid + <span class="number">1</span>, right));   </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">ListNode* <span class="title">mergeKLists</span><span class="params">(vector&lt;ListNode*&gt;&amp; lists)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">merge</span>(lists, <span class="number">0</span>, lists.<span class="built_in">size</span>() - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>注：mergeTwoLists()两种写法的时空开销差异分析</strong></p><p>方法一（30ms,30MB）:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ListNode* <span class="title">mergeTwoLists</span><span class="params">(ListNode* list1, ListNode* list2)</span> </span>&#123;</span><br><span class="line">    ListNode* DummyHead = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">    ListNode* curr = DummyHead;</span><br><span class="line">    <span class="type">int</span> value = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (list1 &amp;&amp; list2) &#123;</span><br><span class="line">        value = <span class="built_in">min</span>(list1-&gt;val, list2-&gt;val);</span><br><span class="line">        curr-&gt;next = <span class="keyword">new</span> <span class="built_in">ListNode</span>(value);</span><br><span class="line">        curr = curr-&gt;next; <span class="comment">// 记得更新curr</span></span><br><span class="line">        <span class="keyword">if</span> (list1-&gt;val &lt;= list2-&gt;val) &#123;</span><br><span class="line">            list1 = list1-&gt;next;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            list2 = list2-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (list1 || list2) &#123;</span><br><span class="line">        curr-&gt;next = list1 ? list1 : list2;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ListNode* ans = DummyHead-&gt;next;</span><br><span class="line">    <span class="keyword">delete</span> DummyHead;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方法二（11ms,16MB）:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ListNode* <span class="title">mergeTwoLists</span><span class="params">(ListNode* a, ListNode* b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> ((!a) || (!b))</span><br><span class="line">        <span class="keyword">return</span> a ? a : b;</span><br><span class="line">    ListNode head, *tail = &amp;head, *aPtr = a, *bPtr = b;<span class="comment">//注意这里的head是ListNode对象</span></span><br><span class="line">    <span class="keyword">while</span> (aPtr &amp;&amp; bPtr) &#123;</span><br><span class="line">        <span class="keyword">if</span> (aPtr-&gt;val &lt; bPtr-&gt;val) &#123;</span><br><span class="line">            tail-&gt;next = aPtr;</span><br><span class="line">            aPtr = aPtr-&gt;next;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            tail-&gt;next = bPtr;</span><br><span class="line">            bPtr = bPtr-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        tail = tail-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    tail-&gt;next = (aPtr ? aPtr : bPtr);</span><br><span class="line">    <span class="keyword">return</span> head.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>同样的时空复杂度，为什么第二种方法开销更小？</p></blockquote><p>因为第一种方法在合并链表的过程中，创建了新的节点来存储合并后的结果，这导致了额外的空间开销；同时，每次迭代过程中都需要动态分配新的节点，这导致速度更慢。第二种方法只是在原有节点的基础上进行连接，而不是创建新的节点。</p><h6 id="法二：优先队列"><a href="#法二：优先队列" class="headerlink" title="法二：优先队列"></a>法二：优先队列</h6><p>这样就相当于先把所有链表节点的值挨个放入队列中，然后让其自行进行快速排序。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">Status</span> &#123;</span><br><span class="line">        <span class="type">int</span> val;</span><br><span class="line">        ListNode *ptr;</span><br><span class="line">        <span class="type">bool</span> <span class="keyword">operator</span> &lt; (<span class="type">const</span> Status &amp;rhs) <span class="type">const</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> val &gt; rhs.val;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    priority_queue &lt;Status&gt; q;</span><br><span class="line"></span><br><span class="line">    <span class="function">ListNode* <span class="title">mergeKLists</span><span class="params">(vector&lt;ListNode*&gt;&amp; lists)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> node: lists) &#123;</span><br><span class="line">            <span class="keyword">if</span> (node) q.<span class="built_in">push</span>(&#123;node-&gt;val, node&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode head, *tail = &amp;head;</span><br><span class="line">        <span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="keyword">auto</span> f = q.<span class="built_in">top</span>(); q.<span class="built_in">pop</span>();</span><br><span class="line">            tail-&gt;next = f.ptr; </span><br><span class="line">            tail = tail-&gt;next;</span><br><span class="line">            <span class="keyword">if</span> (f.ptr-&gt;next) q.<span class="built_in">push</span>(&#123;f.ptr-&gt;next-&gt;val, f.ptr-&gt;next&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> head.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><p>重载运算符’&lt;’，用于自定义类型Status的比较规则，使得在优先队列中可以按照<code>val</code>的值进行降序排列。(自定义比较器)</p></blockquote><p>关于优先队列priority_queue，详见《0.常用STL用法》的2-5.</p>]]></content>
    
    
    <summary type="html">链表部分</summary>
    
    
    
    <category term="leetcode刷题笔记" scheme="https://sumikiru.top/categories/leetcode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="C++" scheme="https://sumikiru.top/tags/C/"/>
    
    <category term="leetcode" scheme="https://sumikiru.top/tags/leetcode/"/>
    
    <category term="链表" scheme="https://sumikiru.top/tags/%E9%93%BE%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>4.栈与递归篇</title>
    <link href="https://sumikiru.top/posts/8a02a46e.html"/>
    <id>https://sumikiru.top/posts/8a02a46e.html</id>
    <published>2024-05-17T14:41:50.000Z</published>
    <updated>2025-02-06T14:42:00.324Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-用栈访问最后若干元素"><a href="#1-用栈访问最后若干元素" class="headerlink" title="1.用栈访问最后若干元素"></a>1.用栈访问最后若干元素</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">stack.<span class="built_in">push_back</span>(<span class="built_in">move</span>(name));</span><br></pre></td></tr></table></figure><p>在这段代码中，<code>move(name)</code> 使用了 C++ 中的 <code>std::move</code> 函数。<code>std::move</code> 是一个用于<u>将对象转换为右值引用</u>的函数，它允许将对象的所有权转移给另一个对象，通常用于在移动语义中。在这段代码中，<code>move(name)</code> 可能是在将 <code>name</code> 对象的所有权转移给 <code>stack</code> 容器，这样做通常可以<mark>提高性能，避免不必要的拷贝操作</mark>。</p><h4 id="1-1-文件的最长绝对路径：388"><a href="#1-1-文件的最长绝对路径：388" class="headerlink" title="1-1.文件的最长绝对路径：388"></a>1-1.文件的最长绝对路径：388</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">lengthLongestPath</span><span class="params">(string input)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> ans = <span class="number">0</span>, pos = <span class="number">0</span>, n = input.<span class="built_in">length</span>();</span><br><span class="line">        stack&lt;<span class="type">int</span>&gt;st;<span class="comment">//用来记录每一段的长度</span></span><br><span class="line">        <span class="comment">// pos作为指针</span></span><br><span class="line">        <span class="keyword">while</span> (pos &lt; n) &#123;</span><br><span class="line">            <span class="comment">// 检测当前文件深度</span></span><br><span class="line">            <span class="type">int</span> depth = <span class="number">1</span>;</span><br><span class="line">            <span class="comment">//&#x27;\t&#x27;是一个符号，这里不是&#x27;\&#x27;和&#x27;t&#x27;</span></span><br><span class="line">            <span class="keyword">while</span> (pos &lt; n &amp;&amp; input[pos] == <span class="string">&#x27;\t&#x27;</span>) &#123;</span><br><span class="line">                ++pos;</span><br><span class="line">                ++depth;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 统计当前文件名的长度</span></span><br><span class="line">            <span class="type">int</span> len = <span class="number">0</span>;</span><br><span class="line">            <span class="type">bool</span> isFile = <span class="literal">false</span>; <span class="comment">// 记录是否为文件名而非目录名</span></span><br><span class="line">            <span class="keyword">while</span> (pos &lt; n &amp;&amp; input[pos] != <span class="string">&#x27;\n&#x27;</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (input[pos] == <span class="string">&#x27;.&#x27;</span>) &#123;</span><br><span class="line">                    isFile = <span class="literal">true</span>; <span class="comment">// 因为此时后面必定是.ext</span></span><br><span class="line">                &#125;</span><br><span class="line">                ++len;</span><br><span class="line">                ++pos;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 跳过换行符</span></span><br><span class="line">            ++pos;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 遇到一次换行符之后的操作，对栈st进行操作</span></span><br><span class="line">            <span class="keyword">while</span> (st.<span class="built_in">size</span>() &gt;= depth) &#123;</span><br><span class="line">                st.<span class="built_in">pop</span>();<span class="comment">//回退一个文件层级</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (!st.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">                len += st.<span class="built_in">top</span>() + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (isFile) &#123;</span><br><span class="line">                ans = <span class="built_in">max</span>(ans, len);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                st.<span class="built_in">emplace</span>(len);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><p><code>stack.emplace(a)</code> 的意思是在栈顶创建一个新的元素，并将参数 <code>a</code> 作为构造函数的参数，用于构造这个新的元素。<code>push_back()</code>，<code>emplace_back()</code>等最终调用的都是<code>emplace_back()</code>，性能并无区别。</p></blockquote><p>关于emplace():<a href="https://www.jianshu.com/p/caad33287dc3">emplace/emplace_back - 简书</a></p><h1 id="2-栈与计算器"><a href="#2-栈与计算器" class="headerlink" title="2.栈与计算器"></a>2.栈与计算器</h1><h5 id="2-1-逆波兰表达式求值：150"><a href="#2-1-逆波兰表达式求值：150" class="headerlink" title="2-1.逆波兰表达式求值：150"></a>2-1.逆波兰表达式求值：150</h5><blockquote><p>   逆波兰表达式严格遵循「从左到右」的运算。计算逆波兰表达式的值时，使用一个栈存储操作数，从左到右遍历逆波兰表达式，进行如下操作：</p><p>1.如果遇到操作数，则将操作数入栈；</p><p>2.如果遇到运算符，则将两个操作数出栈，其中<mark>先出栈的是右操作数</mark>，后出栈的是左操作数，使用运算符对两个操作数进行运算，将运算得到的新操作数入栈。</p><p>   整个逆波兰表达式遍历完毕之后，栈内只有一个元素，该元素即为逆波兰表达式的值。[“13”,”5”,”/“]则表示13/5.</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">isNumber</span><span class="params">(string&amp; s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> !(s == <span class="string">&quot;+&quot;</span> || s == <span class="string">&quot;-&quot;</span> || s == <span class="string">&quot;*&quot;</span> || s == <span class="string">&quot;/&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">evalRPN</span><span class="params">(vector&lt;string&gt;&amp; tokens)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = tokens.<span class="built_in">size</span>();</span><br><span class="line">        stack&lt;<span class="type">int</span>&gt; stk;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            string&amp; token = tokens[i];</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">isNumber</span>(token)) &#123;</span><br><span class="line">                stk.<span class="built_in">emplace</span>(<span class="built_in">stoi</span>(token));</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//注意num2和num1的先后顺序</span></span><br><span class="line">                <span class="type">int</span> num2 = stk.<span class="built_in">top</span>();</span><br><span class="line">                stk.<span class="built_in">pop</span>();</span><br><span class="line">                <span class="type">int</span> num1 = stk.<span class="built_in">top</span>();</span><br><span class="line">                stk.<span class="built_in">pop</span>();</span><br><span class="line">                <span class="keyword">switch</span> (token[<span class="number">0</span>]) &#123;</span><br><span class="line">                    <span class="keyword">case</span> <span class="string">&#x27;+&#x27;</span>:</span><br><span class="line">                        stk.<span class="built_in">emplace</span>(num1 + num2);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span> <span class="string">&#x27;-&#x27;</span>:</span><br><span class="line">                        stk.<span class="built_in">emplace</span>(num1 - num2);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span> <span class="string">&#x27;*&#x27;</span>:</span><br><span class="line">                        stk.<span class="built_in">emplace</span>(num1 * num2);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span> <span class="string">&#x27;/&#x27;</span>:</span><br><span class="line">                        stk.<span class="built_in">emplace</span>(num1 / num2);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> stk.<span class="built_in">top</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这里的<code>emplace()</code>也可以改用<code>push()</code>。为什么不是<code>emplace_back()/push_back()</code>的原因：<code>emplace()/push()</code>对应<u>stack/queue</u>，<code>emplace_back()/push_back()</code>对应<u>list/vector</u>(包括string这种特殊的字符数组)。</p><h5 id="2-2-基本计算器II-227"><a href="#2-2-基本计算器II-227" class="headerlink" title="2-2.基本计算器II:227"></a>2-2.基本计算器II:227</h5><p>本题不需要先将中缀表达式转为后缀表达式，因为全是正整数并且没有括号。该题本质上是用栈来处理，这里可以使用stack/vector。</p><p>1.使用stack:（易错点较多，需要注意）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">calculate</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        stack&lt;<span class="type">int</span>&gt; stk;</span><br><span class="line">        <span class="type">int</span> n = s.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> sign = <span class="string">&#x27;+&#x27;</span>; <span class="comment">// 记录数字前的符号，默认为正</span></span><br><span class="line">        <span class="type">int</span> num = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">isdigit</span>(s[i])) &#123;</span><br><span class="line">                num = num * <span class="number">10</span> + <span class="built_in">int</span>(s[i] - <span class="string">&#x27;0&#x27;</span>); <span class="comment">// 小心溢出</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (!<span class="built_in">isdigit</span>(s[i]) &amp;&amp; s[i] != <span class="string">&#x27; &#x27;</span> || i == n - <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="comment">// 记得考虑空格和末位的特殊情况</span></span><br><span class="line">                <span class="keyword">switch</span> (sign) &#123; <span class="comment">// 是sign而不是s[i],否则第一个数字无法存放</span></span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;+&#x27;</span>:</span><br><span class="line">                    stk.<span class="built_in">push</span>(num);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;-&#x27;</span>:</span><br><span class="line">                    stk.<span class="built_in">push</span>(-num);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;*&#x27;</span>:</span><br><span class="line">                    stk.<span class="built_in">top</span>() *= num;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;/&#x27;</span>:</span><br><span class="line">                    stk.<span class="built_in">top</span>() /= num;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 处理完运算符以后，更新符号和数字</span></span><br><span class="line">                sign = s[i];</span><br><span class="line">                num = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (!stk.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            sum += stk.<span class="built_in">top</span>();</span><br><span class="line">            stk.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><p>注意：<code>num = num * 10 + s[i] - &#39;0&#39;;</code>会导致溢出，因为这时的运算顺序是先将num*10加上转为int的s[i]，之后再减去’0’转为的int值。而<code>int(s[i]-&#39;0&#39;)</code>则能够避免溢出。</p></blockquote><p>2.使用vector:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">calculate</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; stk;</span><br><span class="line">        <span class="type">char</span> preSign = <span class="string">&#x27;+&#x27;</span>;</span><br><span class="line">        <span class="type">int</span> num = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> n = s.<span class="built_in">length</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">isdigit</span>(s[i])) &#123;</span><br><span class="line">                num = num * <span class="number">10</span> + <span class="built_in">int</span>(s[i] - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (!<span class="built_in">isdigit</span>(s[i]) &amp;&amp; s[i] != <span class="string">&#x27; &#x27;</span> || i == n - <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">switch</span> (preSign) &#123;</span><br><span class="line">                    <span class="keyword">case</span> <span class="string">&#x27;+&#x27;</span>:</span><br><span class="line">                        stk.<span class="built_in">push_back</span>(num);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span> <span class="string">&#x27;-&#x27;</span>:</span><br><span class="line">                        stk.<span class="built_in">push_back</span>(-num);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span> <span class="string">&#x27;*&#x27;</span>:</span><br><span class="line">                        stk.<span class="built_in">back</span>() *= num;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">default</span>:</span><br><span class="line">                        stk.<span class="built_in">back</span>() /= num;</span><br><span class="line">                &#125;</span><br><span class="line">                preSign = s[i];</span><br><span class="line">                num = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">accumulate</span>(stk.<span class="built_in">begin</span>(), stk.<span class="built_in">end</span>(), <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>通过对比可以看出，二者调用的方法略有不同。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">graph LR</span><br><span class="line">    %%需要使用“ ”双引号将（）进行括起来，并给出一个命名，否则括号不可用</span><br><span class="line">    subgraph vector</span><br><span class="line">        A(&quot;push_back()&quot;)</span><br><span class="line">        B[&quot;back()&quot;] </span><br><span class="line">        C[&quot;accumulate()&quot;]</span><br><span class="line">    end</span><br><span class="line"></span><br><span class="line">    subgraph stack</span><br><span class="line">        D(&quot;push()&quot;)</span><br><span class="line">        E[&quot;top()&quot;]</span><br><span class="line">        循环累加</span><br><span class="line">    end</span><br><span class="line"></span><br><span class="line">    A&lt;--&gt;D</span><br><span class="line">    B&lt;--&gt;E</span><br><span class="line">    C&lt;--&gt;循环累加</span><br></pre></td></tr></table></figure><h4 id="2-3-基本计算器：224（困难）"><a href="#2-3-基本计算器：224（困难）" class="headerlink" title="2-3.基本计算器：224（困难）"></a>2-3.基本计算器：224（困难）</h4><p>相比上一道题，其实就是多了括号和负数，本质是根据’+’分段存入栈中并计算。这类题如果采取先转为逆波兰表达式、再计算结果的方法，会使得代码非常庞杂。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">calculate</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        stack&lt;<span class="type">int</span>&gt; stk; <span class="comment">// 这里stk存储的不是操作数，而是符号ops</span></span><br><span class="line">        stk.<span class="built_in">push</span>(<span class="number">1</span>);    <span class="comment">// 默认为正号，所以提前存储1进去</span></span><br><span class="line">        <span class="type">int</span> n = s.<span class="built_in">length</span>();</span><br><span class="line">        <span class="type">int</span> ans = <span class="number">0</span>, pos = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> sign = <span class="number">1</span>; <span class="comment">// 默认为正数.sign值只能是+1或者-1</span></span><br><span class="line">        <span class="keyword">while</span> (pos &lt; n) &#123;</span><br><span class="line">            <span class="keyword">switch</span> (s[pos]) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27; &#x27;</span>:</span><br><span class="line">                pos++;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;+&#x27;</span>:</span><br><span class="line">                sign = stk.<span class="built_in">top</span>();</span><br><span class="line">                pos++;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;-&#x27;</span>:</span><br><span class="line">                sign = -stk.<span class="built_in">top</span>();</span><br><span class="line">                pos++;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;(&#x27;</span>:</span><br><span class="line">                stk.<span class="built_in">push</span>(sign);</span><br><span class="line">                pos++;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;)&#x27;</span>:</span><br><span class="line">                stk.<span class="built_in">pop</span>();</span><br><span class="line">                pos++;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>: <span class="comment">// 是数字</span></span><br><span class="line">                <span class="type">int</span> num = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">while</span> (pos &lt; n &amp;&amp; <span class="built_in">isdigit</span>(s[pos])) &#123;</span><br><span class="line">                    num = num * <span class="number">10</span> + <span class="built_in">int</span>(s[pos++] - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                ans += sign * num;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><p>进阶思考：存在乘除法，并且’+’可以用作一元运算符(例如<code>&quot;+1&quot;</code>和<code>&quot;+(2+3)&quot;</code>有效)</p></blockquote><h1 id="3-栈与括号匹配"><a href="#3-栈与括号匹配" class="headerlink" title="3.栈与括号匹配"></a>3.栈与括号匹配</h1><h4 id="3-1-有效的括号：20"><a href="#3-1-有效的括号：20" class="headerlink" title="3-1.有效的括号：20"></a>3-1.有效的括号：20</h4><p>难度不高</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isValid</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        stack&lt;<span class="type">char</span>&gt; stk;</span><br><span class="line">        <span class="type">int</span> n = s.<span class="built_in">length</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> pos = <span class="number">0</span>; pos &lt; n; pos++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s[pos] == <span class="string">&#x27;(&#x27;</span> || s[pos] == <span class="string">&#x27;[&#x27;</span> || s[pos] == <span class="string">&#x27;&#123;&#x27;</span>) &#123;</span><br><span class="line">                stk.<span class="built_in">emplace</span>(s[pos]);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (stk.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (s[pos] == <span class="string">&#x27;)&#x27;</span> &amp;&amp; stk.<span class="built_in">top</span>() != <span class="string">&#x27;(&#x27;</span>) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (s[pos] == <span class="string">&#x27;]&#x27;</span> &amp;&amp; stk.<span class="built_in">top</span>() != <span class="string">&#x27;[&#x27;</span>) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (s[pos] == <span class="string">&#x27;&#125;&#x27;</span> &amp;&amp; stk.<span class="built_in">top</span>() != <span class="string">&#x27;&#123;&#x27;</span>) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                stk.<span class="built_in">pop</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> stk.<span class="built_in">empty</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="3-2-函数的独占时间：636"><a href="#3-2-函数的独占时间：636" class="headerlink" title="3-2.函数的独占时间：636"></a>3-2.函数的独占时间：636</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">exclusiveTime</span><span class="params">(<span class="type">int</span> n, vector&lt;string&gt;&amp; logs)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">res</span><span class="params">(n)</span></span>;</span><br><span class="line">        stack&lt;<span class="type">int</span>&gt; stk;</span><br><span class="line">        <span class="type">int</span> lastTimeStamp = <span class="number">0</span>; <span class="comment">// 上一个数的时间戳</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; log : logs) &#123;</span><br><span class="line">            <span class="comment">// 错误：数字可能不止一位</span></span><br><span class="line">            <span class="comment">// int id = log[0] - &#x27;0&#x27;;</span></span><br><span class="line">            <span class="comment">// char StartOrEnd = log[3];</span></span><br><span class="line">            <span class="comment">// int timeStamp = log[(int)log.size() - 1];</span></span><br><span class="line">            <span class="type">int</span> id, timeStamp;</span><br><span class="line">            <span class="type">char</span> StartOrEnd[<span class="number">6</span>];</span><br><span class="line">            <span class="built_in">sscanf</span>(log.<span class="built_in">c_str</span>(), <span class="string">&quot;%d:%[^:]:%d&quot;</span>, &amp;id, StartOrEnd, &amp;timeStamp);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 本质是括号匹配</span></span><br><span class="line">            <span class="keyword">if</span> (StartOrEnd[<span class="number">0</span>] == <span class="string">&#x27;s&#x27;</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!stk.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">                    res[stk.<span class="built_in">top</span>()] += timeStamp - lastTimeStamp;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 存在栈里的都是start部分未被end匹配消除的部分对应的id</span></span><br><span class="line">                stk.<span class="built_in">push</span>(id);</span><br><span class="line">                <span class="comment">// 每次循环结束更新时间戳</span></span><br><span class="line">                lastTimeStamp = timeStamp;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                res[stk.<span class="built_in">top</span>()] += timeStamp - lastTimeStamp + <span class="number">1</span>;</span><br><span class="line">                stk.<span class="built_in">pop</span>();</span><br><span class="line">                <span class="comment">// 为了统一时间戳标准，end的5相当于start的6.确保end-end正常</span></span><br><span class="line">                lastTimeStamp = timeStamp + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>注：关于<code>sscanf(log.c_str(), &quot;%d:%[^:]:%d&quot;, &amp;id, StartOrEnd, &amp;timeStamp);</code>，这里的租用类似于其他语言中的spilt()函数，用于将字符串根据’:’分割成不同的部分。sscanf()的功能类似于正则表达式的regex，胜在<u>轻量级和高效</u>，但是没有其强大。关于正则表达式regex，详见《2.1字符串篇(2)—-关于正则》。当字符串很长时，regex会涉及更多的内存释放和分配，并且需要更多的时间开销，可能导致<u>超时或内存占用过高</u>。</p><p>sscanf语法为：<code>int sscanf(const char *str, const char *format, T* dividePart1ptr, T* dividePart2ptr, ...);</code>，并将分割出的各个部分赋值到各个dividePart上。详细讲解：<a href="https://zhuanlan.zhihu.com/p/370029604">sscanf的用法</a></p><p><code>c_str()</code>是一个用于将C++字符串转换为C风格的字符串（以null结尾的字符数组）的成员函数，它返回一个指向以null结尾的字符数组的<mark>指针</mark>，该字符数组包含了与C++字符串相对应的字符序列。比如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">char</span> *cStyleStringPointer = myString.<span class="built_in">c_str</span>();</span><br></pre></td></tr></table></figure><p>现在再来将之前sscanf代码转换为regex代码，如下：(在本题中会超时)</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">regex <span class="title">pattern</span><span class="params">(<span class="string">&quot;(\\d+):(\\w+):(\\d+)&quot;</span>)</span></span>;</span><br><span class="line">smatch matches;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">regex_search</span>(log, matches, pattern)) &#123;</span><br><span class="line">    id = <span class="built_in">stoi</span>(matches[<span class="number">1</span>]);</span><br><span class="line">    string temp = matches[<span class="number">2</span>];</span><br><span class="line">    <span class="built_in">strcpy</span>(StartOrEnd, temp.<span class="built_in">c_str</span>());</span><br><span class="line">    timeStamp = <span class="built_in">stoi</span>(matches[<span class="number">3</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在又带来了新的知识点：是否可以将第6行代码写作<code>StartEnd = temp.c_str();</code>?答案是否定的，正如前面所说，<code>c_str()</code>返回的是<mark>以null结尾</mark>的字符数组的指针，而StartEnd只是个普通字符数组的指针，使用<code>strcpy()</code>则可以保证将<code>temp</code>中的内容复制到<code>StartOrEnd</code>中，并且最后有一个<u>字符串结束符</u>。</p><p>   同理，第5和第6行也可以直接改为<code>StartEnd = matches[2];</code>，前提要求声明的是<code>string StartEnd;</code>，因为字符串也相当于是一个以null结尾的字符数组。</p><hr><p>官方题解：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">exclusiveTime</span><span class="params">(<span class="type">int</span> n, vector&lt;string&gt;&amp; logs)</span> </span>&#123;</span><br><span class="line">        stack&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt; st; <span class="comment">// &#123;idx, 开始运行的时间&#125;</span></span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">res</span><span class="params">(n, <span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; log : logs) &#123;</span><br><span class="line">            <span class="type">char</span> type[<span class="number">10</span>];</span><br><span class="line">            <span class="type">int</span> idx, timestamp;</span><br><span class="line">            <span class="built_in">sscanf</span>(log.<span class="built_in">c_str</span>(), <span class="string">&quot;%d:%[^:]:%d&quot;</span>, &amp;idx, type, &amp;timestamp);</span><br><span class="line">            <span class="keyword">if</span> (type[<span class="number">0</span>] == <span class="string">&#x27;s&#x27;</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!st.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">                    res[st.<span class="built_in">top</span>().first] += timestamp - st.<span class="built_in">top</span>().second;</span><br><span class="line">                &#125;</span><br><span class="line">                st.<span class="built_in">emplace</span>(idx, timestamp);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">auto</span> t = st.<span class="built_in">top</span>();</span><br><span class="line">                st.<span class="built_in">pop</span>();</span><br><span class="line">                res[t.first] += timestamp - t.second + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span> (!st.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">                    st.<span class="built_in">top</span>().second = timestamp + <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="3-3-标签验证器：591（困难）"><a href="#3-3-标签验证器：591（困难）" class="headerlink" title="3-3.标签验证器：591（困难）"></a>3-3.标签验证器：591（困难）</h4><p>法一：正则表达式匹配</p><p>错解：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isValid</span><span class="params">(string code)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// ECMAScript</span></span><br><span class="line">        <span class="comment">// std::regex</span></span><br><span class="line">        <span class="comment">// pattern(&quot;&lt;([A-Z]&#123;1,9&#125;?&gt;)[^&lt;]*(&lt;!\[CDATA\[(.+?)\]\]&gt;)*[^&lt;]*&lt;\/\1&quot;);</span></span><br><span class="line">        <span class="comment">// leetcode需要将转义字符\再进行一次转义</span></span><br><span class="line">        <span class="function">std::regex <span class="title">pattern</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">            <span class="string">&quot;&lt;([A-Z]&#123;1,9&#125;?&gt;)[^&lt;]*(&lt;!\\[CDATA\\[(.*?)\\]\\]&gt;)*[^&lt;]*&lt;\\/\\1&quot;</span>)</span></span>;</span><br><span class="line">        <span class="keyword">if</span> (std::<span class="built_in">regex_match</span>(code, pattern)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>   这样的代码存在缺陷，比如code=<code>&quot;&lt;A&gt;&lt;A&gt;/A&gt;&lt;/A&gt;&lt;/A&gt;&quot;</code>或者<code>&quot;&lt;HTML&gt;&lt;DIV&gt;/A&gt;&lt;/DIV&gt;&lt;/HTML&gt;&quot;</code>或者<code>&quot;&lt;A&gt;&lt;B&gt;&lt;C&gt;&lt;D&gt;&lt;E&gt;&lt;F&gt;&lt;G&gt;&lt;/G&gt;&lt;H&gt;&lt;/H&gt;&lt;/F&gt;&lt;/E&gt;&lt;/D&gt;&lt;/C&gt;&lt;/B&gt;&lt;/A&gt;&quot;</code>代码返回false，而实际应该返回true。如果改为regex_search()使用局部匹配而非完全匹配，则会导致<code>&quot;&lt;HTMLQQQ&gt;&lt;DIV&gt;/A&gt;&lt;/DIV&gt;&lt;/HTML&gt;&quot;</code>返回了true。</p><p><strong>改进第一步：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isValid</span><span class="params">(string code)</span> </span>&#123;</span><br><span class="line">        <span class="function">std::regex <span class="title">pattern</span><span class="params">(<span class="string">&quot;&lt;([A-Z]&#123;1,9&#125;?&gt;)[^&lt;]*(&lt;!\\[CDATA\\[(.*?)\\]\\]&gt;)*[^&lt;]*&lt;\\/\\1&quot;</span>)</span></span>;</span><br><span class="line">        <span class="keyword">while</span> (std::<span class="built_in">regex_search</span>(code, pattern) &amp;&amp; code.<span class="built_in">length</span>() &gt; <span class="number">1</span>) &#123;</span><br><span class="line">            code = std::<span class="built_in">regex_replace</span>(code, pattern, <span class="string">&quot;#&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> code == <span class="string">&quot;#&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>   注意一点，<code>&quot;&lt;DIV&gt;&lt;UV&gt;&lt;![CDATA[&lt;GK&gt;&lt;![CDATA[&lt;![CDATA[OQA]]&gt;]]&gt;&lt;/GK&gt;]]&gt;&lt;/UV&gt;&lt;/DIV&gt;&quot;</code>应该返回false!因为<code>&lt;![CDATA[CDATA_CONTENT]]&gt;</code>，<code>CDATA_CONTENT</code> 的范围被定义成 <code>&lt;![CDATA[</code> 和<strong>后续的第一个</strong> <code>]]&gt;</code>之间的字符。因此还需要进一步改进。</p><p><strong>改进第二步：(正解)</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isValid</span><span class="params">(string code)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 先处理掉cdata</span></span><br><span class="line">        <span class="function">std::regex <span class="title">CDATApattern</span><span class="params">(<span class="string">&quot;&lt;!\\[CDATA\\[(.*?)\\]\\]&gt;&quot;</span>)</span></span>;</span><br><span class="line">        <span class="keyword">while</span> (std::<span class="built_in">regex_search</span>(code, CDATApattern)) &#123;</span><br><span class="line">            code = std::<span class="built_in">regex_replace</span>(code, CDATApattern, <span class="string">&quot;&amp;&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//再解决可能嵌套的标签</span></span><br><span class="line">        <span class="function">std::regex <span class="title">pattern</span><span class="params">(<span class="string">&quot;&lt;([A-Z]&#123;1,9&#125;?&gt;)[^&lt;]*&amp;*[^&lt;]*&lt;\\/\\1&quot;</span>)</span></span>;</span><br><span class="line">        <span class="keyword">while</span> (std::<span class="built_in">regex_search</span>(code, pattern)) &#123;</span><br><span class="line">            code = std::<span class="built_in">regex_replace</span>(code, pattern, <span class="string">&quot;#&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> code == <span class="string">&quot;#&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>至此解题完毕，不过时空开销较大。</p><p><img src="C:\Users\huangjiakun\Pictures\Marktext全局图片\f74d34754b8e317524894d4974f1dee69f4eb0df.png" alt=""></p><p><img src="C:\Users\huangjiakun\Pictures\Marktext全局图片\ab2a014851d62419a59e526f6a328a69263aaefa.png" alt=""></p><p>法二：栈+字符串遍历</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isValid</span><span class="params">(string code)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = code.<span class="built_in">size</span>();</span><br><span class="line">        stack&lt;string&gt; tags;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; n) &#123;</span><br><span class="line">            <span class="keyword">if</span> (code[i] == <span class="string">&#x27;&lt;&#x27;</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (i == n - <span class="number">1</span>) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (code[i + <span class="number">1</span>] == <span class="string">&#x27;/&#x27;</span>) &#123;</span><br><span class="line">                    <span class="type">int</span> j = code.<span class="built_in">find</span>(<span class="string">&#x27;&gt;&#x27;</span>, i);</span><br><span class="line">                    <span class="keyword">if</span> (j == string::npos) &#123;</span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    string tagname = code.<span class="built_in">substr</span>(i + <span class="number">2</span>, j - (i + <span class="number">2</span>));</span><br><span class="line">                    <span class="keyword">if</span> (tags.<span class="built_in">empty</span>() || tags.<span class="built_in">top</span>() != tagname) &#123;</span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    tags.<span class="built_in">pop</span>();</span><br><span class="line">                    i = j + <span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">if</span> (tags.<span class="built_in">empty</span>() &amp;&amp; i != n) &#123;</span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (code[i + <span class="number">1</span>] == <span class="string">&#x27;!&#x27;</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (tags.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    string cdata = code.<span class="built_in">substr</span>(i + <span class="number">2</span>, <span class="number">7</span>);</span><br><span class="line">                    <span class="keyword">if</span> (cdata != <span class="string">&quot;[CDATA[&quot;</span>) &#123;</span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="type">int</span> j = code.<span class="built_in">find</span>(<span class="string">&quot;]]&gt;&quot;</span>, i);</span><br><span class="line">                    <span class="keyword">if</span> (j == string::npos) &#123;</span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    i = j + <span class="number">3</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="type">int</span> j = code.<span class="built_in">find</span>(<span class="string">&#x27;&gt;&#x27;</span>, i);</span><br><span class="line">                    <span class="keyword">if</span> (j == string::npos) &#123;</span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    string tagname = code.<span class="built_in">substr</span>(i + <span class="number">1</span>, j - (i + <span class="number">1</span>));</span><br><span class="line">                    <span class="keyword">if</span> (tagname.<span class="built_in">size</span>() &lt; <span class="number">1</span> || tagname.<span class="built_in">size</span>() &gt; <span class="number">9</span>) &#123;</span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (!<span class="built_in">all_of</span>(tagname.<span class="built_in">begin</span>(), tagname.<span class="built_in">end</span>(),</span><br><span class="line">                                [](<span class="type">unsigned</span> <span class="type">char</span> c) &#123; <span class="keyword">return</span> <span class="built_in">isupper</span>(c); &#125;)) &#123;</span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    tags.<span class="built_in">push</span>(<span class="built_in">move</span>(tagname));</span><br><span class="line">                    i = j + <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (tags.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                ++i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> tags.<span class="built_in">empty</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="3-4-最长有效括号：32（困难）"><a href="#3-4-最长有效括号：32（困难）" class="headerlink" title="3-4.最长有效括号：32（困难）"></a>3-4.最长有效括号：32（困难）</h4><p>理解题意，有效括号子串形式为：1、”()()”;2、”(())”…其实就是满足3-1.第20题的那种字符串。</p><p>法一：动态规划</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">longestValidParentheses</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = s.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(n, <span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123; <span class="comment">// dp[0]必定为0</span></span><br><span class="line">            <span class="comment">// s[i]==&#x27;(&#x27;时dp[i]必定为0</span></span><br><span class="line">            <span class="keyword">if</span> (s[i] == <span class="string">&#x27;)&#x27;</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (s[i - <span class="number">1</span>] == <span class="string">&#x27;(&#x27;</span>) &#123; <span class="comment">//&quot;...()&quot;型</span></span><br><span class="line">                    dp[i] = (i &gt;= <span class="number">2</span> ? dp[i - <span class="number">2</span>] + <span class="number">2</span> : <span class="number">2</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (i &gt; dp[i - <span class="number">1</span>] &amp;&amp; s[i - dp[i - <span class="number">1</span>] - <span class="number">1</span>] == <span class="string">&#x27;(&#x27;</span>) &#123; <span class="comment">//&quot;...))&quot;型   </span></span><br><span class="line">                    dp[i] = dp[i - <span class="number">1</span>] + ((i - dp[i - <span class="number">1</span>]) &gt;= <span class="number">2</span> ? dp[i - dp[i - <span class="number">1</span>] - <span class="number">2</span>] + <span class="number">2</span> : <span class="number">2</span>);      </span><br><span class="line">                &#125;</span><br><span class="line">                ans = <span class="built_in">max</span>(ans, dp[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>法二：栈</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">longestValidParentheses</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = s.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        stack&lt;<span class="type">int</span>&gt; stk; <span class="comment">// 存储的是最后一个无法匹配的括号对应的下标</span></span><br><span class="line">        <span class="comment">// 如果一开始栈为空，第一个字符为左括号的时候我们会将其放入栈中，</span></span><br><span class="line">        <span class="comment">// 这样就不满足提及的「最后一个没有被匹配的右括号的下标」，</span></span><br><span class="line">        <span class="comment">// 为了保持统一，我们在一开始的时候往栈中放入一个值为-1的元素。</span></span><br><span class="line">        stk.<span class="built_in">push</span>(<span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s[i] == <span class="string">&#x27;(&#x27;</span>) &#123;</span><br><span class="line">                stk.<span class="built_in">push</span>(i);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                stk.<span class="built_in">pop</span>();<span class="comment">//-1的作用体现在这里，一开始为&#x27;)&#x27;时避免出错</span></span><br><span class="line">                <span class="keyword">if</span> (stk.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">                    stk.<span class="built_in">push</span>(i);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    ans = <span class="built_in">max</span>(ans, i - stk.<span class="built_in">top</span>());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>法三：双计数器，近似于双指针（最优，不需要额外空间）</p><p>left统计左括号数，right统计右括号数。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">longestValidParentheses</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = s.<span class="built_in">size</span>(), left = <span class="number">0</span>, right = <span class="number">0</span>, ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s[i] == <span class="string">&#x27;(&#x27;</span>) &#123;</span><br><span class="line">                left++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                right++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (left == right) &#123;</span><br><span class="line">                ans = <span class="built_in">max</span>(ans, <span class="number">2</span> * right);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (right &gt; left) &#123;</span><br><span class="line">                left = right = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        left = right = <span class="number">0</span>; <span class="comment">// 重置，为下一次遍历做准备</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s[i] == <span class="string">&#x27;(&#x27;</span>) &#123;</span><br><span class="line">                left++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                right++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (left == right) &#123;</span><br><span class="line">                ans = <span class="built_in">max</span>(ans, <span class="number">2</span> * left);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (left &gt; right) &#123;</span><br><span class="line">                left = right = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="4-递归-了解"><a href="#4-递归-了解" class="headerlink" title="4.递归(了解)"></a>4.递归(了解)</h1><h4 id="4-1-迷你语法分析器：385"><a href="#4-1-迷你语法分析器：385" class="headerlink" title="4-1.迷你语法分析器：385"></a>4-1.迷你语法分析器：385</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> index = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">NestedInteger <span class="title">deserialize</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (s[index] == <span class="string">&#x27;[&#x27;</span>) &#123;</span><br><span class="line">            index++;</span><br><span class="line">            NestedInteger ni;</span><br><span class="line">            <span class="keyword">while</span> (s[index] != <span class="string">&#x27;]&#x27;</span>) &#123;</span><br><span class="line">                ni.<span class="built_in">add</span>(<span class="built_in">deserialize</span>(s));</span><br><span class="line">                <span class="keyword">if</span> (s[index] == <span class="string">&#x27;,&#x27;</span>) &#123;</span><br><span class="line">                    index++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            index++;</span><br><span class="line">            <span class="keyword">return</span> ni;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="type">bool</span> negative = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">if</span> (s[index] == <span class="string">&#x27;-&#x27;</span>) &#123;</span><br><span class="line">                negative = <span class="literal">true</span>;</span><br><span class="line">                index++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">int</span> num = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (index &lt; s.<span class="built_in">size</span>() &amp;&amp; <span class="built_in">isdigit</span>(s[index])) &#123;</span><br><span class="line">                num = num * <span class="number">10</span> + s[index] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">                index++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (negative) &#123;</span><br><span class="line">                num *= <span class="number">-1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">NestedInteger</span>(num);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>341、394略。就是利用给的接口的方法解题。</p>]]></content>
    
    
    <summary type="html">栈与递归部分</summary>
    
    
    
    <category term="leetcode刷题笔记" scheme="https://sumikiru.top/categories/leetcode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="C++" scheme="https://sumikiru.top/tags/C/"/>
    
    <category term="leetcode" scheme="https://sumikiru.top/tags/leetcode/"/>
    
    <category term="栈" scheme="https://sumikiru.top/tags/%E6%A0%88/"/>
    
    <category term="递归" scheme="https://sumikiru.top/tags/%E9%80%92%E5%BD%92/"/>
    
  </entry>
  
  <entry>
    <title>3.数与位篇</title>
    <link href="https://sumikiru.top/posts/f83528c7.html"/>
    <id>https://sumikiru.top/posts/f83528c7.html</id>
    <published>2024-04-25T13:06:58.000Z</published>
    <updated>2025-02-06T14:42:00.323Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-数字的位操作"><a href="#1-数字的位操作" class="headerlink" title="1.数字的位操作"></a>1.数字的位操作</h1><h2 id="1-1-回文"><a href="#1-1-回文" class="headerlink" title="1-1.回文"></a>1-1.回文</h2><h3 id="1-1-1-回文数：9"><a href="#1-1-1-回文数：9" class="headerlink" title="1-1-1.回文数：9"></a>1-1-1.回文数：9</h3><p>法一：常规解法，但是需要考虑整数溢出问题</p><p>法二：反转一半数字</p><p>方法与法一类似，但是这样可以避免考虑溢出问题。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isPalindrome</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (x &lt; <span class="number">0</span> || (x % <span class="number">10</span> == <span class="number">0</span> &amp;&amp; x)) &#123;</span><br><span class="line">            <span class="comment">//因为最终return部分加入了x==res/10的情况，所以需要(x % 10 == 0 &amp;&amp; x)</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (x &gt; res) &#123;</span><br><span class="line">            <span class="type">int</span> digit = x % <span class="number">10</span>;</span><br><span class="line">            x /= <span class="number">10</span>;</span><br><span class="line">            res = res * <span class="number">10</span> + digit;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 当数字长度为奇数时，我们可以通过 revertedNumber/10 去除处于中位的数字。</span></span><br><span class="line">        <span class="comment">// 例如，当输入为 12321 时，在 while 循环的末尾我们可以得到 x = 12，revertedNumber = 123，</span></span><br><span class="line">        <span class="comment">// 由于处于中位的数字不影响回文（它总是与自己相等），所以我们可以简单地将其去除。</span></span><br><span class="line">        <span class="keyword">return</span> x == res || x == res / <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="1-1-2-寻找最近的回文数：564（困难）"><a href="#1-1-2-寻找最近的回文数：564（困难）" class="headerlink" title="1-1-2.寻找最近的回文数：564（困难）"></a>1-1-2.寻找最近的回文数：564（困难）</h3><p>模拟：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> ULL = <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;ULL&gt; <span class="title">getCandidates</span><span class="params">(<span class="type">const</span> string&amp; n)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> len = n.<span class="built_in">length</span>();</span><br><span class="line">        <span class="comment">// 候选数组，符合这4中情况的数字</span></span><br><span class="line">        vector&lt;ULL&gt; candidates = &#123;</span><br><span class="line">            (ULL)<span class="built_in">pow</span>(<span class="number">10</span>, len - <span class="number">1</span>) - <span class="number">1</span>,</span><br><span class="line">            (ULL)<span class="built_in">pow</span>(<span class="number">10</span>, len) + <span class="number">1</span>,</span><br><span class="line">        &#125;;</span><br><span class="line">        ULL selfPrefix = <span class="built_in">stoull</span>(n.<span class="built_in">substr</span>(<span class="number">0</span>, (len + <span class="number">1</span>) / <span class="number">2</span>));</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i : &#123;selfPrefix - <span class="number">1</span>, selfPrefix, selfPrefix + <span class="number">1</span>&#125;) &#123;</span><br><span class="line">            <span class="comment">// i只在这三个数之间遍历</span></span><br><span class="line">            <span class="comment">// prefix就是原数字的前半部分</span></span><br><span class="line">            string prefix = <span class="built_in">to_string</span>(i);</span><br><span class="line">            string candidate = prefix + <span class="built_in">string</span>(prefix.<span class="built_in">rbegin</span>() + (len &amp; <span class="number">1</span>), prefix.<span class="built_in">rend</span>());</span><br><span class="line">            candidates.<span class="built_in">push_back</span>(<span class="built_in">stoull</span>(candidate));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> candidates;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">string <span class="title">nearestPalindromic</span><span class="params">(string n)</span> </span>&#123;</span><br><span class="line">        ULL selfNumber = <span class="built_in">stoull</span>(n), ans = <span class="number">-1</span>;</span><br><span class="line">        <span class="type">const</span> vector&lt;ULL&gt;&amp; candidates = <span class="built_in">getCandidates</span>(n);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; candidate : candidates) &#123;</span><br><span class="line">            <span class="keyword">if</span> (candidate != selfNumber) &#123;</span><br><span class="line">                <span class="keyword">if</span> (ans == <span class="number">-1</span> ||</span><br><span class="line">                    <span class="built_in">llabs</span>(candidate - selfNumber) &lt; <span class="built_in">llabs</span>(ans - selfNumber) ||</span><br><span class="line">                    <span class="built_in">llabs</span>(candidate - selfNumber) == <span class="built_in">llabs</span>(ans - selfNumber) &amp;&amp; candidate &lt; ans) &#123;</span><br><span class="line">                    ans = candidate;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">to_string</span>(ans);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>注：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 第一种：typedef</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> myInt1;</span><br><span class="line"><span class="keyword">typedef</span> std::vector&lt;<span class="type">int</span>&gt; IntVector1;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第二种：using 别名声明</span></span><br><span class="line"><span class="keyword">using</span> myInt2 = <span class="type">int</span>;</span><br><span class="line"><span class="keyword">using</span> IntVector2 = std::vector&lt;<span class="type">int</span>&gt;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第三种：using 模板别名</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">using</span> myIntVector = std::vector&lt;T&gt;;</span><br></pre></td></tr></table></figure><ol><li><p><code>using ULL = unsigned long long;</code>：关于别名有三种写法，typedef、using别名声明、using模板声明。</p><p>类型别名（type alias）、<code>#define</code> 宏和 <code>const</code> 常量的区别：<br><img src="https://s2.loli.net/2024/03/02/KH47ykvXJzDcOGq.png" alt=""><br><img src="https://s2.loli.net/2024/03/02/ENLYWubxaqS8IvM.png" alt=""></p></li><li><p><code>string(prefix.rbegin() + (len &amp; 1), prefix.rend());</code>：<br>+<code>len&amp;1</code>是指，如果长度len为单数（len&amp;1==1，涉及位运算，奇数的二进制末位为1），则从下标1开始添加，否则从0开始。<code>string(startIterater,endIterater);</code></p></li><li><p>stoull()、llabs():不在赘述，注意并没有ullabs()的用法。还有一点值得注意，应该使用unsigned long long而非long long,是因为如果输入为：”999999999999999999”,对于13行这句 <code>candidates.push_back(stol(candidate)); stol</code> 会产生溢出，原因是candidate超过 long long，是两个大数相加接近 2^65了。</p></li></ol><h2 id="1-2-x的幂"><a href="#1-2-x的幂" class="headerlink" title="1-2.x的幂"></a>1-2.x的幂</h2><h3 id="1-2-1-2的幂：231"><a href="#1-2-1-2的幂：231" class="headerlink" title="1-2-1.2的幂：231"></a>1-2-1.2的幂：231</h3><p>法一：位运算</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isPowerOfTwo</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> n &gt; <span class="number">0</span> &amp;&amp; (n &amp; (n - <span class="number">1</span>)) == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isPowerOfTwo</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> n &gt; <span class="number">0</span> &amp;&amp; (n &amp; -n) == n;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>法二：判断是否为最大的2的幂的约数（取巧，了解）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">static</span> <span class="keyword">constexpr</span> <span class="type">int</span> BIG = <span class="number">1</span> &lt;&lt; <span class="number">30</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isPowerOfTwo</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> n &gt; <span class="number">0</span> &amp;&amp; BIG % n == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>注:<code>1&lt;&lt;30</code>是指二进制数1左移30位变成$2^{31}$。</p><h3 id="关于常量"><a href="#关于常量" class="headerlink" title="关于常量"></a>关于常量</h3><p>   constexpr用于声明常量表达式,const用于声明常量。<code>1&lt;&lt;30</code>是常量表达式，因为它在<u>编译时就能得到计算结果</u>。并且这里必须加上static使得BIG被声明为<mark>静态常量</mark>，让所有Solution的实例都共享同一份BIG。</p><hr><p>Q:如何判断一个常量表达式是不是运行时才能计算出结果？</p><p>A:考虑以下几点：</p><ol><li><p><strong>非编译时计算</strong>：如果一个常量表达式可以在编译时就计算出结果，那么它就不是运行时才能计算出的。编译器会在编译阶段对这些表达式进行求值。</p></li><li><p><strong>依赖运行时信息</strong>：如果一个常量表达式依赖于在运行时才能确定的信息，比如用户输入、动态分配的内存地址等，那么它就是运行时才能计算出的。</p></li><li><p><strong>函数调用</strong>：如果一个常量表达式中包含函数调用，特别是虚函数调用或者依赖于动态多态性的调用，那么它通常是在运行时才能计算出结果的。</p></li><li><p><strong>条件表达式</strong>：如果一个常量表达式包含条件运算符（如<code>? :</code>），并且条件是在运行时才能确定的，那么它也是在运行时才能计算出结果的。</p></li></ol><p>比如<code>1&lt;&lt;x</code>,<code>pow(3,19)</code>,<code>a&gt;15?true:false</code>都是在运行时才能计算出结果。第一个对应第2点，x在运行时才能确定；第二个对应第3点，包含了pow()函数调用;第三个对应第4点，包含了条件运算符的同时包含了运行时才能确定的条件a&gt;15.</p><p>而诸如<code>20&gt;15</code>,<code>4+3</code>,<code>110&lt;&lt;24</code>这类，则是编译时就能计算出结果。</p><hr><p>constexpr和const的详细区别：<a href="https://zhuanlan.zhihu.com/p/635720513">constexpr和const</a></p><p>   总的来说，const 是一个用于指定常量的关键字，而 constexpr 则是一个用于指定常量表达式的关键字。使用 constexpr 可以让编译器进行优化和检查，提高代码的可读性和运行效率。 </p><h3 id="1-2-2-4的幂：342"><a href="#1-2-2-4的幂：342" class="headerlink" title="1-2-2.4的幂：342"></a>1-2-2.4的幂：342</h3><p>法一：位运算</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isPowerOfFour</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> n &gt; <span class="number">0</span> &amp;&amp; (n &amp; (n - <span class="number">1</span>)) == <span class="number">0</span> &amp;&amp; (n &amp; <span class="number">0xaaaaaaaa</span>) == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>法二：取模</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isPowerOfFour</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> n &gt; <span class="number">0</span> &amp;&amp; (n &amp; (n - <span class="number">1</span>)) == <span class="number">0</span> &amp;&amp; n % <span class="number">3</span> == <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>尝试写出判断一个数是否为8的幂次方。</p><h3 id="1-2-3-3的幂：326"><a href="#1-2-3-3的幂：326" class="headerlink" title="1-2-3.3的幂：326"></a>1-2-3.3的幂：326</h3><p>法一：判断是否为最大的3的幂的约数（取巧，了解）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">static</span> <span class="type">const</span> <span class="type">int</span> BIG = <span class="number">1162261467</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isPowerOfThree</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123; </span><br><span class="line">        <span class="keyword">return</span> n &gt; <span class="number">0</span> &amp;&amp; BIG % n == <span class="number">0</span>; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>法二：试除法（时间复杂度较高）</p><p>不断除以3直到n=1:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isPowerOfThree</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (n &amp;&amp; n % <span class="number">3</span> == <span class="number">0</span>) &#123;</span><br><span class="line">            n /= <span class="number">3</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> n == <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="1-3-颠倒二进制位：190"><a href="#1-3-颠倒二进制位：190" class="headerlink" title="1-3.颠倒二进制位：190"></a>1-3.颠倒二进制位：190</h2><p><code>uint32_t</code>是无符号32位整数类型，范围在$0$~$2^{32}-1$，定义在头文件<code>&lt;cstdint&gt;</code>中。</p><p>法一：逐位颠倒</p><p>每次把 res 左移，把 n 的二进制末尾数字，拼接到结果 res 的末尾。然后把 n 右移。</p><p>以8位二进制为例：</p><div class="table-container"><table><thead><tr><th style="text-align:center">i</th><th style="text-align:center">n</th><th style="text-align:center">n&amp;1</th><th style="text-align:center">res</th></tr></thead><tbody><tr><td style="text-align:center">—-</td><td style="text-align:center">11001001</td><td style="text-align:center">1</td><td style="text-align:center">—-</td></tr><tr><td style="text-align:center">0</td><td style="text-align:center">01100100</td><td style="text-align:center">0</td><td style="text-align:center">1,0000000</td></tr><tr><td style="text-align:center">1</td><td style="text-align:center">00110010</td><td style="text-align:center">0</td><td style="text-align:center">10,000000</td></tr><tr><td style="text-align:center">2</td><td style="text-align:center">00011001</td><td style="text-align:center">1</td><td style="text-align:center">100,00000</td></tr><tr><td style="text-align:center">3</td><td style="text-align:center">00001100</td><td style="text-align:center">0</td><td style="text-align:center">1001,0000</td></tr><tr><td style="text-align:center">4</td><td style="text-align:center">00000110</td><td style="text-align:center">0</td><td style="text-align:center">10010,000</td></tr><tr><td style="text-align:center">5</td><td style="text-align:center">00000011</td><td style="text-align:center">1</td><td style="text-align:center">100100,00</td></tr><tr><td style="text-align:center">6</td><td style="text-align:center">00000001</td><td style="text-align:center">1</td><td style="text-align:center">1001001,0</td></tr><tr><td style="text-align:center">7</td><td style="text-align:center">00000000</td><td style="text-align:center">—-</td><td style="text-align:center">10010011</td></tr></tbody></table></div><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">uint32_t</span> <span class="title">reverseBits</span><span class="params">(<span class="type">uint32_t</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="type">uint32_t</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; n &gt; <span class="number">0</span> &amp;&amp; i &lt; <span class="number">32</span>; i++) &#123;</span><br><span class="line">            res |= (n &amp; <span class="number">1</span>) &lt;&lt; (<span class="number">31</span> - i);</span><br><span class="line">            <span class="comment">//如n&amp;1==1时,n为奇数.同时也能判断出n末位为1,所以n&amp;1也代表末位</span></span><br><span class="line">            <span class="comment">//末位右移31-i位，后面补上0并与res进行位或操作</span></span><br><span class="line">            n &gt;&gt;= <span class="number">1</span>; <span class="comment">// n左移1位，相当于去除之前的末位</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>或者：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">uint32_t</span> <span class="title">reverseBits</span><span class="params">(<span class="type">uint32_t</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="type">uint32_t</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; n &gt; <span class="number">0</span> &amp;&amp; i &lt; <span class="number">32</span>; i++) &#123;<span class="comment">//去掉n&gt;0的条件</span></span><br><span class="line">            res = (res &lt;&lt; <span class="number">1</span>) | (n &amp; <span class="number">1</span>);</span><br><span class="line">            n &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>法二：位运算分治(最优)</p><p>   类似归并排序，其思想是分而治之，把数字分为两半，然后交换这两半的顺序；然后把前后两个半段都再分成两半，交换内部顺序……直至最后交换顺序的时候，交换的数字只有 1 位。</p><p><img src="https://s2.loli.net/2024/03/03/o8rGDi5tnCQw6e1.png" alt=""></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">const</span> <span class="type">uint32_t</span> M1 = <span class="number">0x55555555</span>; <span class="comment">// 01010101010101010101010101010101</span></span><br><span class="line">    <span class="type">const</span> <span class="type">uint32_t</span> M2 = <span class="number">0x33333333</span>; <span class="comment">// 00110011001100110011001100110011</span></span><br><span class="line">    <span class="type">const</span> <span class="type">uint32_t</span> M4 = <span class="number">0x0f0f0f0f</span>; <span class="comment">// 00001111000011110000111100001111</span></span><br><span class="line">    <span class="type">const</span> <span class="type">uint32_t</span> M8 = <span class="number">0x00ff00ff</span>; <span class="comment">// 00000000111111110000000011111111</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">uint32_t</span> <span class="title">reverseBits</span><span class="params">(<span class="type">uint32_t</span> n)</span> </span>&#123;</span><br><span class="line">        n = n &gt;&gt; <span class="number">1</span> &amp; M1 | (n &amp; M1) &lt;&lt; <span class="number">1</span>;</span><br><span class="line">        n = n &gt;&gt; <span class="number">2</span> &amp; M2 | (n &amp; M2) &lt;&lt; <span class="number">2</span>;</span><br><span class="line">        n = n &gt;&gt; <span class="number">4</span> &amp; M4 | (n &amp; M4) &lt;&lt; <span class="number">4</span>;</span><br><span class="line">        n = n &gt;&gt; <span class="number">8</span> &amp; M8 | (n &amp; M8) &lt;&lt; <span class="number">8</span>;</span><br><span class="line">        <span class="keyword">return</span> n &gt;&gt; <span class="number">16</span> | n &lt;&lt; <span class="number">16</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>关于分治算法：<a href="https://zhuanlan.zhihu.com/p/510267724">分治算法</a></p><h3 id="1-3-1-位1的个数：191"><a href="#1-3-1-位1的个数：191" class="headerlink" title="1-3-1.位1的个数：191"></a>1-3-1.位1的个数：191</h3><p>法一：遍历每个二进制位</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">hammingWeight</span><span class="params">(<span class="type">uint32_t</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> num = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">32</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (n &amp; (<span class="number">1</span> &lt;&lt; i)) &#123; <span class="comment">// 1左移i位</span></span><br><span class="line">                num++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> num;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>法二：优化</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">hammingWeight</span><span class="params">(<span class="type">uint32_t</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> num = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (n) &#123;</span><br><span class="line">            n &amp;= n - <span class="number">1</span>;</span><br><span class="line">            num++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> num;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><code>n&amp;(n-1)</code>可以用来判断有几个1，也可以通过其值是否为0来判断一个数是不是2的幂(详见1-2-2)。也有内置函数<code>__builtin_popcount(n)</code>，时间复杂度$O(1)$。</p><h3 id="1-3-2-数字的补数：476-低位取反"><a href="#1-3-2-数字的补数：476-低位取反" class="headerlink" title="1-3-2.数字的补数：476(低位取反)"></a>1-3-2.数字的补数：476(低位取反)</h3><p>法一:常规位运算</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findComplement</span><span class="params">(<span class="type">int</span> num)</span> </span>&#123;</span><br><span class="line">        uint t = (uint)<span class="number">1</span> &lt;&lt; <span class="number">31</span>;</span><br><span class="line">        <span class="keyword">while</span> ((t &amp; num) == <span class="number">0</span>) &#123;</span><br><span class="line">            num |= t;</span><br><span class="line">            t &gt;&gt;= <span class="number">1</span>; <span class="comment">// t右移一位</span></span><br><span class="line">            <span class="comment">//相当于对num从高位到地位逐个遍历,把num第一个1前面的0都改为1</span></span><br><span class="line">            <span class="comment">// 这样num取反才是正确的</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ~num; <span class="comment">// 取反</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>t:1000…000-&gt;0100…000-&gt;…-&gt;0000…0001(如果一直循环)</p><p>num(5):000…0101-&gt;100…0101-&gt;…-&gt;111…1101-&gt;(取反)000…0010(32位二进制数)-&gt;2</p><p>注意，<code>==</code>的优先级比<code>&amp;</code>高，所以<code>t&amp;num</code>必须带上括号。</p><p><code>(uint)1&lt;&lt;31</code>也可以写为<code>1u&lt;&lt;31</code>。uint相当于unsigned int.</p><hr><p>或者：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findComplement</span><span class="params">(<span class="type">int</span> num)</span> </span>&#123;</span><br><span class="line">        uint mask = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (mask &lt; num) &#123;</span><br><span class="line">            mask &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">            mask |= <span class="number">1</span>;<span class="comment">//mask比较特殊，这里mask++;也可以</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> mask ^ num;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>由于mask只含有1个“1”,因此mask&lt;num也就是mask的“1”相比num中的最高位1，总是在同位或者更低位，即还在遍历num中。000…1000&lt;000…1011</p><hr><p>法二：位运算分治</p><p>时间复杂度为$O(log log num)$</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findComplement</span><span class="params">(<span class="type">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> t = num;</span><br><span class="line">        t |= t &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        t |= t &gt;&gt; <span class="number">2</span>;</span><br><span class="line">        t |= t &gt;&gt; <span class="number">4</span>;</span><br><span class="line">        t |= t &gt;&gt; <span class="number">8</span>;</span><br><span class="line">        t |= t &gt;&gt; <span class="number">16</span>;</span><br><span class="line">        <span class="keyword">return</span> ~num &amp; t;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>注</strong>：分治目的是把t各低位为零数取反，最终变为与num对应低位全1的32位二进制数。</p><p>t:0000…0101-&gt;0000…0111(<mark>奇位且低位的0变为1</mark>)-&gt;…-&gt;0000…0111</p><p>~num=1111…1010,则<code>~num&amp;t=num^t</code>=0000…0010</p><p>在位运算中，<code>^</code> 表示<u>按位异或</u>运算，它的结果是对应位不同则为1，相同则为0。而 <code>&amp;</code> 表示<u>按位与</u>运算，它的结果是对应位都为1时为1，否则为0。</p><h3 id="1-3-3-汉明距离：461"><a href="#1-3-3-汉明距离：461" class="headerlink" title="1-3-3.汉明距离：461"></a>1-3-3.汉明距离：461</h3><p>汉明距离指两个数字对应的<mark>二进制位不同</mark>的位置的数目。该题其实是1-3-1和1-3-2的结合</p><p>法一：(最优)内置函数，时间复杂度O(1)。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">hammingDistance</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> __builtin_popcount(x ^ y);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>法二：Brian Kernighan算法(基础位运算结合)</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">hammingDistance</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> t = x ^ y;<span class="comment">//按位异或,不同的地方全变为1</span></span><br><span class="line">        <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (t) &#123;</span><br><span class="line">            t &amp;= t - <span class="number">1</span>;<span class="comment">//用来判断有几个1</span></span><br><span class="line">            count++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>或者:移位实现位计数</p><p>只是换一种方式统计1的个数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">hammingDistance</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> t = x ^ y; <span class="comment">// 按位异或,不同的地方全变为1</span></span><br><span class="line">        <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (t) &#123;</span><br><span class="line">            count += t &amp; <span class="number">1</span>;<span class="comment">//t末位为1,则t&amp;1=1,count加1</span></span><br><span class="line">            t &gt;&gt;= <span class="number">1</span>;<span class="comment">//相当于去除末位,首位补0</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>法三：位运算分治</p><p><img src="https://s2.loli.net/2024/03/05/yXfnBWUePE2uRHz.png" alt=""></p><p>两两切分统计：掩码对数值进行切分，连续的0用于进位，连续的1是运算位。五次运算分别类似于是二进制数加法，四进制数加法，十六进制数加法和三十二进制数加法。如01111011-&gt;01 10 01 10(1212)-&gt;0011 0011(33)-&gt;00000110(6)，个数即为6。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">const</span> <span class="type">uint32_t</span> M1 = <span class="number">0x55555555</span>;</span><br><span class="line">    <span class="type">const</span> <span class="type">uint32_t</span> M2 = <span class="number">0x33333333</span>;</span><br><span class="line">    <span class="type">const</span> <span class="type">uint32_t</span> M4 = <span class="number">0x0f0f0f0f</span>;</span><br><span class="line">    <span class="type">const</span> <span class="type">uint32_t</span> M8 = <span class="number">0x00ff00ff</span>;</span><br><span class="line">    <span class="type">const</span> <span class="type">uint32_t</span> M16 = <span class="number">0x0000ffff</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">hammingDistance</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = x ^ y;</span><br><span class="line">        n = ((n &gt;&gt; <span class="number">1</span>) &amp; M1) + (n &amp; M1);</span><br><span class="line">        n = ((n &gt;&gt; <span class="number">2</span>) &amp; M2) + (n &amp; M2);</span><br><span class="line">        n = ((n &gt;&gt; <span class="number">4</span>) &amp; M4) + (n &amp; M4);</span><br><span class="line">        n = ((n &gt;&gt; <span class="number">8</span>) &amp; M8) + (n &amp; M8);</span><br><span class="line">        n = ((n &gt;&gt; <span class="number">16</span>) &amp; M16) + (n &amp; M16);</span><br><span class="line">        <span class="keyword">return</span> n;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="关于运算符优先级"><a href="#关于运算符优先级" class="headerlink" title="关于运算符优先级"></a>关于运算符优先级</h3><p>最好是手动加入括号控制运算顺序。总优先级：算术运算&gt;关系运算&gt;逻辑运算。</p><p>算术运算（加+ 减- 乘* 除/ 取余%），关系运算（&gt; &gt;= &lt; &lt;= != ==) ，逻辑运算 （与或非）</p><p><img title="" src="https://s2.loli.net/2024/03/05/56LdGaltPXoRqpU.png" alt="" width="430"></p><h3 id="常见位运算技巧"><a href="#常见位运算技巧" class="headerlink" title="常见位运算技巧"></a>常见位运算技巧</h3><ol><li><p><code>n &amp; M1</code>:将二进制数n中的奇数位的1保留，丢弃偶数位。如n=00011001…01110101-&gt;00010001…01010001。<code>(n&gt;&gt;2)&amp;M2</code>同理。</p></li><li><p><code>(n &gt;&gt; 1) &amp; M1 | (n &amp; M1) &lt;&lt; 1</code>：交换相邻两个数的位置。<code>(n &gt;&gt; 2) &amp; M2 | (n &amp; M2) &lt;&lt; 2</code>则是两个为一组，互相交换各组。如0011-&gt;1100</p></li><li><p><code>((n &gt;&gt; 1) &amp; M1) + (n &amp; M1)</code>：将n中的相邻两位相加，如10110101-&gt;1211(即01110101).<code>((n &gt;&gt; 2) &amp; M2) + (n &amp; M2)</code>同理，如1211(即01 11 01 01)-&gt;32(即0011 0010)</p></li><li><p><code>t &amp; 1</code>：判断t是否为奇数,如果为奇数则结果为1。/获取t末位数字。<code>(t&gt;&gt;i) &amp; 1</code>则用来获取第i位的值（从右往左数第i位）。</p></li><li><p><code>t &amp; (t-1)</code>：每在循环内执行一次并计数+1，则循环完成就可以统计出二进制数中1的个数。</p></li></ol><hr><h3 id="1-3-4-汉明距离总和-477"><a href="#1-3-4-汉明距离总和-477" class="headerlink" title="1-3-4.汉明距离总和:477"></a>1-3-4.汉明距离总和:477</h3><p>最优解：逐位统计</p><p>先看所有数字的第一位，然后再第二位…而非先计算出两两之间的汉明距离。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">totalHammingDistance</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> ans = <span class="number">0</span>, size = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">32</span>; i++) &#123;</span><br><span class="line">            <span class="type">int</span> n = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> num : nums) &#123;</span><br><span class="line">                n += (num &gt;&gt; i) &amp; <span class="number">1</span>; <span class="comment">// n加上num第i位的值(从右往左第i位)</span></span><br><span class="line">                <span class="comment">//第i位的值只可能是0/1，因此n记录下出现过1的次数</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//第i位一共n个1，size-n个0</span></span><br><span class="line">            ans += n * (size - n);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="1-3-5-交替位二进制数：693"><a href="#1-3-5-交替位二进制数：693" class="headerlink" title="1-3-5.交替位二进制数：693"></a>1-3-5.交替位二进制数：693</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">hasAlternatingBits</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        uint a = n ^ (n &gt;&gt; <span class="number">1</span>);<span class="comment">//long也可以，但是int不行</span></span><br><span class="line">        <span class="keyword">return</span> (a &amp; (a + <span class="number">1</span>)) == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><code>a=n^(n&gt;&gt;1)</code>:a除去前导的0之外，其它数位全部都是1。因为如果a是低位二进制位交替出现的话，那右移一位就是原来是0的移到了原来是1的位置上；再异或，就全部都是1了。</p><p><code>a&amp;(a+1)</code>:二进制位全部都是1的a加上1,得到的二进制数a+1多了最前面一个数位1其它都是0,再与全部是0的a进行&amp;位与运算肯定是0。</p><h2 id="1-4-数学思维（-）"><a href="#1-4-数学思维（-）" class="headerlink" title="1-4.数学思维（*）"></a>1-4.数学思维（*）</h2><h3 id="1-4-1-可怜的小猪：458"><a href="#1-4-1-可怜的小猪：458" class="headerlink" title="1-4-1.可怜的小猪：458"></a>1-4-1.可怜的小猪：458</h3><p>数学分析+base进制：</p><p><a href="https://leetcode.cn/problems/poor-pigs/solutions/1/hua-jie-suan-fa-458-ke-lian-de-xiao-zhu-by-guanpen/">画解算法:458.可怜的小猪</a></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">poorPigs</span><span class="params">(<span class="type">int</span> buckets, <span class="type">int</span> minutesToDie, <span class="type">int</span> minutesToTest)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> base = minutesToTest / minutesToDie + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">ceil</span>(<span class="built_in">log</span>(buckets) / <span class="built_in">log</span>(base) - <span class="number">1e-5</span>);<span class="comment">//是1e-5即10^(-5)</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><code>ceil()</code>:向上取整函数。</p><p>减去1e-5:目的是让<code>log(buckets) / log(base)</code>减去一个即小的值以避免<mark>舍入误差</mark>，也可以是1e-7等等。因为当buckets=125,minutesToDie=1,minutesToTest=4时，结果应该是3，而不考虑舍入误差，则答案会是4。在这段代码中，<code>log(buckets) / log(base)</code>的结果通常是一个浮点数，但由于浮点数计算的精度限制，可能会出现微小的舍入误差。通过减去 1e-5，可以确保结果向下取整，避免由于舍入误差而导致的计算结果错误。这样做可以更接近正确的整数结果。</p><h3 id="1-4-2-各位相加：258"><a href="#1-4-2-各位相加：258" class="headerlink" title="1-4-2.各位相加：258"></a>1-4-2.各位相加：258</h3><p>详细思路：<a href="https://leetcode.cn/problems/add-digits/solutions/1/xiang-xi-tong-su-de-si-lu-fen-xi-duo-jie-fa-by-5-7/">力扣（LeetCode)</a></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">addDigits</span><span class="params">(<span class="type">int</span> num)</span> </span>&#123; </span><br><span class="line">        <span class="keyword">return</span> (num - <span class="number">1</span>) % <span class="number">9</span> + <span class="number">1</span>; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="1-4-3-灯泡开关：319"><a href="#1-4-3-灯泡开关：319" class="headerlink" title="1-4-3.灯泡开关：319"></a>1-4-3.灯泡开关：319</h3><p>详细思路：<a href="https://leetcode.cn/problems/bulb-switcher/solutions/1102293/gong-shui-san-xie-jing-dian-shu-lun-tui-upnnb/">【宫水三叶】经典数论推论题</a></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">bulbSwitch</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123; </span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">sqrt</span>(n + <span class="number">0.5</span>); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>答案为$\lfloor \sqrt{n} \rfloor$，其中 $\lfloor \cdot \rfloor$ 表示向下取整。</p><p>加上0.5：由于 $\sqrt{n}$涉及到浮点数运算，为了保证不出现精度问题（避免<mark>舍入误差</mark>），我们可以计算 $\sqrt{n + \dfrac{1}{2}}$​，这样可以保证计算出来的结果向下取整在32位整数范围内一定正确。其实加上一个较小的数也可以，比如1e-5。</p><p>   综上，对于<u>return浮点数类型</u>且<u>函数返回值类型为int</u>的，往往需要向上或者向下取整。为避免舍入误差，需要引入较小的数，比如1e-5($10^{-5}$)，是加是减根据题目判断。</p><h2 id="1-5-进制转换"><a href="#1-5-进制转换" class="headerlink" title="1-5.进制转换"></a>1-5.进制转换</h2><h3 id="1-5-1-数字转换为16进制数：405"><a href="#1-5-1-数字转换为16进制数：405" class="headerlink" title="1-5-1.数字转换为16进制数：405"></a>1-5-1.数字转换为16进制数：405</h3><p>位运算，关键在于<code>int val = (num &gt;&gt; (4 * i)) &amp; 0xf</code>将二进制数分组以后再一一运算。如果这里是转为8进制数，则每三个数为一组，同理。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">toHex</span><span class="params">(<span class="type">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (num == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;0&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        string ans = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="comment">// 32位的二进制数一共8组，每组4个数num&gt;&gt;(4*i)可以将第i组的四个数移到末尾</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">7</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="type">int</span> val = (num &gt;&gt; (<span class="number">4</span> * i)) &amp; <span class="number">0xf</span>;<span class="comment">//一个val对应十六进制的一个数字0-9/字母a-f</span></span><br><span class="line">            <span class="keyword">if</span> (ans.<span class="built_in">length</span>() &gt; <span class="number">0</span> || val &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="type">char</span> digit = val &lt; <span class="number">10</span> ? (<span class="type">char</span>)(val + <span class="string">&#x27;0&#x27;</span>) : (<span class="type">char</span>)(<span class="string">&#x27;a&#x27;</span> + val - <span class="number">10</span>);</span><br><span class="line">                ans.<span class="built_in">push_back</span>(digit);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><p><code>ans.length()&gt;0</code>用于避免出现前置0.</p></li><li><p>求负整数的补码:将其原码<u>除符号位外</u>的所有位取反（0变1，1变0，符号位为1不变）后加1。</p></li><li><p>该题还要注意一点，<code>val+&#39;0&#39;</code>只适用于val&lt;10时的情况，因为<code>&#39;a&#39;!=&#39;9&#39;+1</code>，它们对应的ASCII码并不是连续的。</p></li></ul><h3 id="1-5-2-Excel表列名称：168"><a href="#1-5-2-Excel表列名称：168" class="headerlink" title="1-5-2.Excel表列名称：168"></a>1-5-2.Excel表列名称：168</h3><p>本质为10进制转26进制。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">convertToTitle</span><span class="params">(<span class="type">int</span> columnNumber)</span> </span>&#123;</span><br><span class="line">        string ans = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">while</span> (columnNumber &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            --columnNumber;</span><br><span class="line">            <span class="type">char</span> c = columnNumber % <span class="number">26</span> + <span class="string">&#x27;A&#x27;</span>;<span class="comment">//从末位从后往前添加字符</span></span><br><span class="line">            ans.<span class="built_in">push_back</span>(c);</span><br><span class="line">            columnNumber /= <span class="number">26</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">reverse</span>(ans.<span class="built_in">begin</span>(), ans.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="1-6-数字变换-统计-数学分析"><a href="#1-6-数字变换-统计-数学分析" class="headerlink" title="1-6.数字变换/统计 + 数学分析"></a>1-6.数字变换/统计 + 数学分析</h2><h3 id="1-6-1-最大变换：670"><a href="#1-6-1-最大变换：670" class="headerlink" title="1-6-1.最大变换：670"></a>1-6-1.最大变换：670</h3><p><u>最接近右边且最大</u>的数是s[maxIndex]与<u>最接近左边且非最大</u>的数s[index]进行交换。但是如果这样得出的maxIndex&lt;index，那么结果会出现问题。因此需要额外引入index2来记录每一次循环完成后的maxIndex，index2=maxIndex.</p><p>贪心：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maximumSwap</span><span class="params">(<span class="type">int</span> num)</span> </span>&#123;</span><br><span class="line">        string s = <span class="built_in">to_string</span>(num);</span><br><span class="line">        <span class="type">int</span> n = s.<span class="built_in">size</span>(), maxIndex = n - <span class="number">1</span>, index1 = <span class="number">-1</span>, index2 = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s[maxIndex] &lt; s[i]) &#123;</span><br><span class="line">                maxIndex = i;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (s[i] &lt; s[maxIndex]) &#123;</span><br><span class="line">                index1 = i;</span><br><span class="line">                index2 = maxIndex;<span class="comment">//比如98368,maxIndex=0,需要额外的index2记录</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (index1 &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">swap</span>(s[index1], s[index2]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">stoi</span>(s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="1-6-2-数字1的个数：233（困难）"><a href="#1-6-2-数字1的个数：233（困难）" class="headerlink" title="1-6-2.数字1的个数：233（困难）"></a>1-6-2.数字1的个数：233（困难）</h3><p>解题思路：<a href="https://leetcode.cn/problems/number-of-digit-one/solutions/1/233-shu-zi-1-de-ge-shu-qing-xi-tu-jie-by-pgb1/">数字 1 的个数（清晰图解）</a></p><script type="math/tex; mode=display">res+=\left \{\begin{array}{}&high \times digit\ ,\ &cur = 0\ ;\\&high \times digit + low + 1 \ ,\ &cur = 1\ ;\\&(high + 1) \times digit\ ,\ &cur\gt1\ ;\\\end{array}\right.</script><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">countDigitOne</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="type">long</span> digit = <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> high = n / <span class="number">10</span>, cur = n % <span class="number">10</span>, low = <span class="number">0</span>, res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (high != <span class="number">0</span> || cur != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (cur == <span class="number">0</span>) &#123;</span><br><span class="line">                res += high * digit;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (cur == <span class="number">1</span>) &#123;</span><br><span class="line">                res += high * digit + low + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                res += (high + <span class="number">1</span>) * digit;</span><br><span class="line">            &#125;</span><br><span class="line">            low += cur * digit;</span><br><span class="line">            cur = high % <span class="number">10</span>;</span><br><span class="line">            high /= <span class="number">10</span>;</span><br><span class="line">            digit *= <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="1-6-3-统计各位数字都不同的数字个数：357"><a href="#1-6-3-统计各位数字都不同的数字个数：357" class="headerlink" title="1-6-3.统计各位数字都不同的数字个数：357"></a>1-6-3.统计各位数字都不同的数字个数：357</h3><p>使用数字的排列组合$A^{n}_{k}​=\frac{n!}{(n−k)!}$</p><blockquote><p>含有 $d（2 \le d \le 10）$位数的各位数字都不同的数字$x$的个数可以由公式$9 \times A<em>9^{d-1}$计算，第一位只能从1-9中选择，后面的d-1位从剩下的9个数之中选，即$A_9^{d-1}$个。总个数其实就是$res = 10 + 9 \times (A^{1}</em>{9}+A^{2}<em>{9}+…+A^{n-1}</em>{9})$</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">countNumbersWithUniqueDigits</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> res = <span class="number">10</span>, CurrentNum = <span class="number">9</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            CurrentNum *= <span class="number">9</span> - i;</span><br><span class="line">            res += CurrentNum;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="2-快速幂"><a href="#2-快速幂" class="headerlink" title="2.快速幂"></a>2.快速幂</h1><h2 id="2-1-实现pow-x-n-：50"><a href="#2-1-实现pow-x-n-：50" class="headerlink" title="2-1.实现pow(x,n)：50"></a>2-1.实现pow(x,n)：50</h2><p>解题思路：<a href="https://leetcode.cn/problems/powx-n/solutions/1/50-powx-n-kuai-su-mi-qing-xi-tu-jie-by-jyd/">快速幂，清晰图解</a></p><p>关于快速幂：<a href="https://zhuanlan.zhihu.com/p/95902286">快速幂-Pecco</a></p><p>快速幂本质是分治算法，有以下两种方法：</p><p>法一：递归（需要额外栈空间）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">quilkMul</span><span class="params">(<span class="type">double</span> x, <span class="type">long</span> <span class="type">long</span> N)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (N == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1.0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">double</span> y = <span class="built_in">quilkMul</span>(x, N / <span class="number">2</span>);</span><br><span class="line">        <span class="keyword">return</span> N % <span class="number">2</span> == <span class="number">0</span> ? y * y : y * y * x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">myPow</span><span class="params">(<span class="type">double</span> x, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> N = n;</span><br><span class="line">        <span class="keyword">return</span> N &gt;= <span class="number">0</span> ? <span class="built_in">quilkMul</span>(x, N) : <span class="number">1.0</span> / <span class="built_in">quilkMul</span>(x, -N);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>法二：迭代（涉及位运算分析）</p><p>判断<code>N%2==1</code>也可以写为<code>N&amp;1==1</code>,<code>N/=2</code>可以写为<code>N&gt;&gt;=1</code>,更能体现位运算思想。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">quilkMul</span><span class="params">(<span class="type">double</span> x, <span class="type">long</span> <span class="type">long</span> N)</span> </span>&#123;</span><br><span class="line">        <span class="type">double</span> ans = <span class="number">1.0</span>;</span><br><span class="line">        <span class="comment">// 贡献的初始值为 x</span></span><br><span class="line">        <span class="type">double</span> x_contribute = x;</span><br><span class="line">        <span class="comment">// 在对 N 进行二进制拆分的同时计算答案</span></span><br><span class="line">        <span class="keyword">while</span> (N &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (N % <span class="number">2</span> == <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="comment">// 如果 N 二进制表示的最低位为 1，那么需要计入贡献</span></span><br><span class="line">                ans *= x_contribute;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 将贡献不断地平方</span></span><br><span class="line">            x_contribute *= x_contribute;</span><br><span class="line">            <span class="comment">// 舍弃 N 二进制表示的最低位，这样我们每次只要判断最低位即可</span></span><br><span class="line">            N /= <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">myPow</span><span class="params">(<span class="type">double</span> x, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> N = n;</span><br><span class="line">        <span class="keyword">return</span> N &gt;= <span class="number">0</span> ? <span class="built_in">quilkMul</span>(x, N) : <span class="number">1.0</span> / <span class="built_in">quilkMul</span>(x, -N);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><p>注意：这里使用了<code>long long N = n;</code>，因为在n=INT_MIN时，-n=-INT_MIN=INT_MIN(INT_MIN=$-2^{31}$,INT_MAX=$2^{31}-1$)，使用long long存储能避免这一麻烦。</p></blockquote><h3 id="2-2-超级次方：372"><a href="#2-2-超级次方：372" class="headerlink" title="2-2.超级次方：372"></a>2-2.超级次方：372</h3><p>法一：倒序遍历+快速幂</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">pow</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 数字太大，不使用long容易超出范围</span></span><br><span class="line">        <span class="type">long</span> ans = <span class="number">1</span>;</span><br><span class="line">        <span class="type">long</span> N = n;</span><br><span class="line">        <span class="type">long</span> x_contribute = x;</span><br><span class="line">        <span class="keyword">while</span> (N &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (N &amp; <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="comment">// 包括之后的多次对1337取模都是为了避免溢出</span></span><br><span class="line">                ans = ans * x_contribute % <span class="number">1337</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            x_contribute = x_contribute * x_contribute % <span class="number">1337</span>;</span><br><span class="line">            N &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">superPow</span><span class="params">(<span class="type">int</span> a, vector&lt;<span class="type">int</span>&gt;&amp; b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (a == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">long</span> res = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = b.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            res = res * <span class="built_in">pow</span>(a, b[i]) % <span class="number">1337</span>;</span><br><span class="line">            a = <span class="built_in">pow</span>(a, <span class="number">10</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>值得注意的是，形如<code>x_contribute = x_contribute * x_contribute % 1337;</code>不能写成<code>x_contribute *= x_contribute % 1337;</code>因为一个最终是平方对1337取的模，另一个是自身对1337取模以后的值再乘以自身，这样会导致溢出（注意运算顺序）。</p><p>法二：正序遍历+秦九韶算法</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">pow</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> n)</span> </span>&#123; <span class="comment">// 数字太大，不使用long容易超出范围</span></span><br><span class="line">        <span class="type">long</span> ans = <span class="number">1</span>;</span><br><span class="line">        <span class="type">long</span> N = n;</span><br><span class="line">        <span class="type">long</span> x_contribute = x;</span><br><span class="line">        <span class="keyword">while</span> (N &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (N &amp; <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="comment">// 包括之后的多次对1337取模都是为了避免溢出</span></span><br><span class="line">                ans = ans * x_contribute % <span class="number">1337</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            x_contribute = x_contribute * x_contribute % <span class="number">1337</span>;</span><br><span class="line">            N &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">superPow</span><span class="params">(<span class="type">int</span> a, vector&lt;<span class="type">int</span>&gt;&amp; b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (a == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">long</span> res = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> num : b) &#123; <span class="comment">// 区别仅在于for循环</span></span><br><span class="line">            res = <span class="built_in">pow</span>(res, <span class="number">10</span>) * <span class="built_in">pow</span>(a, num) % <span class="number">1337</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="2-3-两数相除：29"><a href="#2-3-两数相除：29" class="headerlink" title="2-3.两数相除：29"></a>2-3.两数相除：29</h3><blockquote><p>类似快速幂通过乘法实现幂，这里使用“快速乘”算法通过加法实现乘法。</p></blockquote><p>快速乘+类二分查找</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">divide</span><span class="params">(<span class="type">int</span> dividend, <span class="type">int</span> divisor)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 三种特殊情况</span></span><br><span class="line">        <span class="comment">//  考虑被除数为最小值的情况</span></span><br><span class="line">        <span class="keyword">if</span> (dividend == INT_MIN) &#123;</span><br><span class="line">            <span class="keyword">if</span> (divisor == <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> INT_MIN;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (divisor == <span class="number">-1</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> INT_MAX;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 考虑除数为最小值的情况</span></span><br><span class="line">        <span class="keyword">if</span> (divisor == INT_MIN) &#123;</span><br><span class="line">            <span class="keyword">return</span> dividend == INT_MIN ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 考虑被除数为 0 的情况</span></span><br><span class="line">        <span class="keyword">if</span> (dividend == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 一般情况，使用类二分查找</span></span><br><span class="line">        <span class="comment">//  将所有的正数取相反数，这样就只需要考虑一种情况</span></span><br><span class="line">        <span class="type">bool</span> rev = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (dividend &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            dividend = -dividend;</span><br><span class="line">            rev = !rev;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (divisor &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            divisor = -divisor;</span><br><span class="line">            rev = !rev;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; candidates = &#123;divisor&#125;;</span><br><span class="line">        <span class="comment">// 注意溢出</span></span><br><span class="line">        <span class="keyword">while</span> (candidates.<span class="built_in">back</span>() &gt;= dividend - candidates.<span class="built_in">back</span>()) &#123;</span><br><span class="line">            candidates.<span class="built_in">push_back</span>(candidates.<span class="built_in">back</span>() + candidates.<span class="built_in">back</span>());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = candidates.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (candidates[i] &gt;= dividend) &#123;</span><br><span class="line">                ans += (<span class="number">1</span> &lt;&lt; i);</span><br><span class="line">                dividend -= candidates[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> rev ? -ans : ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2024/03/10/vhsgej4YJL8tq9O.png" alt=""></p><p><img src="https://s2.loli.net/2024/03/10/jgRMEvPXiGp4klB.png" alt=""></p><blockquote><p>将所有正数取相反数：确保都是负数，从而避免溢出，因为都转为正数会导致INT_MIN这个边界难以处理。</p></blockquote><p>快速乘代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 快速乘</span></span><br><span class="line">    <span class="keyword">auto</span> quickAdd = [](<span class="type">int</span> y, <span class="type">int</span> z, <span class="type">int</span> x) &#123;</span><br><span class="line">        <span class="comment">// x 和 y 是负数，z 是正数</span></span><br><span class="line">        <span class="comment">// 需要判断 z * y &gt;= x 是否成立</span></span><br><span class="line">        <span class="type">int</span> result = <span class="number">0</span>, add = y;</span><br><span class="line">        <span class="keyword">while</span> (z) &#123;</span><br><span class="line">            <span class="keyword">if</span> (z &amp; <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="comment">// 需要保证 result + add &gt;= x</span></span><br><span class="line">                <span class="keyword">if</span> (result &lt; x - add) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                result += add;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (z != <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="comment">// 需要保证 add + add &gt;= x</span></span><br><span class="line">                <span class="keyword">if</span> (add &lt; x - add) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                add += add;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 不能使用除法</span></span><br><span class="line">            z &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>y对应除数divisor，z对应中点mid，x对应被除数dividend.</p>]]></content>
    
    
    <summary type="html">位运算部分</summary>
    
    
    
    <category term="leetcode刷题笔记" scheme="https://sumikiru.top/categories/leetcode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="C++" scheme="https://sumikiru.top/tags/C/"/>
    
    <category term="leetcode" scheme="https://sumikiru.top/tags/leetcode/"/>
    
    <category term="位运算" scheme="https://sumikiru.top/tags/%E4%BD%8D%E8%BF%90%E7%AE%97/"/>
    
  </entry>
  
  <entry>
    <title>2.2字符串篇(3)</title>
    <link href="https://sumikiru.top/posts/1f30e95.html"/>
    <id>https://sumikiru.top/posts/1f30e95.html</id>
    <published>2024-04-05T19:31:58.000Z</published>
    <updated>2025-02-06T14:42:00.323Z</updated>
    
    <content type="html"><![CDATA[<h1 id="7-字符串子序列问题"><a href="#7-字符串子序列问题" class="headerlink" title="7.字符串子序列问题"></a>7.字符串子序列问题</h1><p>可以用双指针/动态规划完成。</p><p>如392、524题</p><p>注：compare方法模板<code>str1.compare(str2);</code>用来比较两个字符串哪个的<mark>字符序</mark>更小（而非长度）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">std::string str1 = <span class="string">&quot;abc&quot;</span>;</span><br><span class="line">std::string str2 = <span class="string">&quot;def&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> result = str1.<span class="built_in">compare</span>(str2);<span class="comment">//返回负数</span></span><br></pre></td></tr></table></figure><ul><li>如果 <code>str1</code> 小于 <code>str2</code>，则 <code>result</code> 将为负数。</li><li>如果 <code>str1</code> 等于 <code>str2</code>，则 <code>result</code> 将为 0。</li><li>如果 <code>str1</code> 大于 <code>str2</code>，则 <code>result</code> 将为正数。</li></ul><hr><p>判断s是否是t的子字符串 </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isSubsequence</span><span class="params">(string s, string t)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> sPos=<span class="number">0</span>,tPos=<span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> n=s.<span class="built_in">length</span>(),m=t.<span class="built_in">length</span>();</span><br><span class="line">        <span class="keyword">while</span>(sPos&lt;n&amp;&amp;tPos&lt;m)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s[sPos]==t[tPos])&#123;</span><br><span class="line">                sPos++;</span><br><span class="line">            &#125;</span><br><span class="line">            tPos++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sPos==n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="8-高精度运算"><a href="#8-高精度运算" class="headerlink" title="8.高精度运算"></a>8.高精度运算</h1><h2 id="8-1-加一：66"><a href="#8-1-加一：66" class="headerlink" title="8-1.加一：66"></a>8-1.加一：66</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">plusOne</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; digits)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = digits.<span class="built_in">size</span>(), pos = n - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (pos &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (digits[pos] != <span class="number">9</span>) &#123;</span><br><span class="line">                digits[pos]++;</span><br><span class="line">                <span class="keyword">return</span> digits;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                digits[pos--] = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//全是9的情况</span></span><br><span class="line">        digits.<span class="built_in">emplace_back</span>(<span class="number">0</span>);</span><br><span class="line">        digits[<span class="number">0</span>] = <span class="number">1</span>; <span class="comment">//其他数字已经在while循环中被改成9了</span></span><br><span class="line">        <span class="keyword">return</span> digits;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="8-2-二进制求和：67"><a href="#8-2-二进制求和：67" class="headerlink" title="8-2.二进制求和：67"></a>8-2.二进制求和：67</h2><p>法一：模拟(最优)</p><p>关键在于多次进行reverse方便运算和进位；同时进位数carry的处理也很巧妙。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">addBinary</span><span class="params">(string a, string b)</span> </span>&#123;</span><br><span class="line">        string ans;</span><br><span class="line">        <span class="built_in">reverse</span>(a.<span class="built_in">begin</span>(), a.<span class="built_in">end</span>());</span><br><span class="line">        <span class="built_in">reverse</span>(b.<span class="built_in">begin</span>(), b.<span class="built_in">end</span>());</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> n = <span class="built_in">max</span>(a.<span class="built_in">size</span>(), b.<span class="built_in">size</span>()), carry = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            carry += i &lt; a.<span class="built_in">size</span>() ? (a[i] == <span class="string">&#x27;1&#x27;</span>) : <span class="number">0</span>;</span><br><span class="line">            carry += i &lt; b.<span class="built_in">size</span>() ? (b[i] == <span class="string">&#x27;1&#x27;</span>) : <span class="number">0</span>;</span><br><span class="line">            ans += carry % <span class="number">2</span> ? <span class="string">&quot;1&quot;</span> : <span class="string">&quot;0&quot;</span>;</span><br><span class="line">            carry /= <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (carry) &#123;</span><br><span class="line">            ans += <span class="string">&quot;1&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">reverse</span>(ans.<span class="built_in">begin</span>(), ans.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>法二：位运算</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">addBinary</span><span class="params">(string a, string b)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 使用bitset来处理二进制相加</span></span><br><span class="line">        <span class="function">bitset&lt;10000&gt; <span class="title">x</span><span class="params">(a)</span></span>;</span><br><span class="line">        <span class="function">bitset&lt;10000&gt; <span class="title">y</span><span class="params">(b)</span></span>;</span><br><span class="line">        <span class="keyword">while</span> (y.<span class="built_in">any</span>()) &#123;</span><br><span class="line">            <span class="comment">// 计算当前位的和和进位</span></span><br><span class="line">            bitset&lt;10000&gt; sum = x ^ y;</span><br><span class="line">            bitset&lt;10000&gt; carry = (x &amp; y) &lt;&lt; <span class="number">1</span>;</span><br><span class="line">            <span class="comment">// 更新x和y</span></span><br><span class="line">            x = sum;</span><br><span class="line">            y = carry;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 将bitset转换为字符串，并去除前导零</span></span><br><span class="line">        string ans = x.<span class="built_in">to_string</span>();</span><br><span class="line">        <span class="type">size_t</span> startPos = ans.<span class="built_in">find</span>(<span class="string">&#x27;1&#x27;</span>);</span><br><span class="line">        <span class="keyword">if</span> (startPos != string::npos) &#123;  <span class="comment">//能找到</span></span><br><span class="line">            <span class="keyword">return</span> ans.<span class="built_in">substr</span>(startPos);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;0&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><p>根据题干，由于<code>1 &lt;= a.length, b.length &lt;= 10^4</code>，因此a可能位数很长，需要很长的二进制数来存储，常规的<code>int x=stoi(a,0,2)</code>会导致溢出，因此这里使用1e4位的bitset来存储转换的a.a不需要转换为其他参数，string或者int等等都可以直接转换为bitset。一般来说，如果a仅仅是一个int型整数，那么只需要<code>bitset&lt;32&gt;</code>即可，因为int范围在$-2^{31}$ 到 $2^{31} - 1$，</p></li><li><p>while循环中应该使用y.any()而非y：在C++中，<code>std::bitset</code> 类型的对象不可以隐式地被转换为 <code>bool</code> 类型。如果 <code>y</code> 是一个 <code>std::bitset</code> 对象，<code>y</code> 会被用作一个条件表达式时，它无法隐式地转换为 <code>bool</code>。使用 <code>y.any()</code> 是一种更明确的方式来表达循环的终止条件，因为它直接检查 <code>std::bitset</code> <u>是否有任何</u>非零位，所有位均为0时为false退出循环。</p></li><li><p><code>(x&amp;y)&lt;&lt;1</code>:处理进位。</p><ol><li><p><code>x &amp; y</code>: 这是 <code>x</code> 和 <code>y</code> 的按位与运算。在二进制中，每一位上的结果是取两个数对应位上的逻辑与（AND）运算。例如，如果 <code>x</code> 的某一位是1，而 <code>y</code> 的相同位置也是1，那么结果的相应位就是1；否则为0。</p></li><li><p><code>(x &amp; y) &lt;&lt; 1</code>: 这是将上述按位与运算的结果左移一位。左移运算是将二进制数的每一位向左移动指定的位数，右侧空出的位补0。因此，<code>(x &amp; y) &lt;&lt; 1</code> 就是将 <code>(x &amp; y)</code> 的所有位都向左移动一位。</p></li></ol></li><li><p><code>x.to_string()</code>:x为bitset类型的对象。<code>x.to_string()</code> 是用于调用对象的成员函数，而 <code>to_string(x)</code> 是用于将基本数据类型(比如int)转换为字符串。</p></li><li><p><code>size_t startPos = ans.find(&#39;1&#39;)</code>:字符串中的find方法在找寻到第一个‘1’后，返回size_t类型的结果。如果没有找到，则返回<code>std::string::npos</code>。<code>size_t</code> 是一种无符号整数类型，通常用于表示对象的大小、索引或长度。它是通过包含头文件 <code>&lt;cstddef&gt;</code>（或 <code>&lt;stddef.h&gt;</code>，在C语言中）来引入的。</p><p>C++标准规定了 <code>size_t</code> 的属性，它被定义为一个足够大以容纳程序中可能的最大对象大小的无符号整数类型。因此，<code>size_t</code> 的大小在不同的平台和编译器中可能会有所不同，但通常足够大以满足实际需求。</p></li><li><p><code>ans.substr(startPos);</code>：substr方法可以只接受一个参数pos,表示这个子字符串时从pos这个位置开始一直到最后(这时候不用再特地说明长度length)</p></li><li><p><code>stoi(a,0,2)或者stoi(a,nullptr,2)</code>:将字符串a转换为2进制的数，并用int表达。比如a=”10101111”，则转换为int x=101011111。<code>0</code>或者<code>nullptr</code> 是用于存储转换错误位置的指针。如果转换过程中发生错误，<code>stoi</code> 函数会将错误的位置存储在这个指针指向的位置。在这里，<code>0</code>或者<code>nullptr</code>表示不存储错误位置。2表示基数，即转换为几进制。</p></li></ul><h2 id="8-3-字符串相加：415、字符串相乘：43"><a href="#8-3-字符串相加：415、字符串相乘：43" class="headerlink" title="8-3.字符串相加：415、字符串相乘：43"></a>8-3.字符串相加：415、字符串相乘：43</h2><p>类似8-2，使用模拟法</p><p>字符串相乘法二：优化竖式</p><p><img src="https://s2.loli.net/2024/01/29/vsTbwaM5f2H6Pum.png" alt=""></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">multiply</span><span class="params">(string num1, string num2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (num1 == <span class="string">&quot;0&quot;</span> || num2 == <span class="string">&quot;0&quot;</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;0&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> n = num1.<span class="built_in">length</span>() + num2.<span class="built_in">length</span>();</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">res</span><span class="params">(n)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = num1.<span class="built_in">length</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = num2.<span class="built_in">length</span>() - <span class="number">1</span>; j &gt;= <span class="number">0</span>; j--) &#123;</span><br><span class="line">                <span class="type">int</span> sum = res[i + j + <span class="number">1</span>] + (num1[i] - <span class="string">&#x27;0&#x27;</span>) * (num2[j] - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">                res[i + j + <span class="number">1</span>] = sum % <span class="number">10</span>;</span><br><span class="line">                res[i + j] += sum / <span class="number">10</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        string ans = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i == <span class="number">0</span> &amp;&amp; res[i] == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">continue</span>; <span class="comment">//去掉前置0</span></span><br><span class="line">            &#125;</span><br><span class="line">            ans += <span class="built_in">to_string</span>(res[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这里也可以先像前面的题一样反转字符串以后再从前往后算，之后再倒回来。</p><h2 id="8-4-累加数：306"><a href="#8-4-累加数：306" class="headerlink" title="8-4.累加数：306"></a>8-4.累加数：306</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h1 id="9-字符串变换"><a href="#9-字符串变换" class="headerlink" title="9.字符串变换"></a>9.字符串变换</h1><h2 id="9-1-Z字形变换：6"><a href="#9-1-Z字形变换：6" class="headerlink" title="9-1.Z字形变换：6"></a>9-1.Z字形变换：6</h2><p>法一：压缩矩阵存储</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">convert</span><span class="params">(string s, <span class="type">int</span> numRows)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = s.<span class="built_in">length</span>(), r = numRows;</span><br><span class="line">        <span class="keyword">if</span> (r == <span class="number">1</span> || r == n) &#123;</span><br><span class="line">            <span class="keyword">return</span> s;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function">vector&lt;string&gt; <span class="title">mat</span><span class="params">(r)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>, x = <span class="number">0</span>, t = r * <span class="number">2</span> - <span class="number">2</span>; i &lt; n; i++) &#123;</span><br><span class="line">            mat[x] += s[i];<span class="comment">//x记录行数</span></span><br><span class="line">            i % t &lt; r - <span class="number">1</span> ? ++x : --x;<span class="comment">//第i%t行读取结束就继续下一行</span></span><br><span class="line">        &#125;</span><br><span class="line">        string ans;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; row : mat) &#123;</span><br><span class="line">            ans += row;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>法二：直接构造</p><p>观察下标规律：</p><p><img src="https://s2.loli.net/2024/02/03/g97q4Kv86TSiy1b.png" alt=""></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">convert</span><span class="params">(string s, <span class="type">int</span> numRows)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = s.<span class="built_in">length</span>(), r = numRows;</span><br><span class="line">        <span class="keyword">if</span> (r == <span class="number">1</span> || r == n) &#123;</span><br><span class="line">            <span class="keyword">return</span> s;</span><br><span class="line">        &#125;</span><br><span class="line">        string ans;</span><br><span class="line">        <span class="type">int</span> t = r * <span class="number">2</span> - <span class="number">2</span>; <span class="comment">//使得s[t]是第二个竖直列的第一个元素</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; r; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j + i &lt; n; j += t) &#123; <span class="comment">//遍历第i行的元素</span></span><br><span class="line">                ans += s[j + i];</span><br><span class="line">                <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; i &lt; r - <span class="number">1</span> &amp;&amp; j + t - i &lt; n) &#123;</span><br><span class="line">                    ans += s[j + t - i];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="9-2-文本左右对齐：68"><a href="#9-2-文本左右对齐：68" class="headerlink" title="9-2.文本左右对齐：68"></a>9-2.文本左右对齐：68</h2><p>贪心算法+模拟</p><p>详见：<a href="https://leetcode.cn/problems/text-justification/solutions/181651/text-justification-by-ikaruga/">平均分布额外空格</a></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">fillWords</span><span class="params">(vector&lt;string&gt;&amp; words, <span class="type">int</span> bg, <span class="type">int</span> ed, <span class="type">int</span> maxWidth,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">bool</span> lastLine = <span class="literal">false</span>)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> wordCount = ed - bg + <span class="number">1</span>;<span class="comment">//end减去begin后再加1</span></span><br><span class="line">        <span class="type">int</span> spaceCount =</span><br><span class="line">            maxWidth + <span class="number">1</span> - wordCount; <span class="comment">// 除去每个单词尾部空格， + 1</span></span><br><span class="line">                                      <span class="comment">// 是最后一个单词的尾部空格的特殊处理</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = bg; i &lt;= ed; i++) &#123;</span><br><span class="line">            spaceCount -= words[i].<span class="built_in">size</span>(); <span class="comment">// 除去所有单词的长度</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> spaceSuffix = <span class="number">1</span>; <span class="comment">// 词尾空格</span></span><br><span class="line">        <span class="type">int</span> spaceAvg = (wordCount == <span class="number">1</span>)</span><br><span class="line">                           ? <span class="number">1</span></span><br><span class="line">                           : spaceCount / (wordCount - <span class="number">1</span>); <span class="comment">// 额外空格的平均值</span></span><br><span class="line">        <span class="type">int</span> spaceExtra = (wordCount == <span class="number">1</span>)</span><br><span class="line">                             ? <span class="number">0</span></span><br><span class="line">                             : spaceCount % (wordCount - <span class="number">1</span>); <span class="comment">// 额外空格的余数</span></span><br><span class="line">        string ans;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = bg; i &lt; ed; i++) &#123;</span><br><span class="line">            ans += words[i]; <span class="comment">// 填入单词</span></span><br><span class="line">            <span class="keyword">if</span> (lastLine) &#123;  <span class="comment">// 特殊处理最后一行</span></span><br><span class="line">                <span class="built_in">fill_n</span>(<span class="built_in">back_inserter</span>(ans), <span class="number">1</span>, <span class="string">&#x27; &#x27;</span>);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">fill_n</span>(<span class="built_in">back_inserter</span>(ans),</span><br><span class="line">                   spaceSuffix + spaceAvg + ((i - bg) &lt; spaceExtra),</span><br><span class="line">                   <span class="string">&#x27; &#x27;</span>); <span class="comment">// 根据计算结果补上空格</span></span><br><span class="line">        &#125;</span><br><span class="line">        ans += words[ed]; <span class="comment">// 填入最后一个单词</span></span><br><span class="line">        <span class="built_in">fill_n</span>(<span class="built_in">back_inserter</span>(ans), maxWidth - ans.<span class="built_in">size</span>(), <span class="string">&#x27; &#x27;</span>);</span><br><span class="line">        <span class="comment">// 补上这一行最后的空格</span></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">vector&lt;string&gt; <span class="title">fullJustify</span><span class="params">(vector&lt;string&gt;&amp; words, <span class="type">int</span> maxWidth)</span> </span>&#123;</span><br><span class="line">        vector&lt;string&gt; ans;</span><br><span class="line">        <span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> bg = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; words.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            cnt += words[i].<span class="built_in">size</span>() + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (i + <span class="number">1</span> == words.<span class="built_in">size</span>() ||</span><br><span class="line">                cnt + words[i + <span class="number">1</span>].<span class="built_in">size</span>() &gt;</span><br><span class="line">                    maxWidth) &#123; <span class="comment">// 如果是最后一个单词，或者加上下一个词就超过长度了，即可凑成一行</span></span><br><span class="line">                ans.<span class="built_in">push_back</span>(</span><br><span class="line">                    <span class="built_in">fillWords</span>(words, bg, i, maxWidth, i + <span class="number">1</span> == words.<span class="built_in">size</span>()));</span><br><span class="line">                bg = i + <span class="number">1</span>;</span><br><span class="line">                cnt = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="10-字符串匹配-难度较高"><a href="#10-字符串匹配-难度较高" class="headerlink" title="10.字符串匹配(难度较高)"></a>10.字符串匹配(难度较高)</h1><h2 id="10-1-找出字符串中第一个匹配项的下标-28"><a href="#10-1-找出字符串中第一个匹配项的下标-28" class="headerlink" title="10-1.找出字符串中第一个匹配项的下标:28"></a>10-1.找出字符串中第一个匹配项的下标:28</h2><p>法一：暴力匹配</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">strStr</span><span class="params">(string haystack, string needle)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = haystack.<span class="built_in">size</span>(), m = needle.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i + m &lt;= n; i++) &#123;</span><br><span class="line">            <span class="type">bool</span> flag = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; m; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (haystack[i + j] != needle[j]) &#123;</span><br><span class="line">                    flag = <span class="literal">false</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (flag) &#123;</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>使用substr与之同理：</p><p><code>substr()</code>的时间复杂度为$O(n)$,空间复杂度是$O(1)$.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">strStr</span><span class="params">(string haystack, string needle)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; haystack.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (haystack[i] == needle[<span class="number">0</span>]) &#123; <span class="comment">//第一个字符是否相等再决定是不是要尝试匹配整个字符串</span></span><br><span class="line">                string x = haystack.<span class="built_in">substr</span>(i, needle.<span class="built_in">size</span>());</span><br><span class="line">                <span class="keyword">if</span> (x == needle) &#123;</span><br><span class="line">                    <span class="keyword">return</span> i;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>法二：KMP算法</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">strStr</span><span class="params">(string haystack, string needle)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = haystack.<span class="built_in">size</span>(), m = needle.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span> (m == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">next</span><span class="params">(m)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>, j = <span class="number">0</span>; i &lt; m; i++) &#123; <span class="comment">//计算出next数组</span></span><br><span class="line">            <span class="keyword">while</span> (j &gt; <span class="number">0</span> &amp;&amp; needle[i] != needle[j]) &#123;</span><br><span class="line">                j = next[j - <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (needle[i] == needle[j]) &#123;</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">            next[i] = j;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>; i &lt; n; i++) &#123; <span class="comment">//根据next数组进行匹配</span></span><br><span class="line">            <span class="keyword">while</span> (j &gt; <span class="number">0</span> &amp;&amp; haystack[i] != needle[j]) &#123;</span><br><span class="line">                j = next[j - <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (haystack[i] == needle[j]) &#123;</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (j == m) &#123;</span><br><span class="line">                <span class="keyword">return</span> i - m + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="关于KMP"><a href="#关于KMP" class="headerlink" title="关于KMP"></a>关于KMP</h2><p><img src="https://s2.loli.net/2024/02/03/SAhEnMkz5LfJD1W.png" alt=""></p><p><img src="https://s2.loli.net/2024/02/03/B6Z1blgJqCnyRpv.png" title="" alt="" width="473"></p><h2 id="常见字符串匹配算法"><a href="#常见字符串匹配算法" class="headerlink" title="常见字符串匹配算法"></a>常见字符串匹配算法</h2><p>讲解：<a href="https://zhuanlan.zhihu.com/p/159879354">字符串匹配之Sunday、KMP和BM算法入门级讲解</a></p><ol><li><p><strong>暴力匹配算法（Brute Force）</strong>：也称为朴素字符串匹配算法，它通过逐个比较文本和模式串的字符来进行匹配。</p></li><li><p><strong>KMP算法</strong>：KMP算法利用模式串自身的特点，通过构建部分匹配表（next数组）来实现快速匹配。</p></li><li><p><strong>Boyer-Moore算法</strong>：该算法通过从右往左比较模式串和文本串，利用坏字符规则和好后缀规则来快速定位匹配位置。</p></li><li><p><strong>Rabin-Karp算法</strong>：Rabin-Karp算法利用哈希函数来快速比较文本中的子串和模式串，以确定是否需要进行进一步的精确比较（首先是计算两个字符串的哈希值，然后通过比较这两个哈希值的大小来判断是否出现匹配）。</p></li><li><p><strong>Sunday算法</strong>：Sunday算法是一种简单而高效的字符串匹配算法，它利用预处理模式串得到的偏移表，以便在匹配失败时快速移动模式串。</p></li></ol><hr><h2 id="10-2-重复叠加字符串匹配：686"><a href="#10-2-重复叠加字符串匹配：686" class="headerlink" title="10-2.重复叠加字符串匹配：686"></a>10-2.重复叠加字符串匹配：686</h2><p>法一：KMP.</p><p>时间复杂度：$O(n+m)$，空间复杂度：$O(m)$。</p><p>该题代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">strStr</span><span class="params">(string haystack, string needle)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = haystack.<span class="built_in">size</span>(), m = needle.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span> (m == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">next</span><span class="params">(m)</span></span>;</span><br><span class="line">        <span class="comment">// 计算出next数组</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>, j = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">            <span class="keyword">while</span> (j &gt; <span class="number">0</span> &amp;&amp; needle[i] != needle[j]) &#123;</span><br><span class="line">                j = next[j - <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (needle[i] == needle[j]) &#123;</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">            next[i] = j;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 根据next数值进行匹配</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>; i - j &lt; n; i++) &#123; <span class="comment">// b 开始匹配的位置是否超过第一个叠加的 a</span></span><br><span class="line">            <span class="keyword">while</span> (j &gt; <span class="number">0</span> &amp;&amp; haystack[i % n] != needle[j]) &#123; <span class="comment">//i%n,因为可能是多个haystack重复</span></span><br><span class="line">                j = next[j - <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (haystack[i % n] == needle[j]) &#123;</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (j == m) &#123;</span><br><span class="line">                <span class="keyword">return</span> i - m + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">repeatedStringMatch</span><span class="params">(string a, string b)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> an = a.<span class="built_in">size</span>(), bn = b.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> index = <span class="built_in">strStr</span>(a, b);</span><br><span class="line">        <span class="keyword">if</span> (index == <span class="number">-1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (an - index &gt;= bn) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (bn + index - an - <span class="number">1</span>) / an + <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>法二：Rabin-Karp算法</p><p>时间复杂度：O(n+m)，空间复杂度：O(1)。</p><p>关于Rabin-Karp的讲解:<a href="https://zhuanlan.zhihu.com/p/563551141?utm_id=0">Rabin–Karp 算法</a></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> BASE 256</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MODULUS 101</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">RabinKarp</span><span class="params">(<span class="type">char</span> t[], <span class="type">char</span> p[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> t_len = <span class="built_in">strlen</span>(t);</span><br><span class="line">    <span class="type">int</span> p_len = <span class="built_in">strlen</span>(p);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 哈希滚动之用</span></span><br><span class="line">    <span class="type">int</span> h = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; p_len - <span class="number">1</span>; i++)</span><br><span class="line">        h = (h * BASE) % MODULUS;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> t_hash = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> p_hash = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; p_len; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        t_hash = (BASE * t_hash + t[i]) % MODULUS;</span><br><span class="line">        p_hash = (BASE * p_hash + p[i]) % MODULUS;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt;= t_len - p_len)</span><br><span class="line">    &#123;</span><br><span class="line">         <span class="comment">// 考虑到哈希碰撞的可能性，还需要用 memcmp 再比对一下</span></span><br><span class="line">        <span class="keyword">if</span> (t_hash == p_hash &amp;&amp; <span class="built_in">memcmp</span>(p, t + i, p_len) == <span class="number">0</span>)</span><br><span class="line">            cout &lt;&lt; p &lt;&lt; <span class="string">&quot; is found at index &quot;</span> &lt;&lt; i &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 哈希滚动</span></span><br><span class="line">        t_hash = (BASE * (t_hash - t[i] * h) + t[i + p_len]) % MODULUS;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 防止出现负数</span></span><br><span class="line">        <span class="keyword">if</span> (t_hash &lt; <span class="number">0</span>)</span><br><span class="line">            t_hash = t_hash + MODULUS;</span><br><span class="line"></span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="C:\Users\huangjiakun\Pictures\Marktext全局图片\09710814ec32b4e67959fb730df10269ff888601.png" alt=""></p><p>该题代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">strStr</span><span class="params">(string haystack, string needle)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = haystack.<span class="built_in">size</span>(), m = needle.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span> (m == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> k1 = <span class="number">1e9</span> + <span class="number">7</span>;  <span class="comment">// 选择一个较大的质数作为模数</span></span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> k2 = <span class="number">1337</span>;  <span class="comment">// 另选一个较小的质数</span></span><br><span class="line">        <span class="built_in">srand</span>((<span class="type">unsigned</span>)<span class="built_in">time</span>(<span class="literal">NULL</span>));  <span class="comment">// 初始化随机数种子</span></span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> kMod1 = <span class="built_in">rand</span>() % k1 + k1;  <span class="comment">// 生成一个随机数作为模数</span></span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> kMod2 = <span class="built_in">rand</span>() % k2 + k2;  <span class="comment">// 生成另一个随机数作为模数</span></span><br><span class="line"></span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> hash_needle = <span class="number">0</span>;  <span class="comment">// 初始化模式串的哈希值</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> c : needle) &#123;</span><br><span class="line">            hash_needle = (hash_needle * kMod2 + c) % kMod1;  <span class="comment">// 计算模式串的哈希值</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> hash_haystack = <span class="number">0</span>, extra = <span class="number">1</span>;  <span class="comment">// 初始化文本串的哈希值和额外变量</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            hash_haystack = (hash_haystack * kMod2 + haystack[i % n]) % kMod1;  <span class="comment">// 计算文本串的哈希值</span></span><br><span class="line">            extra = (extra * kMod2) % kMod1;  <span class="comment">// 更新额外变量</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = m - <span class="number">1</span>; (i - m + <span class="number">1</span>) &lt; n; i++) &#123;</span><br><span class="line">            hash_haystack = (hash_haystack * kMod2 + haystack[i % n]) % kMod1;  <span class="comment">// 更新文本串的哈希值</span></span><br><span class="line">            <span class="keyword">if</span> (hash_haystack == hash_needle) &#123;  <span class="comment">// 检查哈希值是否匹配</span></span><br><span class="line">                <span class="keyword">return</span> i - m + <span class="number">1</span>;  <span class="comment">// 返回匹配位置</span></span><br><span class="line">            &#125;</span><br><span class="line">            hash_haystack = (hash_haystack - extra * haystack[(i - m + <span class="number">1</span>) % n]) % kMod1;  <span class="comment">// 更新文本串的哈希值</span></span><br><span class="line">            hash_haystack = (hash_haystack + kMod1) % kMod1;  <span class="comment">// 处理负数情况</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;  <span class="comment">// 未找到匹配，返回-1</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">repeatedStringMatch</span><span class="params">(string a, string b)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> an = a.<span class="built_in">size</span>(), bn = b.<span class="built_in">size</span>();  <span class="comment">// 获取字符串a和b的长度</span></span><br><span class="line">        <span class="type">int</span> index = <span class="built_in">strStr</span>(a, b);  <span class="comment">// 调用strStr函数查找b在a中的匹配位置</span></span><br><span class="line">        <span class="keyword">if</span> (index == <span class="number">-1</span>) &#123;  <span class="comment">// 如果未找到匹配位置</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;  <span class="comment">// 返回-1</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (an - index &gt;= bn) &#123;  <span class="comment">// 如果匹配位置之后的长度大于等于b的长度</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;  <span class="comment">// 返回1，表示a本身就包含了至少一个b</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (bn + index - an - <span class="number">1</span>) / an + <span class="number">2</span>;  <span class="comment">// 返回重复拼接a后能够包含b的最小次数</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="10-3-重复的子字符串：459"><a href="#10-3-重复的子字符串：459" class="headerlink" title="10-3.重复的子字符串：459"></a>10-3.重复的子字符串：459</h2><h2 id="10-4-最短回文串：214（困难）"><a href="#10-4-最短回文串：214（困难）" class="headerlink" title="10-4.最短回文串：214（困难）"></a>10-4.最短回文串：214（困难）</h2><h1 id="11-中心拓展法"><a href="#11-中心拓展法" class="headerlink" title="11.中心拓展法"></a>11.中心拓展法</h1><p>中心拓展法的基本思想是以字符串中的每个字符（或者每两个字符之间）为中心，向两边扩展，以<u>寻找最长的回文串</u>。这种方法的时间复杂度较低，因为在中心拓展时，只需要线性的时间。</p><p>具体步骤如下：</p><ol><li>遍历字符串，以每个字符（或者每两个字符之间）为中心，向两边扩展，直到不再满足回文串的条件。</li><li>在扩展的过程中，记录下最长的回文串的起始位置和长度。</li></ol><p>中心拓展法在解决回文串相关问题时非常有效，例如在寻找最长回文子串或者统计回文子串的个数时，该方法可以提供较高的效率。</p><h2 id="11-1-最长回文子串：5"><a href="#11-1-最长回文子串：5" class="headerlink" title="11-1.最长回文子串：5"></a>11-1.最长回文子串：5</h2><p>法一：动态规划</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">longestPalindrome</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = s.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span> (n &lt; <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> s;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> maxLen = <span class="number">1</span>, begin = <span class="number">0</span>;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(n, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n));</span><br><span class="line">        <span class="comment">// 边界条件P(i,i)=true</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            dp[i][i] = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 枚举子串长度L</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> L = <span class="number">2</span>; L &lt;= n; L++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">                <span class="type">int</span> j = L + i - <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span> (j &gt;= n) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (s[i] != s[j]) &#123;</span><br><span class="line">                    dp[i][j] = <span class="literal">false</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (j - i &lt; <span class="number">3</span>) &#123; <span class="comment">//(j-1)-(i+1)&lt;=0</span></span><br><span class="line">                        dp[i][j] = <span class="literal">true</span>;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        dp[i][j] = dp[i + <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 只要 dp[i][j] == true 成立，就表示子串 s[i..j]</span></span><br><span class="line">                <span class="comment">// 是回文，此时记录回文长度和起始位置</span></span><br><span class="line">                <span class="keyword">if</span> (dp[i][j]) &#123;</span><br><span class="line">                    maxLen = <span class="built_in">max</span>(maxLen, j - i + <span class="number">1</span>);</span><br><span class="line">                    begin = i;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s.<span class="built_in">substr</span>(begin, maxLen);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>法二：中心扩展法</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; <span class="title">expandAroundCenter</span><span class="params">(<span class="type">const</span> string&amp; s, <span class="type">int</span> left, <span class="type">int</span> right)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (left &gt;= <span class="number">0</span> &amp;&amp; right &lt; s.<span class="built_in">size</span>() &amp;&amp; s[left] == s[right]) &#123;</span><br><span class="line">            <span class="comment">// 满足回文条件，向两边扩展</span></span><br><span class="line">            --left;</span><br><span class="line">            ++right;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> &#123;left + <span class="number">1</span>, right - <span class="number">1</span>&#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">string <span class="title">longestPalindrome</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> start = <span class="number">0</span>, end = <span class="number">0</span>; <span class="comment">// 从最左侧边界开始</span></span><br><span class="line">        <span class="comment">// 如果从最右侧边界，则start和end初始值应为s.size;同时auto [left2,right2]=expandAroundCenter(s,i-1,i);</span></span><br><span class="line">        <span class="comment">// 然后i从s.size()-1反向遍历nter(s,i-1,i);</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="keyword">auto</span> [left1, right1] = <span class="built_in">expandAroundCenter</span>(s, i, i);     <span class="comment">// a&#x27;b&#x27;a</span></span><br><span class="line">            <span class="keyword">auto</span> [left2, right2] = <span class="built_in">expandAroundCenter</span>(s, i, i + <span class="number">1</span>); <span class="comment">// a&#x27;bb&#x27;a</span></span><br><span class="line">            <span class="keyword">if</span> (right1 - left1 &gt; end - start) &#123;</span><br><span class="line">                start = left1;</span><br><span class="line">                end = right1;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (right2 - left2 &gt; end - start) &#123;</span><br><span class="line">                start = left2;</span><br><span class="line">                end = right2;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s.<span class="built_in">substr</span>(start, end - start + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>法三：Manacher算法(了解)</p><h2 id="11-2-统计回文子串数目：647"><a href="#11-2-统计回文子串数目：647" class="headerlink" title="11-2.统计回文子串数目：647"></a>11-2.统计回文子串数目：647</h2><p>三个方法类似11-1，这里展示中心扩展法代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">expandAroundCenter</span><span class="params">(<span class="type">const</span> string&amp; s, <span class="type">int</span> left, <span class="type">int</span> right)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (left &gt;= <span class="number">0</span> &amp;&amp; right &lt; s.<span class="built_in">size</span>() &amp;&amp; s[left] == s[right]) &#123;</span><br><span class="line">            --left;</span><br><span class="line">            ++right;</span><br><span class="line">            ++ans;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">countSubstrings</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> left = <span class="number">0</span>, right = <span class="number">0</span>, ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            ans +=<span class="built_in">expandAroundCenter</span>(s, i, i) + <span class="built_in">expandAroundCenter</span>(s, i, i + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">字符串进阶部分</summary>
    
    
    
    <category term="leetcode刷题笔记" scheme="https://sumikiru.top/categories/leetcode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="C++" scheme="https://sumikiru.top/tags/C/"/>
    
    <category term="leetcode" scheme="https://sumikiru.top/tags/leetcode/"/>
    
    <category term="string" scheme="https://sumikiru.top/tags/string/"/>
    
  </entry>
  
  <entry>
    <title>2.1字符串篇(2)</title>
    <link href="https://sumikiru.top/posts/283bba67.html"/>
    <id>https://sumikiru.top/posts/283bba67.html</id>
    <published>2024-04-05T19:27:48.000Z</published>
    <updated>2025-02-06T14:42:00.323Z</updated>
    
    <content type="html"><![CDATA[<h1 id="6-数字与字符串之间转换"><a href="#6-数字与字符串之间转换" class="headerlink" title="6.数字与字符串之间转换"></a>6.数字与字符串之间转换</h1><p>299:使用额外两个数组记录Bulls,cows</p><h2 id="6-1-相对名次：506"><a href="#6-1-相对名次：506" class="headerlink" title="6-1.相对名次：506"></a>6-1.相对名次：506</h2><p><code>make_pair(a,b)</code>:形成诸如<code>pair&lt;int,int&gt;</code>的形式</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;string&gt; <span class="title">findRelativeRanks</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; score)</span> </span>&#123;</span><br><span class="line">        vector&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt; arr;</span><br><span class="line">        <span class="type">int</span> n = score.<span class="built_in">size</span>();</span><br><span class="line">        string rankTop[<span class="number">3</span>] = &#123;<span class="string">&quot;Gold Medal&quot;</span>, <span class="string">&quot;Silver Medal&quot;</span>, <span class="string">&quot;Bronze Medal&quot;</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            arr.<span class="built_in">emplace_back</span>(</span><br><span class="line">                <span class="built_in">make_pair</span>(-score[i], i)); <span class="comment">//-score[i]以保证sort排序时由大到小</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">sort</span>(arr.<span class="built_in">begin</span>(), arr.<span class="built_in">end</span>());<span class="comment">//根据arr[index].first的大小排序</span></span><br><span class="line">        <span class="function">vector&lt;string&gt; <span class="title">res</span><span class="params">(n)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i &lt; <span class="number">3</span>) &#123;</span><br><span class="line">                res[arr[i].second] = rankTop[i];<span class="comment">//arr[i].second记录原下标</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                res[arr[i].second] = <span class="built_in">to_string</span>(i + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在C++中，<code>arr</code>可以是任何<u>支持随机访问迭代器的容器</u>类型，例如：</p><ul><li><code>std::vector</code></li><li><code>std::array</code></li><li><code>std::deque</code></li><li><code>std::string</code></li><li>内置数组（例如<code>int arr[5]</code>）</li></ul><p>这些类型都支持<code>begin()</code>和<code>end()</code>成员函数，因此可以作为<code>sort</code>函数的参数。</p><hr><p><code>vector</code>中每个元素都是<code>pair</code>类型时，也可以使用<code>sort</code>函数。因为<code>vector&lt;pair&lt;T1, T2&gt;&gt;</code>支持随机访问迭代器，所以可以直接作为<code>sort</code>函数的参数,排序默认是按照<code>pair</code>的<mark>第一个</mark>元素进行比较的。如果第一个元素相等，则会比较第二个元素。</p><hr><p>法二：使用map(不是unordered_map),它能够实现自主排序</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;string&gt; <span class="title">findRelativeRanks</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; score)</span> </span>&#123;</span><br><span class="line">        map&lt;<span class="type">int</span>, <span class="type">int</span>, greater&lt;<span class="type">int</span>&gt;&gt; mp; <span class="comment">//由大到小,看第一个int</span></span><br><span class="line">        <span class="type">int</span> n = score.<span class="built_in">size</span>();</span><br><span class="line">        string rankTop[<span class="number">3</span>] = &#123;<span class="string">&quot;Gold Medal&quot;</span>, <span class="string">&quot;Silver Medal&quot;</span>, <span class="string">&quot;Bronze Medal&quot;</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            mp[score[i]] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function">vector&lt;string&gt; <span class="title">res</span><span class="params">(n)</span></span>;</span><br><span class="line">        <span class="keyword">auto</span> it = mp.<span class="built_in">begin</span>(); <span class="comment">// it是迭代器</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i &lt; <span class="number">3</span>) &#123;</span><br><span class="line">                res[(*it).second] = rankTop[i];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                res[(*it).second] = <span class="built_in">to_string</span>(i + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            it++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>法三：使用set,方法与使用map类似</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;string&gt; <span class="title">findRelativeRanks</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; score)</span> </span>&#123;</span><br><span class="line">        set&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;, greater&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt;&gt; s; <span class="comment">//由大到小</span></span><br><span class="line">        <span class="type">int</span> n = score.<span class="built_in">size</span>();</span><br><span class="line">        string rankTop[<span class="number">3</span>] = &#123;<span class="string">&quot;Gold Medal&quot;</span>, <span class="string">&quot;Silver Medal&quot;</span>, <span class="string">&quot;Bronze Medal&quot;</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            s.<span class="built_in">emplace</span>(score[i], i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function">vector&lt;string&gt; <span class="title">res</span><span class="params">(n)</span></span>;</span><br><span class="line">        <span class="keyword">auto</span> it = s.<span class="built_in">begin</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i &lt; <span class="number">3</span>) &#123;</span><br><span class="line">                res[(*it).second] = rankTop[i];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                res[(*it).second] = <span class="built_in">to_string</span>(i + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            it++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>值得注意的是:1.set<mark>不存在</mark>类似s[i]的表示形式</p><p>2.向set中加入元素应该使用<code>emplace</code>而非empalce_back</p><p>3.元素形式为pair时，定义应该为<code>set&lt;pair&lt;int, int&gt;, greater&lt;pair&lt;int, int&gt;&gt;&gt; s</code>，这里的排序写法不是greater<int>!<code>greater&lt;int&gt;</code>表示<mark>按照键值</mark>进行降序排序，只有map、vector这种元素对应键值才是固定的，set则随时改变元素的位置，在元素为int类型时greater<int>没有问题，但在pair<int,int>类型时，会出错。</p><p>在这种情况下，我们需要使用<code>greater&lt;pair&lt;int, int&gt;&gt;</code>而不是<code>greater&lt;int&gt;</code>，因为我们想要按照分数降序排列，并且在分数相同时，按照索引升序排列。使用<code>greater&lt;pair&lt;int, int&gt;&gt;</code>可以确保首先按照分数降序排列，然后按照索引升序排列。 </p><hr><p>鸽巢原理：539法二。由鸽巢原理可知，如果 timePoints 的长度超过 1440，那么必然会有两个相同的时间，此时可以直接返回 0.</p><h2 id="6-2-正则表达式：537"><a href="#6-2-正则表达式：537" class="headerlink" title="6-2.正则表达式：537"></a>6-2.正则表达式：537</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">string <span class="title">complexNumberMultiply</span><span class="params">(string num1, string num2)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 定义正则表达式，用于匹配&quot;+&quot;和&quot;i&quot;</span></span><br><span class="line">    <span class="function">regex <span class="title">re</span><span class="params">(<span class="string">&quot;\\+|i&quot;</span>)</span></span>; </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 用正则表达式对复数字符串进行分割，存储到vector中</span></span><br><span class="line">    <span class="function">vector&lt;string&gt; <span class="title">complex1</span><span class="params">(sregex_token_iterator(num1.begin(), num1.end(), re, <span class="number">-1</span>), std::sregex_token_iterator())</span></span>;</span><br><span class="line">    <span class="function">vector&lt;string&gt; <span class="title">complex2</span><span class="params">(sregex_token_iterator(num2.begin(), num2.end(), re, <span class="number">-1</span>), std::sregex_token_iterator())</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将分割后的字符串转换为整数部分和虚数部分</span></span><br><span class="line">    <span class="type">int</span> real1 = <span class="built_in">stoi</span>(complex1[<span class="number">0</span>]);</span><br><span class="line">    <span class="type">int</span> imag1 = <span class="built_in">stoi</span>(complex1[<span class="number">1</span>]);</span><br><span class="line">    <span class="type">int</span> real2 = <span class="built_in">stoi</span>(complex2[<span class="number">0</span>]);</span><br><span class="line">    <span class="type">int</span> imag2 = <span class="built_in">stoi</span>(complex2[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算两个复数的乘积</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">to_string</span>(real1 * real2 - imag1 * imag2) + <span class="string">&quot;+&quot;</span> + <span class="built_in">to_string</span>(real1 * imag2 + imag1 * real2) + <span class="string">&quot;i&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="关于正则"><a href="#关于正则" class="headerlink" title="关于正则"></a>关于正则</h2><p>1.<strong>regex</strong>:<code>regex</code>是C++标准库中用于处理正则表达式的类。它允许你使用正则表达式来进行字符串的匹配、搜索和替换操作。通过使用<code>regex</code>类，你可以在C++中执行与正则表达式相关的操作，例如查找模式匹配、提取部分字符串、替换文本等。需要头文件<code>&lt;regex&gt;</code></p><p>2.<strong>sregex_token_iterator</strong>:<code>sregex_token_iterator</code>是C++标准库中用于在字符串上执行正则表达式分词操作的迭代器。它允许你在字符串中使用正则表达式来进行分词，从而将字符串分割为符合特定模式的子字符串。在上面的代码中，<code>sregex_token_iterator</code>来将复数字符串根据正则表达式分割为整数部分和虚数部分。</p><p><mark>语法</mark>：sregex_token_iterator(起始位置，终止位置，正则, 返回的匹配类型（-1是返回未匹配的部分，即分隔操作）)。</p><p>会返回一个迭代器的首地址，<code>std::sregex_token_iterator()</code>会返回一个end。vector用这两个迭代器构造得到符合匹配的序列</p><p>3.<strong>正则匹配</strong>：<a href="https://www.cnblogs.com/yongchao/p/17165643.html">正则表达式-菜鸟教程 - Theseus‘Ship - 博客园</a></p><p><a href="https://www.cnblogs.com/chen-cs/p/13387914.html">C++ 正则表达式 - Chen沉尘 - 博客园</a></p><p><a href="https://blog.51cto.com/u_12071646/3752288">[笔记]c++基础实践《二》regex正则表达式_51CTO博客_c++ 正则表达式</a></p><p>4.<code>&quot;\\+|i&quot;</code> 这个正则表达式中，<code>\\+</code> 匹配加号 “+”，<code>|</code> 表示或，<code>i</code> 匹配字符 “i”。因此，这个正则表达式可以用于匹配复数字符串中的加号和虚数单位 “i”。</p><p>  <code>&quot;(-?\\d+)/(\\d+)([+-])(-?\\d+)/(\\d+)&quot;</code>表示两个分数相加。</p><ul><li><code>-?</code>：表示匹配一个可选的减号（负号）。<code>-</code> 表示减号，<code>?</code> 表示前面的字符（这里是减号）在文本中可以出现 0 次或 1 次。</li><li><code>\\d+</code>：表示匹配一个或多个数字。<code>\\d</code> 表示一个数字，<code>+</code> 表示前面的元素（这里是数字）可以出现一次或多次。(<code>\\.</code>用来表示小数点)</li><li><code>[+-]</code> 是一个正则表达式模式，用于匹配加号(+)或减号(-)。在正则表达式中，方括号 <code>[]</code> 用于表示一个字符集，其中列出的字符之一都可以匹配成功。因此，<code>[+-]</code> 表示匹配一个加号或减号。</li></ul><p>5.<strong>smatch</strong>:<code>smatch</code> 是 C++ 标准库中的一种数据结构，用于存储正则表达式匹配的结果。它是 <code>std::match_results</code> 类型的别名，用于保存正则表达式匹配的结果和子匹配的位置信息。当使用正则表达式进行匹配时，匹配结果会被存储在 <code>smatch</code> 对象中，可以通过索引或迭代器来访问匹配的子字符串。在T592中，使用 <code>smatch</code> 对象来存储正则表达式匹配的结果，并从中提取分数的分子、分母以及操作符等信息。</p><p>  <code>matches[5].str()</code> 表示从 <code>smatch</code> 对象中获取第 5 个匹配的子字符串，并将其作为 <code>std::string</code> 类型返回。在这种情况下，<code>matches[5]</code> 用于访问正则表达式匹配中的第 5 个捕获组，即第 5 个括号内匹配的内容。在T592中，<code>matches[5].str()</code> 用于获取第 5 个捕获组的字符串表示形式<code>(\\d+)</code>，这个捕获组对应于分数的分母。</p><p>  <code>matches.prefix().str()</code> 表示从 <code>smatch</code> 对象中获取<mark>匹配的子字符串之前</mark>的部分，并将其作为 <code>std::string</code> 类型返回。在这种情况下，<code>matches.prefix()</code> 用于获取匹配子字符串之前的部分，然后通过 <code>str()</code> 方法将其转换为字符串表示形式。</p><p>  <code>matches.suffix().str()</code>则表示之后的那部分。</p><p>6.<strong>用括号将正则表达式分成多组</strong></p><p>在正则表达式中使用括号可以将匹配的部分分组，这样做有几个好处：</p><ul><li><p><strong>提取子匹配</strong>：括号可以将匹配的部分分成多个组，这样可以方便地从整个匹配中提取出我们感兴趣的部分。在这个例子中，括号将分数的分子、分母以及操作符分成了多个组，方便后续的处理。</p></li><li><p><strong>方便后续处理</strong>：分组可以让我们更方便地对匹配到的内容进行后续处理，比如在这个例子中，可以方便地提取出分数的分子和分母，然后进行加减法运算。</p></li><li><p><strong>捕获匹配信息</strong>：分组可以捕获匹配的信息，方便后续的引用。在这个例子中，我们可以使用 <code>matches[1]</code>、<code>matches[2]</code>、<code>matches[3]</code> 等来引用不同的匹配组。</p></li></ul><p>因此，使用括号将正则表达式的部分分成多个组可以使代码更清晰、更易于理解，并且方便后续的处理和提取。</p><p>7.<strong>regex_search</strong>:<code>regex_search(expression, matches, pattern)</code>用于在字符串 <code>expression</code> 中搜索满足正则表达式模式 <code>pattern</code> 的部分，并将匹配的结果存储在 <code>matches</code> 对象中，以便后续的处理和提取。</p><p>8.<strong>regex_match</strong>:<code>regex_match(string code, regex pattern)</code>用于检查字符串是否与给定的正则表达式模式匹配。在这种情况下，它会尝试使用给定的正则表达式模式pattern来匹配输入的代码字符串code，并返回bool值。</p><p>9.<strong>相关学习网站</strong>：<a href="https://r2coding.com/#/?id=正则表达式">Road 2 Coding</a></p><p>正则表达式测试网站：<a href="https://regex101.com/">regex101</a></p><blockquote><p>在对性能敏感的程序中尽量避免使用正则表达式，尽量使用更加高效、更加简单的字符串匹配方案来提高程序性能。在C++中，正则表达式使用<u>ECMAScript语法</u>作为默认语法。这意味着它使用类似于JavaScript和Python的正则表达式语法。但C++的正则表达式与其他语言的正则表达式相比，<u>缺少了独占模式</u>，只有贪婪模式和非贪婪模式(懒惰模式)，这使得匹配所消耗的时间更长。</p><p>ECMAScript语法：<a href="https://zhuanlan.zhihu.com/p/634341574">Modern C++ 学习笔记——正则表达式</a></p><p><a href="https://zhuanlan.zhihu.com/p/38278481/">藏在正则表达式中的陷阱—知乎</a></p><p><a href="https://www.cnblogs.com/lixuwu/p/16201714.html">正则表达式引起的性能下降—博客园</a></p></blockquote><hr><h2 id="正则规则汇总"><a href="#正则规则汇总" class="headerlink" title="正则规则汇总"></a>正则规则汇总</h2><hr><h2 id="6-3-分数加减运算：592"><a href="#6-3-分数加减运算：592" class="headerlink" title="6-3.分数加减运算：592"></a>6-3.分数加减运算：592</h2><p>法一：模拟，遍历整个字符串</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">fractionAddition</span><span class="params">(string expression)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = expression.<span class="built_in">size</span>(), index = <span class="number">0</span>;</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> x = <span class="number">0</span>, y = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (index &lt; n) &#123;</span><br><span class="line">            <span class="comment">//分子</span></span><br><span class="line">            <span class="type">long</span> <span class="type">long</span> x1 = <span class="number">0</span>, sign = <span class="number">1</span>; <span class="comment">// x1记录当前数字,sign记录正负号</span></span><br><span class="line">            <span class="keyword">if</span> (expression[index] == <span class="string">&#x27;-&#x27;</span> || expression[index] == <span class="string">&#x27;+&#x27;</span>) &#123;</span><br><span class="line">                sign = expression[index] == <span class="string">&#x27;-&#x27;</span> ? <span class="number">-1</span> : <span class="number">1</span>;</span><br><span class="line">                index++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> (index &lt; n &amp;&amp; <span class="built_in">isdigit</span>(expression[index])) &#123; <span class="comment">// index&lt;n别忘了</span></span><br><span class="line">                x1 = x1 * <span class="number">10</span> + expression[index] - <span class="string">&#x27;0&#x27;</span>;       <span class="comment">//更新x1</span></span><br><span class="line">                index++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//遇到“/”</span></span><br><span class="line">            x1 *= sign; <span class="comment">//最后把符号带上</span></span><br><span class="line">            index++;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//分母.再次遇到+/-时则结束</span></span><br><span class="line">            <span class="type">long</span> <span class="type">long</span> y1 = <span class="number">0</span>; <span class="comment">//分母不可能有符号，所以无需sign</span></span><br><span class="line">            <span class="keyword">while</span> (index &lt; n &amp;&amp; <span class="built_in">isdigit</span>(expression[index])) &#123;</span><br><span class="line">                y1 = y1 * <span class="number">10</span> + expression[index] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">                index++;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//更新当前数字(再次遇到“+/-”时),x/y+=x1/y1</span></span><br><span class="line">            x = x * y1 + x1 * y;</span><br><span class="line">            y *= y1;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (x == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;0/1&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> g = <span class="built_in">gcd</span>(<span class="built_in">abs</span>(x), y); <span class="comment">//获取最大公约数，用来化简分数</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">to_string</span>(x / g) + <span class="string">&quot;/&quot;</span> + <span class="built_in">to_string</span>(y / g);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>法二：正则匹配,该解法的时间复杂度为$ O(n^2)$，空间复杂度为 $O(1)$,但法一时间复杂度仅为$O(n+log⁡C)$。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;regex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">performOperation</span><span class="params">(<span class="type">int</span> num1, <span class="type">int</span> den1, <span class="type">int</span> num2, <span class="type">int</span> den2, <span class="type">char</span> op)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> numerator, denominator;</span><br><span class="line">        <span class="keyword">if</span> (op == <span class="string">&#x27;+&#x27;</span>) &#123;</span><br><span class="line">            numerator = num1 * den2 + num2 * den1;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            numerator = num1 * den2 - num2 * den1;</span><br><span class="line">        &#125;</span><br><span class="line">        denominator = den1 * den2;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">toLowestTerms</span>(numerator, denominator);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">string <span class="title">toLowestTerms</span><span class="params">(<span class="type">int</span> numerator, <span class="type">int</span> denominator)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> divisor = <span class="built_in">gcd</span>(<span class="built_in">abs</span>(numerator), <span class="built_in">abs</span>(denominator));</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">to_string</span>(numerator / divisor) + <span class="string">&quot;/&quot;</span> +</span><br><span class="line">               <span class="built_in">to_string</span>(denominator / divisor);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">string <span class="title">fractionAddition</span><span class="params">(string expression)</span> </span>&#123;</span><br><span class="line">        <span class="function">regex <span class="title">pattern</span><span class="params">(<span class="string">&quot;(-?\\d+)/(\\d+)([+-])(-?\\d+)/(\\d+)&quot;</span>)</span></span>;</span><br><span class="line">        smatch matches;</span><br><span class="line">        <span class="keyword">while</span> (<span class="built_in">regex_search</span>(expression, matches, pattern)) &#123;</span><br><span class="line">            <span class="type">int</span> num1 = std::<span class="built_in">stoi</span>(matches[<span class="number">1</span>].<span class="built_in">str</span>());</span><br><span class="line">            <span class="type">int</span> den1 = std::<span class="built_in">stoi</span>(matches[<span class="number">2</span>].<span class="built_in">str</span>());</span><br><span class="line">            <span class="type">int</span> num2 = std::<span class="built_in">stoi</span>(matches[<span class="number">4</span>].<span class="built_in">str</span>());</span><br><span class="line">            <span class="type">int</span> den2 = std::<span class="built_in">stoi</span>(matches[<span class="number">5</span>].<span class="built_in">str</span>());</span><br><span class="line">            <span class="type">char</span> op = matches[<span class="number">3</span>].<span class="built_in">str</span>()[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">            expression = matches.<span class="built_in">prefix</span>().<span class="built_in">str</span>() +</span><br><span class="line">                         <span class="built_in">performOperation</span>(num1, den1, num2, den2, op) +</span><br><span class="line">                         matches.<span class="built_in">suffix</span>().<span class="built_in">str</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> expression;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>关于最大公约数gcd和最小公倍数lcm:</p><p>(Greatest Common Divisor、Least Common Multiple)</p><p>需要的头文件为<code>&lt;numeric&gt;</code></p><h2 id="6-4-分数到小数-分数乘除运算-：166"><a href="#6-4-分数到小数-分数乘除运算-：166" class="headerlink" title="6-4.分数到小数(分数乘除运算)：166"></a>6-4.分数到小数(分数乘除运算)：166</h2><p>两个整数相除，结果一定是有理数，一定有循环。使用了哈希表存储竖式模拟过程中出现过的余数。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">fractionToDecimal</span><span class="params">(<span class="type">int</span> numerator, <span class="type">int</span> denominator)</span> </span>&#123;</span><br><span class="line">        <span class="type">long</span> numeratorLong = numerator;</span><br><span class="line">        <span class="type">long</span> denominatorLong = denominator;</span><br><span class="line">        <span class="keyword">if</span> (numeratorLong % denominatorLong == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">to_string</span>(numeratorLong / denominatorLong);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        string ans;</span><br><span class="line">        <span class="keyword">if</span> (numeratorLong &lt; <span class="number">0</span> ^ denominatorLong &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            ans.<span class="built_in">push_back</span>(<span class="string">&#x27;-&#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 整数部分</span></span><br><span class="line">        numeratorLong = <span class="built_in">abs</span>(numeratorLong);</span><br><span class="line">        denominatorLong = <span class="built_in">abs</span>(denominatorLong);</span><br><span class="line">        <span class="type">long</span> integerPart = numeratorLong / denominatorLong;</span><br><span class="line">        ans += <span class="built_in">to_string</span>(integerPart);</span><br><span class="line">        ans.<span class="built_in">push_back</span>(<span class="string">&#x27;.&#x27;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 小数部分</span></span><br><span class="line">        string fractionPart;</span><br><span class="line">        unordered_map&lt;<span class="type">long</span>, <span class="type">int</span>&gt; remainderIndexMap;</span><br><span class="line">        <span class="type">long</span> remainder = numeratorLong % denominatorLong;</span><br><span class="line">        <span class="type">int</span> index = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (remainder != <span class="number">0</span> &amp;&amp; !remainderIndexMap.<span class="built_in">count</span>(remainder)) &#123;</span><br><span class="line">            remainderIndexMap[remainder] = index;</span><br><span class="line">            remainder *= <span class="number">10</span>;</span><br><span class="line">            fractionPart += <span class="built_in">to_string</span>(remainder / denominatorLong);</span><br><span class="line">            remainder %= denominatorLong;</span><br><span class="line">            index++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (remainder != <span class="number">0</span>) &#123; <span class="comment">// 有循环节</span></span><br><span class="line">            <span class="type">int</span> insertIndex = remainderIndexMap[remainder];</span><br><span class="line">            fractionPart = fractionPart.<span class="built_in">substr</span>(<span class="number">0</span>,insertIndex) + <span class="string">&#x27;(&#x27;</span> + fractionPart.<span class="built_in">substr</span>(insertIndex);</span><br><span class="line">            fractionPart.<span class="built_in">push_back</span>(<span class="string">&#x27;)&#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        ans += fractionPart;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="6-5-求解方程：640"><a href="#6-5-求解方程：640" class="headerlink" title="6-5.求解方程：640"></a>6-5.求解方程：640</h2><p><img src="https://s2.loli.net/2024/01/23/NfTy7ME3SJHCcKV.png" alt=""></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">solveEquation</span><span class="params">(string equation)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> index = <span class="number">0</span>, n = equation.<span class="built_in">size</span>(), sign1 = <span class="number">1</span>; <span class="comment">// sign1记录等式右边系数</span></span><br><span class="line">        <span class="type">int</span> factor = <span class="number">0</span>, val = <span class="number">0</span>; <span class="comment">//记录变量的系数，常量值</span></span><br><span class="line">        <span class="keyword">while</span> (index &lt; n) &#123;</span><br><span class="line">            <span class="keyword">if</span> (equation[index] == <span class="string">&#x27;=&#x27;</span>) &#123;</span><br><span class="line">                sign1 = <span class="number">-1</span>; <span class="comment">//等式右边默认系数为负</span></span><br><span class="line">                index++;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">int</span> sign2 = sign1, number = <span class="number">0</span>;</span><br><span class="line">            <span class="type">bool</span> valid = <span class="literal">false</span>; <span class="comment">//记录number是否有效</span></span><br><span class="line">            <span class="keyword">if</span> (equation[index] == <span class="string">&#x27;-&#x27;</span> ||</span><br><span class="line">                equation[index] == <span class="string">&#x27;+&#x27;</span>) &#123; <span class="comment">//去掉前面的符号</span></span><br><span class="line">                sign2 = (equation[index] == <span class="string">&#x27;-&#x27;</span>) ? -sign1 : sign1;</span><br><span class="line">                index++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> (index &lt; n &amp;&amp; <span class="built_in">isdigit</span>(equation[index])) &#123;</span><br><span class="line">                number = number * <span class="number">10</span> + equation[index] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">                index++;</span><br><span class="line">                valid = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (index &lt; n &amp;&amp; equation[index] == <span class="string">&#x27;x&#x27;</span>) &#123; <span class="comment">//变量</span></span><br><span class="line">                factor += valid ? sign2 * number : sign2;</span><br><span class="line">                index++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123; <span class="comment">//数值</span></span><br><span class="line">                val += sign2 * number;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!factor) &#123;  <span class="comment">//factor * x + val = 0</span></span><br><span class="line">            <span class="keyword">return</span> val == <span class="number">0</span> ? <span class="string">&quot;Infinite solutions&quot;</span> : <span class="string">&quot;No solution&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;x=&quot;</span> + <span class="built_in">to_string</span>(-val / factor);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="6-6-外观数列：38"><a href="#6-6-外观数列：38" class="headerlink" title="6-6.外观数列：38"></a>6-6.外观数列：38</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">countAndSay</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        string prev = <span class="string">&quot;1&quot;</span>; <span class="comment">//记录下前一个字符串是什么，默认为第一个字符串&quot;1&quot;</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            string curr = <span class="string">&quot;&quot;</span>;</span><br><span class="line">            <span class="type">int</span> start = <span class="number">0</span>, pos = <span class="number">0</span>;<span class="comment">//双指针</span></span><br><span class="line">            <span class="keyword">while</span> (pos &lt; prev.<span class="built_in">size</span>()) &#123;</span><br><span class="line">                <span class="keyword">while</span> (pos &lt; prev.<span class="built_in">size</span>() &amp;&amp; prev[pos] == prev[start]) &#123;</span><br><span class="line">                    pos++;</span><br><span class="line">                &#125;</span><br><span class="line">                curr += <span class="built_in">to_string</span>(pos - start) + prev[start];</span><br><span class="line">                start = pos; <span class="comment">//更新start</span></span><br><span class="line">            &#125;</span><br><span class="line">            prev = curr; <span class="comment">//更新prev为下一个字符串</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> prev;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>6-6.自定义字符串转换整数：8</p><p>法一：依次遍历</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">strToInt</span><span class="params">(string str)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (str.<span class="built_in">empty</span>()) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> index = <span class="number">0</span>, n = str.<span class="built_in">size</span>(), sign = <span class="number">1</span>, res = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 处理前置空格</span></span><br><span class="line">        <span class="keyword">while</span> (index &lt; n &amp;&amp; str[index] == <span class="string">&#x27; &#x27;</span>) &#123;</span><br><span class="line">            ++index;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 处理符号，应该继续向后，因为+-12的结果应为0</span></span><br><span class="line">        <span class="keyword">if</span> (index &lt; n &amp;&amp; (str[index] == <span class="string">&#x27;+&#x27;</span> || str[index] == <span class="string">&#x27;-&#x27;</span>)) &#123;</span><br><span class="line">            sign = str[index++] == <span class="string">&#x27;+&#x27;</span> ? <span class="number">1</span> : <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 处理数字</span></span><br><span class="line">        <span class="keyword">while</span> (index &lt; n &amp;&amp; <span class="built_in">isdigit</span>(str[index])) &#123;</span><br><span class="line">            <span class="type">int</span> digit = str[index++] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">            <span class="comment">// 判断是否溢出</span></span><br><span class="line">            <span class="keyword">if</span> (res &gt; (INT_MAX - digit) / <span class="number">10</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> sign == <span class="number">1</span> ? INT_MAX : INT_MIN;</span><br><span class="line">            &#125;</span><br><span class="line">            res = res * <span class="number">10</span> + digit;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res * sign;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>本题关键：处理整数溢出的情况，原题：如果整数数超过 32 位有符号整数范围 $[−2^{31},  2^{31} − 1]$ ，需要截断这个整数，使其保持在这个范围内。具体来说，小于 $2^{31}$ 的整数应该被固定为 $2^{31}$ ，大于 $2^{31}− 1$ 的整数应该被固定为 $2^{31}− 1 $。</p><hr><p>法二：自动机</p><p><img src="https://s2.loli.net/2024/01/24/TAa7d6Hgjy4iYqC.png" alt=""></p><p><img src="https://s2.loli.net/2024/01/24/QxOmc2DHh3U51nf.png" alt=""></p><p><img src="https://s2.loli.net/2024/01/24/d13ieFt2Aa4SQIX.png" alt=""></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Automaton</span> &#123;</span><br><span class="line">    string state = <span class="string">&quot;start&quot;</span>;</span><br><span class="line">    unordered_map&lt;string, vector&lt;string&gt;&gt; table = &#123;</span><br><span class="line">        &#123;<span class="string">&quot;start&quot;</span>, &#123;<span class="string">&quot;start&quot;</span>, <span class="string">&quot;signed&quot;</span>, <span class="string">&quot;in_number&quot;</span>, <span class="string">&quot;end&quot;</span>&#125;&#125;,</span><br><span class="line">        &#123;<span class="string">&quot;signed&quot;</span>, &#123;<span class="string">&quot;end&quot;</span>, <span class="string">&quot;end&quot;</span>, <span class="string">&quot;in_number&quot;</span>, <span class="string">&quot;end&quot;</span>&#125;&#125;,</span><br><span class="line">        &#123;<span class="string">&quot;in_number&quot;</span>, &#123;<span class="string">&quot;end&quot;</span>, <span class="string">&quot;end&quot;</span>, <span class="string">&quot;in_number&quot;</span>, <span class="string">&quot;end&quot;</span>&#125;&#125;,</span><br><span class="line">        &#123;<span class="string">&quot;end&quot;</span>, &#123;<span class="string">&quot;end&quot;</span>, <span class="string">&quot;end&quot;</span>, <span class="string">&quot;end&quot;</span>, <span class="string">&quot;end&quot;</span>&#125;&#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">get_col</span><span class="params">(<span class="type">char</span> c)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">isspace</span>(c)) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="string">&#x27;+&#x27;</span> <span class="keyword">or</span> c == <span class="string">&#x27;-&#x27;</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">isdigit</span>(c)) <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">3</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> sign = <span class="number">1</span>;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> ans = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">get</span><span class="params">(<span class="type">char</span> c)</span> </span>&#123;</span><br><span class="line">        state = table[state][<span class="built_in">get_col</span>(c)];</span><br><span class="line">        <span class="keyword">if</span> (state == <span class="string">&quot;in_number&quot;</span>) &#123;</span><br><span class="line">            ans = ans * <span class="number">10</span> + c - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">            ans = sign == <span class="number">1</span> ? <span class="built_in">min</span>(ans, (<span class="type">long</span> <span class="type">long</span>)INT_MAX) : <span class="built_in">min</span>(ans, -(<span class="type">long</span> <span class="type">long</span>)INT_MIN);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (state == <span class="string">&quot;signed&quot;</span>)</span><br><span class="line">            sign = c == <span class="string">&#x27;+&#x27;</span> ? <span class="number">1</span> : <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">myAtoi</span><span class="params">(string str)</span> </span>&#123;</span><br><span class="line">        Automaton automaton;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">char</span> c : str)</span><br><span class="line">            automaton.<span class="built_in">get</span>(c);</span><br><span class="line">        <span class="keyword">return</span> automaton.sign * automaton.ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="关于自动机"><a href="#关于自动机" class="headerlink" title="关于自动机"></a>关于自动机</h2><p>在C++中，自动机通常指的是有限状态自动机（Finite State Machine，FSM），它是一种抽象的数学模型，用于描述系统的状态及状态之间的转移。</p><p>一个简单的有限状态自动机由以下几部分组成：</p><ul><li>一组状态：描述系统可能处于的状态。</li><li>一组转移：描述状态之间的转移条件。</li><li>初始状态：描述系统的初始状态。</li><li>终止状态：描述系统的结束状态。</li></ul><p>在C++中，我们可以使用类和枚举类型来实现有限状态自动机。以下是一个简单的示例，演示了一个有限状态自动机，用于模拟一个简单的灯的状态变化。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 枚举类型表示灯的状态</span></span><br><span class="line"><span class="keyword">enum class</span> <span class="title class_">LightState</span> &#123;</span><br><span class="line">    OFF,</span><br><span class="line">    ON,</span><br><span class="line">    DIM</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LightStateMachine</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    LightState state;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">LightStateMachine</span>() : <span class="built_in">state</span>(LightState::OFF) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">transition</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">switch</span> (state) &#123;</span><br><span class="line">            <span class="keyword">case</span> LightState::OFF:</span><br><span class="line">                state = LightState::ON;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> LightState::ON:</span><br><span class="line">                state = LightState::DIM;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> LightState::DIM:</span><br><span class="line">                state = LightState::OFF;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">LightState <span class="title">getState</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> state;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    LightStateMachine light;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Initial state: &quot;</span> &lt;&lt; <span class="built_in">static_cast</span>&lt;<span class="type">int</span>&gt;(light.<span class="built_in">getState</span>()) &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    light.<span class="built_in">transition</span>();</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;State after transition: &quot;</span> &lt;&lt; <span class="built_in">static_cast</span>&lt;<span class="type">int</span>&gt;(light.<span class="built_in">getState</span>()) &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    light.<span class="built_in">transition</span>();</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;State after transition: &quot;</span> &lt;&lt; <span class="built_in">static_cast</span>&lt;<span class="type">int</span>&gt;(light.<span class="built_in">getState</span>()) &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面的示例中，我们定义了一个简单的有限状态自动机 <code>LightStateMachine</code>，用于模拟灯的状态变化。通过调用 <code>transition</code> 方法，状态机会根据当前状态进行转移，并可以通过 <code>getState</code> 方法获取当前状态。</p><h2 id="6-6-整数转罗马数字：12"><a href="#6-6-整数转罗马数字：12" class="headerlink" title="6-6.整数转罗马数字：12"></a>6-6.整数转罗马数字：12</h2><p>法一：模拟</p><p>注意，这里<mark>不能</mark>用unordered_map，因为其遍历的时候是乱序的，应该用能设置排列规则的map，用<code>greater&lt;int&gt;</code>保证由大到小遍历。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">const</span> map&lt;<span class="type">int</span>, string, greater&lt;<span class="type">int</span>&gt;&gt; valueSymbols = &#123;</span><br><span class="line">        &#123;<span class="number">1000</span>, <span class="string">&quot;M&quot;</span>&#125;,</span><br><span class="line">        &#123;<span class="number">900</span>,  <span class="string">&quot;CM&quot;</span>&#125;,</span><br><span class="line">        &#123;<span class="number">500</span>,  <span class="string">&quot;D&quot;</span>&#125;,</span><br><span class="line">        &#123;<span class="number">400</span>,  <span class="string">&quot;CD&quot;</span>&#125;,</span><br><span class="line">        &#123;<span class="number">100</span>,  <span class="string">&quot;C&quot;</span>&#125;,</span><br><span class="line">        &#123;<span class="number">90</span>,   <span class="string">&quot;XC&quot;</span>&#125;,</span><br><span class="line">        &#123;<span class="number">50</span>,   <span class="string">&quot;L&quot;</span>&#125;,</span><br><span class="line">        &#123;<span class="number">40</span>,   <span class="string">&quot;XL&quot;</span>&#125;,</span><br><span class="line">        &#123;<span class="number">10</span>,   <span class="string">&quot;X&quot;</span>&#125;,</span><br><span class="line">        &#123;<span class="number">9</span>,    <span class="string">&quot;IX&quot;</span>&#125;,</span><br><span class="line">        &#123;<span class="number">5</span>,    <span class="string">&quot;V&quot;</span>&#125;,</span><br><span class="line">        &#123;<span class="number">4</span>,    <span class="string">&quot;IV&quot;</span>&#125;,</span><br><span class="line">        &#123;<span class="number">1</span>,    <span class="string">&quot;I&quot;</span>&#125;,</span><br><span class="line">    &#125;;</span><br><span class="line"><span class="comment">//使用了greater&lt;int&gt;才能保证遍历顺序是按照当前1000-&gt;500-&gt;...</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">intToRoman</span><span class="params">(<span class="type">int</span> num)</span> </span>&#123;</span><br><span class="line">        string roman;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; [value, symbol] : valueSymbols) &#123; <span class="comment">//注意auto前面这里需要加上const</span></span><br><span class="line">            <span class="keyword">while</span> (num &gt;= value) &#123;</span><br><span class="line">                num -= value;</span><br><span class="line">                roman += symbol;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (num == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> roman;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>也可以直接使用数组，其中每个元素均为pair类型。遍历数组的顺序并不是乱序。pair数组除了第一行的定义以外，其他代码几乎没有区别。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> pair&lt;<span class="type">int</span>, string&gt; valueSymbols[] = &#123;</span><br><span class="line">    &#123;<span class="number">1000</span>, <span class="string">&quot;M&quot;</span>&#125;,</span><br><span class="line">    &#123;<span class="number">900</span>,  <span class="string">&quot;CM&quot;</span>&#125;,</span><br><span class="line">    &#123;<span class="number">500</span>,  <span class="string">&quot;D&quot;</span>&#125;,</span><br><span class="line">    &#123;<span class="number">400</span>,  <span class="string">&quot;CD&quot;</span>&#125;,</span><br><span class="line">    &#123;<span class="number">100</span>,  <span class="string">&quot;C&quot;</span>&#125;,</span><br><span class="line">    &#123;<span class="number">90</span>,   <span class="string">&quot;XC&quot;</span>&#125;,</span><br><span class="line">    &#123;<span class="number">50</span>,   <span class="string">&quot;L&quot;</span>&#125;,</span><br><span class="line">    &#123;<span class="number">40</span>,   <span class="string">&quot;XL&quot;</span>&#125;,</span><br><span class="line">    &#123;<span class="number">10</span>,   <span class="string">&quot;X&quot;</span>&#125;,</span><br><span class="line">    &#123;<span class="number">9</span>,    <span class="string">&quot;IX&quot;</span>&#125;,</span><br><span class="line">    &#123;<span class="number">5</span>,    <span class="string">&quot;V&quot;</span>&#125;,</span><br><span class="line">    &#123;<span class="number">4</span>,    <span class="string">&quot;IV&quot;</span>&#125;,</span><br><span class="line">    &#123;<span class="number">1</span>,    <span class="string">&quot;I&quot;</span>&#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">intToRoman</span><span class="params">(<span class="type">int</span> num)</span> </span>&#123;</span><br><span class="line">        string roman;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span> &amp;[value, symbol] : valueSymbols) &#123;</span><br><span class="line">            <span class="keyword">while</span> (num &gt;= value) &#123;</span><br><span class="line">                num -= value;</span><br><span class="line">                roman += symbol;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (num == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> roman;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>法二：硬编码数字</p><p><img src="https://s2.loli.net/2024/01/24/wqVmOtoUaXb4H7A.png" alt=""></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> string thousands[] = &#123;<span class="string">&quot;&quot;</span>, <span class="string">&quot;M&quot;</span>, <span class="string">&quot;MM&quot;</span>, <span class="string">&quot;MMM&quot;</span>&#125;;</span><br><span class="line"><span class="type">const</span> string hundreds[]  = &#123;<span class="string">&quot;&quot;</span>, <span class="string">&quot;C&quot;</span>, <span class="string">&quot;CC&quot;</span>, <span class="string">&quot;CCC&quot;</span>, <span class="string">&quot;CD&quot;</span>, <span class="string">&quot;D&quot;</span>, <span class="string">&quot;DC&quot;</span>, <span class="string">&quot;DCC&quot;</span>, <span class="string">&quot;DCCC&quot;</span>, <span class="string">&quot;CM&quot;</span>&#125;;</span><br><span class="line"><span class="type">const</span> string tens[]      = &#123;<span class="string">&quot;&quot;</span>, <span class="string">&quot;X&quot;</span>, <span class="string">&quot;XX&quot;</span>, <span class="string">&quot;XXX&quot;</span>, <span class="string">&quot;XL&quot;</span>, <span class="string">&quot;L&quot;</span>, <span class="string">&quot;LX&quot;</span>, <span class="string">&quot;LXX&quot;</span>, <span class="string">&quot;LXXX&quot;</span>, <span class="string">&quot;XC&quot;</span>&#125;;</span><br><span class="line"><span class="type">const</span> string ones[]      = &#123;<span class="string">&quot;&quot;</span>, <span class="string">&quot;I&quot;</span>, <span class="string">&quot;II&quot;</span>, <span class="string">&quot;III&quot;</span>, <span class="string">&quot;IV&quot;</span>, <span class="string">&quot;V&quot;</span>, <span class="string">&quot;VI&quot;</span>, <span class="string">&quot;VII&quot;</span>, <span class="string">&quot;VIII&quot;</span>, <span class="string">&quot;IX&quot;</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">intToRoman</span><span class="params">(<span class="type">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> thousands[num / <span class="number">1000</span>] + hundreds[num % <span class="number">1000</span> / <span class="number">100</span>] + tens[num % <span class="number">100</span> / <span class="number">10</span>] + ones[num % <span class="number">10</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="6-7-比较版本号：165"><a href="#6-7-比较版本号：165" class="headerlink" title="6-7.比较版本号：165"></a>6-7.比较版本号：165</h2><p>注意其中细节即可，双指针法，尽可能简化代码</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">compareVersion</span><span class="params">(string version1, string version2)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> pos1 = <span class="number">0</span>, pos2 = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> n1 = version1.<span class="built_in">length</span>(), n2 = version2.<span class="built_in">length</span>();</span><br><span class="line">        <span class="keyword">while</span> (pos1 &lt; n1 || pos2 &lt; n2) &#123; <span class="comment">//用或，需要把两个都遍历完</span></span><br><span class="line">            <span class="type">long</span> <span class="type">int</span> v1 = <span class="number">0</span>, v2 = <span class="number">0</span>; <span class="comment">//版本号可能是&quot;1.2147483647&quot;</span></span><br><span class="line">            <span class="keyword">while</span> (pos1 &lt; n1 &amp;&amp; version1[pos1] != <span class="string">&#x27;.&#x27;</span>) &#123;</span><br><span class="line">                v1 = v1 * <span class="number">10</span> + version1[pos1++] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> (pos2 &lt; n2 &amp;&amp; version2[pos2] != <span class="string">&#x27;.&#x27;</span>) &#123;</span><br><span class="line">                v2 = v2 * <span class="number">10</span> + version2[pos2++] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (v1 != v2) &#123;</span><br><span class="line">                <span class="keyword">return</span> v1 &gt; v2 ? <span class="number">1</span> : <span class="number">-1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            pos1++;</span><br><span class="line">            pos2++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><code>stoi(stringVar)</code>中，stringVar不能为空。</p><h2 id="6-8-神奇字符串：481"><a href="#6-8-神奇字符串：481" class="headerlink" title="6-8.神奇字符串：481"></a>6-8.神奇字符串：481</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">magicalString</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        string s = <span class="string">&quot;\1\2\2&quot;</span>; <span class="comment">//需要用反斜杠</span></span><br><span class="line">        <span class="comment">// 值就是 1,2,2，这样就可以直接用 s[i] 当作个数</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; s.<span class="built_in">length</span>() &lt; n; ++i) &#123;</span><br><span class="line">            s += <span class="built_in">string</span>(s[i], s.<span class="built_in">back</span>() ^ <span class="number">3</span>);</span><br><span class="line">            <span class="comment">// 1^3=2, 2^3=1，这样就能在 1 和 2 之间转换</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">count</span>(s.<span class="built_in">begin</span>(), s.<span class="built_in">begin</span>() + n, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ol><li><p><code>string s = &quot;\1\2\2&quot;;</code>和<code>string s = &quot;122&quot;;</code>的区别:在C++中，字符串字面值中的转义序列是以反斜杠（<code>\</code>）开头的字符序列。<code>&quot;\1\2\2&quot;</code> 和 <code>&quot;122&quot;</code> 的区别在于<mark>转义序列</mark>的使用。<code>&quot;\1\2\2&quot;</code>：这个字符串包含了转义序列 <code>\1</code>、<code>\2</code> 和 <code>\2</code>。这些是八进制转义序列，代表特定的ASCII字符。具体而言，<code>\1</code> 对应ASCII值1，<code>\2</code> 对应ASCII值2。因此，这个字符串实际上是包含了三个字符，分别是1、2和2。<code>&quot;122&quot;</code>这个字符串没有使用八进制转义序列，它只包含了三个字符，分别是’1’、’2’和’2’。前者的s[i]可以直接用来当做个数。</p></li><li><p><code>s += string(s[i], s.back()^3)</code>：<code>string(int count,char value);</code>这是表示s加上一个包含value字符，且长度为count的字符串。比如<code>s+=string(&#39;\2&#39;, 1)</code>就是<code>s+=&quot;11&quot;</code>,常规写法是<code>string(2, &#39;1&#39;)</code>;</p></li><li><p><code>s.back()^3</code>:s.back()就是字符串s的最后一个字符。<code>^3</code>用于实现1与2的不断切换，1^3=2, 2^3=1.(二进制运算)</p></li><li><p><code>count(s.begin(), s.begin()+n, 1)</code>:计数特定区间内有多少个值为1的字符。模板<code>count(T.begin(),T.end(),value)</code>。</p></li></ol><hr><p>现在不用反斜杠：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">magicalString</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        string s = <span class="string">&quot;122&quot;</span>; <span class="comment">//不用反斜杠</span></span><br><span class="line">        <span class="comment">// 这样就不可以直接用 s[i] 当作个数</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; s.<span class="built_in">length</span>() &lt; n; ++i) &#123;</span><br><span class="line">            s += <span class="built_in">string</span>(s[i]-<span class="string">&#x27;0&#x27;</span>, (s.<span class="built_in">back</span>()-<span class="string">&#x27;0&#x27;</span>) ^ <span class="number">3</span> +<span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">            <span class="comment">// 1^3=2, 2^3=1，这样就能在 1 和 2 之间转换</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">count</span>(s.<span class="built_in">begin</span>(), s.<span class="built_in">begin</span>() + n, <span class="string">&#x27;1&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">字符串进阶部分</summary>
    
    
    
    <category term="leetcode刷题笔记" scheme="https://sumikiru.top/categories/leetcode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="C++" scheme="https://sumikiru.top/tags/C/"/>
    
    <category term="leetcode" scheme="https://sumikiru.top/tags/leetcode/"/>
    
    <category term="string" scheme="https://sumikiru.top/tags/string/"/>
    
  </entry>
  
  <entry>
    <title>2.0字符串篇</title>
    <link href="https://sumikiru.top/posts/10e5d792.html"/>
    <id>https://sumikiru.top/posts/10e5d792.html</id>
    <published>2024-04-05T18:51:21.000Z</published>
    <updated>2025-02-06T14:42:00.323Z</updated>
    
    <content type="html"><![CDATA[<h1 id="关于string和cstring"><a href="#关于string和cstring" class="headerlink" title="关于string和cstring"></a>关于string和cstring</h1><p><code>&lt;string&gt;</code> 和 <code>&lt;cstring&gt;</code> 是 C++ 中的两个不同的头文件，它们有不同的作用和功能：</p><ul><li><p><code>&lt;string&gt;</code> 头文件包含了 C++ 标准库中的字符串类 <code>std::string</code>，以及与字符串相关的一些函数和操作符重载。这个头文件用于处理 C++ 中的字符串操作，提供了更多的字符串处理功能和便利。</p></li><li><p><code>&lt;cstring&gt;</code> 头文件是 C 标准库中的头文件，其中定义了一些 C 语言字符串操作的函数，比如字符串复制、连接、比较等。在 C++ 中，这些函数通常被包含在 <code>std</code> 命名空间中，比如 <code>std::strcpy</code>、<code>std::strcat</code> 等。</p></li></ul><p>总的来说，<code>&lt;string&gt;</code> 更适合用于 C++ 中的字符串操作，而 <code>&lt;cstring&gt;</code> 则更适合用于 C 风格的字符串操作。</p><hr><h1 id="关于string包含的常见函数"><a href="#关于string包含的常见函数" class="headerlink" title="关于string包含的常见函数"></a>关于string包含的常见函数</h1><ul><li><code>length()</code> 或 <code>size()</code>: 返回字符串的长度。</li><li><code>append(str)</code>: 在字符串末尾添加另一个字符串。</li><li><code>insert(pos, str)</code>: 在指定位置插入另一个字符串。</li><li><code>erase(pos, len)</code>: 从指定位置删除指定长度的字符。</li><li><code>find(str)</code>: 查找字符串中是否包含指定的子字符串。</li><li><code>substr(pos, len)</code>: 返回从指定位置开始的指定长度的子字符串。</li><li><code>compare(str)</code>: 比较两个字符串。</li><li><code>replace(pos, len, str)</code>: 用另一个字符串替换指定位置的指定长度的字符。</li><li><code>push_back()、pop_back()</code>:类似数组的操作方式，对字符串依然使用。</li></ul><hr><p>异或：<code>^</code>.运算规则：<code>N^0=N;N^N=0;</code></p><p>判断大小写：<code>islower</code>、<code>isupper</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">detectCapitalUse</span><span class="params">(string word)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (word.<span class="built_in">size</span>() &gt;= <span class="number">2</span> &amp;&amp; <span class="built_in">islower</span>(word[<span class="number">0</span>]) &amp;&amp; <span class="built_in">isupper</span>(word[<span class="number">1</span>])) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;<span class="comment">//排除形如uSA的情况</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt; word.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">islower</span>(word[i]) ^ <span class="built_in">islower</span>(word[<span class="number">1</span>])) &#123;</span><br><span class="line">                <span class="comment">//除了第一个字母以外的字母大小写不一致</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>转为小写：<code>tolower</code>/转为大写:<code>toupper</code>(注意，返回值类型为int。可以写作<code>char ch = tolower(c);</code>或者<code>auto ch = char(tolower(c));</code>)。如果是数字，则无变化，<mark>可以接受数字</mark></p><p>检查一个字符是否是字母或数字:<code>isalnum</code>,需要头文件<code>&lt;cctype&gt;</code>.如果判断是否为字母:<code>isalpha</code>,判断是否为数字:<code>isdigit</code>.也是需要头文件<code>&lt;cctype&gt;</code></p><p>定义b为a的逆序字符串：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">string b(a.rbgin(),a.rend());</span><br></pre></td></tr></table></figure><h1 id="1-回文串的定义"><a href="#1-回文串的定义" class="headerlink" title="1.回文串的定义"></a>1.回文串的定义</h1><h2 id="验证回文串：125"><a href="#验证回文串：125" class="headerlink" title="验证回文串：125"></a>验证回文串：125</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isPalindrome</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        string schange;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">char</span> ch : s) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">isalnum</span>(ch)) &#123;</span><br><span class="line">                schange += <span class="built_in">tolower</span>(ch); <span class="comment">//防止大小写干扰之后的相等判断</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function">string <span class="title">schangeReverse</span><span class="params">(schange.rbegin(), schange.rend())</span></span>;</span><br><span class="line">        <span class="keyword">return</span> schange == schangeReverse;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>空间优化:使用双指针，在原字符串上直接判断</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isPalindrome</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n=s.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> left=<span class="number">0</span>,right=n<span class="number">-1</span>;</span><br><span class="line">        <span class="comment">//每次将指针移到下一个字母字符或数字字符，再判断这两个指针指向的字符是否相同</span></span><br><span class="line">        <span class="keyword">while</span>(left&lt;right)&#123;</span><br><span class="line">            <span class="keyword">while</span>(left&lt;right&amp;&amp;!<span class="built_in">isalnum</span>(s[left]))&#123;</span><br><span class="line">                ++left;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span>(left&lt;right&amp;&amp;!<span class="built_in">isalnum</span>(s[right]))&#123;</span><br><span class="line">                --right;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(left&lt;right)&#123;</span><br><span class="line">                <span class="keyword">if</span>(<span class="built_in">tolower</span>(s[left])!=<span class="built_in">tolower</span>(s[right]))&#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                ++left;</span><br><span class="line">                --right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>取字符串str从索引 0 开始、长度为 index 的子字符串：(注意包括的是str[0]到str[i-1]的部分！)</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">str.<span class="built_in">substr</span>(<span class="number">0</span>, index);</span><br></pre></td></tr></table></figure><h1 id="2-公共前缀"><a href="#2-公共前缀" class="headerlink" title="2.公共前缀"></a>2.公共前缀</h1><h2 id="最长公共前缀：14"><a href="#最长公共前缀：14" class="headerlink" title="最长公共前缀：14"></a>最长公共前缀：14</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//纵向扫描</span></span><br><span class="line"><span class="comment">//从前往后遍历所有字符串的每一列，比较相同列上的字符是否相同，</span></span><br><span class="line"><span class="comment">//如果相同则继续对下一列进行比较，如果不相同则当前列不再属于公共前缀，</span></span><br><span class="line"><span class="comment">//当前列之前的部分为最长公共前缀。</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">longestCommonPrefix</span><span class="params">(vector&lt;string&gt;&amp; strs)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!strs.<span class="built_in">size</span>()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; strs[<span class="number">0</span>].<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt; strs.<span class="built_in">size</span>(); j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (strs[<span class="number">0</span>][i] != strs[j][i]) &#123;</span><br><span class="line">                    <span class="keyword">return</span> strs[<span class="number">0</span>].<span class="built_in">substr</span>(<span class="number">0</span>, i) ;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> strs[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="3-单词"><a href="#3-单词" class="headerlink" title="3.单词"></a>3.单词</h1><h2 id="判断单词数：434"><a href="#判断单词数：434" class="headerlink" title="判断单词数：434"></a>判断单词数：434</h2><p>关键在于看该字符的<u>前一个</u>字符s[i-1]是否为空(这样可以遍历到所有字符而且不需要额外判断)，而不是看下一个字符s[i+1]是否为空</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">countSegments</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s[i] != <span class="string">&#x27; &#x27;</span> &amp;&amp; (i == <span class="number">0</span> || s[i - <span class="number">1</span>] == <span class="string">&#x27; &#x27;</span>)) &#123;</span><br><span class="line">                <span class="comment">// i==0必须写在s[i-1]前面，否则会溢出</span></span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="4-字符串的反转"><a href="#4-字符串的反转" class="headerlink" title="4.字符串的反转"></a>4.字符串的反转</h1><h2 id="反转字符串s"><a href="#反转字符串s" class="headerlink" title="反转字符串s"></a>反转字符串s</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">reverseString</span><span class="params">(vector&lt;<span class="type">char</span>&gt;&amp; s)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//法一</span></span><br><span class="line">    <span class="type">int</span> n = s.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= n / <span class="number">2</span> - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="built_in">swap</span>(s[i], s[n - <span class="number">1</span> - i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//法二：自带方法</span></span><br><span class="line">    <span class="built_in">reverse</span>(s.<span class="built_in">begin</span>(),s.<span class="built_in">end</span>());</span><br><span class="line">    <span class="comment">//法三：双指针</span></span><br><span class="line">    <span class="type">int</span> n = s.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> left = <span class="number">0</span>, right = n - <span class="number">1</span>; left &lt; right; ++left, --right) &#123;</span><br><span class="line">        <span class="built_in">swap</span>(s[left], s[right]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注：关于min()，两个参数都必须是int类型，而s.size()是unsigned int类型，需要转换！(或者一开始就写成<code>int n=s.size()</code>，然后后面用n代替)</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">reverse</span>(s.<span class="built_in">begin</span>() + i, s.<span class="built_in">begin</span>() + <span class="built_in">min</span>(i + k, (<span class="type">int</span>)s.<span class="built_in">size</span>()));</span><br></pre></td></tr></table></figure><p>反转字符串中的各个单词：557(进阶：包括前置后置以后中间与多个空格时，stringstream能够很好解决,只不过用到了额外空间ans和t并非原地解法,时间复杂度为O(n * m + k)，空间复杂度为O(n)。原地解法应该用双指针)</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">string <span class="title">reverseWords</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">    <span class="function">stringstream <span class="title">ss</span><span class="params">(s)</span></span>;</span><br><span class="line">    string t, ans;</span><br><span class="line">    <span class="keyword">while</span> (ss &gt;&gt; t) &#123;</span><br><span class="line">        <span class="built_in">reverse</span>(t.<span class="built_in">begin</span>(), t.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">if</span> (!ans.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            ans += <span class="string">&quot; &quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ans += t;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="5-统计字符串-哈希表"><a href="#5-统计字符串-哈希表" class="headerlink" title="5.统计字符串(哈希表)"></a>5.统计字符串(哈希表)</h1><h2 id="5-1-字符串中的第一个唯一字符：387"><a href="#5-1-字符串中的第一个唯一字符：387" class="headerlink" title="5-1.字符串中的第一个唯一字符：387"></a>5-1.字符串中的第一个唯一字符：387</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">firstUniqChar</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n = s.<span class="built_in">length</span>();</span><br><span class="line">    unordered_map&lt;<span class="type">char</span>, <span class="type">int</span>&gt; count;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">char</span> ch : s) &#123;</span><br><span class="line">        count[ch]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (count[s[i]] == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>还可以用find()和rfind():(空间复杂度为$O(1)$,时间复杂度$O(n^2)$)</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">firstUniqChar</span><span class="params">(string s)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>( i = <span class="number">0</span>; i &lt; s.<span class="built_in">size</span>(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(s.<span class="built_in">find</span>(s[i]) == s.<span class="built_in">rfind</span>(s[i]))<span class="comment">//find()时间复杂度O(n)</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>优化：记录频数改为记录<strong>索引</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">firstUniqChar</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = s.<span class="built_in">length</span>();</span><br><span class="line">        unordered_map&lt;<span class="type">char</span>, <span class="type">int</span>&gt; position;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (position.<span class="built_in">count</span>(s[i])) &#123; <span class="comment">//该字符已经出现过至少一次</span></span><br><span class="line">                position[s[i]] = <span class="number">-1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                position[s[i]] = i; <span class="comment">//只出现第一次的，记录下对应索引</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> first = n;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; [_, pos] : position) &#123;</span><br><span class="line">            <span class="keyword">if</span> (pos != <span class="number">-1</span>) &#123;</span><br><span class="line">                first = <span class="built_in">min</span>(first, pos);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> first == n ? <span class="number">-1</span> : first;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>注：（用纯数组更快，尽管时间复杂度和空间复杂度相同，但是哈希表牵涉到建表、哈希碰撞等等）</p><p>方法二：使用队列queue（时间空间复杂度同法一）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">firstUniqChar</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = s.<span class="built_in">length</span>();</span><br><span class="line">        unordered_map&lt;<span class="type">char</span>, <span class="type">int</span>&gt; position;</span><br><span class="line">        queue&lt;pair&lt;<span class="type">char</span>, <span class="type">int</span>&gt;&gt; q;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (position.<span class="built_in">count</span>(s[i])) &#123; <span class="comment">//该字符已经出现过至少一次</span></span><br><span class="line">                position[s[i]] = <span class="number">-1</span>;</span><br><span class="line">                <span class="keyword">while</span> (!q.<span class="built_in">empty</span>() &amp;&amp; position[q.<span class="built_in">front</span>().first] == <span class="number">-1</span>) &#123;</span><br><span class="line">                    q.<span class="built_in">pop</span>();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                position[s[i]] = i; <span class="comment">//只出现第一次的，记录下对应索引</span></span><br><span class="line">                q.<span class="built_in">emplace</span>(s[i], i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> q.<span class="built_in">empty</span>() ? <span class="number">-1</span> : q.<span class="built_in">front</span>().second;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><code>emplace()</code> 是 C++ 中容器类的一个成员函数，用于在容器中就地构造元素，而不是通过拷贝或移动构造函数。</p><p>对于<mark>容器类</mark>（如 <code>std::vector</code>、<code>std::map</code>、<code>std::unordered_map</code> 等），<code>emplace()</code> 函数接受构造函数的参数，并在容器中直接构造一个新的元素，而不是将一个已经构造好的对象插入容器。</p><p>这种就地构造的方式可以避免额外的拷贝或移动操作，提高代码的效率。它对于大型对象或者不可复制/移动的对象特别有用。</p><hr><h3 id="注：关于哈希表"><a href="#注：关于哈希表" class="headerlink" title="注：关于哈希表"></a>注：关于哈希表</h3><p>统计出现次数(时间复杂度$O(1)$)：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">position.<span class="built_in">count</span>(s[i]);</span><br></pre></td></tr></table></figure><p>内部定义：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">unordered_map&lt;<span class="type">char</span>, <span class="type">int</span>&gt; mp = &#123;</span><br><span class="line">        &#123;<span class="string">&#x27;I&#x27;</span>, <span class="number">1</span>&#125;,  </span><br><span class="line">        &#123;<span class="string">&#x27;V&#x27;</span>, <span class="number">5</span>&#125;,   </span><br><span class="line">        &#123;<span class="string">&#x27;X&#x27;</span>, <span class="number">10</span>&#125;,   </span><br><span class="line">        &#123;<span class="string">&#x27;L&#x27;</span>, <span class="number">50</span>&#125;,</span><br><span class="line">        &#123;<span class="string">&#x27;C&#x27;</span>, <span class="number">100</span>&#125;, </span><br><span class="line">        &#123;<span class="string">&#x27;D&#x27;</span>, <span class="number">500</span>&#125;, </span><br><span class="line">        &#123;<span class="string">&#x27;M&#x27;</span>, <span class="number">1000</span>&#125;,</span><br><span class="line">    &#125;;</span><br></pre></td></tr></table></figure><p>遍历元素：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span>&amp; [_, pos] : position) &#123;</span><br><span class="line">     <span class="keyword">if</span> (pos != <span class="number">-1</span>) &#123;</span><br><span class="line">          first = <span class="built_in">min</span>(first, pos);</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码使用了 C++17 中的结构化绑定（structured bindings）语法，用于遍历名为 <code>position</code> 的容器中的元素。遍历的顺序并不是unordered_map中元素的插入顺序，由于unordered_map<mark>没有保证</mark>元素的插入顺序，遍历顺序为乱序，从而影响结果。这是因为 <code>std::unordered_map</code> 使用哈希表实现，元素的存储位置是根据哈希值计算得到的，而不是按照插入顺序或其他特定顺序。</p><p>在每次循环迭代中，<code>auto&amp; [_, pos]</code> 将容器中的键值对解构为两个变量 <code>_</code> 和 <code>pos</code>。这里使用 <code>_</code> 表示<u>不需要使用</u>的变量，而 <code>pos</code> 则表示容器中的值。</p><p>这两个for循环等价：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span>&amp; [_,strArray]:mp)&#123;</span><br><span class="line">    res.<span class="built_in">emplace_back</span>(strArray);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> it = mp.<span class="built_in">begin</span>(); it != mp.<span class="built_in">end</span>(); ++it) &#123;</span><br><span class="line">     res.<span class="built_in">emplace_back</span>(it-&gt;second);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//注：unordered_map&lt;string, vector&lt;string&gt;&gt; mp;</span></span><br><span class="line"><span class="comment">//vector&lt;vector&lt;string&gt;&gt; res;详细可见49题</span></span><br></pre></td></tr></table></figure><p>哈希表中的每个元素的类型为pair</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">unordered_map&lt;<span class="type">char</span>, <span class="type">int</span>&gt; mp;</span><br><span class="line">vector&lt;pair&lt;<span class="type">char</span>, <span class="type">int</span>&gt;&gt; cnt;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span>&amp; it : mp) &#123; <span class="comment">// it的类型是pair&lt;char,int&gt;</span></span><br><span class="line">     cnt.<span class="built_in">emplace_back</span>(it);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>自定义比较方法(这里second值大的排在前面)</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sort</span>(cnt.<span class="built_in">begin</span>(), cnt.<span class="built_in">end</span>(),</span><br><span class="line">     [](<span class="type">const</span> pair&lt;<span class="type">char</span>, <span class="type">int</span>&gt;&amp; a, <span class="type">const</span> pair&lt;<span class="type">char</span>, <span class="type">int</span>&gt;&amp; b) &#123;</span><br><span class="line">         <span class="keyword">return</span> a.second &gt; b.second;</span><br><span class="line">     &#125;);</span><br></pre></td></tr></table></figure><hr><h2 id="5-2-字符串找不同：389、242"><a href="#5-2-字符串找不同：389、242" class="headerlink" title="5-2.字符串找不同：389、242"></a>5-2.字符串找不同：389、242</h2><p>一、计数：首先遍历字符串 s，对其中的每个字符都将计数值加 1；然后遍历字符串 t，对其中的每个字符都将计数值减 1。也可以使用哈希表，但法一空间复杂度较高。(如果是Unicode字符就老老实实用这种方法)</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">char</span> <span class="title">findTheDifference</span><span class="params">(string s, string t)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = t.<span class="built_in">size</span>(), n1 = s.<span class="built_in">size</span>();</span><br><span class="line">        unordered_map&lt;<span class="type">char</span>, <span class="type">int</span>&gt; count;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n1; i++) &#123;</span><br><span class="line">            count[t[i]]++;</span><br><span class="line">            count[s[i]]--;</span><br><span class="line">        &#125;</span><br><span class="line">        count[t[n - <span class="number">1</span>]]++;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; [pos, cnt] : count) &#123;<span class="comment">//pos是key,cnt是值。都用到了不能写为_</span></span><br><span class="line">            <span class="keyword">if</span> (cnt != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> pos;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>二、求和:将字符串 s 中每个字符的 ASCII 码的值求和，得到 $A_s$​；对字符串 t 同样的方法得到 $A_t$。两者的差值 $A_t-A_s$​ 即代表了被添加的字符。</p><p>三、<mark>位运算</mark>:将两个字符串拼接成一个字符串，则问题转换成求字符串中出现<u>奇数次</u>的字符。(136题也是位运算，用到了异或<code>^</code>)</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">char</span> <span class="title">findTheDifference</span><span class="params">(string s, string t)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> ret = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">char</span> ch: s) &#123;</span><br><span class="line">            ret ^= ch;<span class="comment">//异或运算时ch会先被转换成ASCII码(此处为int型)</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">char</span> ch: t) &#123;</span><br><span class="line">            ret ^= ch;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>因为在s和t之中都出现的ch,在异或运算之后变成了0，相当于<code>ret^s[0]^s[1]...^t[0]^t[1]...=0^(s[0]^t[0])^(s[1]^t[1])^...^t[more]=0^0^0^...^0^t[more]=t[more].</code></p><p>(这里假设s[0]==t[0],s[1]==t[1]…)</p><p>容器角度一般的优化思路。完整的是多容器-&gt;多次新建容器-&gt;单容器-&gt;数组-&gt;二进制位。</p><h2 id="5-3-字母异位词分组：49"><a href="#5-3-字母异位词分组：49" class="headerlink" title="5-3.字母异位词分组：49"></a>5-3.字母异位词分组：49</h2><p>法一：排序(由于互为字母异位词的两个字符串包含的字母相同，因此对两个字符串分别进行排序之后得到的字符串一定是相同的，故可以将<strong>排序之后的字符串作为哈希表的键</strong>。)可以不用sort()来排序以节省时间开销，但是可能增加空间开销。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;string&gt;&gt; <span class="built_in">groupAnagrams</span>(vector&lt;string&gt;&amp; strs) &#123;</span><br><span class="line">        unordered_map&lt;string, vector&lt;string&gt;&gt; mp;</span><br><span class="line">        <span class="keyword">for</span> (string&amp; str : strs) &#123;</span><br><span class="line">            string key = str;</span><br><span class="line">            <span class="built_in">sort</span>(key.<span class="built_in">begin</span>(), key.<span class="built_in">end</span>());</span><br><span class="line">            mp[key].<span class="built_in">emplace_back</span>(str);</span><br><span class="line">        &#125;</span><br><span class="line">        vector&lt;vector&lt;string&gt;&gt; res;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> it = mp.<span class="built_in">begin</span>(); it != mp.<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line">            res.<span class="built_in">emplace_back</span>(it-&gt;second);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>法二：计数(将每个字母出现的次数使用字符串表示，作为哈希表的键。时间复杂度更低，空间复杂度更高)</p><h2 id="5-4-根据字符串出现频率排序：451"><a href="#5-4-根据字符串出现频率排序：451" class="headerlink" title="5-4.根据字符串出现频率排序：451"></a>5-4.根据字符串出现频率排序：451</h2><p>桶排序：速度比sort()快</p><p>1.遍历字符串，统计每个字符出现的频率，同时记录最高频率 maxFreq；</p><p>2.创建桶，存储从 1 到 maxFreq 的每个出现频率的字符；</p><p>3.按照出现频率从大到小的顺序遍历桶，对于每个出现频率，获得对应的字符，然后将每个字符按照出现频率拼接到排序后的字符串。</p><h2 id="5-5-求连续递增子串的个数，并去重：467"><a href="#5-5-求连续递增子串的个数，并去重：467" class="headerlink" title="5-5.求连续递增子串的个数，并去重：467"></a>5-5.求连续递增子串的个数，并去重：467</h2><p>动态规划</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findSubstringInWraproundString</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> k = <span class="number">0</span>;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(<span class="number">26</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">length</span>(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i &amp;&amp; (s[i] - s[i - <span class="number">1</span>] + <span class="number">26</span>) % <span class="number">26</span> == <span class="number">1</span>) &#123; <span class="comment">// s[i-1]在s[i]前面</span></span><br><span class="line">                k++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                k = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            dp[s[i] - <span class="string">&#x27;a&#x27;</span>] = <span class="built_in">max</span>(dp[s[i] - <span class="string">&#x27;a&#x27;</span>], k);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">accumulate</span>(dp.<span class="built_in">begin</span>(), dp.<span class="built_in">end</span>(), <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="5-6-URL的解密与加密：535"><a href="#5-6-URL的解密与加密：535" class="headerlink" title="5-6.URL的解密与加密：535"></a>5-6.URL的解密与加密：535</h2><p>如果想要实现相同的 URL 加密成同一个 TinyURL，则额外保存一个从 URL到 TinyURL 的映射。</p><p>注：int-&gt;string:<code>to_string(intVar);</code></p><p>string-&gt;int:<code>stoi(stringVar);</code></p><h3 id="关于随机数"><a href="#关于随机数" class="headerlink" title="关于随机数"></a>关于随机数</h3><p><code>time(0)</code>函数返回当前的系统时间（从某一时刻开始的秒数），而<code>srand</code>函数是用来设置随机数生成器的种子。将<code>time(0)</code>的返回值传递给<code>srand</code>函数，可以使用当前时间作为随机数生成器的种子，从而使得每次程序运行时生成的随机数序列都不同。</p><p>在C++中，通常在使用随机数生成函数<code>rand</code>之前，会调用<code>srand(time(0))</code>来<u>初始化随机数生成器</u>。这样可以确保每次程序运行时都会生成不同的随机数序列，因为种子不同会导致不同的随机数序列。之后就可以使用<code>randomNumber=rand();</code></p>]]></content>
    
    
    <summary type="html">字符串基础部分</summary>
    
    
    
    <category term="leetcode刷题笔记" scheme="https://sumikiru.top/categories/leetcode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="C++" scheme="https://sumikiru.top/tags/C/"/>
    
    <category term="leetcode" scheme="https://sumikiru.top/tags/leetcode/"/>
    
    <category term="string" scheme="https://sumikiru.top/tags/string/"/>
    
  </entry>
  
  <entry>
    <title>1.数组篇</title>
    <link href="https://sumikiru.top/posts/254d58d4.html"/>
    <id>https://sumikiru.top/posts/254d58d4.html</id>
    <published>2024-04-05T18:47:50.000Z</published>
    <updated>2025-02-06T14:42:00.323Z</updated>
    
    <content type="html"><![CDATA[<p>数组的遍历:414</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">thirdMax</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//sort(nums.begin(),nums.end(),greater&lt;&gt;());//从大到小排序</span></span><br><span class="line">        <span class="comment">//使用了set就没有必要sort()，排序需要 O(nlog⁡n)的时间</span></span><br><span class="line">        set&lt;<span class="type">int</span>&gt;s;<span class="comment">//set会自动从小到大排序（默认时）,一个元素只能出现一次</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> num:nums)&#123;</span><br><span class="line">            s.<span class="built_in">insert</span>(num);<span class="comment">//set自动去重</span></span><br><span class="line">            <span class="keyword">if</span>(s.<span class="built_in">size</span>()&gt;<span class="number">3</span>)&#123;</span><br><span class="line">                s.<span class="built_in">erase</span>(s.<span class="built_in">begin</span>());<span class="comment">//注意s.begin()是迭代器类型</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s.<span class="built_in">size</span>()==<span class="number">3</span>?*s.<span class="built_in">begin</span>():*s.<span class="built_in">rbegin</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>统计数组中的元素：645(哈希表解法)。关键思想:<strong>原地哈希</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">findErrorNums</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt;<span class="built_in">res</span>(<span class="number">2</span>);</span><br><span class="line">        unordered_map&lt;<span class="type">int</span>,<span class="type">int</span>&gt;mp;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; num:nums)&#123;    <span class="comment">//需要利用迭代器进行遍历</span></span><br><span class="line">            mp[num]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=nums.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            <span class="type">int</span> count=mp[i];</span><br><span class="line">            <span class="keyword">if</span>(count==<span class="number">2</span>)&#123;</span><br><span class="line">                res[<span class="number">0</span>]=i;<span class="comment">//重复的数字</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(count==<span class="number">0</span>)&#123;</span><br><span class="line">                res[<span class="number">1</span>]=i;<span class="comment">//缺失的数字</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>难题：41</p><p>二分搜索：274</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">hIndex</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; citations)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//双指针，二分搜索</span></span><br><span class="line">        <span class="type">int</span> left = <span class="number">0</span>, right = citations.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> mid = <span class="number">0</span>, count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">            mid = (left + right + <span class="number">1</span>) / <span class="number">2</span>;<span class="comment">//加1防止死循环</span></span><br><span class="line">            count = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; citations.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (citations[i] &gt;= mid) &#123;</span><br><span class="line">                    count++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (count &gt;= mid) &#123;</span><br><span class="line">                left = mid;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                right = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>类似min的函数：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> minNum = *<span class="built_in">min_element</span>(nums.<span class="built_in">begin</span>(),nums.<span class="built_in">end</span>());</span><br></pre></td></tr></table></figure><p>扫描：419</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">countBattleships</span><span class="params">(vector&lt;vector&lt;<span class="type">char</span>&gt;&gt;&amp; board)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> row = board.<span class="built_in">size</span>(), col = board[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; row; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; col; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (board[i][j] == <span class="string">&#x27;X&#x27;</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> ((i &gt;= <span class="number">1</span> &amp;&amp; board[i - <span class="number">1</span>][j] == <span class="string">&#x27;X&#x27;</span>) ||</span><br><span class="line">                        (j &gt;= <span class="number">1</span> &amp;&amp; board[i][j - <span class="number">1</span>] == <span class="string">&#x27;X&#x27;</span>)) &#123;</span><br><span class="line">                        <span class="comment">//如果发现其上方或者左边有过X,则继续向右下扫描</span></span><br><span class="line">                        <span class="comment">//此时res不增加，直接continue进入下一次循环</span></span><br><span class="line">                        <span class="comment">//直到确实走到尽头才会结束，然后计数+1</span></span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    res++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>迭代：396</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;climits&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;numeric&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxRotateFunction</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">size</span>(), res = INT_MIN, Fk = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> sum = <span class="built_in">accumulate</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>(), <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            Fk += i * nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        res = Fk; <span class="comment">//也就是让res=F(0)，避免nums只有一个元素时return INT_MIN</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = n - <span class="number">1</span>; i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">            Fk += sum - n * nums[i];</span><br><span class="line">            res = <span class="built_in">max</span>(res, Fk);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>模拟：54、59</p><p>对角线遍历498：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m + n - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i % <span class="number">2</span>) &#123;</span><br><span class="line">                <span class="type">int</span> x = (i &lt; n ? <span class="number">0</span> : i - n + <span class="number">1</span>);</span><br><span class="line">                <span class="type">int</span> y = (i &lt; n ? i : n - <span class="number">1</span>);</span><br><span class="line">                <span class="keyword">while</span> (x &lt; m &amp;&amp; y &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                    res.<span class="built_in">emplace_back</span>(mat[x][y]);</span><br><span class="line">                    x++;</span><br><span class="line">                    y--; </span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="type">int</span> x = (i &lt; m ? i : m - <span class="number">1</span>);</span><br><span class="line">                <span class="type">int</span> y = (i &lt; m ? <span class="number">0</span> : i - m + <span class="number">1</span>);</span><br><span class="line">                <span class="keyword">while</span> (x &gt;= <span class="number">0</span> &amp;&amp; y &lt; n) &#123;</span><br><span class="line">                    res.<span class="built_in">emplace_back</span>(mat[x][y]);</span><br><span class="line">                    x--;</span><br><span class="line">                    y++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在选择使用 <code>emplace_back</code> 还是 <code>push_back</code> 时，通常情况下，<code>emplace_back</code> 更好一些。这是因为 <code>emplace_back</code> 可以避免创建临时对象，从而提高了性能。</p><p>另外，<code>emplace_back</code> 也更加灵活，因为它允许你直接传递构造元素所需的参数，而不需要显式地创建对象。</p><p>总的来说，如果你需要向 <code>vector</code> 中添加新元素，通常情况下优先考虑使用 <code>emplace_back</code>。</p><p>二维数组变换行列长宽：566</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> m = mat.<span class="built_in">size</span>(), n = mat[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m * n; i++) &#123;</span><br><span class="line">     res[i / c][i % c] =mat[i / n][i % n]; </span><br><span class="line">     <span class="comment">//找到第i个数到底分别在数组的哪个位置</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>二维矩阵顺时针旋转（48）=<code>水平</code>翻转(竖直线对称翻转)+(沿)<code>主对角</code>线翻转</p><p><u>矩阵原地置换(73)</u>：用矩阵第一行和第一列代替标记行和列的两个标记数组，使得空间复杂度为$O(1)$，时间复杂度为$O(row*col)$.但这样会导致原数组的第一行和第一列被修改，无法记录它们是否原本包含 0。因此我们需要额外使用两个标记变量分别记录第一行和第一列是否原本包含 0。</p><p>   在实际代码中，我们首先预处理出两个标记变量，接着使用其他行与列去处理第一行与第一列，然后反过来使用第一行与第一列去更新其他行与列，最后使用两个标记变量更新第一行与第一列即可。</p><pre><code>我们可以对方法二进一步优化，只使用一个标记变量记录第一列是否原本存在 0。这样，第一列的第一个元素即可以标记第一行是否出现 0。但为了防止每一列的第一个元素被提前更新，我们需要从最后一行开始，倒序地处理矩阵元素。</code></pre><p><u>矩阵原地置换拓展(289)</u>：创建复合状态2，可以知道修改前是0，而之后变为1.常用于需要同步更新情况。</p><p>涉及到类：303</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">NumArray</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; sum;</span><br><span class="line">    <span class="built_in">NumArray</span>(vector&lt;<span class="type">int</span>&gt;&amp; nums) &#123; <span class="comment">//初始化sum数组</span></span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        sum.<span class="built_in">resize</span>(n + <span class="number">1</span>); <span class="comment">//注意</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            sum[i + <span class="number">1</span>] = sum[i] + nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">sumRange</span><span class="params">(<span class="type">int</span> left, <span class="type">int</span> right)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//错误：nums是临时数组，应该用sum</span></span><br><span class="line">        <span class="comment">// return accumulate(nums.begin() + left, nums.begin() + right, 0);</span></span><br><span class="line">        <span class="keyword">return</span> sum[right + <span class="number">1</span>] - sum[left];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>二维数组resize:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sums.<span class="built_in">resize</span>(m + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n + <span class="number">1</span>));</span><br></pre></td></tr></table></figure><p>二维数组定义：(创建n×n的数组，默认初始化所有元素为0)</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">res</span>(n, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n));</span><br></pre></td></tr></table></figure><p>前缀/后缀之和/之积：238</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">productExceptSelf</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">res</span><span class="params">(nums.size())</span></span>;</span><br><span class="line">        res[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; nums.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            res[i]=res[i<span class="number">-1</span>]*nums[i<span class="number">-1</span>];<span class="comment">//先用res存储前缀之积</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> r=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=nums.<span class="built_in">size</span>()<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">            res[i]=res[i]*r;<span class="comment">//更新res,res[i]最终应为nums[i]的前缀之积×后缀之积</span></span><br><span class="line">            r*=nums[i];<span class="comment">//用R存储当前对应元素的后缀之积</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">数组的常见用法与实战</summary>
    
    
    
    <category term="leetcode刷题笔记" scheme="https://sumikiru.top/categories/leetcode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="C++" scheme="https://sumikiru.top/tags/C/"/>
    
    <category term="leetcode" scheme="https://sumikiru.top/tags/leetcode/"/>
    
    <category term="数组" scheme="https://sumikiru.top/tags/%E6%95%B0%E7%BB%84/"/>
    
  </entry>
  
  <entry>
    <title>0.常用的C++ STL用法</title>
    <link href="https://sumikiru.top/posts/123456.html"/>
    <id>https://sumikiru.top/posts/123456.html</id>
    <published>2024-04-05T14:37:04.000Z</published>
    <updated>2025-02-06T14:42:00.323Z</updated>
    
    <content type="html"><![CDATA[<p>转载自github.</p><p><strong>C++ 标准模板库 (STL, Standard Template Library)</strong>：包含一些常用数据结构与算法的模板的 C++ 软件库。其包含四个组件——算法 (Algorithms)、容器 (Containers)、仿函数 (Functors)、迭代器 (Iterators).</p><span id="more"></span><p>示例：</p><ul><li>算法：<code>sort(a.begin(), a.end())</code></li><li>容器：<code>priority_queue&lt;int&gt; pque</code></li><li>仿函数：<code>greater&lt;int&gt;()</code></li><li>迭代器：<code>vector&lt;int&gt;::iterator it = a.begin()</code></li></ul><h1 id="1-前言"><a href="#1-前言" class="headerlink" title="1 前言"></a>1 前言</h1><p>STL 作为一个封装良好，性能合格的 C++ 标准库，在算法竞赛中运用极其常见。灵活且正确使用 STL 可以节省非常多解题时间，这一点不仅是由于可以直接调用，还是因为它封装良好，可以让代码的可读性变高，解题思路更清晰，调试过程 <del>往往</del> 更顺利。</p><p>不过 STL 毕竟使用了很多复杂的结构来实现丰富的功能，它的效率往往是比不上自己手搓针对特定题目的数据结构与算法的。因此，STL 的使用相当于使用更长的运行时间换取更高的编程效率。因此，在实际比赛中要权衡 STL 的利弊，不过这一点就得靠经验了。</p><p>接下来，我会分享在算法竞赛中常用的 STL 容器和算法，对于函数和迭代器，就不着重展开讲了。</p><h1 id="2-常用容器"><a href="#2-常用容器" class="headerlink" title="2 常用容器"></a>2 常用容器</h1><h2 id="2-1-内容总览"><a href="#2-1-内容总览" class="headerlink" title="2.1 内容总览"></a>2.1 内容总览</h2><p>打勾的是本次将会详细讲解的，加粗的是算法竞赛中有必要学习的。</p><ul><li><p>顺序容器</p><ul><li><p>[ ] <strong>array</strong></p></li><li><p>[x] <strong>vector</strong></p></li><li><p>[ ] <strong>deque</strong></p></li><li><p>[ ] forward_list</p></li><li><p>[ ] <strong>list</strong></p></li></ul></li><li><p>关联容器</p><ul><li>[x] <strong>set</strong></li><li>[x] <strong>map</strong></li><li>[ ] <strong>multiset</strong></li><li>[ ] <strong>multimap</strong></li></ul></li><li><p>无序关联容器</p><ul><li>[ ] <strong>unordered_set</strong></li><li>[ ] <strong>unordered_map</strong></li><li>[ ] <strong>unordered_multiset</strong></li><li>[ ] <strong>unordered_multimap</strong></li></ul></li><li><p>容器适配器</p><ul><li>[x] <strong>stack</strong></li><li>[x] <strong>queue</strong></li><li>[x] <strong>priority_queue</strong></li><li>[ ] flat_set</li><li>[ ] flat_map</li><li>[ ] flat_multiset</li><li>[ ] flat_multimap</li></ul></li><li><p>字符串</p><ul><li>[x] <strong>string</strong> (basic_string\<char\>)</li></ul></li><li><p>对与元组</p><ul><li>[x] <strong>pair</strong></li><li>[ ] <strong>tuple</strong></li></ul></li></ul><h2 id="2-2-向量-vector"><a href="#2-2-向量-vector" class="headerlink" title="2.2 向量 vector"></a>2.2 向量 <a href="https://zh.cppreference.com/w/cpp/container/vector">vector</a></h2><p><strong><code>#include &lt;vector&gt;</code></strong></p><p>连续的顺序的储存结构（和数组一样的类别），但是有长度可变的特性。</p><h3 id="2-2-1-常用方法"><a href="#2-2-1-常用方法" class="headerlink" title="2.2.1 常用方法"></a>2.2.1 常用方法</h3><h4 id="构造"><a href="#构造" class="headerlink" title="构造"></a>构造</h4><p><strong><code>vector&lt;类型&gt; arr(长度, [初值])</code></strong></p><p>时间复杂度：$O(n)$</p><p>常用的一维和二维数组构造示例，高维也是一样的（就是会有点长）.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; arr;         <span class="comment">// 构造int数组</span></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">arr</span><span class="params">(<span class="number">100</span>)</span></span>;    <span class="comment">// 构造初始长100的int数组</span></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">arr</span><span class="params">(<span class="number">100</span>, <span class="number">1</span>)</span></span>; <span class="comment">// 构造初始长100的int数组，初值为1</span></span><br><span class="line"></span><br><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">mat</span>(<span class="number">100</span>, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt; ());       <span class="comment">// 构造初始100行，不指定列数的二维数组</span></span><br><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">mat</span>(<span class="number">100</span>, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt; (<span class="number">666</span>, <span class="number">-1</span>)) <span class="comment">// 构造初始100行，初始666列的二维数组，初值为-1</span></span><br></pre></td></tr></table></figure><p>构造二维数组的奇葩写法，千万别用：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; arr[<span class="number">100</span>];         <span class="comment">// 正确，构造初始100行，不指定列数的二维数组，可用于链式前向星存图</span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; arr[<span class="number">100</span>](<span class="number">100</span>, <span class="number">1</span>); <span class="comment">// 语法错误！</span></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">arr</span><span class="params">(<span class="number">100</span>, <span class="number">1</span>)</span>[100]</span>; <span class="comment">// 语法错误！</span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; arr[<span class="number">100</span>] &#123;&#123;<span class="number">100</span>, <span class="number">1</span>&#125;, 这里省略<span class="number">98</span>个 ,&#123;<span class="number">100</span>, <span class="number">1</span>&#125;&#125;; <span class="comment">// 正确但奇葩，使用列表初始化</span></span><br></pre></td></tr></table></figure><h4 id="尾接-amp-尾删"><a href="#尾接-amp-尾删" class="headerlink" title="尾接 &amp; 尾删"></a>尾接 &amp; 尾删</h4><ul><li><strong><code>.push_back(元素)</code></strong>：在 vector 尾接一个元素，数组长度 $+1$.</li><li><strong><code>.pop_back()</code></strong>：删除 vector 尾部的一个元素，数组长度 $-1$</li></ul><p>时间复杂度：均摊 $O(1)$</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// init: arr = []</span></span><br><span class="line">arr.<span class="built_in">push_back</span>(<span class="number">1</span>);</span><br><span class="line"><span class="comment">// after: arr = [1]</span></span><br><span class="line">arr.<span class="built_in">push_back</span>(<span class="number">2</span>);</span><br><span class="line"><span class="comment">// after: arr = [1, 2]</span></span><br><span class="line">arr.<span class="built_in">pop_back</span>();</span><br><span class="line"><span class="comment">// after: arr = [1]</span></span><br><span class="line">arr.<span class="built_in">pop_back</span>();</span><br><span class="line"><span class="comment">// after: arr = []</span></span><br></pre></td></tr></table></figure><h4 id="中括号运算符"><a href="#中括号运算符" class="headerlink" title="中括号运算符"></a>中括号运算符</h4><p>和一般数组一样的作用</p><p>时间复杂度：$O(1)$</p><h4 id="获取长度"><a href="#获取长度" class="headerlink" title="获取长度"></a>获取长度</h4><p><strong><code>.size()</code></strong></p><p>获取当前 vector 的长度</p><p>时间复杂度：$O(1)$</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; arr.<span class="built_in">size</span>(); i++)</span><br><span class="line">    cout &lt;&lt; a[i] &lt;&lt; endl;</span><br></pre></td></tr></table></figure><h4 id="清空"><a href="#清空" class="headerlink" title="清空"></a>清空</h4><p><strong><code>.clear()</code></strong></p><p>清空 vector</p><p>时间复杂度：$O(n)$</p><h4 id="判空"><a href="#判空" class="headerlink" title="判空"></a>判空</h4><p><strong><code>.empty()</code></strong></p><p>如果是空返回 <code>true</code> 反之返回 <code>false</code>.</p><p>时间复杂度：$O(1)$</p><h4 id="改变长度"><a href="#改变长度" class="headerlink" title="改变长度"></a>改变长度</h4><p><strong><code>.resize(新长度, [默认值])</code></strong></p><p>修改 vector 的长度</p><ul><li>如果是缩短，则删除多余的值</li><li>如果是扩大，且指定了默认值，则新元素均为默认值<strong>（旧元素不变）</strong></li></ul><p>时间复杂度：$O(n)$</p><h3 id="2-2-2-适用情形"><a href="#2-2-2-适用情形" class="headerlink" title="2.2.2 适用情形"></a>2.2.2 适用情形</h3><p>一般情况 <code>vector</code> 可以替换掉普通数组，除非该题卡常。</p><p>有些情况普通数组没法解决：$n\times m$ 的矩阵，$1\leq n,m\leq 10^6$ 且 $n\times m \leq 10^6$</p><ul><li>如果用普通数组 <code>int mat[1000010][1000010]</code>，浪费内存，会导致 MLE。</li><li>如果使用 <code>vector&lt;vector&lt;int&gt;&gt; mat(n + 10, vector&lt;int&gt; (m + 10))</code>，完美解决该问题。</li></ul><p>另外，<code>vector</code> 的数据储存在堆空间中，不会爆栈。</p><h3 id="2-2-3-注意事项"><a href="#2-2-3-注意事项" class="headerlink" title="2.2.3 注意事项"></a>2.2.3 注意事项</h3><h4 id="提前指定长度"><a href="#提前指定长度" class="headerlink" title="提前指定长度"></a>提前指定长度</h4><p>如果长度已经确定，那么应当直接在构造函数指定长度，而不是一个一个 <code>.push_back()</code>. 因为 <code>vector</code> 额外内存耗尽后的重分配是有时间开销的，直接指定长度就不会出现重分配了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 优化前: 522ms</span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; a;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1e8</span>; i++)</span><br><span class="line">    a.<span class="built_in">push_back</span>(i);</span><br><span class="line"><span class="comment">// 优化后: 259ms</span></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">a</span><span class="params">(<span class="number">1e8</span>)</span></span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; a.<span class="built_in">size</span>(); i++)</span><br><span class="line">    a[i] = i;</span><br></pre></td></tr></table></figure><h4 id="当心-size-t-溢出"><a href="#当心-size-t-溢出" class="headerlink" title="当心 size_t 溢出"></a>当心 size_t 溢出</h4><p>vector 获取长度的方法 <code>.size()</code> 返回值类型为 <code>size_t</code>，通常 OJ 平台使用的是 32 位编译器（有些平台例如 cf 可选 64 位），那么该类型范围为 $[0,2^{32})$.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">a</span><span class="params">(<span class="number">65536</span>)</span></span>;</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> a = a.<span class="built_in">size</span>() * a.<span class="built_in">size</span>(); <span class="comment">// 直接溢出变成0了</span></span><br></pre></td></tr></table></figure><h2 id="2-3-栈-stack"><a href="#2-3-栈-stack" class="headerlink" title="2.3 栈 stack"></a>2.3 栈 <a href="https://zh.cppreference.com/w/cpp/container/stack">stack</a></h2><p><strong><code>#include &lt;stack&gt;</code></strong></p><p>通过二次封装双端队列 (deque) 容器，实现先进后出的栈数据结构。</p><h3 id="2-3-1-常用方法"><a href="#2-3-1-常用方法" class="headerlink" title="2.3.1 常用方法"></a>2.3.1 常用方法</h3><div class="table-container"><table><thead><tr><th>作用</th><th>用法</th><th>示例</th></tr></thead><tbody><tr><td>构造</td><td><code>stack&lt;类型&gt; stk</code></td><td><code>stack&lt;int&gt; stk;</code></td></tr><tr><td>进栈</td><td><code>.push(元素)</code></td><td><code>stk.push(1);</code></td></tr><tr><td>出栈</td><td><code>.pop()</code></td><td><code>stk.pop();</code></td></tr><tr><td>取栈顶</td><td><code>.top()</code></td><td><code>int a = stk.top();</code></td></tr><tr><td>查看大小 / 清空 / 判空</td><td>略</td><td>略</td></tr></tbody></table></div><h3 id="2-3-2-适用情形"><a href="#2-3-2-适用情形" class="headerlink" title="2.3.2 适用情形"></a>2.3.2 适用情形</h3><p>如果不卡常的话，就可以直接用它而不需要手写栈了。</p><p>另外，vector 也可以当栈用，vector 的 <code>.back()</code> 取尾部元素，就相当于取栈顶，<code>.push_back()</code> 相当于进栈，<code>.pop_back()</code> 相当于出栈。</p><h3 id="2-3-3-注意事项"><a href="#2-3-3-注意事项" class="headerlink" title="2.3.3 注意事项"></a>2.3.3 注意事项</h3><p>不可访问内部元素！<strong>下面都是错误用法</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; stk.<span class="built_in">size</span>(); i++)</span><br><span class="line">    cout &lt;&lt; stk[i] &lt;&lt; endl;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> ele : stk)</span><br><span class="line">    cout &lt;&lt; stk &lt;&lt; endl;</span><br></pre></td></tr></table></figure><h2 id="2-4-队列-queue"><a href="#2-4-队列-queue" class="headerlink" title="2.4 队列 queue"></a>2.4 队列 <a href="https://zh.cppreference.com/w/cpp/container/queue">queue</a></h2><p><strong><code>#include &lt;queue&gt;</code></strong></p><p>通过二次封装双端队列 (deque) 容器，实现先进先出的队列数据结构。</p><h3 id="2-4-1-常用方法"><a href="#2-4-1-常用方法" class="headerlink" title="2.4.1 常用方法"></a>2.4.1 常用方法</h3><div class="table-container"><table><thead><tr><th>作用</th><th>用法</th><th>示例</th></tr></thead><tbody><tr><td>构造</td><td><code>queue&lt;类型&gt; que</code></td><td><code>queue&lt;int&gt; que;</code></td></tr><tr><td>进队</td><td><code>.push(元素)</code></td><td><code>que.push(1);</code></td></tr><tr><td>出队</td><td><code>.pop()</code></td><td><code>que.pop();</code></td></tr><tr><td>取队首</td><td><code>.front()</code></td><td><code>int a = que.front();</code></td></tr><tr><td>取队尾</td><td><code>.back()</code></td><td><code>int a = que.back();</code></td></tr><tr><td>查看大小 / 清空 / 判空</td><td>略</td><td>略</td></tr></tbody></table></div><h3 id="2-4-2-适用情形"><a href="#2-4-2-适用情形" class="headerlink" title="2.4.2 适用情形"></a>2.4.2 适用情形</h3><p>如果不卡常的话，就可以直接用它而不需要手写队列了。</p><h3 id="2-4-3-注意事项"><a href="#2-4-3-注意事项" class="headerlink" title="2.4.3 注意事项"></a>2.4.3 注意事项</h3><p>不可访问内部元素！<strong>下面都是错误用法</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; que.<span class="built_in">size</span>(); i++)</span><br><span class="line">    cout &lt;&lt; que[i] &lt;&lt; endl;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> ele : que)</span><br><span class="line">    cout &lt;&lt; ele &lt;&lt; endl;</span><br></pre></td></tr></table></figure><h2 id="2-5-优先队列-priority-queue"><a href="#2-5-优先队列-priority-queue" class="headerlink" title="2.5 优先队列 priority_queue"></a>2.5 优先队列 <a href="https://zh.cppreference.com/w/cpp/container/priority_queue">priority_queue</a></h2><p><strong><code>#include &lt;queue&gt;</code></strong></p><p>提供常数时间的最大元素查找，对数时间的插入与提取，底层原理是二叉堆。</p><h3 id="2-5-1-常用方法"><a href="#2-5-1-常用方法" class="headerlink" title="2.5.1 常用方法"></a>2.5.1 常用方法</h3><h4 id="构造-1"><a href="#构造-1" class="headerlink" title="构造"></a>构造</h4><p><strong><code>priority_queue&lt;类型, 容器, 比较器&gt; pque</code></strong></p><ul><li>类型：要储存的数据类型</li><li>容器：储存数据的底层容器，默认为 <code>vector&lt;类型&gt;</code>，竞赛中保持默认即可</li><li>比较器：比较大小使用的比较器，默认为 <code>less&lt;类型&gt;</code>，可自定义</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">priority_queue&lt;<span class="type">int</span>&gt; pque1;                            <span class="comment">// 储存int的大顶堆</span></span><br><span class="line">priority_queue&lt;<span class="type">int</span>, vector&lt;<span class="type">int</span>&gt;, greater&lt;<span class="type">int</span>&gt;&gt; pque2; <span class="comment">// 储存int的小顶堆</span></span><br></pre></td></tr></table></figure><blockquote><p>对于需要自定义比较器的情况，涉及一些初学时容易看迷糊的语法（重载小括号运算符 / lambda 表达式），在此就不展开讲了。如果想要了解，可以查阅 cppreference 中的代码示例。</p></blockquote><h4 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h4><div class="table-container"><table><thead><tr><th>作用</th><th>用法</th><th>示例</th></tr></thead><tbody><tr><td>进堆</td><td><code>.push(元素)</code></td><td><code>que.push(1);</code></td></tr><tr><td>出堆</td><td><code>.pop()</code></td><td><code>que.pop();</code></td></tr><tr><td>取堆顶</td><td><code>.top()</code></td><td><code>int a = que.top();</code></td></tr><tr><td>查看大小 / 判空</td><td>略</td><td>略</td></tr></tbody></table></div><p>进出队复杂度 $O(\log n)$，取堆顶 $O(1)$.</p><h3 id="2-5-2-适用情形"><a href="#2-5-2-适用情形" class="headerlink" title="2.5.2 适用情形"></a>2.5.2 适用情形</h3><p>持续维护元素的有序性：每次向队列插入大小不定的元素，或者每次从队列里取出大小最小/最大的元素，元素数量 $n$，插入操作数量 $k$.</p><ul><li>每次插入后进行快速排序：$k\cdot n\log n$</li><li>使用优先队列维护：$k\cdot\log n$</li></ul><h3 id="2-5-3-注意事项"><a href="#2-5-3-注意事项" class="headerlink" title="2.5.3 注意事项"></a>2.5.3 注意事项</h3><h4 id="仅堆顶可读"><a href="#仅堆顶可读" class="headerlink" title="仅堆顶可读"></a>仅堆顶可读</h4><p>只可访问堆顶，其他元素都无法读取到。<strong>下面是错误用法：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cout &lt;&lt; pque[<span class="number">1</span>] &lt;&lt; endl;</span><br></pre></td></tr></table></figure><h4 id="所有元素不可写"><a href="#所有元素不可写" class="headerlink" title="所有元素不可写"></a>所有元素不可写</h4><p>堆中所有元素是不可修改的。<strong>下面是错误用法：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pque[<span class="number">1</span>] = <span class="number">2</span>;</span><br><span class="line">pque.<span class="built_in">top</span>() = <span class="number">1</span>;</span><br></pre></td></tr></table></figure><p>如果你恰好要修改的是堆顶元素，那么是可以完成的：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> tp = pque.<span class="built_in">top</span>();</span><br><span class="line">pque.<span class="built_in">pop</span>();</span><br><span class="line">pque.<span class="built_in">push</span>(tp + <span class="number">1</span>);</span><br></pre></td></tr></table></figure><h2 id="2-6-集合-set"><a href="#2-6-集合-set" class="headerlink" title="2.6 集合 set"></a>2.6 集合 <a href="https://zh.cppreference.com/w/cpp/container/set">set</a></h2><p><strong><code>#include &lt;set&gt;</code></strong></p><p>提供对数时间的插入、删除、查找的集合数据结构。底层原理是红黑树。</p><div class="table-container"><table><thead><tr><th>集合三要素</th><th>解释</th><th>set</th><th>multiset</th><th>unordered_set</th></tr></thead><tbody><tr><td>确定性</td><td>一个元素要么在集合中，要么不在</td><td>✔</td><td>✔</td><td>✔</td></tr><tr><td>互异性</td><td>一个元素仅可以在集合中出现一次</td><td>✔</td><td>❌（任意次）</td><td>✔</td></tr><tr><td>无序性</td><td>集合中的元素是没有顺序的</td><td>❌（从小到大）</td><td>❌（从小到大）</td><td>✔</td></tr></tbody></table></div><h3 id="2-6-1-常用方法"><a href="#2-6-1-常用方法" class="headerlink" title="2.6.1 常用方法"></a>2.6.1 常用方法</h3><h4 id="构造-2"><a href="#构造-2" class="headerlink" title="构造"></a>构造</h4><p><strong><code>set&lt;类型, 比较器&gt; st</code></strong></p><ul><li>类型：要储存的数据类型</li><li>比较器：比较大小使用的比较器，默认为 <code>less&lt;类型&gt;</code>，可自定义</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">set&lt;<span class="type">int</span>&gt; st1;               <span class="comment">// 储存int的集合（从小到大）</span></span><br><span class="line">set&lt;<span class="type">int</span>, greater&lt;<span class="type">int</span>&gt;&gt; st2; <span class="comment">// 储存int的集合（从大到小）</span></span><br></pre></td></tr></table></figure><blockquote><p>对于需要自定义比较器的情况，涉及一些初学时容易看迷糊的语法（重载小括号运算符 / lambda 表达式），在此就不展开讲了。</p></blockquote><h4 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h4><p>可使用迭代器进行遍历：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (set&lt;<span class="type">int</span>&gt;::iterator it = st.<span class="built_in">begin</span>(); it != st.<span class="built_in">end</span>(); ++it)</span><br><span class="line">    cout &lt;&lt; *it &lt;&lt; endl;</span><br></pre></td></tr></table></figure><p>基于范围的循环（C++ 11）：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> &amp;ele : st)</span><br><span class="line">    cout &lt;&lt; ele &lt;&lt; endl;</span><br></pre></td></tr></table></figure><h4 id="其他-1"><a href="#其他-1" class="headerlink" title="其他"></a>其他</h4><div class="table-container"><table><thead><tr><th>作用</th><th>用法</th><th>示例</th></tr></thead><tbody><tr><td>插入元素</td><td><code>.insert(元素)</code></td><td><code>st.insert(1);</code></td></tr><tr><td>删除元素</td><td><code>.erase(元素)</code></td><td><code>st.erase(2);</code></td></tr><tr><td>查找元素</td><td><code>.find(元素)</code></td><td><code>auto it = st.find(1);</code></td></tr><tr><td>判断元素是否存在</td><td><code>.count(元素)</code></td><td><code>st.count(3);</code></td></tr><tr><td>查看大小 / 清空 / 判空</td><td>略</td><td>略</td></tr></tbody></table></div><p>增删查时间复杂度均为 $O(\log n)$</p><h3 id="2-6-2-适用情形"><a href="#2-6-2-适用情形" class="headerlink" title="2.6.2 适用情形"></a>2.6.2 适用情形</h3><ul><li>元素去重：$[1,1,3,2,4,4]\to[1,2,3,4]$</li><li>维护顺序：$[1,5,3,7,9]\to[1,3,5,7,9]$</li><li>元素是否出现过：元素大小 $[-10^{18},10^{18}]$，元素数量 $10^6$，vis 数组无法实现，通过 set 可以完成。</li></ul><h3 id="2-6-3-注意事项"><a href="#2-6-3-注意事项" class="headerlink" title="2.6.3 注意事项"></a>2.6.3 注意事项</h3><h4 id="不存在下标索引"><a href="#不存在下标索引" class="headerlink" title="不存在下标索引"></a>不存在下标索引</h4><p>set 虽说可遍历，但仅可使用迭代器进行遍历，它不存在下标这一概念，无法通过下标访问到数据。<strong>下面是错误用法：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cout &lt;&lt; st[<span class="number">0</span>] &lt;&lt; endl;</span><br></pre></td></tr></table></figure><h4 id="元素只读"><a href="#元素只读" class="headerlink" title="元素只读"></a>元素只读</h4><p>set 的迭代器取到的元素是只读的（因为是 const 迭代器），不可修改其值。如果要改，需要先 erase 再 insert. <strong>下面是错误用法：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cout &lt;&lt; *st.<span class="built_in">begin</span>() &lt;&lt; endl; <span class="comment">// 正确。可读。</span></span><br><span class="line">*st.<span class="built_in">begin</span>() = <span class="number">1</span>;             <span class="comment">// 错误！不可写！</span></span><br></pre></td></tr></table></figure><h4 id="不可用迭代器计算下标"><a href="#不可用迭代器计算下标" class="headerlink" title="不可用迭代器计算下标"></a>不可用迭代器计算下标</h4><p>set 的迭代器不能像 vector 一样相减得到下标。<strong>下面是错误用法：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> it = st.<span class="built_in">find</span>(<span class="number">2</span>);      <span class="comment">// 正确，返回2所在位置的迭代器。</span></span><br><span class="line"><span class="type">int</span> idx = it - st.<span class="built_in">begin</span>(); <span class="comment">// 错误！不可相减得到下标。</span></span><br></pre></td></tr></table></figure><h2 id="2-7-映射-map"><a href="#2-7-映射-map" class="headerlink" title="2.7 映射 map"></a>2.7 映射 <a href="https://zh.cppreference.com/w/cpp/container/map">map</a></h2><p><strong><code>#include &lt;map&gt;</code></strong></p><p>提供对数时间的有序键值对结构。底层原理是红黑树。</p><p>映射：</p><script type="math/tex; mode=display">\begin{matrix}1&\to&2\\2&\to&2\\3&\to&1\\4&\to&5\\&\vdots\end{matrix}</script><div class="table-container"><table><thead><tr><th>性质</th><th>解释</th><th>map</th><th>multimap</th><th>unordered_map</th></tr></thead><tbody><tr><td>互异性</td><td>一个键仅可以在映射中出现一次</td><td>✔</td><td>❌（任意次）</td><td>✔</td></tr><tr><td>无序性</td><td>键是没有顺序的</td><td>❌（从小到大）</td><td>❌（从小到大）</td><td>✔</td></tr></tbody></table></div><h3 id="2-7-1-常用方法"><a href="#2-7-1-常用方法" class="headerlink" title="2.7.1 常用方法"></a>2.7.1 常用方法</h3><h4 id="构造-3"><a href="#构造-3" class="headerlink" title="构造"></a>构造</h4><p><strong><code>map&lt;键类型, 值类型, 比较器&gt; mp</code></strong></p><ul><li>键类型：要储存键的数据类型</li><li>值类型：要储存值的数据类型</li><li>比较器：键比较大小使用的比较器，默认为 <code>less&lt;类型&gt;</code>，可自定义</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; mp1;               <span class="comment">// int-&gt;int 的映射（键从小到大）</span></span><br><span class="line">map&lt;<span class="type">int</span>, <span class="type">int</span>, greater&lt;<span class="type">int</span>&gt;&gt; st2; <span class="comment">// int-&gt;int 的映射（键从大到小）</span></span><br></pre></td></tr></table></figure><blockquote><p>对于需要自定义比较器的情况，涉及一些初学时容易看迷糊的语法（重载小括号运算符 / lambda 表达式），在此就不展开讲了。</p></blockquote><h4 id="遍历-1"><a href="#遍历-1" class="headerlink" title="遍历"></a>遍历</h4><p>可使用迭代器进行遍历：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (map&lt;<span class="type">int</span>, <span class="type">int</span>&gt;::iterator it = mp.<span class="built_in">begin</span>(); it != mp.<span class="built_in">end</span>(); ++it)</span><br><span class="line">    cout &lt;&lt; it-&gt;first &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; it-&gt;second &lt;&lt; endl;</span><br></pre></td></tr></table></figure><p>基于范围的循环（C++ 11）：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> &amp;pr : mp)</span><br><span class="line">    cout &lt;&lt; pr.first &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; pr.second &lt;&lt; endl;</span><br></pre></td></tr></table></figure><p>结构化绑定 + 基于范围的循环（C++17）：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> &amp;[key, val] : mp)</span><br><span class="line">    cout &lt;&lt; key &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; val &lt;&lt; endl;</span><br></pre></td></tr></table></figure><h4 id="其他-2"><a href="#其他-2" class="headerlink" title="其他"></a>其他</h4><div class="table-container"><table><thead><tr><th>作用</th><th>用法</th><th>示例</th></tr></thead><tbody><tr><td>增 / 改 / 查元素</td><td>中括号</td><td><code>mp[1] = 2;</code></td></tr><tr><td>查元素（返回迭代器）</td><td><code>.find(元素)</code></td><td><code>auto it = mp.find(1);</code></td></tr><tr><td>删除元素</td><td><code>.erase(元素)</code></td><td><code>mp.erase(2);</code></td></tr><tr><td>判断元素是否存在</td><td><code>.count(元素)</code></td><td><code>mp.count(3);</code></td></tr><tr><td>查看大小 / 清空 / 判空</td><td>略</td><td>略</td></tr></tbody></table></div><p>增删改查时间复杂度均为 $O(\log n)$</p><h3 id="2-7-2-适用情形"><a href="#2-7-2-适用情形" class="headerlink" title="2.7.2 适用情形"></a>2.7.2 适用情形</h3><p>需要维护映射的场景可以使用：输入若干字符串，统计每种字符串的出现次数。(<code>map&lt;string, int&gt; mp</code>)</p><h3 id="2-7-3-注意事项"><a href="#2-7-3-注意事项" class="headerlink" title="2.7.3 注意事项"></a>2.7.3 注意事项</h3><h4 id="中括号访问时默认值"><a href="#中括号访问时默认值" class="headerlink" title="中括号访问时默认值"></a>中括号访问时默认值</h4><p>如果使用中括号访问 map 时对应的键不存在，那么会新增这个键，并且值为默认值，因此中括号会影响键的存在性。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">map&lt;<span class="type">char</span>, <span class="type">int</span>&gt; mp;</span><br><span class="line">cout &lt;&lt; mp.<span class="built_in">count</span>(<span class="string">&#x27;a&#x27;</span>) &lt;&lt; endl; <span class="comment">// 0</span></span><br><span class="line">mp[<span class="string">&#x27;a&#x27;</span>];                       <span class="comment">// 即使什么都没做，此时mp[&#x27;a&#x27;]=0已经插入了</span></span><br><span class="line">cout &lt;&lt; mp.<span class="built_in">count</span>(<span class="string">&#x27;a&#x27;</span>) &lt;&lt; endl; <span class="comment">// 1</span></span><br><span class="line">cout &lt;&lt; mp[<span class="string">&#x27;a&#x27;</span>] &lt;&lt; endl;       <span class="comment">// 0</span></span><br></pre></td></tr></table></figure><h4 id="不可用迭代器计算下标-1"><a href="#不可用迭代器计算下标-1" class="headerlink" title="不可用迭代器计算下标"></a>不可用迭代器计算下标</h4><p>map 的迭代器不能像 vector 一样相减得到下标。<strong>下面是错误用法：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> it = mp.<span class="built_in">find</span>(<span class="string">&#x27;a&#x27;</span>);      <span class="comment">// 正确，返回2所在位置的迭代器。</span></span><br><span class="line"><span class="type">int</span> idx = it - mp.<span class="built_in">begin</span>();   <span class="comment">// 错误！不可相减得到下标。</span></span><br></pre></td></tr></table></figure><h2 id="2-8-字符串-string"><a href="#2-8-字符串-string" class="headerlink" title="2.8 字符串 string"></a>2.8 字符串 <a href="https://zh.cppreference.com/w/cpp/string">string</a></h2><p><strong><code>#include &lt;string&gt;</code></strong></p><p>顾名思义，就是储存字符串的。</p><h3 id="2-8-1-常用方法"><a href="#2-8-1-常用方法" class="headerlink" title="2.8.1 常用方法"></a>2.8.1 常用方法</h3><h4 id="构造-4"><a href="#构造-4" class="headerlink" title="构造"></a>构造</h4><p>构造函数：<code>string(长度, 初值)</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">string s1;           <span class="comment">// 构造字符串，为空</span></span><br><span class="line">string s2 = <span class="string">&quot;awa!&quot;</span>;  <span class="comment">// 构造字符串，并赋值awa!</span></span><br><span class="line"><span class="function">string <span class="title">s3</span><span class="params">(<span class="number">10</span>, <span class="string">&#x27;6&#x27;</span>)</span></span>;  <span class="comment">// 构造字符串，通过构造函数构造为6666666666</span></span><br></pre></td></tr></table></figure><h4 id="输入输出"><a href="#输入输出" class="headerlink" title="输入输出"></a>输入输出</h4><p>C++</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">string s;</span><br><span class="line">cin &gt;&gt; s;</span><br><span class="line">cout &lt;&lt; s;</span><br></pre></td></tr></table></figure><p>C</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">string s;</span><br><span class="line"><span class="type">char</span> buf[<span class="number">100</span>];</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, &amp;buf);</span><br><span class="line">s = buf;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>, s.<span class="built_in">c_str</span>());</span><br></pre></td></tr></table></figure><h4 id="其他-3"><a href="#其他-3" class="headerlink" title="其他"></a>其他</h4><div class="table-container"><table><thead><tr><th>作用</th><th>用法</th><th>示例</th></tr></thead><tbody><tr><td>修改、查询指定下标字符</td><td><code>[]</code></td><td><code>s[1] = &#39;a&#39;;</code></td></tr><tr><td>是否相同</td><td><code>==</code></td><td><code>if (s1 == s2) ...</code></td></tr><tr><td>字符串连接</td><td><code>+</code></td><td><code>string s = s1 + s2;</code></td></tr><tr><td>尾接字符串</td><td><code>+=</code></td><td><code>s += &quot;awa&quot;;</code></td></tr><tr><td>取子串</td><td><code>.substr(起始下标, 子串长度)</code></td><td><code>string sub = s.substr(2, 10);</code></td></tr><tr><td>查找字符串</td><td><code>.find(字符串, 起始下标)</code></td><td><code>int pos = s.find(&quot;awa&quot;);</code></td></tr></tbody></table></div><h4 id="数值与字符串互转（C-11）"><a href="#数值与字符串互转（C-11）" class="headerlink" title="数值与字符串互转（C++11）"></a>数值与字符串互转（C++11）</h4><div class="table-container"><table><thead><tr><th>源</th><th>目的</th><th>函数</th></tr></thead><tbody><tr><td>int / long long / float / double / long double</td><td>string</td><td>to_string()</td></tr><tr><td>string</td><td>int</td><td>stoi()</td></tr><tr><td>string</td><td>long long</td><td>stoll()</td></tr><tr><td>string</td><td>float</td><td>stof()</td></tr><tr><td>string</td><td>double</td><td>stod()</td></tr><tr><td>string</td><td>long double</td><td>stold()</td></tr></tbody></table></div><h3 id="2-8-2-适用情形"><a href="#2-8-2-适用情形" class="headerlink" title="2.8.2 适用情形"></a>2.8.2 适用情形</h3><p>非常好用！<del>建议直接把字符数组扔了，赶快投入 string 的怀抱。</del></p><h3 id="2-8-3-注意事项"><a href="#2-8-3-注意事项" class="headerlink" title="2.8.3 注意事项"></a>2.8.3 注意事项</h3><h4 id="尾接字符串一定要用"><a href="#尾接字符串一定要用" class="headerlink" title="尾接字符串一定要用 +="></a>尾接字符串一定要用 <code>+=</code></h4><p>string 的 += 运算符，将会在原字符串原地尾接字符串。而 + 了再 = 赋值，会先生成一个临时变量，在复制给 string.</p><p>通常字符串长度可以很长，如果使用 + 字符串很容易就 TLE 了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 优化前: 15139ms</span></span><br><span class="line">string s;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5e5</span>; i++)</span><br><span class="line">    s = s + <span class="string">&quot;a&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 优化后: &lt; 1ms (计时器显示0)</span></span><br><span class="line">string s;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5e5</span>; i++)</span><br><span class="line">    s += <span class="string">&quot;a&quot;</span>;</span><br></pre></td></tr></table></figure><h4 id="substr-方法的奇葩参数"><a href="#substr-方法的奇葩参数" class="headerlink" title=".substr() 方法的奇葩参数"></a><code>.substr()</code> 方法的奇葩参数</h4><p>一定要注意，C++ string 的取子串的第一个参数是<strong>子串起点下标</strong>，第二个参数是<strong>子串长度</strong>。</p><p>第二个参数不是子串终点！不是子串终点！要与 java 等其他语言区分开来。</p><h4 id="find-方法的复杂度"><a href="#find-方法的复杂度" class="headerlink" title=".find() 方法的复杂度"></a><code>.find()</code> 方法的复杂度</h4><p>该方法实现为暴力实现，时间复杂度为 $O(n^2)$.</p><p><del>不要幻想 STL 内置了个 $O(n)$ 的 KMP 算法</del></p><h2 id="2-9-二元组-pair"><a href="#2-9-二元组-pair" class="headerlink" title="2.9 二元组 pair"></a>2.9 二元组 <a href="https://zh.cppreference.com/w/cpp/utility/pair">pair</a></h2><p><strong><code>#include &lt;utility&gt;</code></strong></p><p>顾名思义，就是储存二元组的。</p><h3 id="2-9-1-常用方法"><a href="#2-9-1-常用方法" class="headerlink" title="2.9.1 常用方法"></a>2.9.1 常用方法</h3><h4 id="构造-5"><a href="#构造-5" class="headerlink" title="构造"></a>构造</h4><p><strong><code>pair&lt;第一个值类型, 第二个值类型&gt; pr</code></strong></p><ul><li>第一个值类型：要储存的第一个值的数据类型</li><li>第二个值类型：要储存的第二个值的数据类型</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; p1;</span><br><span class="line">pair&lt;<span class="type">int</span>, <span class="type">long</span> <span class="type">long</span>&gt; p2;</span><br><span class="line">pair&lt;<span class="type">char</span>, <span class="type">int</span>&gt; p3;</span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure><h4 id="赋值"><a href="#赋值" class="headerlink" title="赋值"></a>赋值</h4><p>老式</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pair&lt;<span class="type">int</span>, <span class="type">char</span>&gt; pr = <span class="built_in">make_pair</span>(<span class="number">1</span>, <span class="string">&#x27;a&#x27;</span>);</span><br></pre></td></tr></table></figure><p>列表构造 C++11</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pair&lt;<span class="type">int</span>, <span class="type">char</span>&gt; pr = &#123;<span class="number">1</span>, <span class="string">&#x27;a&#x27;</span>&#125;;</span><br></pre></td></tr></table></figure><h4 id="取值"><a href="#取值" class="headerlink" title="取值"></a>取值</h4><p>直接取值</p><ul><li>取第一个值：<code>.first</code></li><li>取第二个值：<code>.second</code></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pair&lt;<span class="type">int</span>, <span class="type">char</span>&gt; pr = &#123;<span class="number">1</span>, <span class="string">&#x27;a&#x27;</span>&#125;;</span><br><span class="line"><span class="type">int</span> awa = pr.first;</span><br><span class="line"><span class="type">char</span> bwb = pr.second;</span><br></pre></td></tr></table></figure><p>结构化绑定 C++17</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pair&lt;<span class="type">int</span>, <span class="type">char</span>&gt; pr = &#123;<span class="number">1</span>, <span class="string">&#x27;a&#x27;</span>&#125;;</span><br><span class="line"><span class="keyword">auto</span> &amp;[awa, bwb] = pr;</span><br></pre></td></tr></table></figure><h4 id="判同"><a href="#判同" class="headerlink" title="判同"></a>判同</h4><p>直接用 <code>==</code> 运算符</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; p1 = &#123;<span class="number">1</span>, <span class="number">2</span>&#125;;</span><br><span class="line">pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; p2 = &#123;<span class="number">1</span>, <span class="number">3</span>&#125;;</span><br><span class="line"><span class="keyword">if</span> (p1 == p2) &#123; ... &#125; <span class="comment">// false</span></span><br></pre></td></tr></table></figure><h3 id="2-9-2-适用场景"><a href="#2-9-2-适用场景" class="headerlink" title="2.9.2 适用场景"></a>2.9.2 适用场景</h3><p>所有需要二元组的场景均可使用，效率和自己定义结构体差不多。</p><h3 id="2-9-3-注意事项"><a href="#2-9-3-注意事项" class="headerlink" title="2.9.3 注意事项"></a>2.9.3 注意事项</h3><p>无</p><h1 id="3-迭代器简介"><a href="#3-迭代器简介" class="headerlink" title="3 迭代器简介"></a>3 迭代器简介</h1><h2 id="3-1-迭代器是什么？"><a href="#3-1-迭代器是什么？" class="headerlink" title="3.1 迭代器是什么？"></a>3.1 迭代器是什么？</h2><p>不搞抽象，直接举例。</p><p>对于一个 vector，我们可以用下标遍历：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; a.<span class="built_in">size</span>(); i++)</span><br><span class="line">    cout &lt;&lt; a[i] &lt;&lt; endl;</span><br></pre></td></tr></table></figure><p>我们同时也可以用迭代器来遍历：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (vector&lt;<span class="type">int</span>&gt;::iterator it = a.<span class="built_in">begin</span>(); it != a.<span class="built_in">end</span>(); ++it)</span><br><span class="line">    cout &lt;&lt; *it &lt;&lt; endl;</span><br></pre></td></tr></table></figure><ul><li><code>a.begin()</code> 是一个迭代器，指向的是第一个元素</li><li><code>a.end()</code> 是一个迭代器，指向的是最后一个元素<strong>再后面一位</strong></li><li>上述迭代器具有自增运算符，自增则迭代器向下一个元素移动</li><li>迭代器与指针相似，如果对它使用解引用运算符，即 <code>*it</code>，就能取到对应值了</li></ul><h2 id="3-2-为何需要迭代器？"><a href="#3-2-为何需要迭代器？" class="headerlink" title="3.2 为何需要迭代器？"></a>3.2 为何需要迭代器？</h2><p>很多数据结构并不是线性的（例如红黑树），对于非线性数据结构，下标是无意义的。无法使用下标来遍历整个数据结构。</p><p>迭代器的作用就是定义某个数据结构的遍历方式，通过迭代器的增减，代表遍历到的位置，通过迭代器便能成功遍历非线性结构了。</p><p>例如，set 的实现是红黑树，我们是没法用下标来访问元素的。但是通过迭代器，我们就能遍历 set 中的元素了：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (set&lt;<span class="type">int</span>&gt;::iterator it = st.<span class="built_in">begin</span>(); it != st.<span class="built_in">end</span>(); ++it)</span><br><span class="line">    cout &lt;&lt; *it &lt;&lt; endl;</span><br></pre></td></tr></table></figure><h2 id="3-3-迭代器用法"><a href="#3-3-迭代器用法" class="headerlink" title="3.3 迭代器用法"></a>3.3 迭代器用法</h2><p>对于 vector 容器，它的迭代器功能比较完整，以它举例：</p><ul><li><code>.begin()</code>：头迭代器</li><li><code>.end()</code>：尾迭代器</li><li><code>.rbegin()</code>：反向头迭代器</li><li><code>.rend()</code>：反向尾迭代器</li><li>迭代器 <code>+</code> 整型：将迭代器向后移动</li><li>迭代器 <code>-</code> 整型：将迭代器向前移动</li><li>迭代器 <code>++</code>：将迭代器向后移动 1 位</li><li>迭代器 <code>--</code>：将迭代器向前移动 1 位</li><li>迭代器 <code>-</code> 迭代器：两个迭代器的距离</li><li><code>prev(it)</code>：返回 it 的前一个迭代器</li><li><code>next(it)</code>：返回 it 的后一个迭代器</li></ul><p>对于其他容器，由于其结构特性，上面的功能不一定都有（例如 set 的迭代器是不能相减求距离的）</p><h2 id="3-4-常见问题"><a href="#3-4-常见问题" class="headerlink" title="3.4 常见问题"></a>3.4 常见问题</h2><p><strong><code>.end()</code> 和 <code>.rend()</code> 指向的位置是无意义的值</strong></p><p>对于一个长度为 10 的数组：<code>for (int i = 0; i &lt; 10; i++)</code>，第 10 位是不可访问的</p><p>对于一个长度为 10 的容器：<code>for (auto it = a.begin(); it != a.end(); ++it)</code>，.end 是不可访问的</p><p><strong>不同容器的迭代器功能可能不一样</strong></p><p>迭代器细化的话有正向、反向、双向，每个容器的迭代器支持的运算符也可能不同，因此不同容器的迭代器细节很有可能是不一样的。</p><p><strong>删除操作时需要警惕</strong></p><p>为什么 3 没删掉？</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; a&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> it = a.<span class="built_in">begin</span>(); it != a.<span class="built_in">end</span>(); ++it)</span><br><span class="line">    <span class="keyword">if</span> (*it == <span class="number">2</span> || *it == <span class="number">3</span>)</span><br><span class="line">        a.<span class="built_in">erase</span>(it);</span><br><span class="line"><span class="comment">// a = [1, 3, 4]</span></span><br></pre></td></tr></table></figure><p>为啥 RE 了？</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; a&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> it = a.<span class="built_in">begin</span>(); it != a.<span class="built_in">end</span>(); ++it)</span><br><span class="line">    <span class="keyword">if</span> (*it == <span class="number">4</span>)</span><br><span class="line">        a.<span class="built_in">erase</span>(it);</span><br></pre></td></tr></table></figure><center><b>建议：如无必要，别用迭代器操作容器。（遍历与访问没关系）</b></center><h1 id="4-常用算法"><a href="#4-常用算法" class="headerlink" title="4 常用算法"></a>4 常用算法</h1><h2 id="4-1-内容总览"><a href="#4-1-内容总览" class="headerlink" title="4.1 内容总览"></a>4.1 内容总览</h2><p>打勾的是本次将会详细讲解的，其他的是算法竞赛中建议学习的，不在下表列出的在比赛中基本用不到。</p><p>（很多函数的功能很简单，自己都能快速写出来，但是使用函数可以让代码可读性变得更高，这在比赛中是至关紧要的）</p><ul><li><p>算法库 Algorithm</p><ul><li>[ ] <code>count()</code></li><li>[ ] <code>find()</code></li><li>[ ] <code>fill()</code></li><li>[x] <a href="https://zh.cppreference.com/w/cpp/algorithm/swap"><code>swap()</code></a></li><li>[x] <a href="https://zh.cppreference.com/w/cpp/algorithm/reverse"><code>reverse()</code></a></li><li>[ ] <code>shuffle()</code> C++11</li><li>[x] <a href="https://zh.cppreference.com/w/cpp/algorithm/unique"><code>unique()</code></a></li><li>[x] <a href="https://zh.cppreference.com/w/cpp/algorithm/sort"><code>sort()</code></a></li><li>[x] <a href="https://zh.cppreference.com/w/cpp/algorithm/lower_bound"><code>lower_bound()</code></a> / <a href="https://zh.cppreference.com/w/cpp/algorithm/upper_bound"><code>upper_bound()</code></a></li><li>[x] <a href="https://zh.cppreference.com/w/cpp/algorithm/max"><code>max()</code></a> / <a href="https://zh.cppreference.com/w/cpp/algorithm/min"><code>min()</code></a></li><li>[ ] <code>max_element()</code> / <code>min_element()</code></li><li>[ ] <code>prev_permutation()</code> / <code>next_permutation()</code></li></ul></li><li><p>数学函数 cmath</p><ul><li>[x] <a href="https://zh.cppreference.com/w/cpp/numeric/math/fabs"><code>abs()</code></a></li><li>[x] <a href="https://zh.cppreference.com/w/cpp/numeric/math/exp"><code>exp()</code></a></li><li>[x] <a href="https://zh.cppreference.com/w/cpp/numeric/math/log"><code>log()</code></a> / <code>log10()</code> / <code>log2()</code></li><li>[x] <a href="https://zh.cppreference.com/w/cpp/numeric/math/pow"><code>pow()</code></a></li><li>[x] <a href="https://zh.cppreference.com/w/cpp/numeric/math/sqrt"><code>sqrt()</code></a></li><li>[ ] <code>sin()</code> / <code>cos()</code> / <code>tan()</code></li><li>[ ] <code>asin()</code> / <code>acos()</code> / <code>atan()</code></li><li>[ ] <code>sinh()</code> / <code>cosh()</code> / <code>tanh()</code></li><li>[ ] <code>asinh()</code> / <code>acosh()</code> / <code>atanh()</code> C++11</li><li>[x] <a href="https://zh.cppreference.com/w/cpp/numeric/math/ceil"><code>ceil()</code></a> / <a href="https://zh.cppreference.com/w/cpp/numeric/math/floor"><code>floor()</code></a></li><li>[x] <a href="https://zh.cppreference.com/w/cpp/numeric/math/round"><code>round()</code></a> C++11</li></ul></li><li><p>数值算法 numeric</p><ul><li>[ ] <code>iota()</code> C++11</li><li>[ ] <code>accumulate()</code></li><li>[x] <a href="https://zh.cppreference.com/w/cpp/numeric/gcd"><code>gcd()</code></a> C++17</li><li>[x] <a href="https://zh.cppreference.com/w/cpp/numeric/lcm"><code>lcm()</code></a> C++17</li></ul></li><li><p>伪随机数生成 random</p><ul><li>[ ] <code>mt19937</code></li><li>[ ] <code>random_device()</code></li></ul></li></ul><h2 id="4-2-swap"><a href="#4-2-swap" class="headerlink" title="4.2 swap()"></a>4.2 <code>swap()</code></h2><p>交换两个变量的值</p><p><strong>用法示例</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt; <span class="keyword">class</span> T &gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">( T&amp; a, T&amp; b )</span></span>;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">0</span>, b = <span class="number">1</span>;</span><br><span class="line"><span class="built_in">swap</span>(a, b);</span><br><span class="line"><span class="comment">// now a = 1, b = 0</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> arr[<span class="number">10</span>] &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>&#125;;</span><br><span class="line"><span class="built_in">swap</span>(arr[<span class="number">4</span>], arr[<span class="number">6</span>]);</span><br><span class="line"><span class="comment">// now arr = &#123;0, 1, 2, 3, 6, 5, 4, 7, 8, 9&#125;</span></span><br></pre></td></tr></table></figure><p><strong>注意事项</strong></p><p>这个 swap 参数是引用的，不需要像 C 语言一样取地址。</p><h2 id="4-3-sort"><a href="#4-3-sort" class="headerlink" title="4.3 sort()"></a>4.3 <code>sort()</code></h2><p>使用快速排序给一个可迭代对象排序</p><p><strong>用法示例</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt; <span class="keyword">class</span> RandomIt, <span class="keyword">class</span> Compare &gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sort</span><span class="params">( RandomIt first, RandomIt last, Compare comp )</span></span>;</span><br></pre></td></tr></table></figure><p>默认排序从小到大</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; arr&#123;<span class="number">1</span>, <span class="number">9</span>, <span class="number">1</span>, <span class="number">9</span>, <span class="number">8</span>, <span class="number">1</span>, <span class="number">0</span>&#125;;</span><br><span class="line"><span class="built_in">sort</span>(arr.<span class="built_in">begin</span>(), arr.<span class="built_in">end</span>());</span><br><span class="line"><span class="comment">// arr = [0, 1, 1, 1, 8, 9, 9]</span></span><br></pre></td></tr></table></figure><p>如果要从大到小，则需要传比较器进去。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; arr&#123;<span class="number">1</span>, <span class="number">9</span>, <span class="number">1</span>, <span class="number">9</span>, <span class="number">8</span>, <span class="number">1</span>, <span class="number">0</span>&#125;;</span><br><span class="line"><span class="built_in">sort</span>(arr.<span class="built_in">begin</span>(), arr.<span class="built_in">end</span>(), <span class="built_in">greater</span>&lt;<span class="type">int</span>&gt;());</span><br><span class="line"><span class="comment">// arr = [9, 9, 8, 1, 1, 1, 0]</span></span><br></pre></td></tr></table></figure><p>如果需要完成特殊比较，则需要手写比较器。</p><p>比较器函数返回值是 bool 类型，传参是需要比较的两个元素。记我们定义的该比较操作为 $\star$：</p><ul><li>若 $a\star b$，则比较器函数应当返回 <code>true</code></li><li>若 $a\not\star b$，则比较器函数应当返回 <code>false</code></li></ul><p><strong>注意：</strong>如果 $a=b$，比较器函数必须返回 <code>false</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; a, pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (a.second != b.second)</span><br><span class="line">        <span class="keyword">return</span> a.second &lt; b.second;</span><br><span class="line">    <span class="keyword">return</span> a.first &gt; b.first;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt; arr&#123;&#123;<span class="number">1</span>, <span class="number">9</span>&#125;, &#123;<span class="number">2</span>, <span class="number">9</span>&#125;, &#123;<span class="number">8</span>, <span class="number">1</span>&#125;, &#123;<span class="number">0</span>, <span class="number">0</span>&#125;&#125;;</span><br><span class="line">    <span class="built_in">sort</span>(arr.<span class="built_in">begin</span>(), arr.<span class="built_in">end</span>(), cmp);</span><br><span class="line">    <span class="comment">// arr = [(0, 0), (8, 1), (2, 9), (1, 9)]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-4-lower-bound-upper-bound"><a href="#4-4-lower-bound-upper-bound" class="headerlink" title="4.4 lower_bound() / upper_bound()"></a>4.4 <code>lower_bound()</code> / <code>upper_bound()</code></h2><p>在<strong>已升序排序</strong>的元素中，应用二分查找检索指定元素，返回对应元素迭代器位置。<strong>找不到则返回尾迭代器。</strong></p><ul><li><code>lower_bound()</code>: 寻找 $\geq x$ 的第一个元素的位置</li><li><code>upper_bound()</code>: 寻找 $&gt;x$ 的第一个元素的位置</li></ul><p>怎么找 $\leq x$ / $&lt; x$ 的第一个元素呢？</p><ul><li>$&gt;x$ 的第一个元素的前一个元素（如果有）便是 $\leq x$ 的第一个元素</li><li>$\geq x$ 的第一个元素的前一个元素（如果有）便是 $&lt;x$ 的第一个元素</li></ul><p>返回的是迭代器，如何转成下标索引呢？减去头迭代器即可。</p><p><strong>用法示例</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt; <span class="keyword">class</span> ForwardIt, <span class="keyword">class</span> T &gt;</span></span><br><span class="line"><span class="function">ForwardIt <span class="title">lower_bound</span><span class="params">( ForwardIt first, ForwardIt last, <span class="type">const</span> T&amp; value )</span></span>;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; arr&#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">9</span>&#125;;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt;::iterator it = <span class="built_in">lower_bound</span>(arr.<span class="built_in">begin</span>(), arr.<span class="built_in">end</span>(), <span class="number">7</span>);</span><br><span class="line"><span class="type">int</span> idx = it - arr.<span class="built_in">begin</span>();</span><br><span class="line"><span class="comment">// idx = 4</span></span><br></pre></td></tr></table></figure><p>我们通常写成一行：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; arr&#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">9</span>&#125;;</span><br><span class="line">idx = <span class="built_in">lower_bound</span>(arr.<span class="built_in">begin</span>(), arr.<span class="built_in">end</span>(), <span class="number">7</span>) - arr.<span class="built_in">begin</span>(); <span class="comment">// 4</span></span><br><span class="line">idx = <span class="built_in">lower_bound</span>(arr.<span class="built_in">begin</span>(), arr.<span class="built_in">end</span>(), <span class="number">8</span>) - arr.<span class="built_in">begin</span>(); <span class="comment">// 4</span></span><br><span class="line">idx = <span class="built_in">upper_bound</span>(arr.<span class="built_in">begin</span>(), arr.<span class="built_in">end</span>(), <span class="number">7</span>) - arr.<span class="built_in">begin</span>(); <span class="comment">// 4</span></span><br><span class="line">idx = <span class="built_in">upper_bound</span>(arr.<span class="built_in">begin</span>(), arr.<span class="built_in">end</span>(), <span class="number">8</span>) - arr.<span class="built_in">begin</span>(); <span class="comment">// 5</span></span><br></pre></td></tr></table></figure><h2 id="4-5-reverse"><a href="#4-5-reverse" class="headerlink" title="4.5 reverse()"></a>4.5 <code>reverse()</code></h2><p>反转一个可迭代对象的元素顺序</p><p><strong>用法示例</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt; <span class="keyword">class</span> BidirIt &gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">reverse</span><span class="params">( BidirIt first, BidirIt last )</span></span>;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">arr</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line"><span class="built_in">iota</span>(arr.<span class="built_in">begin</span>(), arr.<span class="built_in">end</span>(), <span class="number">1</span>);</span><br><span class="line"><span class="comment">// 1, 2, 3, 4, 5, 6, 7, 8, 9, 10</span></span><br><span class="line"><span class="built_in">reverse</span>(arr.<span class="built_in">begin</span>(), arr.<span class="built_in">end</span>());</span><br><span class="line"><span class="comment">// 10, 9, 8, 7, 6, 5, 4, 3, 2, 1</span></span><br></pre></td></tr></table></figure><h2 id="4-6-max-min"><a href="#4-6-max-min" class="headerlink" title="4.6 max() / min()"></a>4.6 <code>max()</code> / <code>min()</code></h2><p>返回最大值 / 最小值的<strong>数值</strong></p><p><strong>用法示例</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> mx = <span class="built_in">max</span>(<span class="number">1</span>, <span class="number">2</span>); <span class="comment">// 2</span></span><br><span class="line"><span class="type">int</span> mn = <span class="built_in">min</span>(<span class="number">1</span>, <span class="number">2</span>); <span class="comment">// 1</span></span><br></pre></td></tr></table></figure><p>在 C++11 之后，可以使用列表构造语法传入一个列表，这样就能一次性给多个元素找最大值而不用套娃了：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Before C++11</span></span><br><span class="line"><span class="type">int</span> mx = <span class="built_in">max</span>(<span class="built_in">max</span>(<span class="number">1</span>, <span class="number">2</span>), <span class="built_in">max</span>(<span class="number">3</span>, <span class="number">4</span>)); <span class="comment">// 4</span></span><br><span class="line"><span class="type">int</span> mn = <span class="built_in">min</span>(<span class="built_in">min</span>(<span class="number">1</span>, <span class="number">2</span>), <span class="built_in">min</span>(<span class="number">3</span>, <span class="number">4</span>)); <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// After C++11</span></span><br><span class="line"><span class="type">int</span> mx = <span class="built_in">max</span>(&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;); <span class="comment">// 4</span></span><br><span class="line"><span class="type">int</span> mn = <span class="built_in">min</span>(&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;); <span class="comment">// 1</span></span><br></pre></td></tr></table></figure><h2 id="4-7-unique"><a href="#4-7-unique" class="headerlink" title="4.7 unique()"></a>4.7 <code>unique()</code></h2><p>消除数组的重复<strong>相邻</strong>元素，数组长度不变，但是有效数据缩短，返回的是有效数据位置的结尾迭代器。</p><p>例如：$[1,1,4,5,1,4]\to[1,4,5,1,4,\underline?]$，下划线位置为返回的迭代器指向。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt; <span class="keyword">class</span> ForwardIt &gt;</span></span><br><span class="line"><span class="function">ForwardIt <span class="title">unique</span><span class="params">( ForwardIt first, ForwardIt last )</span></span>;</span><br></pre></td></tr></table></figure><p><strong>用法示例</strong></p><p>单独使用 unique 并不能达成去重效果，因为它只消除<strong>相邻</strong>的重复元素。但是如果序列有序，那么它就能去重了。</p><p>但是它去重后，序列尾部会产生一些无效数据：$[1,1,2,4,4,4,5]\to[1,2,4,5,\underline?,?,?]$，为了删掉这些无效数据，我们需要结合 erase.</p><p>最终，给 vector 去重的写法便是：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; arr&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">4</span>&#125;;</span><br><span class="line"><span class="built_in">sort</span>(arr.<span class="built_in">begin</span>(), arr.<span class="built_in">end</span>());</span><br><span class="line">arr.<span class="built_in">erase</span>(<span class="built_in">unique</span>(arr.<span class="built_in">begin</span>(), arr.<span class="built_in">end</span>()), arr.<span class="built_in">end</span>());</span><br></pre></td></tr></table></figure><h2 id="4-8-数学函数"><a href="#4-8-数学函数" class="headerlink" title="4.8 数学函数"></a>4.8 数学函数</h2><p>所有函数参数均支持 <code>int</code> / <code>long long</code> / <code>float</code> / <code>double</code> / <code>long double</code></p><div class="table-container"><table><thead><tr><th>公式</th><th>示例</th></tr></thead><tbody><tr><td>$f(x)=\lvert x\rvert$</td><td><code>abs(-1.0)</code></td></tr><tr><td>$f(x)=e^x$</td><td><code>exp(2)</code></td></tr><tr><td>$f(x)=\ln x$</td><td><code>log(3)</code></td></tr><tr><td>$f(x,y)=x^y$</td><td><code>pow(2, 3)</code></td></tr><tr><td>$f(x)=\sqrt x$</td><td><code>sqrt(2)</code></td></tr><tr><td>$f(x)=\lceil x\rceil$</td><td><code>ceil(2.1)</code></td></tr><tr><td>$f(x)=\lfloor x\rfloor$</td><td><code>floor(2.1)</code></td></tr><tr><td>$f(x)=\left<x\right>$</td><td><code>rount(2.1)</code></td></tr></tbody></table></div><p><strong>注意事项</strong></p><p>由于浮点误差，有些的数学函数的行为可能与预期不符，导致 WA。如果你的操作数都是整型，那么用下面的写法会更稳妥。</p><blockquote><p>原文地址：<a href="https://codeforces.com/blog/entry/107717">https://codeforces.com/blog/entry/107717</a></p></blockquote><ul><li>$\lfloor\frac{a}{b}\rfloor$<ul><li>别用：<code>floor(1.0 * a / b)</code></li><li>要用：<code>a / b</code></li></ul></li><li>$\lceil\frac{a}{b}\rceil$<ul><li>别用：<code>ceil(1.0 * a / b)</code></li><li>要用：<code>(a + b - 1) / b</code>  （$\lceil\frac{a}{b}\rceil=\lfloor\frac{a+b-1}{b}\rfloor$）</li></ul></li><li>$\lfloor\sqrt a\rfloor$<ul><li>别用：<code>(int) sqrt(a)</code></li><li>要用：二分查找 <a href="https://io.zouht.com/7.html">https://io.zouht.com/7.html</a></li></ul></li><li>$a^b$<ul><li>别用：<code>pow(a, b)</code></li><li>要用：快速幂 <a href="https://io.zouht.com/18.html">https://io.zouht.com/18.html</a></li></ul></li><li>$\lfloor\log_2 a\rfloor$<ul><li>别用：<code>log2(a)</code></li><li>要用：<code>__lg</code> （不规范，但是这是竞赛）/ <code>bit_width</code>（C++20 可用）</li></ul></li></ul><h2 id="4-9-gcd-lcm"><a href="#4-9-gcd-lcm" class="headerlink" title="4.9 gcd() / lcm()"></a>4.9 <code>gcd()</code> / <code>lcm()</code></h2><p>（C++17）返回最大公因数 / 最小公倍数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> x = <span class="built_in">gcd</span>(<span class="number">8</span>, <span class="number">12</span>); <span class="comment">// 4</span></span><br><span class="line"><span class="type">int</span> y = <span class="built_in">lcm</span>(<span class="number">8</span>, <span class="number">12</span>); <span class="comment">// 24</span></span><br></pre></td></tr></table></figure><p>如果不是 C++17，但是是 GNU 编译器（g++），那么可以用内置函数 <code>__gcd()</code>.</p><p>当然，<code>gcd</code> / <code>lcm</code> 函数也挺好写，直接写也行（欧几里得算法）：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">gcd</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!b)</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">gcd</span>(b, a % b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">lcm</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a / <span class="built_in">gcd</span>(a, b) * b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">转载自github</summary>
    
    
    
    <category term="leetcode刷题笔记" scheme="https://sumikiru.top/categories/leetcode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="C++" scheme="https://sumikiru.top/tags/C/"/>
    
    <category term="STL" scheme="https://sumikiru.top/tags/STL/"/>
    
    <category term="leetcode" scheme="https://sumikiru.top/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>欢迎来到本站</title>
    <link href="https://sumikiru.top/posts/9b94e219.html"/>
    <id>https://sumikiru.top/posts/9b94e219.html</id>
    <published>2024-04-05T00:00:00.000Z</published>
    <updated>2025-02-06T14:42:00.324Z</updated>
    
    
    <summary type="html">欢迎，一起来研究C++吧~</summary>
    
    
    
    
  </entry>
  
</feed>
