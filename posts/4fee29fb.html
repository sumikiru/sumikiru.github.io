<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover"><title>语言基础4.并发与多线程 | SumikiruのBlog</title><meta name="author" content="Sumikiru"><meta name="copyright" content="Sumikiru"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="C++基础：多线程"><meta property="og:type" content="article"><meta property="og:title" content="语言基础4.并发与多线程"><meta property="og:url" content="https://sumikiru.top/posts/4fee29fb.html"><meta property="og:site_name" content="SumikiruのBlog"><meta property="og:description" content="C++基础：多线程"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://pic.imgdb.cn/item/6692a239d9c307b7e99355e5.jpg"><meta property="article:published_time" content="2024-12-15T19:52:10.000Z"><meta property="article:modified_time" content="2024-12-23T23:16:03.000Z"><meta property="article:author" content="Sumikiru"><meta property="article:tag" content="C++"><meta property="article:tag" content="多线程"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://pic.imgdb.cn/item/6692a239d9c307b7e99355e5.jpg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://sumikiru.top/posts/4fee29fb.html"><link rel="preconnect" href="//cdn.jsdelivr.net"><link rel="preconnect" href="//busuanzi.ibruce.info"><link rel="manifest" href="/manifest.json"><meta name="msapplication-TileColor" content="#d9f8ff"><link rel="apple-touch-icon" sizes="180x180" href="/images/siteicon/128.png"><link rel="icon" type="image/png" sizes="32x32" href="/images/siteicon/32.png"><link rel="icon" type="image/png" sizes="16x16" href="/images/siteicon/16.png"><link rel="mask-icon" href="/images/siteicon/128.png" color="#5bbad5"><link rel="stylesheet" href="/css/index.css?v=4.13.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.5.1/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar@0.1.16/dist/snackbar.min.css" media="print" onload='this.media="all"'><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.33/dist/fancybox/fancybox.min.css" media="print" onload='this.media="all"'><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"找不到您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":200},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"你已切换为繁体中文","cht_to_chs":"你已切换为简体中文","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#49b1f5","bgDark":"#1f1f1f","position":"top-center"},
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.11.1/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyload: true,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE={title:"语言基础4.并发与多线程",isPost:!0,isHome:!1,isHighlightShrink:!1,isToc:!0,postUpdate:"2024-12-23 23:16:03"}</script><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
        if (t === 'dark') activateDarkMode()
        else if (t === 'light') activateLightMode()
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><link rel="stylesheet" href="/css/custom.css" media="defer" onload='this.media="all"'><link rel="stylesheet" href="https://cdn.cbd.int/hexo-butterfly-clock-anzhiyu/lib/clock.min.css"><link rel="stylesheet" href="https://npm.elemecdn.com/anzhiyu-blog@2.0.4/css/runtime/runtime.min.css" media="print" onload='this.media="all"'><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-swiper/lib/swiper.min.css" media="print" onload='this.media="all"'><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-swiper/lib/swiperstyle.css" media="print" onload='this.media="all"'><link rel="stylesheet" href="https://cdn.cbd.int/hexo-butterfly-tag-plugins-plus@latest/lib/assets/font-awesome-animation.min.css" media="defer" onload='this.media="all"'><link rel="stylesheet" href="https://cdn.cbd.int/hexo-butterfly-tag-plugins-plus@latest/lib/tag_plugins.css" media="defer" onload='this.media="all"'><script src="https://cdn.cbd.int/hexo-butterfly-tag-plugins-plus@latest/lib/assets/carousel-touch.js"></script><link rel="stylesheet" href="https://cdn.cbd.int/hexo-butterfly-wowjs/lib/animate.min.css" media="print" onload='this.media="screen"'><meta name="generator" content="Hexo 6.3.0"><link rel="alternate" href="/atom.xml" title="SumikiruのBlog" type="application/atom+xml"></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/glow.jpg" onerror='onerror=null,src="/img/friend_404.gif"' alt="avatar"></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">19</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">21</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">4</div></a></div><hr class="custom-hr"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i> <span>Home</span></a></div><div class="menus_item"><a class="site-page" href="/bangumis/index.html"><i class="fa-fw fas fa-video"></i> <span>追番</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i> <span>标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i> <span>分类</span></a></div><div class="menus_item"><a class="site-page" href="/comments/"><i class="fa-fw fas fa-envelope"></i> <span>留言板</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image:url(https://pic.imgdb.cn/item/6692a239d9c307b7e99355e5.jpg)"><nav id="nav"><span id="blog-info"><a href="/" title="SumikiruのBlog"><span class="site-name">SumikiruのBlog</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i> <span>搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i> <span>Home</span></a></div><div class="menus_item"><a class="site-page" href="/bangumis/index.html"><i class="fa-fw fas fa-video"></i> <span>追番</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i> <span>标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i> <span>分类</span></a></div><div class="menus_item"><a class="site-page" href="/comments/"><i class="fa-fw fas fa-envelope"></i> <span>留言板</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">语言基础4.并发与多线程</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2024-12-15T19:52:10.000Z" title="发表于 2024-12-15 19:52:10">2024-12-15</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-12-23T23:16:03.000Z" title="更新于 2024-12-23 23:16:03">2024-12-23</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/C-%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/">C++语言基础</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">20.1k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>82分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" data-flag-title="语言基础4.并发与多线程"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><blockquote><p>参考文章：<a target="_blank" rel="noopener" href="https://www.zhihu.com/tardis/zm/art/194198073">C++多线程开发基础入门教程</a>，<a target="_blank" rel="noopener" href="https://www.zhihu.com/column/c_1479157429707059201">C++学习笔记：并发与多线程</a><br>参考视频：<a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1An4y1d7Jc?vd_source=6176273f0f24da0db424c2d99bd01fd5">C++编程进阶教程</a></p></blockquote><h1 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h1><h2 id="什么是线程、进程、并发"><a href="#什么是线程、进程、并发" class="headerlink" title="什么是线程、进程、并发"></a>什么是线程、进程、并发</h2><p><strong>线程</strong>（Thread）是操作系统能够进行CPU调度的<strong>最小单位</strong>，它被<strong>包含在进程（program）之中</strong>，一个进程可包含单个或者多个线程。<br>一条线程指的是进程中单一的控制流，每条线程执行不同的任务。</p><p><strong>进程</strong>是运行起来的可执行程序。<br><strong>并发</strong>是指多个任务同时发生，一个程序同时执行多个独立任务。</p><h2 id="进程与线程的关系"><a href="#进程与线程的关系" class="headerlink" title="进程与线程的关系"></a>进程与线程的关系</h2><p>一个进程可以包含多个线程，这些线程<font color="#00b050">共享</font>相同的<u>进程空间（代码段、数据段、堆）</u>和<u>系统资源（文件描述符、信号处理）</u>，但各自有<font color="#00b050">独立的栈空间和线程控制块</font>，不共享内存。</p><p>🚀详细区分：</p><ol><li><strong>容器</strong>：每个进程都有相应的线程。进程是线程的<font color="#00b050">容器</font>。</li><li><strong>最小单位</strong>：进程是<strong>资源分配</strong>的最小单位，而线程是<strong>程序执行</strong>的最小单位。</li><li><strong>地址空间</strong>：进程有自己<font color="#00b050">独立的地址空间</font>，而线程没有独立的地址空间，<strong>同一进程</strong>的线程<font color="#00b050">共享本进程的地址空间</font>。</li><li><strong>资源</strong>：进程之间的<font color="#00b050">资源是独立的</font>，而同一进程内的线程<font color="#00b050">共享本进程的资源</font>。</li><li><strong>并发执行</strong>：进程可以并发执行，<strong>同一进程</strong>内的多个线程也可以并发执行。</li></ol><p>锅炉爷爷是一个进程，每条手可以被看成一个线程。</p><h2 id="线程的特点"><a href="#线程的特点" class="headerlink" title="线程的特点"></a>线程的特点</h2><ol><li><strong>轻量级</strong>：与进程相比，线程的创建和销毁成本低。因为线程是进程的一个执行流，共享进程的大部分资源，只需要少量的额外开销来维护进程的状态和控制信息。</li><li><strong>共享地址空间和资源</strong>：同一进程内的线程共享进程地址空间和全局变量等资源，这使得线程间通信更加便捷。但是这也带来了数据同步和互斥问题，需要适当的同步机制来避免数据竞争和死锁的问题。</li><li><strong>并发执行</strong>：多个线程可以在同一时间内并发执行，提高了程序的执行效率。但是由于线程的执行顺序和速度受到操作系统调度策略和硬件性能的影响，因此线程的执行结果可能是不确定的。</li><li><strong>独立调度</strong>：线程是独立调度的基本单位。在多线程操作系统中，调度器根据线程的优先级、状态等因素来决定线程的调度顺序和执行时间。</li></ol><h2 id="什么是多线程编程"><a href="#什么是多线程编程" class="headerlink" title="什么是多线程编程"></a>什么是多线程编程</h2><p>一个<font color="#00b050">程序中创建多个线程并发</font>的执行，每个线程执行不同的任务。</p><h2 id="为什么使用多线程-并发（优点）"><a href="#为什么使用多线程-并发（优点）" class="headerlink" title="为什么使用多线程/并发（优点）"></a>为什么使用多线程/并发（优点）</h2><ol><li>充分利用 CPU 资源</li><li>提高程序响应速度</li><li>便于程序设计和维护</li></ol><h2 id="并发与并行的区别"><a href="#并发与并行的区别" class="headerlink" title="并发与并行的区别"></a>并发与并行的区别</h2><ul><li>并发：同一时间段，多个任务<font color="#00b050">交替</font>执行。</li><li>并行：同一时间段，多个任务<font color="#00b050">同时</font>执行。</li></ul><h2 id="线程的声明周期"><a href="#线程的声明周期" class="headerlink" title="线程的声明周期"></a>线程的声明周期</h2><ol><li>新建状态 New</li><li>就绪状态 Runnable</li><li>运行状态 Running</li><li>阻塞状态 Blocked</li><li>死亡状态 Dead</li></ol><h1 id="Thread-创建线程"><a href="#Thread-创建线程" class="headerlink" title="Thread 创建线程"></a>Thread 创建线程</h1><h2 id="总体代码"><a href="#总体代码" class="headerlink" title="总体代码"></a>总体代码</h2><p>需要包含头文件 <code>&lt;thread&gt;</code>。可通过回调函数、仿函数、Lambda表达式创建。<br></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//通过函数来创建线程：</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">myprint</span><span class="params">()</span><span class="comment">//初始函数 //回调函数</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;自己创建的线程开始执行&quot;</span> &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;自己创建的线程执行中1&quot;</span> &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;自己创建的线程执行中2&quot;</span> &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;自己创建的线程执行中3&quot;</span> &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;自己创建的线程执行中4&quot;</span> &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;自己创建的线程执行中5&quot;</span> &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;自己创建的线程执行完毕&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test05_01</span><span class="params">()</span> <span class="comment">//通过函数来创建线程</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function">thread <span class="title">myobj</span><span class="params">(myprint)</span></span>; <span class="comment">//thread：创建线程的类；//创建线程，调用myprint，从myprint开始执行；</span></span><br><span class="line">	<span class="comment">// 🚩创建该线程以后，线程就已经开始执行，并不是等到调用join()或者detach()时才开始执行</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (myobj.<span class="built_in">joinable</span>())<span class="comment">//判断能不能join或者detach，true表示可以join或者detach；</span></span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;joinable() = true&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;joinable() = false&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 🚩当线程启动后，一定要在和线程相关的thread对象被销毁前，对线程调用join()或者detach()方法</span></span><br><span class="line">	myobj.<span class="built_in">join</span>();<span class="comment">//阻塞主线程，让主线程等待子线程执行完毕，然后子线程和主线程汇合；</span></span><br><span class="line">	<span class="comment">//myobj.detach(); //一旦使用detach()后，与这个主线程关联的thread对象就失去了与这个主线程的关联，此时这个子线程就会在后台运行（守护线程）；</span></span><br><span class="line">	<span class="comment">//这个子线程就相当于被C++运行时库接管，这个子线程运行完后，由运行时库清理该线程相关资源；就不能再用join()接管回来了；</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (myobj.<span class="built_in">joinable</span>())</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;joinable2() = true&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;joinable2() = false&quot;</span> &lt;&lt; endl; <span class="comment">//join()之后也不能再join</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;主线程运行结束&quot;</span> &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;主线程运行结束2&quot;</span> &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;主线程运行结束3&quot;</span> &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;主线程运行结束4&quot;</span> &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;主线程运行结束5&quot;</span> &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;主线程运行结束6&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 通过类来创建线程，类作为可调用对象（仿函数）：</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TA</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">TA</span>(<span class="type">int</span> i):<span class="built_in">m_i</span>(i) <span class="comment">//有参构造 //不能用引用int &amp;i</span></span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;TA有参构造函数被执行&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">TA</span>(<span class="type">const</span> TA &amp;ta) :<span class="built_in">m_i</span>(ta.m_i) <span class="comment">//拷贝构造</span></span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;TA拷贝构造函数被执行&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	~<span class="built_in">TA</span>() <span class="comment">//析构</span></span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;TA析构函数被执行&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">()</span><span class="comment">//不能带参数 //operator()()就是线程的入口点</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;operator()线程开始执行&quot;</span> &lt;&lt; endl;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;m_i = &quot;</span> &lt;&lt; m_i &lt;&lt; endl;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;m_i = &quot;</span> &lt;&lt; m_i &lt;&lt; endl;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;m_i = &quot;</span> &lt;&lt; m_i &lt;&lt; endl;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;m_i = &quot;</span> &lt;&lt; m_i &lt;&lt; endl;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;m_i = &quot;</span> &lt;&lt; m_i &lt;&lt; endl;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;m_i = &quot;</span> &lt;&lt; m_i &lt;&lt; endl;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;operator()线程执行完毕&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//int &amp;m_i;</span></span><br><span class="line">	<span class="type">int</span> m_i;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test05_02</span><span class="params">()</span> <span class="comment">//通过类来创建线程</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> myi = <span class="number">6</span>;</span><br><span class="line">	<span class="function">TA <span class="title">ta</span><span class="params">(myi)</span></span>;</span><br><span class="line">	<span class="function">thread <span class="title">myjob</span><span class="params">(ta)</span></span>;<span class="comment">//ta: 可调用对象	//ta是被复制到了线程中（拷贝构造），主线程结束后这个被复杂的对象依然存在；只要没有引用、指针就不会有问题；</span></span><br><span class="line">	myjob.<span class="built_in">join</span>();<span class="comment">//等待线程结束</span></span><br><span class="line">	<span class="comment">//如果用detach()，因为有局部变量ta，且构造函数里是引用，主线程运行结束后会回收这块局部变量ta的内存，在子线程的构造函数里就获取不到这个地址了，会产生不可预料的后果；</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;主线程与子线程汇合&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//用Lambda表达式创建线程：（前提是和test05_03一样在局部作用域中才行，不能赋值给全局变量）</span></span><br><span class="line"><span class="keyword">auto</span> mylamthread = []() <span class="comment">//线程入口</span></span><br><span class="line">&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;Lambda线程开始执行&quot;</span> &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;Lambda线程执行结束&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test05_03</span><span class="params">()</span><span class="comment">//用Lambda表达式创建线程</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function">thread <span class="title">myjob</span><span class="params">(mylamthread)</span></span>;</span><br><span class="line">	myjob.<span class="built_in">join</span>();</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;主线程与子线程汇合&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><h2 id="通过可调用对象创建线程"><a href="#通过可调用对象创建线程" class="headerlink" title="通过可调用对象创建线程"></a>通过可调用对象创建线程</h2><ol><li>函数指针</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">FunctionPtrTask</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;Executed&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">void</span> (*ptr)() = []()  <span class="comment">// 另一种</span></span><br><span class="line">&#123;  </span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Executed&quot;</span> &lt;&lt; endl;  </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function">thread <span class="title">t</span><span class="params">(FunctionPtrTask)</span></span>;</span><br><span class="line">	t.<span class="built_in">join</span>();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>成员函数指针</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">TestClass</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">MemberFunctionTask</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Executed&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	TestClass obj;</span><br><span class="line">	<span class="function">thread <span class="title">t</span><span class="params">(&amp;TestClass::MemberFunctionTask, &amp;obj)</span></span>;</span><br><span class="line">	t.<span class="built_in">join</span>();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>Lambda 表达式</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">	<span class="comment">// Lambda表达式放在全局作用域中会导致类型问题，建议放在局部作用域中使用</span></span><br><span class="line">    <span class="function">thread <span class="title">t</span><span class="params">([]()  </span></span></span><br><span class="line"><span class="params"><span class="function">    &#123;  </span></span></span><br><span class="line"><span class="params"><span class="function">        std::cout &lt;&lt; <span class="string">&quot;Executed&quot;</span> &lt;&lt; endl;  </span></span></span><br><span class="line"><span class="params"><span class="function">    &#125;)</span></span>;  </span><br><span class="line">    t.<span class="built_in">join</span>();  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>或者：<br></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    function&lt;<span class="type">void</span>(<span class="type">void</span>)&gt; Lambda = []()  </span><br><span class="line">    &#123;  </span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Executed&quot;</span> &lt;&lt; endl;  </span><br><span class="line">    &#125;;  </span><br><span class="line">    <span class="function">thread <span class="title">t</span><span class="params">(Lambda)</span></span>;  </span><br><span class="line">    t.<span class="built_in">join</span>();  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>🤔例子：不在同一作用域，有警告<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">function&lt;<span class="type">void</span>(<span class="type">void</span>)&gt; WrongLambda = []()  <span class="comment">//警告</span></span><br><span class="line">&#123;  </span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Executed&quot;</span> &lt;&lt; endl;  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"><span class="built_in">void</span> (*ptr)() = []()  <span class="comment">//函数指针同理</span></span><br><span class="line">&#123;  </span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Executed&quot;</span> &lt;&lt; endl;  </span><br><span class="line">&#125;;</span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="function">thread <span class="title">t</span><span class="params">(WrongLambda)</span></span>;  </span><br><span class="line">    t.<span class="built_in">join</span>();  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><ol><li>仿函数 functor（也叫函数对象）</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Functor</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">()</span>	<span class="comment">//不能带参数</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Executed&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Functor functor;</span><br><span class="line">	<span class="function">thread <span class="title">t</span><span class="params">(functor)</span></span>;</span><br><span class="line">	t.<span class="built_in">join</span>();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>绑定对象（<code>std::bind</code> 创建）</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">FunctionWithArgs</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;a = &quot;</span> &lt;&lt; a &lt;&lt; <span class="string">&quot;,b = &quot;</span> &lt;&lt; b &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">auto</span> BoundFunc = std::<span class="built_in">bind</span>(FunctionWithArgs, <span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">	<span class="function">thread <span class="title">t</span><span class="params">(BoundFunc)</span></span>;</span><br><span class="line">	t.<span class="built_in">join</span>();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="线程参数传递"><a href="#线程参数传递" class="headerlink" title="线程参数传递"></a>线程参数传递</h2><h3 id="通过值传递"><a href="#通过值传递" class="headerlink" title="通过值传递"></a>通过值传递</h3><p>见前文，1-4 都没传递任何参数。如果要值传递参数且不使用 <code>std::bind</code>，参考以下代码：<br></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="built_in">void</span> (*ptr)(<span class="type">int</span>) = [](<span class="type">int</span> x)  </span><br><span class="line">    &#123;  </span><br><span class="line">        std::cout &lt;&lt; x &lt;&lt; endl;  </span><br><span class="line">    &#125;;  </span><br><span class="line">    <span class="function">thread <span class="title">t</span><span class="params">(ptr, <span class="number">45</span>)</span></span>; <span class="comment">//输出45 </span></span><br><span class="line">    t.<span class="built_in">join</span>();  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>或者在使用了 <code>std::bind</code> 的情况下：<br></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">FunctionWithArgs</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;a = &quot;</span> &lt;&lt; a &lt;&lt; <span class="string">&quot;,b = &quot;</span> &lt;&lt; b &lt;&lt; endl;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="keyword">auto</span> BoundFunc = std::<span class="built_in">bind</span>(FunctionWithArgs, <span class="number">1</span>, placeholders::_1);  </span><br><span class="line">    <span class="function">thread <span class="title">t</span><span class="params">(BoundFunc, <span class="number">2</span>)</span></span>; <span class="comment">//a = 1,b = 2  </span></span><br><span class="line">    t.<span class="built_in">join</span>();  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><h3 id="通过引用传递"><a href="#通过引用传递" class="headerlink" title="通过引用传递"></a>通过引用传递</h3><p>这意味着原始数据和线程中使用的数据是同一个实体（而不是副本），这就需要小心了，如果你在一个线程中修改了数据，这些修改将在所有引用该数据的线程中可见。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">ModifyAndPrint</span><span class="params">(<span class="type">int</span>&amp; a, <span class="type">int</span>&amp; b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	a += <span class="number">5</span>;</span><br><span class="line">	b += <span class="number">10</span>;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;Modified Values:&quot;</span> &lt;&lt; a &lt;&lt; <span class="string">&quot;,&quot;</span> &lt;&lt; b &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> x = <span class="number">5</span>;</span><br><span class="line">	<span class="type">int</span> y = <span class="number">10</span>;</span><br><span class="line">	<span class="function">thread <span class="title">t</span><span class="params">(ModifyAndPrint, std::ref(x), std::ref(y))</span></span>;</span><br><span class="line">	t.<span class="built_in">join</span>();</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;Values in main thread: &quot;</span> &lt;&lt; x &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; y &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Modified Values:10,20</span></span><br><span class="line"><span class="comment">//Values in main thread: 10, 20</span></span><br></pre></td></tr></table></figure><p>这里使用了 <code>std::ref</code> 来包装 <code>x</code> 和 <code>y</code> 的引用并进行参数传递。</p><p>🚀注意事项：</p><ul><li>线程安全性：引用传递数据时需要保证对数据的访问是线程安全的，否则可能遇到数据竞争等并发问题。</li><li>资源管理：特别是在新线程使用了动态分配的内存时，确保这些资源在不再需要的时候被正确释放。</li><li>异常处理：新线程中抛出的异常不会自动传播到创建该子线程的线程，所以需要确保在新线程中处理可能产生的所有异常（不要尝试在主线程中捕获子线程中可能产生的异常）。</li></ul><h2 id="join-与-detach-的区别"><a href="#join-与-detach-的区别" class="headerlink" title="join 与 detach 的区别"></a>join 与 detach 的区别</h2><ul><li><strong><code>join</code></strong>：阻塞调用，等待线程完成，适用于需要同步和资源管理的场景。</li><li><strong><code>detach</code></strong>：非阻塞调用，线程独立运行，适用于后台任务或不需要同步的场景。</li><li><strong>必须调用 <code>join</code> 或 <code>detach</code></strong>：否则程序会崩溃。</li><li>调用 <code>join</code> 或 <code>detach</code> 后，线程对象不再与实际线程相关联，线程对象可以安全销毁。</li><li>一个线程对象只能调用一次 <code>join</code> / <code>detach</code> 方法。</li></ul><p>✅表格：</p><div class="table-container"><table><thead><tr><th>特性</th><th>join</th><th>detach</th></tr></thead><tbody><tr><td>阻塞性</td><td>阻塞调用，等待线程完成</td><td>非阻塞调用，立即返回（从主线程分离，和主线程并发执行）</td></tr><tr><td>资源管理</td><td>线程完成后，资源被回收</td><td>线程独立运行，资源由操作系统管理</td></tr><tr><td>线程控制</td><td>主线程需要等待线程完成</td><td>主线程不需要等待线程完成</td></tr><tr><td>线程对象状态</td><td>调用 <code>join</code> 后，线程对象变为无效</td><td>调用 <code>detach</code> 后，线程对象变为无效</td></tr><tr><td>使用场景</td><td>需要等待线程结果或同步时</td><td>线程独立运行，不需要同步（如后台任务）</td></tr></tbody></table></div><p>💻代码示例：<br></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">SayHello</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span>(i &lt; <span class="number">1000</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Hello: &quot;</span> &lt;&lt; i &lt;&lt; endl;</span><br><span class="line">		i++;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function">thread <span class="title">t</span><span class="params">(SayHello)</span></span>;</span><br><span class="line">	t.<span class="built_in">join</span>();	<span class="comment">//阻塞主线程</span></span><br><span class="line">	<span class="comment">//t.detach();	//从主线程中分离出去</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;This is main Thread.&quot;</span> &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用t.join();</span></span><br><span class="line"><span class="comment">//Hello: 0</span></span><br><span class="line"><span class="comment">//Hello: 1</span></span><br><span class="line"><span class="comment">//......</span></span><br><span class="line"><span class="comment">//Hello: 998</span></span><br><span class="line"><span class="comment">//Hello: 999</span></span><br><span class="line"><span class="comment">//This is main Thread.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//使用t.detach();</span></span><br><span class="line"><span class="comment">//This is main Thread.Hello:	//顺序是乱的，因为detach后的线程t和主线程是并发执行的</span></span><br></pre></td></tr></table></figure><p></p><h2 id="主线程包含的内容"><a href="#主线程包含的内容" class="headerlink" title="主线程包含的内容"></a>主线程包含的内容</h2><ol><li>线程 ID：系统中的唯一标识符，区分不同线程。</li><li>线程栈 (Thread Stack)：每个线程</li><li>线程状态：新建 New，就绪 Ready，运行 Running，阻塞 Blocked，终止 Terminated</li><li>线程上下文（Thread Context）</li><li>线程函数（Thread Function）</li><li>线程优先级</li><li>线程属性</li><li>线程同步原语：互斥锁 Mutex、条件变量、信号量 Semaphore，帮助线程在访问共享资源时避免冲突和竞态条件。</li></ol><h2 id="this-thread"><a href="#this-thread" class="headerlink" title="this_thread"></a>this_thread</h2><p><code>std::this_thread</code> 是 C++11 引入的一个<font color="#00b050">命名空间</font>，提供了与当前线程相关的操作。它包含一些静态成员函数，用于获取当前线程的信息或控制当前线程的行为。</p><ol><li><strong>获取当前线程的 ID</strong>：<code>this_thread::get_id()</code></li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">threadFunction</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Thread ID: &quot;</span> &lt;&lt; this_thread::<span class="built_in">get_id</span>() &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">thread <span class="title">t</span><span class="params">(threadFunction)</span></span>;</span><br><span class="line">    t.<span class="built_in">join</span>();</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Main Thread ID: &quot;</span> &lt;&lt; std::this_thread::<span class="built_in">get_id</span>() &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Thread ID: 140234567890176</span></span><br><span class="line"><span class="comment">//Main Thread ID: 140234576282880</span></span><br></pre></td></tr></table></figure><ol><li><strong>暂停当前线程一段时间</strong>：<code>this_thread::sleep_for()</code></li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;chrono&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">threadFunction</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Thread starts&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="comment">// 参数为一个 std::chrono::duration 类型的对象</span></span><br><span class="line">    this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">seconds</span>(<span class="number">2</span>)); <span class="comment">// 暂停2秒</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Thread resumes after 2 seconds&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">thread <span class="title">t</span><span class="params">(threadFunction)</span></span>;</span><br><span class="line">    t.<span class="built_in">join</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li><strong>暂停当前线程到指定时间点</strong>：<code>std::this_thread::sleep_until()</code></li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;chrono&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">threadFunction</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> now = std::chrono::system_clock::<span class="built_in">now</span>();</span><br><span class="line">    <span class="keyword">auto</span> endTime = now + std::chrono::<span class="built_in">seconds</span>(<span class="number">2</span>); <span class="comment">// 当前时间 + 2 秒</span></span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Thread starts&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="comment">// 参数为一个 std::chrono::time_point 类型的对象</span></span><br><span class="line">    this_thread::<span class="built_in">sleep_until</span>(endTime); <span class="comment">// 暂停到指定时间点</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Thread resumes after 2 seconds&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">thread <span class="title">t</span><span class="params">(threadFunction)</span></span>;</span><br><span class="line">    t.<span class="built_in">join</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Thread starts</span></span><br><span class="line"><span class="comment">//Thread resumes after 2 seconds</span></span><br></pre></td></tr></table></figure><ol><li><strong>主动让出 CPU 时间片</strong>：<code>std::this_thread::yield()</code></li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">threadFunction</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; ++i) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Thread is running&quot;</span> &lt;&lt; endl;</span><br><span class="line">        this_thread::<span class="built_in">yield</span>(); <span class="comment">// 让出CPU时间片，允许其他线程运行。用于实现线程的协作式调度，避免长时间占用CPU</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">thread <span class="title">t</span><span class="params">(threadFunction)</span></span>;</span><br><span class="line">    t.<span class="built_in">join</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="线程同步"><a href="#线程同步" class="headerlink" title="线程同步"></a>线程同步</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>线程同步（Thread Synchronization）是指通过一定机制来<font color="#00b050">控制多个线程之间的执行顺序，以确保它们能够正确地访问和修改共享资源</font>，从而避免数据竞争和不一致性问题。<br><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://i.imgur.com/dXCWFZc.png" alt="|861"><br>✅C++提供了多种线程同步机制（重要）：</p><ol><li><strong>互斥锁（Mutex）</strong>：当一个线程想要访问共享资源时，它<font color="#00b050">首先会尝试获取与该资源关联的互斥锁</font>。如果锁已经被其他线程持有，则该线程被阻塞，直到锁被释放。这样可以确保任何时候只有一个线程能够访问共享资源。包含于头文件 <code>&lt;mutex&gt;</code> 中。</li><li><strong>条件变量（Condition Value）</strong>：使线程在满足某条件前等待，通常与互斥锁一起使用，以便在<font color="#00b050">等待条件成立时释放锁，并在条件成立时创建锁</font>。这允许线程在等待期间不占用锁，提高并发性能。包含于头文件 <code>&lt;condition_variable&gt;</code> 中。</li><li><strong>信号量（Semaphore）</strong>：允许<font color="#00b050">多个线程同时访问共享资源，但限制同时访问的线程数量</font>。信号量内部维护一个计数器，用于表示可用资源的数量。当线程需要访问资源时，它会尝试减少计数器的值；当线程释放资源时，它会增加计数器的值。当计数器的值小于零时，尝试获取资源的线程将被阻塞。（PV 操作）</li><li><strong>原子操作（Atomic Operations）</strong>：原子操作是不可中断的操作（执行过程中<font color="#00b050">不会被其他线程打断</font>），用于安全地更新共享数据，而<font color="#00b050">无需使用互斥锁等同步机制</font>。包含于 C++11 及以后的头文件 <code>&lt;atomic&gt;</code> 中。</li><li><strong>读写锁</strong>：允许<font color="#00b050">多个线程同时读取</font>，但只允许<font color="#00b050">一个线程写入</font>。</li><li><strong>栅栏（Barrier）</strong>：用于协调多个线程的执行，使得它们<font color="#00b050">在某个同步点等待</font>，直到所有线程都到达该点（C++20 新特性）。</li></ol><h2 id="🚩互斥锁-mutex"><a href="#🚩互斥锁-mutex" class="headerlink" title="🚩互斥锁 mutex"></a>🚩互斥锁 mutex</h2><blockquote><p>当一个线程想要访问共享资源时，它<font color="#00b050">首先会尝试获取与该资源关联的互斥锁</font>。如果锁已经被其他线程持有，则该线程被阻塞，直到锁被释放。这样可以确保任何时候只有一个线程能够访问共享资源。</p></blockquote><p>💻代码示例：</p><p>未引入互斥锁时：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//共享变量</span></span><br><span class="line"><span class="type">int</span> counter = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">increment_counter</span><span class="params">(<span class="type">int</span> times)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; times; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//数据竞争，多个线程可能同时执行这行代码</span></span><br><span class="line">		counter++;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function">thread <span class="title">t1</span><span class="params">(increment_counter, <span class="number">100000</span>)</span></span>;</span><br><span class="line">	<span class="function">thread <span class="title">t2</span><span class="params">(increment_counter, <span class="number">100000</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">	t1.<span class="built_in">join</span>();</span><br><span class="line">	t2.<span class="built_in">join</span>();</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;最终结果：&quot;</span> &lt;&lt; counter &lt;&lt; endl;	<span class="comment">// 145593</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>🚩引入互斥锁（需要头文件 <code>&lt;mutex&gt;</code>）：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> counter = <span class="number">0</span>;  </span><br><span class="line">mutex mtx;  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">increment_counter</span><span class="params">(<span class="type">int</span> times)</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; times; i++)  </span><br><span class="line">    &#123;  </span><br><span class="line">        mtx.<span class="built_in">lock</span>();	<span class="comment">//访问临界变量前先加锁  </span></span><br><span class="line">        counter++;  </span><br><span class="line">        mtx.<span class="built_in">unlock</span>();   <span class="comment">//访问完成，解锁  </span></span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="function">thread <span class="title">t1</span><span class="params">(increment_counter, <span class="number">100000</span>)</span></span>;  </span><br><span class="line">    <span class="function">thread <span class="title">t2</span><span class="params">(increment_counter, <span class="number">100000</span>)</span></span>;  </span><br><span class="line">  </span><br><span class="line">    t1.<span class="built_in">join</span>();  </span><br><span class="line">    t2.<span class="built_in">join</span>();  </span><br><span class="line">  </span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;最终结果：&quot;</span> &lt;&lt; counter &lt;&lt; endl; <span class="comment">// 200000  </span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><ol><li><strong>死锁</strong>：<br>如果线程在持有互斥量的情况下调用了另一个阻塞操作（如另一个互斥量的 <code>lock()</code>），并且这个阻塞操作永远不会完成（因为其他线程持有它需要的资源），那么就会发生死锁。避免死锁的一种方法是始终<font color="#00b050">按照相同的顺序锁定互斥量</font>，或者使用更高级的<font color="#00b050">同步原语</font>，如 <code>std::lock_guard</code> 或 <code>std::unique_lock</code>，它们可以自动管理锁的获取和释放。</li><li><strong>异常安全</strong>：<br>如果在锁定互斥量后抛出异常，那么必须确保互斥量被正确解锁。使用 <code>std::lock_guard</code> 或 <code>std::unique_lock</code> 可以自动处理这种情况，因为它们在析构时会释放锁。</li><li><strong>不要手动解锁未锁定的互斥量</strong>：<br>调用 <code>unlock</code> 之前，必须确保互斥量已经被 <code>lock</code> 锁定。否则该行为是未定义的。</li><li><strong>不要多次锁定同一个互斥量</strong>：<br>对于非递归互斥量（如 <code>std::mutex</code>），不要在同一线程中多次锁定它，这会导致未定义行为。如果需要递归锁定，使用 <code>std::recursive_mutex</code>。</li><li><strong>使用 RAII 管理锁</strong>：<br>使用 RAII（资源获取即初始化）原则来管理锁的生命周期，通过 <code>std::lock_guard</code> 或者 <code>std::unique_lock</code> 来确保锁在不需要时自动释放。</li><li><strong>避免长时间持有锁</strong>：<br>尽量缩短持有锁的时间，以<font color="#00b050">减少线程之间的争用</font>，提高程序并发性能。</li><li><strong>考虑使用更高级的同步原语</strong>：<br>除了 <code>std::mutex</code>，还可以使用条件变量 <code>std::condition_variable</code>、读写锁 <code>std::shared_mutex</code> 等等。</li></ol><p>🚀使用 <code>std::lock_guard</code> 或 <code>std::unique_lock</code>（遵循 RAII 原则）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span>  </span></span><br><span class="line">  </span><br><span class="line">std::mutex mtx;  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">SafeFunction</span><span class="params">()</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mtx)</span></span>;  <span class="comment">//锁定互斥量  </span></span><br><span class="line">    <span class="comment">//这里执行需要互斥访问的代码。  </span></span><br><span class="line">    <span class="comment">//如果抛出异常，lock_guard会在析构时自动解锁 mtx    try &#123;  </span></span><br><span class="line">        <span class="keyword">if</span> (<span class="comment">/*一些可能造成异常的代码*/</span>)  </span><br><span class="line">        &#123;  </span><br><span class="line">            <span class="keyword">throw</span> std::<span class="built_in">runtime_error</span>(<span class="string">&quot;An error occurred!&quot;</span>);  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125; <span class="built_in">catch</span> (<span class="type">const</span> std::exception&amp; e)&#123;  </span><br><span class="line">        <span class="comment">//处理异常，不需要担心解锁，lock_guard会处理  </span></span><br><span class="line">        std::cerr &lt;&lt; e.<span class="built_in">what</span>() &lt;&lt; std::endl;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="comment">//lock_guard会在析构/离开作用域时自动解锁 mtx</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="✅关于RAII"><a href="#✅关于RAII" class="headerlink" title="✅关于RAII"></a>✅关于RAII</h3><p>全称为 <strong>Resource Acquisition Is Initialization</strong>（资源获取即初始化）。它是 C++ 中管理资源（如内存、文件句柄、互斥锁等）的一种重要机制。RAII 的核心思想是将资源的获取和释放与对象的生命周期绑定，从而<font color="#00b050">确保资源在对象创建时自动获取，在对象销毁时自动释放</font>。</p><p><strong>优点</strong>：自动管理资源、异常安全、简化代码。</p><p>RAII 的实现依赖于构造和析构函数。💻示例代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">FileHandler</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">FileHandler</span>(<span class="type">const</span> string&amp; filename) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Opening file: &quot;</span> &lt;&lt; filename &lt;&lt; endl;</span><br><span class="line">        <span class="comment">// 模拟打开文件</span></span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">FileHandler</span>() &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Closing file&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="comment">// 模拟关闭文件</span></span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">write</span><span class="params">(<span class="type">const</span> string&amp; data)</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Writing data: &quot;</span> &lt;&lt; data &lt;&lt; endl;</span><br><span class="line">        <span class="comment">// 模拟写入文件</span></span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">FileHandler <span class="title">file</span><span class="params">(<span class="string">&quot;example.txt&quot;</span>)</span></span>; <span class="comment">// 资源获取</span></span><br><span class="line">    file.<span class="built_in">write</span>(<span class="string">&quot;Hello, RAII!&quot;</span>);       <span class="comment">// 使用资源</span></span><br><span class="line">    <span class="comment">// 资源在 file 对象销毁时自动释放</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Opening file: example.txt</span></span><br><span class="line"><span class="comment">//Writing data: Hello, RAII!</span></span><br><span class="line"><span class="comment">//Closing file</span></span><br></pre></td></tr></table></figure><ul><li><strong>构造函数</strong>：在 <code>FileHandler</code> 对象创建时，构造函数会自动打开文件（模拟）。</li><li><strong>析构函数</strong>：在 <code>FileHandler</code> 对象销毁时，析构函数会自动关闭文件（模拟）。</li><li><strong>资源管理</strong>：通过对象的生命周期管理文件的打开和关闭，避免了手动调用 <code>close()</code> 的复杂性。</li></ul><p>🚩RAII 在标准库中应用：</p><ol><li>动态内存管理：<code>unique_ptr</code> 和 <code>shared_ptr</code></li><li>互斥锁管理：<code>lock_guard</code> 和 <code>unique_lock</code></li><li>文件管理: <code>ifstream</code> 和 <code>ofstream</code></li></ol><h3 id="mutex-的四种类型"><a href="#mutex-的四种类型" class="headerlink" title="mutex 的四种类型"></a>mutex 的四种类型</h3><ol><li><strong><code>std::mutex</code></strong>：最基本的互斥锁，适用于简单的资源保护。</li><li><strong><code>std::recursive_mutex</code></strong>：支持递归锁定，适用于递归函数或多次锁定场景。</li><li><strong><code>std::timed_mutex</code></strong>：支持超时锁定，适用于需要避免长时间阻塞的场景。</li><li><strong><code>std::recursive_timed_mutex</code></strong>：结合递归锁定和超时锁定功能，适用于复杂的同步需求。</li></ol><p>💻代码示例：<br><code>recursive_mutex</code>：<br></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line">std::recursive_mutex mtx; <span class="comment">// 定义一个递归互斥锁</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">recursiveFunction</span><span class="params">(<span class="type">int</span> count)</span> </span>&#123;</span><br><span class="line">    <span class="function">std::lock_guard&lt;std::recursive_mutex&gt; <span class="title">lock</span><span class="params">(mtx)</span></span>;	<span class="comment">//锁定互斥量</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Count: &quot;</span> &lt;&lt; count &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">if</span> (count &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">recursiveFunction</span>(count - <span class="number">1</span>); <span class="comment">// 递归调用</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::thread <span class="title">t</span><span class="params">(recursiveFunction, <span class="number">5</span>)</span></span>;</span><br><span class="line">    t.<span class="built_in">join</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//Count: 5</span></span><br><span class="line"><span class="comment">//Count: 4</span></span><br><span class="line"><span class="comment">//Count: 3</span></span><br><span class="line"><span class="comment">//Count: 2</span></span><br><span class="line"><span class="comment">//Count: 1</span></span><br><span class="line"><span class="comment">//Count: 0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//或者：</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">recursiveFunction</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    mtx.<span class="built_in">lock</span>();	<span class="comment">//第一次锁定</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Thread: &quot;</span> &lt;&lt; std::this_thread::<span class="built_in">get_id</span>() &lt;&lt; <span class="string">&quot; locked mutex.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    mtx.<span class="built_in">lock</span>();	<span class="comment">//可以多次锁定</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Thread: &quot;</span> &lt;&lt; std::this_thread::<span class="built_in">get_id</span>() &lt;&lt; <span class="string">&quot; locked mutex.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">	mtx.<span class="built_in">unlock</span>();</span><br><span class="line">	std::cout &lt;&lt; <span class="string">&quot;Thread: &quot;</span> &lt;&lt; std::this_thread::<span class="built_in">get_id</span>() &lt;&lt; <span class="string">&quot; unlocked mutex.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">	mtx.<span class="built_in">unlock</span>();</span><br><span class="line">	std::cout &lt;&lt; <span class="string">&quot;Thread: &quot;</span> &lt;&lt; std::this_thread::<span class="built_in">get_id</span>() &lt;&lt; <span class="string">&quot; unlocked mutex.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p><code>timed_mutex</code>:<br></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;chrono&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line">std::timed_mutex mtx; <span class="comment">// 定义一个定时互斥锁</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">threadFunction</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mtx.<span class="built_in">try_lock_for</span>(std::chrono::<span class="built_in">seconds</span>(<span class="number">1</span>))) &#123; <span class="comment">// 尝试锁定 1 秒，使用try_lock_for或者try_lock_until</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Thread ID: &quot;</span> &lt;&lt; std::this_thread::<span class="built_in">get_id</span>() &lt;&lt; <span class="string">&quot; acquired the lock&quot;</span> &lt;&lt; endl;</span><br><span class="line">        std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">seconds</span>(<span class="number">2</span>)); <span class="comment">// 模拟工作</span></span><br><span class="line">        mtx.<span class="built_in">unlock</span>();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Thread ID: &quot;</span> &lt;&lt; std::this_thread::<span class="built_in">get_id</span>() &lt;&lt; <span class="string">&quot; failed to acquire the lock&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::thread <span class="title">t1</span><span class="params">(threadFunction)</span></span>;</span><br><span class="line">    <span class="function">std::thread <span class="title">t2</span><span class="params">(threadFunction)</span></span>;</span><br><span class="line"></span><br><span class="line">    t1.<span class="built_in">join</span>();</span><br><span class="line">    t2.<span class="built_in">join</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Thread ID: 140234567890176 acquired the lock</span></span><br><span class="line"><span class="comment">//Thread ID: 140234576282880 failed to acquire the lock</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">threadFunction</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> deadline = std::chrono::system_clock::<span class="built_in">now</span>() + std::chrono::<span class="built_in">seconds</span>(<span class="number">1</span>); <span class="comment">// 设置截止时间</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mtx.<span class="built_in">try_lock_until</span>(deadline)) &#123; <span class="comment">// 尝试在截止时间之前获取锁</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Thread ID: &quot;</span> &lt;&lt; std::this_thread::<span class="built_in">get_id</span>() &lt;&lt; <span class="string">&quot; acquired the lock&quot;</span> &lt;&lt; endl;</span><br><span class="line">        std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">seconds</span>(<span class="number">2</span>)); <span class="comment">// 模拟工作</span></span><br><span class="line">        mtx.<span class="built_in">unlock</span>();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Thread ID: &quot;</span> &lt;&lt; std::this_thread::<span class="built_in">get_id</span>() &lt;&lt; <span class="string">&quot; failed to acquire the lock&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p><code>recursive_timed_mutex</code>：<br></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;chrono&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line">std::recursive_timed_mutex mtx; <span class="comment">// 定义一个递归定时互斥锁</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">recursiveFunction</span><span class="params">(<span class="type">int</span> count)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mtx.<span class="built_in">try_lock_for</span>(std::chrono::<span class="built_in">seconds</span>(<span class="number">1</span>))) &#123; <span class="comment">// 尝试锁定 1 秒</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Count: &quot;</span> &lt;&lt; count &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">if</span> (count &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">recursiveFunction</span>(count - <span class="number">1</span>); <span class="comment">// 递归调用</span></span><br><span class="line">        &#125;</span><br><span class="line">        mtx.<span class="built_in">unlock</span>();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Failed to acquire the lock at count: &quot;</span> &lt;&lt; count &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::thread <span class="title">t</span><span class="params">(recursiveFunction, <span class="number">5</span>)</span></span>;</span><br><span class="line">    t.<span class="built_in">join</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Count: 5</span></span><br><span class="line"><span class="comment">//Count: 4</span></span><br><span class="line"><span class="comment">//Count: 3</span></span><br><span class="line"><span class="comment">//Count: 2</span></span><br><span class="line"><span class="comment">//Count: 1</span></span><br><span class="line"><span class="comment">//Count: 0</span></span><br></pre></td></tr></table></figure><p></p><p>（了解）关于 <code>std::chrono</code>：<br>它提供了高精度的时间操作和计时功能，允许开发者以灵活的方式处理时间点和时间段。<code>std::chrono</code> 的核心概念包括 <strong>时间点（time_point）</strong>、<strong>时间段（duration）</strong> 和 <strong>时钟（clock）</strong>。</p><p>常用操作有：<br></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//时间段duration的操作---------------------------------------</span></span><br><span class="line"><span class="comment">//创建时间段</span></span><br><span class="line">std::<span class="function">chrono::seconds <span class="title">sec</span><span class="params">(<span class="number">10</span>)</span></span>;          <span class="comment">// 10 秒</span></span><br><span class="line">std::<span class="function">chrono::milliseconds <span class="title">ms</span><span class="params">(<span class="number">500</span>)</span></span>;     <span class="comment">// 500 毫秒</span></span><br><span class="line">std::<span class="function">chrono::microseconds <span class="title">us</span><span class="params">(<span class="number">1000</span>)</span></span>;    <span class="comment">// 1000 微秒</span></span><br><span class="line"><span class="comment">//时间段转换</span></span><br><span class="line">std::chrono::seconds sec = std::chrono::<span class="built_in">duration_cast</span>&lt;std::chrono::seconds&gt;(ms);</span><br><span class="line"><span class="comment">//时间段运算</span></span><br><span class="line">std::<span class="function">chrono::seconds <span class="title">sec1</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line">std::<span class="function">chrono::seconds <span class="title">sec2</span><span class="params">(<span class="number">20</span>)</span></span>;</span><br><span class="line">std::chrono::seconds sec3 = sec1 + sec2; <span class="comment">// 30 秒</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//时间点time_point的操作--------------------------------------</span></span><br><span class="line"><span class="comment">//获取当前时间点</span></span><br><span class="line"><span class="keyword">auto</span> now = std::chrono::system_clock::<span class="built_in">now</span>();</span><br><span class="line"><span class="comment">//时间点转换为时间戳</span></span><br><span class="line">std::<span class="type">time_t</span> <span class="type">now_time_t</span> = std::chrono::system_clock::<span class="built_in">to_time_t</span>(now);</span><br><span class="line"><span class="comment">//时间点运算</span></span><br><span class="line"><span class="keyword">auto</span> now = std::chrono::system_clock::<span class="built_in">now</span>();</span><br><span class="line"><span class="keyword">auto</span> future = now + std::chrono::<span class="built_in">seconds</span>(<span class="number">10</span>); <span class="comment">// 当前时间 + 10 秒</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//时钟clock的操作--------------------------------------------</span></span><br><span class="line"><span class="comment">//获取当前时间点</span></span><br><span class="line"><span class="keyword">auto</span> now = std::chrono::system_clock::<span class="built_in">now</span>();</span><br><span class="line"><span class="comment">//获取稳定时间点</span></span><br><span class="line"><span class="keyword">auto</span> steady_now = std::chrono::steady_clock::<span class="built_in">now</span>();</span><br></pre></td></tr></table></figure><p></p><h3 id="lock-guard"><a href="#lock-guard" class="headerlink" title="lock_guard"></a>lock_guard</h3><blockquote><p>什么是 <code>lock_guard</code>？为什么需要 <code>lock_guard</code>？</p></blockquote><p><code>lock_guard</code> 是一个模板类，位于 <code>&lt;mutex&gt;</code> 头文件中，符合 RAII 风格，用于管理 <code>mutex</code> 的生命周期，解决了手动管理 <code>mutex</code> 锁定和解锁时可能出现的问题（忘记解锁、异常情况下未解锁等）。<br>可以理解为，<code>lock_guard</code> 是对 mutex 的一种管理封装，它可以更好地管理 mutex。</p><blockquote><p>💻代码示例</p></blockquote><p><strong>通过设定作用域，使得std::lock_guard在合适的地方被析构</strong>（在互斥量锁定到互斥量解锁之间的代码叫做临界区（需要互斥访问共享资源的那段代码称为临界区），临界区范围应该尽可能的小，即lock互斥量后应该尽早unlock），<strong>通过使用{}来调整作用域范围，可使得互斥量m在合适的地方被解锁</strong>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line">mutex m;<span class="comment">//实例化m对象，不要理解为定义变量</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">proc1</span><span class="params">(<span class="type">int</span> a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">lock_guard&lt;mutex&gt; <span class="title">g1</span><span class="params">(m)</span></span>;<span class="comment">//用此语句替换了m.lock()；lock_guard传入一个参数时，该参数为互斥量，此时调用了lock_guard的构造函数，申请锁定m</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;proc1函数正在改写a&quot;</span> &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;原始a为&quot;</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;现在a为&quot;</span> &lt;&lt; a + <span class="number">2</span> &lt;&lt; endl;</span><br><span class="line">&#125;<span class="comment">//此时不需要写m.unlock(),g1出了作用域被释放，自动调用析构函数，于是m被解锁</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">proc2</span><span class="params">(<span class="type">int</span> a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function">lock_guard&lt;mutex&gt; <span class="title">g2</span><span class="params">(m)</span></span>;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;proc2函数正在改写a&quot;</span> &lt;&lt; endl;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;原始a为&quot;</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;现在a为&quot;</span> &lt;&lt; a + <span class="number">1</span> &lt;&lt; endl;</span><br><span class="line">    &#125;<span class="comment">//通过使用&#123;&#125;来调整作用域范围，可使得m在合适的地方被解锁</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;作用域外的内容3&quot;</span> &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;作用域外的内容4&quot;</span> &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;作用域外的内容5&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">0</span>;</span><br><span class="line">    <span class="function">thread <span class="title">t1</span><span class="params">(proc1, a)</span></span>;</span><br><span class="line">    <span class="function">thread <span class="title">t2</span><span class="params">(proc2, a)</span></span>;</span><br><span class="line">    t1.<span class="built_in">join</span>();</span><br><span class="line">    t2.<span class="built_in">join</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//proc1函数正在改写a</span></span><br><span class="line"><span class="comment">//原始a为0</span></span><br><span class="line"><span class="comment">//现在a为2</span></span><br><span class="line"><span class="comment">//proc2函数正在改写a</span></span><br><span class="line"><span class="comment">//原始a为0</span></span><br><span class="line"><span class="comment">//现在a为1</span></span><br><span class="line"><span class="comment">//作用域外的内容3</span></span><br><span class="line"><span class="comment">//作用域外的内容4</span></span><br><span class="line"><span class="comment">//作用域外的内容5</span></span><br></pre></td></tr></table></figure><p><code>std::lock_guard</code> 也可以传入两个参数，第一个参数被 <code>adopt_lock</code> 标识时，表示构造函数中不再进行互斥量锁定，因此<strong>此时需要提前手动锁定</strong>。<br></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line">mutex m;<span class="comment">//实例化m对象，不要理解为定义变量</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">proc1</span><span class="params">(<span class="type">int</span> a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    m.<span class="built_in">lock</span>();<span class="comment">//手动锁定</span></span><br><span class="line">    <span class="function">lock_guard&lt;mutex&gt; <span class="title">g1</span><span class="params">(m, std::adopt_lock)</span></span>;	<span class="comment">// adapt_lock是一个标记(tag)，告诉 lock_guard 互斥锁 m 已经被锁定</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;proc1函数正在改写a&quot;</span> &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;原始a为&quot;</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;现在a为&quot;</span> &lt;&lt; a + <span class="number">2</span> &lt;&lt; endl;</span><br><span class="line">&#125;<span class="comment">//自动解锁</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">proc2</span><span class="params">(<span class="type">int</span> a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">lock_guard&lt;mutex&gt; <span class="title">g2</span><span class="params">(m)</span></span>;<span class="comment">//自动锁定</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;proc2函数正在改写a&quot;</span> &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;原始a为&quot;</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;现在a为&quot;</span> &lt;&lt; a + <span class="number">1</span> &lt;&lt; endl;</span><br><span class="line">&#125;<span class="comment">//自动解锁</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">0</span>;</span><br><span class="line">    <span class="function">thread <span class="title">t1</span><span class="params">(proc1, a)</span></span>;</span><br><span class="line">    <span class="function">thread <span class="title">t2</span><span class="params">(proc2, a)</span></span>;</span><br><span class="line">    t1.<span class="built_in">join</span>();</span><br><span class="line">    t2.<span class="built_in">join</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><ul><li><code>lock_guard</code> 禁用了拷贝构造函数和拷贝复制运算符，所以它<font color="#00b050">不支持拷贝语义</font>，只能通过<font color="#00b050">直接创建对象</font>来使用。这样可以避免多个 <code>lock_guard</code> 对象同时管理同一个互斥锁而导致的错误行为。</li><li><code>lock_guard</code> 仅用于管理 mutex 的锁定和解锁（单一职责），对于更复杂的锁定需求，使用 <code>std::unique_lock</code>。</li></ul><h3 id="unique-lock"><a href="#unique-lock" class="headerlink" title="unique_lock"></a>unique_lock</h3><blockquote><p>为什么需要 <code>unique_lock</code>？</p></blockquote><p><code>mutex</code> 在管理方面有瑕疵，因此使用互斥量封装器 <code>lock_guard</code> 来智能管理 mutex，但其功能较弱，需要功能更加强大的 <code>unique_lock</code>（也叫”灵活锁”）。</p><blockquote><p><code>lock_guard</code> 的瑕疵在于？</p></blockquote><p>下表给出二者区别：</p><div class="table-container"><table><thead><tr><th>特性</th><th>lock_guard</th><th>unique_lock</th></tr></thead><tbody><tr><td>自动锁定</td><td>✅</td><td>✅</td></tr><tr><td>自动解锁</td><td>✅</td><td>✅</td></tr><tr><td>手动加锁</td><td>✅</td><td>✅</td></tr><tr><td>延迟锁定</td><td>不支持</td><td>支持</td></tr><tr><td>手动解锁</td><td>不支持，只能通过作用域自动解锁</td><td>支持</td></tr><tr><td>参数</td><td>支持 adopt_lock</td><td>支持 adopt_lock/try_to_lock/defer_lock</td></tr><tr><td>与条件变量结合</td><td>不支持</td><td>支持</td></tr><tr><td>递归锁</td><td>不支持</td><td>支持</td></tr><tr><td>灵活性</td><td>低</td><td>高</td></tr><tr><td>性能开销</td><td>低</td><td>高</td></tr><tr><td>适用场景</td><td>简单的锁管理</td><td>复杂的锁管理</td></tr></tbody></table></div><h4 id="💻代码示例"><a href="#💻代码示例" class="headerlink" title="💻代码示例"></a>💻代码示例</h4><p>构造（多种锁定策略）</p><ul><li><code>std::defer_lock</code>：延迟锁定，互斥锁在构造时不锁定。需要时调用 <code>lock</code> 手动锁定，结束时自动解锁。</li><li><code>std::try_to_lock</code>：尝试锁定，如果互斥锁已被占用，则立即返回。</li><li><code>std::adopt_lock</code>：接管已经锁定的互斥锁。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">mutex mtx;</span><br><span class="line">timed_mutex TimeMtx;</span><br><span class="line"><span class="function">unique_lock&lt;mutex&gt; <span class="title">lock</span><span class="params">(mtx)</span></span>;	<span class="comment">//自动上锁</span></span><br><span class="line"><span class="function">unique_lock&lt;timed_mutex&gt; <span class="title">TimeLock</span><span class="params">(TimeMtx, std::chrono::seconds(<span class="number">1</span>))</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">unique_lock&lt;mutex&gt; <span class="title">lock1</span><span class="params">(mtx, std::defer_lock)</span></span>;	<span class="comment">//延迟锁定，不要自动锁定</span></span><br><span class="line"><span class="function">unique_lock&lt;mutex&gt; <span class="title">lock2</span><span class="params">(mtx, std::try_to_lock)</span></span>;<span class="comment">//尝试锁定</span></span><br><span class="line"><span class="function">unique_lock&lt;mutex&gt; <span class="title">lock3</span><span class="params">(mtx, std::adopt_lock)</span></span>;	<span class="comment">//接收已经锁定的mutex</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//所有权转移（unique_lock对象之间的转移）</span></span><br><span class="line"><span class="function">unique_lock&lt;mutex&gt; <span class="title">lock4</span><span class="params">(move(lock))</span></span>;	<span class="comment">//所有权转移，此时由lock来管理互斥量mtx</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//判断是否锁成功</span></span><br><span class="line"><span class="keyword">if</span> (lock2.<span class="built_in">owns_lock</span>())</span><br><span class="line">&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;锁成功&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="🚩条件变量-condition-variable"><a href="#🚩条件变量-condition-variable" class="headerlink" title="🚩条件变量 condition_variable"></a>🚩条件变量 condition_variable</h2><blockquote><p>什么是条件变量 <code>std::condition_variable</code>？</p></blockquote><p><code>std::condition_variable</code> 是 C++11 引入的一个同步原语，用于实现线程间的通信和同步。它通常与 <code>std::mutex</code> 配合使用，<font color="#00b050">允许一个线程等待另一个线程的通知</font>，从而实现线程间的协作。</p><blockquote><p>条件变量的使用场景？</p></blockquote><ul><li><strong>生产者-消费者模型</strong>：一个线程生产数据，另一个线程消费数据，通过条件变量实现同步。</li><li><strong>事件通知</strong>：一个线程等待某个事件的发生，另一个线程在事件发生时通知它。</li><li><strong>线程协作</strong>：多个线程需要协作完成任务，通过条件变量实现同步。</li></ul><h3 id="💻代码示例-1"><a href="#💻代码示例-1" class="headerlink" title="💻代码示例"></a>💻代码示例</h3><ul><li><strong>等待（wait）</strong>：一个线程调用 <code>wait()</code> 方法，进入等待状态，直到另一个线程调用 <code>notify_one()</code> 或 <code>notify_all()</code> 通知它。<br>线程进入等待期间，会释放与之关联的互斥锁，允许其他线程访问共享数据。当线程被唤醒后，会重新获取互斥锁并继续执行。</li><li><strong>通知（notify）</strong>：另一个线程调用 <code>notify_one()</code> 或 <code>notify_all()</code> 方法，唤醒等待的线程。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//两个线程交替执行</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;thread&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;mutex&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;condition_variable&gt;</span>  </span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;  </span><br><span class="line">  </span><br><span class="line">mutex mtx;  </span><br><span class="line">condition_variable cv;  </span><br><span class="line"><span class="type">int</span> MyValue = <span class="number">0</span>;  </span><br><span class="line"><span class="type">bool</span> turn = <span class="literal">false</span>;  <span class="comment">//控制哪个线程该执行  </span></span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Increment</span><span class="params">(<span class="type">int</span> thread_id)</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; ++i) &#123;  </span><br><span class="line">        <span class="function">unique_lock&lt;mutex&gt; <span class="title">lock</span><span class="params">(mtx)</span></span>;  </span><br><span class="line">        cv.<span class="built_in">wait</span>(lock, [&amp;] &#123; <span class="keyword">return</span> thread_id == <span class="number">1</span> ? !turn : turn; &#125;);  </span><br><span class="line">        ++MyValue;  </span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Thread &quot;</span> &lt;&lt; thread_id &lt;&lt; <span class="string">&quot; incremented value to: &quot;</span> &lt;&lt; MyValue &lt;&lt; endl;  </span><br><span class="line">        <span class="comment">// 切换turn标志并通知另一个线程  </span></span><br><span class="line">        turn = !turn;  </span><br><span class="line">        cv.<span class="built_in">notify_all</span>();    <span class="comment">//这里只需要notify_one()即可  </span></span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="function">thread <span class="title">t1</span><span class="params">(Increment, <span class="number">1</span>)</span></span>;  </span><br><span class="line">    <span class="function">thread <span class="title">t2</span><span class="params">(Increment, <span class="number">2</span>)</span></span>;  </span><br><span class="line">    t1.<span class="built_in">join</span>();  </span><br><span class="line">    t2.<span class="built_in">join</span>();  </span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Final Value: &quot;</span> &lt;&lt; MyValue &lt;&lt; endl;  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Thread 1 incremented value to: 1</span></span><br><span class="line"><span class="comment">//Thread 2 incremented value to: 2</span></span><br><span class="line"><span class="comment">//Thread 1 incremented value to: 3</span></span><br><span class="line"><span class="comment">//Thread 2 incremented value to: 4</span></span><br><span class="line"><span class="comment">//Thread 1 incremented value to: 5</span></span><br><span class="line"><span class="comment">//Thread 2 incremented value to: 6</span></span><br><span class="line"><span class="comment">//Final Value: 6</span></span><br></pre></td></tr></table></figure><ol><li><code>wait(std::unique_lock&lt;std::mutex&gt;&amp;, Predicate)</code>，其中 <code>Predicate</code> 指可调用对象。</li><li><code>wait_for(std::unique_lock&lt;std::mutex&gt;&amp;, std::chrono::seconds, Predicate)</code>：允许指定一个超时时间，这段时间内没有收到唤醒信号/条件不满足，则函数会返回，并且线程会重新获取互斥锁。</li><li><code>notify_one()</code>：唤醒一个等待的线程，适用于只有一个线程需要被唤醒的场景。<br>例如，生产者-消费者模型中，生产者生产一个数据后，只需要唤醒一个消费者。</li><li><strong><code>notify_all()</code></strong>：唤醒所有等待的线程，适用于多个线程需要被唤醒的场景。<br>例如，多个消费者等待同一个条件变量时，生产者生产数据后，需要唤醒所有消费者。</li></ol><p>代码示例：<br></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//生产者-消费者模型</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;condition_variable&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span>  </span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;  </span><br><span class="line">  </span><br><span class="line">std::mutex mtx; <span class="comment">// 定义一个互斥锁  </span></span><br><span class="line">std::condition_variable cv; <span class="comment">// 定义一个条件变量  </span></span><br><span class="line">std::queue&lt;<span class="type">int</span>&gt; SharedQueue; <span class="comment">// 共享队列 </span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">producer</span><span class="params">(<span class="type">bool</span> notify_all)</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">50000</span>; ++i) &#123;   <span class="comment">//样本数较大时效果更加直观  </span></span><br><span class="line">        <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mtx)</span></span>; <span class="comment">// 自动锁定    </span></span><br><span class="line">		SharedQueue.<span class="built_in">push</span>(i); <span class="comment">// 生产数据    </span></span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Produced: &quot;</span> &lt;&lt; i &lt;&lt; endl;  </span><br><span class="line">        <span class="keyword">if</span> (notify_all) &#123;  </span><br><span class="line">            cv.<span class="built_in">notify_all</span>(); <span class="comment">// 通知所有消费者    </span></span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">            cv.<span class="built_in">notify_one</span>(); <span class="comment">// 通知一个消费者    </span></span><br><span class="line">		&#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">consumer</span><span class="params">(<span class="type">int</span> id)</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;  </span><br><span class="line">        <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mtx)</span></span>; <span class="comment">// 自动锁定    </span></span><br><span class="line">		cv.<span class="built_in">wait</span>(lock, [] &#123; <span class="keyword">return</span> !SharedQueue.<span class="built_in">empty</span>(); &#125;); <span class="comment">// 等待队列非空  </span></span><br><span class="line">        <span class="type">int</span> value = SharedQueue.<span class="built_in">front</span>(); <span class="comment">// 消费数据    </span></span><br><span class="line">		SharedQueue.<span class="built_in">pop</span>();  </span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Consumer &quot;</span> &lt;&lt; id &lt;&lt; <span class="string">&quot; consumed: &quot;</span> &lt;&lt; value &lt;&lt; endl;  </span><br><span class="line">        <span class="keyword">if</span> (value == <span class="number">4</span>) <span class="keyword">break</span>; <span class="comment">// 结束条件  </span></span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">    <span class="type">bool</span> notify_all = <span class="literal">true</span>; <span class="comment">// 选择 notify_all 或 notify_one</span></span><br><span class="line">    <span class="function">std::thread <span class="title">producerThread</span><span class="params">(producer, notify_all)</span></span>;  </span><br><span class="line">    <span class="function">std::thread <span class="title">consumerThread1</span><span class="params">(consumer, <span class="number">1</span>)</span></span>;  </span><br><span class="line">    <span class="function">std::thread <span class="title">consumerThread2</span><span class="params">(consumer, <span class="number">2</span>)</span></span>;  </span><br><span class="line">  </span><br><span class="line">    producerThread.<span class="built_in">join</span>();  </span><br><span class="line">    consumerThread1.<span class="built_in">join</span>();  </span><br><span class="line">    consumerThread2.<span class="built_in">join</span>();  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>选择 <code>notify_one()</code>：等待队列中的第一个线程（和 id 等无关）执行函数<br></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Produced: 0</span><br><span class="line">Produced: 1</span><br><span class="line">Produced: 2</span><br><span class="line">...</span><br><span class="line">Consumer 1 consumed: 0</span><br><span class="line">Consumer 1 consumed: 1</span><br><span class="line">Produced: 9</span><br><span class="line">Produced: 10</span><br><span class="line">Consumer 1 consumed: 3</span><br><span class="line">Consumer 1 consumed: 4</span><br><span class="line">Consumer 1 consumed: 5</span><br><span class="line">...</span><br><span class="line">Consumer 1 consumed: 49999</span><br></pre></td></tr></table></figure><p></p><p>选择 <code>notify_all()</code>：由于消费者线程之间的竞争，很可能出现仅有 consumer 1/2 参与的情况。<br></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Produced: 0</span><br><span class="line">Produced: 1</span><br><span class="line">Produced: 2</span><br><span class="line">...</span><br><span class="line">Consumer 1 consumed: 0</span><br><span class="line">Consumer 1 consumed: 1</span><br><span class="line">Produced: 9</span><br><span class="line">Produced: 10</span><br><span class="line">Consumer 2 consumed: 3</span><br><span class="line">Consumer 2 consumed: 4</span><br><span class="line">Consumer 2 consumed: 5</span><br><span class="line">...</span><br><span class="line">Consumer 1 consumed: 49999</span><br></pre></td></tr></table></figure><br>每次运行的输出结果不会完全一致，但大体逻辑不变。<br><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://i.imgur.com/uqJNdUG.png" alt="|916"><p></p><h2 id="🚩读写锁-shared-mutex"><a href="#🚩读写锁-shared-mutex" class="headerlink" title="🚩读写锁 shared_mutex"></a>🚩读写锁 shared_mutex</h2><h3 id="基本概念-1"><a href="#基本概念-1" class="headerlink" title="基本概念"></a>基本概念</h3><blockquote><p>什么是读写锁？</p></blockquote><p>读写锁（共享锁、独占锁）是一种同步机制，允许多个线程同时读取资源，但是同一时间只允许一个线程写入资源。</p><blockquote><p>基本特征？</p></blockquote><p>读读之间不互斥，写写/读写之间互斥。</p><div class="table-container"><table><thead><tr><th>特性</th><th>描述</th></tr></thead><tbody><tr><td>共享锁</td><td>- 允许多个线程同时持有<br>- 多个线程可以并发地读取共享资源<br>- 不能与独占锁同时持有</td></tr><tr><td>独占锁</td><td>- 只能有一个线程持有<br>- 持有独占锁的线程可以写入共享资源<br>- 当持有独占锁时，其他线程不能持有共享锁或独占锁</td></tr><tr><td>读写分离</td><td>- 读操作和写操作分开处理，提高并发性能<br>- 当持有独占锁时，其他线程不能持有共享锁或独占锁</td></tr><tr><td>互斥性</td><td>- 读写锁中的写操作与其他写操作、读操作互斥<br>- 读操作之间不互斥</td></tr><tr><td>公平性</td><td>- 有些读写锁实现提供公平性机制，确保读线程和写线程不会被长期阻塞</td></tr><tr><td>性能</td><td>- 在<font color="#00b050">读多写少</font>的情况下能显著提高性能<br>- 在写多的情况下，读写锁的性能优势可能不明显</td></tr></tbody></table></div><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><h4 id="shared-mutex"><a href="#shared-mutex" class="headerlink" title="shared_mutex"></a>shared_mutex</h4><p><code>std::shared_mutex</code> 是 C++17 引入的一种互斥锁，支持多读单写的并发访问模式。<br>它允许多个线程同时持有共享锁（读锁），但在持有独占锁时，其他线程不能再持有任何类型的锁。<br><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://i.imgur.com/p13vBAL.png" alt="|566"><br>虽然其存在排他性锁定的成员函数（lock/unlock 等），但是一般使用：<br><code>unique_lock</code> / <code>lock_guard</code> 管理<font color="#00b050">独占锁</font>（排他性锁定），<code>shared_mutex</code> 管理<font color="#00b050">共享锁定</font>。<br><code>unique_lock</code> 和 <code>shared_mutex</code> 都会自动上锁（构造函数实现了）。前者位于头文件 <code>&lt;mutex&gt;</code> 中，后者位于头文件 <code>&lt;shared_mutex&gt;</code> 中。</p><h4 id="shared-lock"><a href="#shared-lock" class="headerlink" title="shared_lock"></a>shared_lock</h4><p>C++17 引入的一种锁管理器，用于管理 <code>shared_mutex</code> 的共享锁。<code>shared_lock</code> 同样可以自动获取和释放锁。<br><code>shared_lock</code> 也称通用共享互斥所有权包装器，<code>unique_lock</code> 也称独占所有权包装器，二者配合使用对 <code>shared_mutex</code> 进行管理，实现读写锁。</p><div class="table-container"><table><thead><tr><th>成员函数</th><th>作用</th></tr></thead><tbody><tr><td><code>std::shared_lock(mutex_type&amp; m)</code></td><td>构造时获取共享锁</td></tr><tr><td><code>std::shared_lock(mutex_type&amp; m, std::defer_lock)</code></td><td>构造时不获取锁</td></tr><tr><td><code>std::shared_lock(mutex_type&amp; m, std::try_to_lock)</code></td><td>构造时尝试获取共享锁</td></tr><tr><td><code>std::shared_lock(mutex_type&amp; m, std::adopt_lock)</code></td><td>构造时认为调用者已经持有共享锁</td></tr><tr><td><code>lock()</code></td><td>获取共享锁</td></tr><tr><td><code>try_lock()</code></td><td>尝试获取共享锁</td></tr><tr><td><code>unlock()</code></td><td>释放共享锁</td></tr><tr><td><code>owns_lock()</code></td><td>返回结果：锁是否被持有</td></tr><tr><td><code>release()</code></td><td>释放锁的所有权，但不解锁</td></tr></tbody></table></div><hr><p>💻代码示例：<br></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;shared_mutex&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span>  </span></span><br><span class="line">  </span><br><span class="line">std::shared_mutex rw_mutex; <span class="comment">// 读写锁  </span></span><br><span class="line"><span class="type">int</span> shared_data = <span class="number">0</span>; <span class="comment">// 共享数据  </span></span><br><span class="line">  </span><br><span class="line"><span class="comment">// 读线程函数  </span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">reader</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">    <span class="function">std::shared_lock <span class="title">lock</span><span class="params">(rw_mutex)</span></span>; <span class="comment">// 申请共享锁  </span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Reader thread: &quot;</span> &lt;&lt; std::this_thread::<span class="built_in">get_id</span>() &lt;&lt; <span class="string">&quot; reads value: &quot;</span> &lt;&lt; shared_data &lt;&lt; std::endl;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">// 写线程函数  </span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">writer</span><span class="params">(<span class="type">int</span> value)</span> </span>&#123;  </span><br><span class="line">    <span class="function">std::unique_lock <span class="title">lock</span><span class="params">(rw_mutex)</span></span>; <span class="comment">// 申请独占锁  </span></span><br><span class="line">    shared_data = value; <span class="comment">// 修改共享数据  </span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Writer thread: &quot;</span> &lt;&lt; std::this_thread::<span class="built_in">get_id</span>() &lt;&lt; <span class="string">&quot; writes value: &quot;</span> &lt;&lt; shared_data &lt;&lt; std::endl;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">    std::vector&lt;std::thread&gt; threads; <span class="comment">// 用于存储线程的向量  </span></span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 创建读线程  </span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; ++i) &#123;  </span><br><span class="line">        threads.<span class="built_in">emplace_back</span>(reader);  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="comment">// 创建写线程  </span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; ++i) &#123;  </span><br><span class="line">        threads.<span class="built_in">emplace_back</span>(writer, i);  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="comment">// 等待所有线程完成  </span></span><br><span class="line">    <span class="keyword">for</span> (std::thread&amp; t : threads) &#123;  </span><br><span class="line">        t.<span class="built_in">join</span>();  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>输出结果：<br><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Reader thread: Reader thread: 3 reads value: Reader thread: 5 reads value: 00</span><br><span class="line">Reader thread: 4 reads value: 0</span><br><span class="line"></span><br><span class="line">Reader thread: 6 reads value: 0</span><br><span class="line">2 reads value: 0</span><br><span class="line">Writer thread: 7 writes value: 0</span><br><span class="line">Writer thread: 8 writes value: 1</span><br></pre></td></tr></table></figure><br>读的输出比较混乱，是因为读与读操作之间并不互斥。<p></p><h2 id="🚩原子变量和原子操作-atomic"><a href="#🚩原子变量和原子操作-atomic" class="headerlink" title="🚩原子变量和原子操作 atomic"></a>🚩原子变量和原子操作 atomic</h2><h3 id="基本概念-2"><a href="#基本概念-2" class="headerlink" title="基本概念"></a>基本概念</h3><blockquote><p>原子变量是什么？</p></blockquote><p>原子变量是指使用 <code>std::atomic</code> 模板类定义的变量，确保在多线程环境中，对变量的读写操作是线程安全的，不会被其他线程中断或干扰。<br></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义原子变量</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;atomic&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">std::atomic&lt;<span class="type">int</span>&gt; <span class="title">atomicInt</span><span class="params">(<span class="number">10</span>)</span></span>;	<span class="comment">//int型的原子变量</span></span><br></pre></td></tr></table></figure><p></p><blockquote><p>原子变量的特性</p></blockquote><ul><li><strong>原子性</strong>：对原子变量的读、写、修改操作是不可分割的，即操作<font color="#00b050">要么完全完成，要么完全不完成</font>。</li><li><strong>无锁</strong>：原子操作<font color="#00b050">不需要锁机制</font>，因此不会引起上下文切换，具有更高的性能。（上下文切换：指操作系统从一个线程转换到另一线程的过程）</li><li><strong>易用性</strong>：标准库提供了原子操作接口，简化了<font color="#00b050">多线程编程中的同步问题</font>。</li></ul><blockquote><p>原子操作是什么？</p></blockquote><p>原子操作是指对原子变量进行的不可分割的操作。不可分割的意思是这些操作要么完全执行，要么完全不执行，不会在执行过程中被其他线程打断。</p><h3 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;atomic&gt;</span>  </span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;  </span><br><span class="line">  </span><br><span class="line">atomic&lt;<span class="type">int</span>&gt; num = <span class="number">0</span>;  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">AddNum</span><span class="params">()</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000000</span>; ++i) &#123;  </span><br><span class="line">        num++;  </span><br><span class="line">        <span class="comment">//num += 1;	//结果为2000000</span></span><br><span class="line">        <span class="comment">//num = num + 1;  //结果为1259262</span></span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">    <span class="function">thread <span class="title">t1</span><span class="params">(AddNum)</span></span>;  </span><br><span class="line">    <span class="function">thread <span class="title">t2</span><span class="params">(AddNum)</span></span>;  </span><br><span class="line">    t1.<span class="built_in">join</span>();  </span><br><span class="line">    t2.<span class="built_in">join</span>();  </span><br><span class="line">    cout &lt;&lt; num &lt;&lt; endl;	<span class="comment">//2000000</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>✅注意：原子变量可以进行原子操作，原子操作才是真正保证变量是线程安全的根本原因。即使使用原子变量，如果进行的不是原子操作，也无法保证线程安全。<br>如果使用 <code>num = num + 1</code>，会发现输出结果并不是预期的 2000000，这是因为该操作并不是原子操作（没有被 <code>atomic</code> 类重载）。</p><h3 id="常见原子操作方法"><a href="#常见原子操作方法" class="headerlink" title="常见原子操作方法"></a>常见原子操作方法</h3><ol><li>加载和存储操作<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> value = atomicInt.<span class="built_in">load</span>();	<span class="comment">//原子加载</span></span><br><span class="line">atomicInt.<span class="built_in">store</span>(<span class="number">10</span>);	<span class="comment">//原子存储</span></span><br></pre></td></tr></table></figure></li><li>读写操作（等价于 load 和 store）<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> value = atomicInt;	<span class="comment">//原子读取</span></span><br><span class="line">atomicInt = <span class="number">10</span>;	<span class="comment">//原子写入</span></span><br></pre></td></tr></table></figure></li><li>自增自减操作<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">atomicInt++;</span><br><span class="line">atomicInt--;</span><br><span class="line">++atomicInt;</span><br><span class="line">--atomicInt;</span><br></pre></td></tr></table></figure></li><li>复合赋值操作<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">atomicInt += <span class="number">5</span>;	<span class="comment">//原子加</span></span><br><span class="line">atomicInt &amp;= <span class="number">3</span>;	<span class="comment">//原子位与</span></span><br></pre></td></tr></table></figure></li><li>高级操作<br><code>compare_exchange</code>：比较当前值和期望值，如果相等则将当前值替换为新值，否则更新期望值。<br><code>fetch_add</code> / <code>fetch_sub</code> / <code>fetch_and</code>：对当前值进行加法/减法/按位与操作，并返回操作前的值。<br><code>exchange</code>：交换当前值和新值，并返回旧值。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> expected = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> desired = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> (atomicInt.<span class="built_in">compare_exchange_strong</span>(expected, desired))</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// 如果atomicInt == expected，则让atomicInt = desired并返回true</span></span><br><span class="line">	<span class="comment">// 否则expected = atomicInt，返回false</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">atomicInt.<span class="built_in">fetch_add</span>(<span class="number">1</span>, memory_order_relaxed);</span><br><span class="line"></span><br><span class="line"><span class="function">std::atomic&lt;<span class="type">int</span>&gt; <span class="title">value</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line"><span class="type">int</span> old_value = value.<span class="built_in">exchange</span>(<span class="number">20</span>); <span class="comment">// 交换值，返回旧值 10，现在value = 20</span></span><br></pre></td></tr></table></figure>以上原子操作仅针对原子变量生效。<h3 id="原子操作的内存序问题"><a href="#原子操作的内存序问题" class="headerlink" title="原子操作的内存序问题"></a>原子操作的内存序问题</h3>原子操作可以指定不同的内存顺序，以控制操作的可见性和排序。<br>内存序不会影响原子操作的原子性，但会影响操作的可见性和顺序。</li></ol><div class="table-container"><table><thead><tr><th>顺序</th><th>特点</th></tr></thead><tbody><tr><td><code>memory_order_relaxed</code></td><td>没有同步或顺序约束，仅保证原子性</td></tr><tr><td><code>memory_order_acquire</code></td><td>确保该操作之前的所有读操作不会被重排序到该操作之后</td></tr><tr><td><code>memory_order_release</code></td><td>确保该操作之后的所有写操作不会被重排序到该操作之前</td></tr><tr><td><code>memory_order_acq_rel</code></td><td>同时具备 acquire 和 release 的属性</td></tr><tr><td><code>memory_order_seq_cst</code></td><td>顺序一致性，保证所有线程的操作按照顺序发生</td></tr></tbody></table></div><h2 id="🚩信号量-semaphore"><a href="#🚩信号量-semaphore" class="headerlink" title="🚩信号量 semaphore"></a>🚩信号量 semaphore</h2><h3 id="基本概念-3"><a href="#基本概念-3" class="headerlink" title="基本概念"></a>基本概念</h3><blockquote><p>什么是信号量？</p></blockquote><p>信号量（Semaphore）是一种用于管理和协调多线程或多进程访问共享资源的同步机制。它<font color="#00b050">通过计数器来控制对资源的访问数量</font>，确保多个线程或进程能够安全地使用共享资源而不会发生数据竞争或死锁。传统的锁（如互斥锁）可以用来保护共享资源，但对于某些场景（如<font color="#00b050">资源的计数管理</font>），信号量提供了更灵活和高效的解决方案。</p><blockquote><p>信号量的类型？</p></blockquote><ol><li>计数信号量：允许对资源的多次访问，计数信号量的值可以是任意非负整数，表示可以同时访问资源的线程或进程的数量。</li><li>二元信号量：也称为互斥信号量 mutex，其值只能是 0 或 1，类似于互斥锁，用于实现对资源的互斥访问。</li></ol><blockquote><p>信号量的作用？</p></blockquote><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://i.imgur.com/dyvLJVP.png" alt="|684"></p><blockquote><p>信号量的基本操作？</p></blockquote><ul><li>P 操作（等待，wait）：如果信号量的值大于 0，则将其减 1，否则线程会被阻塞，直到信号量的值大于 0。</li><li>V 操作（释放，signal）：将信号量的值加 1，如果有线程被阻塞在 P 操作上，则唤醒一个阻塞的线程。<br>PV 操作均为原子操作。类似加锁解锁的操作。<br><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://i.imgur.com/EE1rJR3.png" alt="|590"><h3 id="counting-semaphore"><a href="#counting-semaphore" class="headerlink" title="counting_semaphore"></a>counting_semaphore</h3><code>std::counting_semaphore</code> 是 C++20 标准库中的一个类模板，实现了一个计数信号量。需要头文件 <code>&lt;semaphore&gt;</code><br>禁止拷贝构造，禁止拷贝赋值操作（不允许 <code>a(b)</code> 或者 <code>a = b</code>）。</li></ul><div class="table-container"><table><thead><tr><th>成员函数</th><th>作用</th></tr></thead><tbody><tr><td><code>void acquire()</code></td><td>尝试获取信号量，如果信号量的计数值为 0，则阻塞当前线程，直到计数值大于 0。</td></tr><tr><td><code>bool try_acquire()</code></td><td>- 尝试获取信号量。如果信号量的计数值大于 0，则将其减 1 并返回 <code>true</code>。<br>- 如果计数值为 0，则立即返回 <code>false</code>，不会阻塞。</td></tr><tr><td><code>bool try_acquire_for(const chrono::duration&amp;)</code></td><td>- 如果在指定时间内信号量的计数值大于 0，则将其减 1 并返回 <code>true</code>。<br>- 如果超时仍未获取到信号量，则返回 <code>false</code>。</td></tr><tr><td><code>bool try_acquire_until(const chrono::time_point&amp;)</code></td><td>- 如果在指定时间点之前信号量的计数值大于 0，则将其减 1 并返回 <code>true</code>。<br>- 如果超时仍未获取到信号量，则返回 <code>false</code>。</td></tr><tr><td><code>void release(std::ptrdiff_t update = 1)</code></td><td>释放信号量，增加信号量的计数值。默认加 1。</td></tr></tbody></table></div><p>示例：<br></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;semaphore&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个最大值为 5 的计数信号量</span></span><br><span class="line"><span class="function">std::counting_semaphore&lt;5&gt; <span class="title">semaphore</span><span class="params">(<span class="number">3</span>)</span></span>; <span class="comment">// 初始值为 3</span></span><br><span class="line">semaphore.<span class="built_in">acquire</span>(); <span class="comment">// 计数值减 1，变为 2</span></span><br><span class="line">semaphore.<span class="built_in">release</span>(); <span class="comment">// 计数值增加 1，变为 3</span></span><br><span class="line">semaphore.<span class="built_in">release</span>(<span class="number">2</span>); <span class="comment">// 计数值增加 2，变为 5</span></span><br><span class="line"><span class="comment">// 创建一个动态最大值的计数信号量</span></span><br><span class="line">std::counting_semaphore&lt;&gt; <span class="built_in">dynamic_semaphore</span>(<span class="number">2</span>); <span class="comment">// 初始值为 2</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (semaphore.<span class="built_in">try_acquire_for</span>(std::chrono::<span class="built_in">seconds</span>(<span class="number">1</span>))) &#123;</span><br><span class="line">    <span class="comment">// 成功获取信号量</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 超时未获取到信号量</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><h4 id="💻代码示例-2"><a href="#💻代码示例-2" class="headerlink" title="💻代码示例"></a>💻代码示例</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;semaphore&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span>  </span></span><br><span class="line">  </span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;  </span><br><span class="line">  </span><br><span class="line"><span class="function">std::counting_semaphore&lt;1&gt; <span class="title">sem</span><span class="params">(<span class="number">1</span>)</span></span>;  <span class="comment">//初始值为1的计数信号量; sem.max()为1  </span></span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">worker</span><span class="params">(<span class="type">int</span> id)</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    sem.<span class="built_in">acquire</span>();  <span class="comment">//P操作，等待信号量大于0并将其减1  </span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;worker &quot;</span> &lt;&lt; id &lt;&lt; <span class="string">&quot; is working&quot;</span> &lt;&lt; endl;  </span><br><span class="line">    std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">seconds</span>(<span class="number">1</span>));    <span class="comment">//模拟工作  </span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;worker &quot;</span> &lt;&lt; id &lt;&lt; <span class="string">&quot; is done&quot;</span> &lt;&lt; endl;  </span><br><span class="line">    sem.<span class="built_in">release</span>();  <span class="comment">//V操作，将信号量加1  </span></span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;max &quot;</span> &lt;&lt; sem.<span class="built_in">max</span>() &lt;&lt; endl;  </span><br><span class="line">    vector&lt;thread&gt; threads;  </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; ++i) &#123;  </span><br><span class="line">        threads.<span class="built_in">emplace_back</span>(worker, i);  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">for</span> (thread&amp; t : threads) &#123;  </span><br><span class="line">        t.<span class="built_in">join</span>();  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：<br></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">max 1</span><br><span class="line">worker 0 is working</span><br><span class="line">worker 0 is done</span><br><span class="line">worker 3 is working</span><br><span class="line">worker 3 is done</span><br><span class="line">worker 4 is working</span><br><span class="line">worker 4 is done</span><br><span class="line">worker 1 is working</span><br><span class="line">worker 1 is done</span><br><span class="line">worker 2 is working</span><br><span class="line">worker 2 is done</span><br></pre></td></tr></table></figure><p></p><p>使用多个信号量：<br></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 信号量，用于线程同步，初始计数值为0，用于控制 work 线程的执行</span></span><br><span class="line"><span class="function">std::counting_semaphore&lt;1&gt; <span class="title">ready</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 信号量，用于线程同步，初始计数值为1，用于控制 prepare 线程的执行</span></span><br><span class="line"><span class="function">std::counting_semaphore&lt;1&gt; <span class="title">done</span><span class="params">(<span class="number">1</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">prepare</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    done.<span class="built_in">acquire</span>(); <span class="comment">// 减少信号量 done 的计数值，确保 prepare 在 work 完成之前不再执行</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Preparing...\n&quot;</span>;</span><br><span class="line">    std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">seconds</span>(<span class="number">2</span>)); <span class="comment">// 模拟准备工作的耗时</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Preparation done.\n&quot;</span>;</span><br><span class="line">    ready.<span class="built_in">release</span>(); <span class="comment">// 增加信号量 ready 的计数值，通知 work 线程可以开始工作</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">work</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ready.<span class="built_in">acquire</span>(); <span class="comment">// 等待 ready 信号量，确保准备工作完成后再执行</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Working...\n&quot;</span>;</span><br><span class="line">    std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">seconds</span>(<span class="number">2</span>)); <span class="comment">// 模拟工作的耗时</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Work done.\n&quot;</span>;</span><br><span class="line">    done.<span class="built_in">release</span>(); <span class="comment">// 增加信号量 done 的计数值，通知 prepare 线程可以重新进入准备阶段</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::thread <span class="title">t1</span><span class="params">(prepare)</span></span>; <span class="comment">// 创建 prepare 线程，执行准备工作</span></span><br><span class="line">    <span class="function">std::thread <span class="title">t2</span><span class="params">(work)</span></span>; <span class="comment">// 创建 work 线程，执行主要工作</span></span><br><span class="line"></span><br><span class="line">    t1.<span class="built_in">join</span>(); <span class="comment">// 等待 prepare 线程执行完成</span></span><br><span class="line">    t2.<span class="built_in">join</span>(); <span class="comment">// 等待 work 线程执行完成</span></span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;All tasks completed.\n&quot;</span>; <span class="comment">// 所有工作完成</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>输出结果：<br><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Preparing...</span><br><span class="line">Preparation done.</span><br><span class="line">Working...</span><br><span class="line">Work done.</span><br><span class="line">All tasks completed.</span><br></pre></td></tr></table></figure><p></p><h2 id="栅栏-barrier"><a href="#栅栏-barrier" class="headerlink" title="栅栏 barrier"></a>栅栏 barrier</h2><h3 id="基本概念-4"><a href="#基本概念-4" class="headerlink" title="基本概念"></a>基本概念</h3><blockquote><p>什么是栅栏？</p></blockquote><p>栅栏是一种同步原语，用于协调多个线程的执行，使得它们能够<font color="#00b050">在某个特定的点（即栅栏）等待</font>。直到所有线程都达到这一个点，才能继续执行。<br>位于 C++20 的头文件 <code>&lt;barrier&gt;</code> 中。</p><blockquote><p>栅栏的作用？</p></blockquote><p>确保并发任务在某些关键时刻同步，比如等待所有线程完成某个阶段的工作，然后再进入下一阶段。<br><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://i.imgur.com/kD6MTES.png" alt="|807"><br>用于阶段同步和批处理。</p><blockquote><p>栅栏的特点？</p></blockquote><ol><li><strong>同步点</strong>：栅栏用于创建一个同步点，确保多个线程在同一时刻同步。</li><li><strong>计数器</strong>：栅栏内部维护一个计数器，记录到达栅栏的线程数量。当计数器达到预设值时，所有等待的线程被同时唤醒。</li><li><strong>可重用性</strong>：C++20 中的 <code>std::barrier</code> 是可重用的，线程可以反复使用同一个栅栏对象进行同步。</li></ol><h3 id="💻代码实现"><a href="#💻代码实现" class="headerlink" title="💻代码实现"></a>💻代码实现</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span>    </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;barrier&gt;</span>  </span></span><br><span class="line">  </span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">worker</span><span class="params">(<span class="type">int</span> id, std::barrier&lt;&gt;&amp; sync_point)</span> <span class="comment">//同步点需要为引用  </span></span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Worker &quot;</span> &lt;&lt; id &lt;&lt; <span class="string">&quot; is doing phase 1 work.\n&quot;</span>;  </span><br><span class="line">    std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">milliseconds</span>(<span class="number">100</span> * id));   <span class="comment">//模拟不同的工作时间  </span></span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 到达栅栏，等待其他线程  </span></span><br><span class="line">    sync_point.<span class="built_in">arrive_and_wait</span>();  </span><br><span class="line">  </span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Worker &quot;</span> &lt;&lt; id &lt;&lt; <span class="string">&quot; has completed phase 1 and is doing phase 2 work.\n&quot;</span>;  </span><br><span class="line">    std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">milliseconds</span>(<span class="number">100</span> * id));   <span class="comment">//模拟不同的工作时间  </span></span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> num_threads = <span class="number">5</span>;  </span><br><span class="line">    <span class="function">std::barrier <span class="title">sync_point</span><span class="params">(num_threads)</span></span>;   <span class="comment">//创建barrier对象，记录同步点  </span></span><br><span class="line">  </span><br><span class="line">    vector&lt;thread&gt; threads;  </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= num_threads; ++i) &#123;  </span><br><span class="line">        threads.<span class="built_in">emplace_back</span>(worker, i, std::<span class="built_in">ref</span>(sync_point));  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">for</span> (thread&amp; t : threads)&#123;  </span><br><span class="line">        t.<span class="built_in">join</span>();  </span><br><span class="line">    &#125;  </span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;All tasks completed.\n&quot;</span>; <span class="comment">// 所有工作完成  </span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：<br></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Worker Worker 2 is doing phase 1 work.</span><br><span class="line">1 is doing phase 1 work.</span><br><span class="line">Worker 3 is doing phase 1 work.</span><br><span class="line">Worker 4 is doing phase 1 work.</span><br><span class="line">Worker 5 is doing phase 1 work.</span><br><span class="line">Worker Worker 5 has completed phase 1 and is doing phase 2 work.</span><br><span class="line">Worker 1 has completed phase 1 and is doing phase 2 work.</span><br><span class="line">Worker 3 has completed phase 1 and is doing phase 2 work.</span><br><span class="line">4 has completed phase 1 and is doing phase 2 work.</span><br><span class="line">Worker 2 has completed phase 1 and is doing phase 2 work.</span><br><span class="line">All tasks completed.</span><br></pre></td></tr></table></figure><p></p><h2 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h2><blockquote><p>什么是死锁？</p></blockquote><p>死锁是指两个或者多个进程<font color="#00b050">互相等待对方释放资源</font>，从而导致所有进程或线程都无法继续执行的现象。<br><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://i.imgur.com/tSbM0ar.png" alt="|647"></p><blockquote><p>死锁的必要条件？</p></blockquote><ol><li><strong>互斥</strong>：资源一次只能被一个资源占用。</li><li><strong>请求和保持</strong>：线程已经持有至少一个资源，同时又申请新的资源，而新资源已经被其他线程占有。</li><li><strong>不剥夺</strong>：已经获得的资源在未使用完之前，不能被强行剥夺，只能在使用完毕后自己释放。</li><li><strong>循环等待</strong>：存在一个线程循环的链，链中的每个线程都持有下一个线程需要的资源。<br>要想解决死锁这一问题，就需要避开上面四点，可以使用高级同步工具（如 <code>unique_lock</code> 等）。</li></ol><h3 id="💻代码示例-3"><a href="#💻代码示例-3" class="headerlink" title="💻代码示例"></a>💻代码示例</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//当线程1 持有 mtx1 并等待 mtx2 时，线程2 持有 mtx2 并等待 mtx1。</span></span><br><span class="line"><span class="comment">//两个线程互相等待对方释放锁，导致死锁</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"></span><br><span class="line">std::mutex mtx1; <span class="comment">// 第一个互斥锁</span></span><br><span class="line">std::mutex mtx2; <span class="comment">// 第二个互斥锁</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">thread1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock1</span><span class="params">(mtx1)</span></span>; <span class="comment">// 先锁定 mtx1</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Thread 1 acquired mtx1\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 模拟一些工作</span></span><br><span class="line">    std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">milliseconds</span>(<span class="number">100</span>));</span><br><span class="line"></span><br><span class="line">    <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock2</span><span class="params">(mtx2)</span></span>; <span class="comment">// 再锁定 mtx2</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Thread 1 acquired mtx2\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">thread2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock2</span><span class="params">(mtx2)</span></span>; <span class="comment">// 先锁定 mtx2</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Thread 2 acquired mtx2\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 模拟一些工作</span></span><br><span class="line">    std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">milliseconds</span>(<span class="number">100</span>));</span><br><span class="line"></span><br><span class="line">    <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock1</span><span class="params">(mtx1)</span></span>; <span class="comment">// 再锁定 mtx1</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Thread 2 acquired mtx1\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::thread <span class="title">t1</span><span class="params">(thread1)</span></span>;</span><br><span class="line">    <span class="function">std::thread <span class="title">t2</span><span class="params">(thread2)</span></span>;</span><br><span class="line"></span><br><span class="line">    t1.<span class="built_in">join</span>();</span><br><span class="line">    t2.<span class="built_in">join</span>();</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;All threads completed.\n&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Thread 1 acquired mtx1</span></span><br><span class="line"><span class="comment">//Thread 2 acquired mtx2</span></span><br><span class="line"><span class="comment">//导致死锁</span></span><br></pre></td></tr></table></figure><ol><li><p>同时锁定两个锁</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">thread1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">lock</span>(mtx1, mtx2); <span class="comment">// 同时锁定 mtx1 和 mtx2</span></span><br><span class="line">    <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock1</span><span class="params">(mtx1, std::adopt_lock)</span></span>;</span><br><span class="line">    <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock2</span><span class="params">(mtx2, std::adopt_lock)</span></span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Thread 1 acquired both locks\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">thread2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::<span class="built_in">lock</span>(mtx1, mtx2); <span class="comment">// 同时锁定 mtx1 和 mtx2</span></span><br><span class="line">    <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock1</span><span class="params">(mtx1, std::adopt_lock)</span></span>;</span><br><span class="line">    <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock2</span><span class="params">(mtx2, std::adopt_lock)</span></span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Thread 2 acquired both locks\n&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>统一锁定顺序</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">thread1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock1</span><span class="params">(mtx1)</span></span>; <span class="comment">// 先锁定 mtx1</span></span><br><span class="line">    <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock2</span><span class="params">(mtx2)</span></span>; <span class="comment">// 再锁定 mtx2</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Thread 1 acquired both locks\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">thread2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock1</span><span class="params">(mtx1)</span></span>; <span class="comment">// 先锁定 mtx1</span></span><br><span class="line">    <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock2</span><span class="params">(mtx2)</span></span>; <span class="comment">// 再锁定 mtx2</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Thread 2 acquired both locks\n&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>使用 <code>std::unique_lock</code> 和 <code>std::defer_lock</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">thread1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock1</span><span class="params">(mtx1, std::defer_lock)</span></span>;</span><br><span class="line">    <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock2</span><span class="params">(mtx2, std::defer_lock)</span></span>;</span><br><span class="line">    std::<span class="built_in">lock</span>(lock1, lock2); <span class="comment">// 同时锁定</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Thread 1 acquired both locks\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">thread2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock1</span><span class="params">(mtx1, std::defer_lock)</span></span>;</span><br><span class="line">    <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock2</span><span class="params">(mtx2, std::defer_lock)</span></span>;</span><br><span class="line">    std::<span class="built_in">lock</span>(lock1, lock2); <span class="comment">// 同时锁定</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Thread 2 acquired both locks\n&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h1 id="异步编程"><a href="#异步编程" class="headerlink" title="异步编程"></a>异步编程</h1><h2 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h2><blockquote><p>什么是异步？</p></blockquote><p>允许程序在等待某些操作完成时继续执行其他任务，而不是阻塞或等待这些操作完成。</p><blockquote><p>异步编程的优点？为什么选择异步编程？</p></blockquote><ul><li><strong>提高性能</strong>：通过并发执行多个任务，异步编程可以更高效地利用 CPU 资源。</li><li><strong>提高响应速度</strong>：异步编程时程序在等待某些操作完成时继续响应用户输入，提高用户体验。</li><li><strong>简化 I/O 操作</strong>：异步编程非常适合处理 I/O 密集型操作，比如文件读取、网络请求等。</li></ul><h2 id="🚩async"><a href="#🚩async" class="headerlink" title="🚩async"></a>🚩async</h2><h3 id="基本概念-5"><a href="#基本概念-5" class="headerlink" title="基本概念"></a>基本概念</h3><blockquote><p>什么是 <code>async</code>？</p></blockquote><p><code>async</code> 是一个函数模板，包含在头文件 <code>&lt;future&gt;</code> 中，用于启动一个异步任务。<br>它接受一个可调用对象作为参数，并在一个单独的线程上异步执行该对象。<br><code>std::async</code> <strong>自动管理异步任务的生命周期</strong>，并返回一个 <code>std::future</code> 对象，该对象可用于获取异步操作的结果。</p><blockquote><p>什么是 <code>future</code>？</p></blockquote><p><code>std::future</code> 是一个模板类，用于表示异步操作的结果。<br><code>std::future</code> 对象需要借助 <code>std::async</code>、<code>std::promise</code>、<code>std::packaged_task</code> 结合使用。</p><h3 id="💻代码实现-1"><a href="#💻代码实现-1" class="headerlink" title="💻代码实现"></a>💻代码实现</h3><p>🚀<code>future</code> 的基本成员函数：</p><div class="table-container"><table><thead><tr><th>成员函数</th><th>作用</th></tr></thead><tbody><tr><td><code>get()</code></td><td>获取异步任务的返回值。如果任务尚未完成，会阻塞直到任务完成。</td></tr><tr><td><code>wait()</code></td><td>等待异步任务完成，但不获取返回值。</td></tr><tr><td><code>wait_for()</code></td><td>等待异步任务完成，直到指定的时间。<br>如果任务在指定时间内完成，返回 <code>std::future_status::ready</code>；<br>如果任务未完成，返回 <code>std::future_status::timeout</code>。</td></tr><tr><td><code>wait_until()</code></td><td>等待异步任务完成，直到指定的时间点。<br>如果任务在指定时间点前完成，返回 <code>std::future_status::ready</code>；<br>如果任务未完成，返回 <code>std::future_status::timeout</code>。</td></tr><tr><td><code>valid()</code></td><td>检查 <code>std::future</code> 对象是否持有有效的异步任务。<br>如果对象有效，返回 <code>true</code>；否则返回 <code>false</code>。</td></tr><tr><td><code>share()</code></td><td>返回一个 <code>std::shared_future</code> 对象，允许多个线程共享异步任务的结果。</td></tr></tbody></table></div><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;future&gt;</span>  </span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">myfunc</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;  </span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;This is myfunc&quot;</span> &lt;&lt; <span class="string">&quot; &quot;</span>;  </span><br><span class="line">    <span class="keyword">return</span> a + b;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">    <span class="comment">// async的返回对象必须要赋值使用，不能直接async(myfunc, 1, 2);  </span></span><br><span class="line">    future&lt;<span class="type">int</span>&gt; MyFunc = <span class="built_in">async</span>(myfunc, <span class="number">1</span>, <span class="number">2</span>);	<span class="comment">/* 等价于 thread t(myfunc, 1, 2); t.join(); 所以会输出&quot;This is my func&quot; */</span>    </span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;MyFunc == &quot;</span> &lt;&lt; MyFunc.<span class="built_in">get</span>() &lt;&lt; <span class="string">&quot; test&quot;</span> &lt;&lt; endl;  <span class="comment">// MyFunc.get()的返回值为3</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">//MyFunc == This is myfunc 3 test	//输出顺序不固定，但test一定在3之后输出，3一定在两句以后输出</span></span><br></pre></td></tr></table></figure><p>✅注意：</p><ul><li><code>get()</code> <font color="#00b050">等待异步操作完成</font>后，再获取结果。如果异步操作尚未完成，调用 <code>get()</code> 的线程将被阻塞，直到操作完成。</li><li>一旦调用 <code>get()</code>，它将返回异步操作的结果，并且 <code>future</code> 对象<font color="#00b050">将变为无效状态</font>，不能再调用 <code>get()</code>。一个 <code>future</code> 对象只能调用一次 <code>get()</code>。</li><li><code>wait()</code> 等待异步操作完成，但不获取结果。与 <code>get()</code> 不同之处在于，调用 <code>wait()</code> 后，<code>future</code> 对象仍然有效，可以继续使用 <code>get()</code> 来获取结果。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;future&gt;</span>  </span></span><br><span class="line">  </span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">myfunc</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;  </span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;This is myfunc &quot;</span>;  </span><br><span class="line">    <span class="keyword">return</span> a + b;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">    future&lt;<span class="type">int</span>&gt; MyFunc = <span class="built_in">async</span>(myfunc, <span class="number">1</span>, <span class="number">2</span>);  </span><br><span class="line">    MyFunc.<span class="built_in">wait</span>();  <span class="comment">//等待异步操作完成，之后进行下一步操作</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;MyFunc == &quot;</span> &lt;&lt; MyFunc.<span class="built_in">get</span>() &lt;&lt; <span class="string">&quot; test&quot;</span> &lt;&lt; endl;  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">//This is myfunc MyFunc == 3 test	//此时输出顺序固定</span></span><br></pre></td></tr></table></figure><h3 id="三种启动策略"><a href="#三种启动策略" class="headerlink" title="三种启动策略"></a>三种启动策略</h3><div class="table-container"><table><thead><tr><th>启动策略</th><th>是否创建新线程</th><th>任务执行时机</th><th>适用场景</th></tr></thead><tbody><tr><td><code>std::launch::async</code></td><td>是</td><td>立即执行，创建新线程</td><td>需要并发执行的任务，任务可以立即开始执行。</td></tr><tr><td><code>std::launch::deferred</code></td><td>否</td><td>延迟执行，调用 <code>get()</code> 或 <code>wait()</code> 时</td><td>不需要立即执行的任务，任务可以在需要时才执行。</td></tr><tr><td>默认</td><td>由实现决定</td><td>由实现决定</td><td>不确定任务是否需要立即执行，由实现自动选择执行方式。</td></tr></tbody></table></div><ol><li><p><code>launch::async</code>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span>   <span class="comment">// this_thread需要头文件和std命名空间  </span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;future&gt;</span>  </span></span><br><span class="line">  </span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">myfunc</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;  </span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;This is myfunc: &quot;</span> &lt;&lt; this_thread::<span class="built_in">get_id</span>() &lt;&lt; endl;  </span><br><span class="line">    <span class="keyword">return</span> a + b;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">    future&lt;<span class="type">int</span>&gt; MyFunc = <span class="built_in">async</span>(launch::async, myfunc, <span class="number">1</span>, <span class="number">2</span>);  </span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;This is main: &quot;</span> &lt;&lt; this_thread::<span class="built_in">get_id</span>() &lt;&lt; endl;  </span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;This is from myfunc: &quot;</span> &lt;&lt; MyFunc.<span class="built_in">get</span>() &lt;&lt; endl;  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">//This is main: This is myfunc: 21  </span></span><br><span class="line"><span class="comment">//This is from myfunc:  </span></span><br><span class="line"><span class="comment">//3</span></span><br></pre></td></tr></table></figure><p>这里由于策略原因，多句话立即同时执行了，<code>async</code> 创建的新线程和主线程同时进行。<br>加上 <code>wait()</code> 即可观察正确的线程 id：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">    future&lt;<span class="type">int</span>&gt; MyFunc = <span class="built_in">async</span>(launch::async, myfunc, <span class="number">1</span>, <span class="number">2</span>);  </span><br><span class="line">    MyFunc.<span class="built_in">wait</span>();  </span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;This is main: &quot;</span> &lt;&lt; this_thread::<span class="built_in">get_id</span>() &lt;&lt; endl;  </span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;This is from myfunc: &quot;</span> &lt;&lt; MyFunc.<span class="built_in">get</span>() &lt;&lt; endl;  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">//This is myfunc: 2  </span></span><br><span class="line"><span class="comment">//This is main: 1  </span></span><br><span class="line"><span class="comment">//This is from myfunc: 3</span></span><br></pre></td></tr></table></figure></li><li><p><code>launch::deferred</code>：<br>需要注意的是，可能隐藏潜在的并发问题，因为任务可能在查询结果时才执行。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">    future&lt;<span class="type">int</span>&gt; MyFunc = <span class="built_in">async</span>(launch::deferred, myfunc, <span class="number">1</span>, <span class="number">2</span>);  </span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;This is main: &quot;</span> &lt;&lt; this_thread::<span class="built_in">get_id</span>() &lt;&lt; endl;  </span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;This is from myfunc: &quot;</span> &lt;&lt; MyFunc.<span class="built_in">get</span>() &lt;&lt; endl;  <span class="comment">// 调用get()方法时才执行myfunc()</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">//This is main: 1  </span></span><br><span class="line"><span class="comment">//This is from myfunc: This is myfunc: 1  </span></span><br><span class="line"><span class="comment">//3</span></span><br></pre></td></tr></table></figure><p>加入 <code>wait</code> 方法：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">    future&lt;<span class="type">int</span>&gt; MyFunc = <span class="built_in">async</span>(launch::deferred, myfunc, <span class="number">1</span>, <span class="number">2</span>);  </span><br><span class="line">    MyFunc.<span class="built_in">wait</span>();  </span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;This is main: &quot;</span> &lt;&lt; this_thread::<span class="built_in">get_id</span>() &lt;&lt; endl;  </span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;This is from myfunc: &quot;</span> &lt;&lt; MyFunc.<span class="built_in">get</span>() &lt;&lt; endl;  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">//This is myfunc: 1  </span></span><br><span class="line"><span class="comment">//This is main: 1  </span></span><br><span class="line"><span class="comment">//This is from myfunc: 3</span></span><br></pre></td></tr></table></figure><p>可以看出，<code>launch::deferred</code> 策略并没有创建新的线程，并且在调用 <code>get</code> 方法时才执行 <code>myfunc()</code></p></li></ol><h2 id="🚩promise"><a href="#🚩promise" class="headerlink" title="🚩promise"></a>🚩promise</h2><h3 id="基本概念-6"><a href="#基本概念-6" class="headerlink" title="基本概念"></a>基本概念</h3><blockquote><p>promise 是什么？</p></blockquote><p><code>std::promise</code> 是一个用于设置异步操作结果的机制。它允许在一个线程中<font color="#00b050">设置值或异常</font>，然后在另一个线程中通过 <code>std::future</code> 对象检索这些值或异常。<br>通常与 <code>std::async</code>、<code>std::packaged_task</code> 或 <code>std::thread</code> 结合使用。需要头文件 <code>&lt;future&gt;</code>。</p><p>一个 promise 对象可以创建多个 future 对象。<br><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://i.imgur.com/Srt7GAa.png" alt="|607"></p><h3 id="💻代码实现-2"><a href="#💻代码实现-2" class="headerlink" title="💻代码实现"></a>💻代码实现</h3><p>设置值：<br></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">AsyncTask</span><span class="params">(promise&lt;<span class="type">int</span>&gt; prom)</span> </span>&#123;  </span><br><span class="line">    std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">seconds</span>(<span class="number">1</span>));  </span><br><span class="line">    prom.<span class="built_in">set_value</span>(<span class="number">3</span>);  <span class="comment">// 设置异步操作的结果  </span></span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">    std::promise&lt;<span class="type">int</span>&gt; prom;  </span><br><span class="line">    std::future&lt;<span class="type">int</span>&gt; FutureObj = prom.<span class="built_in">get_future</span>(); <span class="comment">//获取与promise关联的future。&lt;int&gt;指prom.set_value的参数类型</span></span><br><span class="line">  </span><br><span class="line">    <span class="function">std::thread <span class="title">t</span><span class="params">(AsyncTask, std::move(prom))</span></span>;  <span class="comment">//启动异步任务，并传递参数promise  </span></span><br><span class="line">  </span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;The result is: &quot;</span> &lt;&lt; FutureObj.<span class="built_in">get</span>() &lt;&lt; endl;  </span><br><span class="line">  </span><br><span class="line">    t.<span class="built_in">join</span>();   <span class="comment">//等待线程结束。必须加上  </span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">//The result is: 3</span></span><br></pre></td></tr></table></figure><br><code>promise</code> 比 <code>async</code> 更加灵活，拥有更多功能。<p></p><div class="table-container"><table><thead><tr><th>成员函数</th><th>作用</th></tr></thead><tbody><tr><td><code>get_future()</code></td><td>获取与 <code>std::promise</code> 关联的 <code>std::future</code> 对象。</td></tr><tr><td><code>set_value()</code></td><td>设置 <code>std::promise</code> 的值。</td></tr><tr><td><code>set_exception()</code></td><td>设置 <code>std::promise</code> 的异常。</td></tr><tr><td><code>set_value_at_thread_exit()</code></td><td>在线程退出时设置值。</td></tr><tr><td><code>set_exception_at_thread_exit()</code></td><td>在线程退出时设置异常。</td></tr></tbody></table></div><p>处理异常：<br></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;future&gt;</span>  </span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">producer</span><span class="params">(std::promise&lt;<span class="type">int</span>&gt;&amp; promise)</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">try</span> &#123;  </span><br><span class="line">        <span class="keyword">throw</span> std::<span class="built_in">runtime_error</span>(<span class="string">&quot;An error occurred!&quot;</span>);  </span><br><span class="line">    &#125; <span class="built_in">catch</span> (<span class="type">const</span> std::exception&amp; e) &#123;  </span><br><span class="line">        promise.<span class="built_in">set_exception</span>(std::<span class="built_in">current_exception</span>()); <span class="comment">// 设置异常  </span></span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">consumer</span><span class="params">(std::future&lt;<span class="type">int</span>&gt;&amp; future)</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">try</span> &#123;  </span><br><span class="line">        <span class="type">int</span> value = future.<span class="built_in">get</span>(); <span class="comment">// 获取值，此时会捕获到抛出的异常 </span></span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Received value: &quot;</span> &lt;&lt; value &lt;&lt; std::endl;  </span><br><span class="line">    &#125; <span class="built_in">catch</span> (<span class="type">const</span> std::exception&amp; e) &#123;  </span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Exception caught: &quot;</span> &lt;&lt; e.<span class="built_in">what</span>() &lt;&lt; std::endl;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">    std::promise&lt;<span class="type">int</span>&gt; promise;  </span><br><span class="line">    std::future&lt;<span class="type">int</span>&gt; future = promise.<span class="built_in">get_future</span>();  </span><br><span class="line">  </span><br><span class="line">    <span class="function">std::thread <span class="title">producer_thread</span><span class="params">(producer, std::ref(promise))</span></span>;  </span><br><span class="line">    <span class="function">std::thread <span class="title">consumer_thread</span><span class="params">(consumer, std::ref(future))</span></span>;  </span><br><span class="line">  </span><br><span class="line">    producer_thread.<span class="built_in">join</span>();  </span><br><span class="line">    consumer_thread.<span class="built_in">join</span>();  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="comment">//Exception caught: An error occurred!</span></span><br></pre></td></tr></table></figure><p></p><h3 id="注意事项-1"><a href="#注意事项-1" class="headerlink" title="注意事项"></a>注意事项</h3><ol><li><strong>只能设置一次值或异常</strong>：<code>std::promise</code> 只能设置一次值或异常。如果多次调用 <code>set_value()</code> 或 <code>set_exception()</code>，会导致未定义行为。</li><li><strong>线程安全</strong>：<code>std::promise</code> 和 <code>std::future</code> 是线程安全的，但需要确保在适当的时机调用 <code>set_value()</code> 和 <code>get()</code>。</li><li><strong>不能被直接复制</strong>：<code>std::promise</code> 对象<font color="#00b050">不能被复制</font>，只能通过 <code>std::move</code> 转移控制权。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">std::promise&lt;<span class="type">int</span>&gt; promise;</span><br><span class="line">std::promise&lt;<span class="type">int</span>&gt; promise2 = std::<span class="built_in">move</span>(promise);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MyFunc</span><span class="params">(promise&lt;<span class="type">int</span>&gt; prom)</span> </span>&#123;</span><br><span class="line">	prom.<span class="built_in">set_exception</span>(std::<span class="built_in">current_exception</span>());</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">std::thread <span class="title">t</span><span class="params">(MyFunc, std::move(promise))</span></span>;	<span class="comment">//值传递</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MyFunc</span><span class="params">(promise&lt;<span class="type">int</span>&gt;&amp; prom)</span> </span>&#123;	<span class="comment">//不可以为const，因为set_exception()</span></span><br><span class="line">	prom.<span class="built_in">set_exception</span>(std::<span class="built_in">current_exception</span>());</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">std::thread <span class="title">t</span><span class="params">(MyFunc, std::ref(promise))</span></span>;	<span class="comment">//引用传递</span></span><br></pre></td></tr></table></figure></li></ol><h2 id="🚩packaged-task"><a href="#🚩packaged-task" class="headerlink" title="🚩packaged_task"></a>🚩packaged_task</h2><h3 id="基本概念-7"><a href="#基本概念-7" class="headerlink" title="基本概念"></a>基本概念</h3><blockquote><p>什么是 <code>packaged_task</code>？</p></blockquote><p><code>packaged_task</code> 是一个模板类，用于<font color="#00b050">封装可调用对象，并将任务的执行与结果的获取分离</font>。同样需要头文件 <code>&lt;future&gt;</code>。</p><h3 id="💻代码实现-3"><a href="#💻代码实现-3" class="headerlink" title="💻代码实现"></a>💻代码实现</h3><p>在另一个线程中执行任务：<br></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">    <span class="function">std::packaged_task&lt;<span class="title">int</span><span class="params">(<span class="type">int</span>,<span class="type">int</span>)</span>&gt; <span class="title">task</span><span class="params">([](<span class="type">int</span> a, <span class="type">int</span> b) &#123; <span class="keyword">return</span> a + b; &#125;)</span></span>;  </span><br><span class="line">    std::future&lt;<span class="type">int</span>&gt; result = task.<span class="built_in">get_future</span>();  </span><br><span class="line">      </span><br><span class="line">    <span class="function">std::thread <span class="title">t</span><span class="params">(std::move(task), <span class="number">1</span>, <span class="number">2</span>)</span></span>;   <span class="comment">//packaged_task同样不可以复制  </span></span><br><span class="line">    t.<span class="built_in">join</span>();  </span><br><span class="line">      </span><br><span class="line">    cout &lt;&lt; result.<span class="built_in">get</span>() &lt;&lt; endl;  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//另一种构造写法：</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Multiply</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> a * b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="function">std::packaged_task&lt;<span class="title">decltype</span><span class="params">(Multiply)</span>&gt; <span class="title">task</span><span class="params">(Multiply)</span></span>;</span><br><span class="line">	<span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>重置对象，获取新的 <code>future</code> 对象：<br></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">    <span class="function">std::packaged_task&lt;<span class="title">int</span><span class="params">(<span class="type">int</span>,<span class="type">int</span>)</span>&gt; <span class="title">task</span><span class="params">([](<span class="type">int</span> a, <span class="type">int</span> b) &#123; <span class="keyword">return</span> a + b; &#125;)</span></span>;  </span><br><span class="line">    std::future&lt;<span class="type">int</span>&gt; result = task.<span class="built_in">get_future</span>();  </span><br><span class="line">  </span><br><span class="line">    <span class="built_in">task</span>(<span class="number">1</span>, <span class="number">2</span>); <span class="comment">//执行任务  </span></span><br><span class="line">    cout &lt;&lt; result.<span class="built_in">get</span>() &lt;&lt; endl;  </span><br><span class="line">  </span><br><span class="line">    task.<span class="built_in">reset</span>();   <span class="comment">//重置packaged_task，因为其只能执行一次任务</span></span><br><span class="line">    result = task.<span class="built_in">get_future</span>(); <span class="comment">//必须获取新的future对象，因为每个future对象在调用get方法后会失效  </span></span><br><span class="line">  </span><br><span class="line">    <span class="built_in">task</span>(<span class="number">3</span>, <span class="number">4</span>);  </span><br><span class="line">    cout &lt;&lt; result.<span class="built_in">get</span>() &lt;&lt; endl;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="comment">//3  </span></span><br><span class="line"><span class="comment">//7</span></span><br></pre></td></tr></table></figure><p></p><div class="table-container"><table><thead><tr><th>成员函数</th><th>作用</th></tr></thead><tbody><tr><td><code>get_future()</code></td><td>获取与 <code>std::packaged_task</code> 关联的 <code>std::future</code> 对象。</td></tr><tr><td><code>operator()</code></td><td>执行封装的可调用对象，并将结果存储在 <code>std::future</code> 中。</td></tr><tr><td><code>make_ready_at_thread_exit()</code></td><td>在线程退出时执行任务，并将结果存储在 <code>std::future</code> 中。</td></tr><tr><td><code>reset()</code></td><td>重置 <code>std::packaged_task</code>，允许重新执行任务。</td></tr></tbody></table></div><h3 id="注意事项-2"><a href="#注意事项-2" class="headerlink" title="注意事项"></a>注意事项</h3><ol><li><code>std::packaged_task</code> 使用 <code>operator()</code> 执行任务，并将结果存储在 <code>std::future</code> 中。</li><li><strong>不可复制</strong>： <code>packaged_task</code> 可移动，但不可复制。因此，构建 <code>thread</code> 中值传递 <code>std::packaged_task</code> 时需要使用 <code>std::move</code>（引用传递用 <code>std::ref</code>）。</li><li><strong>只能执行一次任务</strong>：<code>std::packaged_task</code> 只能执行一次任务。如果需要重新执行任务，应使用 <code>reset()</code> 重置 <code>std::packaged_task</code>。</li><li><strong>线程安全</strong>：<code>std::packaged_task</code> 和 <code>std::future</code> 是线程安全的，但需要确保在适当的时机调用 <code>get_future()</code> 和 <code>get()</code>。</li></ol><h2 id="三种异步工具的比较"><a href="#三种异步工具的比较" class="headerlink" title="三种异步工具的比较"></a>三种异步工具的比较</h2><div class="table-container"><table><thead><tr><th>特性</th><th>async</th><th>promise</th><th>packaged_task</th></tr></thead><tbody><tr><td>代码写法</td><td>简单，自动管理线程和任务执行</td><td>复杂，手动管理线程和任务执行</td><td>复杂，手动管理线程和任务执行</td></tr><tr><td>成员函数</td><td>自动设置值或异常</td><td><code>get_future()</code>、<code>set_value()</code>、<code>set_exception()</code></td><td><code>get_future()</code>、<code>operator()</code>、<code>reset()</code></td></tr><tr><td>应用场景</td><td>简单异步任务</td><td>复杂线程间通信，灵活性最高</td><td>任务调度、线程池、封装可调用对象</td></tr></tbody></table></div><p>共同点是，它们均为 C++11 新特性，包含在头文件 <code>&lt;future&gt;</code> 中，并且都需要搭配 <code>future</code> 对象实现功能。</p><h4 id="之间的关系"><a href="#之间的关系" class="headerlink" title="之间的关系"></a>之间的关系</h4><p>以下内容摘自 <a target="_blank" rel="noopener" href="https://www.51cto.com/article/713316.html">Thread、Future、Promise、Packaged_task、Async之间有什么关系？</a><br><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://i.imgur.com/aljI5fH.png" alt="|852"></p><ul><li><code>packaged_task</code> ≈ <code>promise</code> + function</li><li><code>async</code> ≈ <code>thread</code> + <code>packaged_task</code></li><li>通过 <code>promise</code> 的 <code>get_future()</code> 可拿到 <code>future</code> 对象</li><li>通过 <code>future</code> 对象的 <code>share()</code> 可拿到 <code>shared_future</code> 对象</li></ul><p><code>promise</code> 只能 <code>set_value</code>，不太好执行复杂的逻辑，有执行函数+阻塞的需求时，就可以考虑使用 <code>packaged_task</code>。</p><p><code>shared_future</code>：<br>普通的 <code>future</code> 有个特点，它不能拷贝，只能移动，这就意味着只能有一个线程一个实例可以通过 <code>get()</code> 拿到对应的结果。<br>如果想要多个线程多个实例拿到结果，就可以使用 <code>shared_future</code>，那怎么拿到 <code>shared_future</code>，可以通过普通 <code>future</code> 的 <code>shared()</code> 方法。<br></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;future&gt;</span>  </span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">    std::promise&lt;<span class="type">int</span>&gt; prom;  </span><br><span class="line">    future&lt;<span class="type">int</span>&gt; fu = prom.<span class="built_in">get_future</span>();  </span><br><span class="line">    shared_future&lt;<span class="type">int</span>&gt; shared_fu = fu.<span class="built_in">share</span>();  </span><br><span class="line">    future&lt;<span class="type">void</span>&gt; f1 = std::<span class="built_in">async</span>(std::launch::async, [shared_fu]() &#123; std::cout &lt;&lt; shared_fu.<span class="built_in">get</span>() &lt;&lt; std::endl; &#125;);  </span><br><span class="line">    future&lt;<span class="type">void</span>&gt; f2 = std::<span class="built_in">async</span>(std::launch::async, [shared_fu]() &#123; std::cout &lt;&lt; shared_fu.<span class="built_in">get</span>() &lt;&lt; std::endl; &#125;);  </span><br><span class="line">    prom.<span class="built_in">set_value</span>(<span class="number">102</span>);  </span><br><span class="line">    f1.<span class="built_in">get</span>();  </span><br><span class="line">    f2.<span class="built_in">get</span>();  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="comment">//102102	//这里的输出顺序无法确定（毕竟因为异步）</span></span><br></pre></td></tr></table></figure><p></p><hr><h1 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h1><h2 id="基本概念-8"><a href="#基本概念-8" class="headerlink" title="基本概念"></a>基本概念</h2><blockquote><p>什么是线程池？作用是什么？</p></blockquote><p>线程池是指一种<font color="#00b050">预先创建一组线程</font>的机制，这些线程在应用程序启动时就已经创建好，等待执行任务。<br>每当有新的任务需要执行时，线程池会从线程集合中分配一个空闲线程来执行该任务，而不是每次都重新创建和销毁线程。（池化思想，如 epoll、SQL）</p><blockquote><p>为什么使用线程池？</p></blockquote><ol><li><strong>提高性能</strong>：<font color="#00b050">创建和销毁线程开销较大</font>，线程池通过重用的线程，减少了这种开销，提高程序性能。</li><li><strong>控制并发量</strong>：线程池允许<font color="#00b050">限制并发线程的数量</font>，防止系统因创建过多线程而出现资源耗尽的问题（如 CPU 过载、内存不足）。</li><li><strong>简化线程管理</strong>：使用线程池可以<font color="#00b050">避免手动管理线程的生命周期</font>，减少代码复杂性。线程池通常还提供了<font color="#00b050">任务排队和调度</font>的功能，使得多线程编程更加容易。</li></ol><blockquote><p>线程池的使用场景？</p></blockquote><ol><li><strong>服务器应用</strong>：比如 Web 服务器，处理每个客户端请求时不必为每个请求创建一个新线程，而是从线程池中取出线程来处理请求。</li><li><strong>高性能计算</strong></li><li><strong>异步任务处理</strong></li></ol><blockquote><p>一个线程池应该包含什么？</p></blockquote><ol><li><strong>线程池管理器（ThreadPool Manager）</strong>：负责创建并管理线程池，包括线程的创建、销毁、任务分配等。</li><li><strong>工作线程（Worker Thread）</strong>：线程池中的线程，负责执行具体的任务。这些线程通常是预先创建好的，并且在任务执行完毕后不会立即销毁，而是返回到线程池中等待下一个任务。</li><li><strong>任务队列（Task Queue）</strong>：用于存储待执行的任务。当有新的任务提交到线程池时，任务会被放入任务队列中，等待工作线程来执行。</li><li><strong>任务（Task）</strong>：需要执行的工作单元，通常是一个函数或方法。<br>图例：<br><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://i.imgur.com/w5pFYyP.png" alt="|954"></li></ol><h2 id="💻代码实现-4"><a href="#💻代码实现-4" class="headerlink" title="💻代码实现"></a>💻代码实现</h2><p>来自 <a target="_blank" rel="noopener" href="https://github.com/lzpong/threadpool?tab=readme-ov-file">threadpool-lzpong</a></p><p><code>threadpool.h</code>：<br></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> THREAD_POOL_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> THREAD_POOL_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;atomic&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;future&gt;</span></span></span><br><span class="line"><span class="comment">//#include &lt;condition_variable&gt;</span></span><br><span class="line"><span class="comment">//#include &lt;thread&gt;</span></span><br><span class="line"><span class="comment">//#include &lt;functional&gt;</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdexcept&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> std</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//线程池最大容量,应尽量设小一点</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>  THREADPOOL_MAX_NUM 16</span></span><br><span class="line"><span class="comment">//线程池是否可以自动增长(如果需要,且不超过 THREADPOOL_MAX_NUM)</span></span><br><span class="line"><span class="comment">//#define  THREADPOOL_AUTO_GROW</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//线程池,可以提交变参函数或Lambda\表达式的匿名函数执行,可以获取执行返回值</span></span><br><span class="line"><span class="comment">//不直接支持类成员函数, 支持类静态成员函数或全局函数,Operator()函数等</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">threadpool</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">short</span> _initSize;       <span class="comment">//初始化线程数量</span></span><br><span class="line">	<span class="keyword">using</span> Task = function&lt;<span class="built_in">void</span>()&gt;; <span class="comment">//定义类型</span></span><br><span class="line">	vector&lt;thread&gt; _pool;          <span class="comment">//线程池</span></span><br><span class="line">	queue&lt;Task&gt; _tasks;            <span class="comment">//任务队列</span></span><br><span class="line">	mutex _lock;                   <span class="comment">//任务队列同步锁</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> THREADPOOL_AUTO_GROW</span></span><br><span class="line">	mutex _lockGrow;               <span class="comment">//线程池增长同步锁</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">// !THREADPOOL_AUTO_GROW</span></span></span><br><span class="line">	condition_variable _task_cv;   <span class="comment">//条件阻塞</span></span><br><span class="line">	atomic&lt;<span class="type">bool</span>&gt; _run&#123; <span class="literal">true</span> &#125;;     <span class="comment">//线程池是否执行</span></span><br><span class="line">	atomic&lt;<span class="type">int</span>&gt;  _idlThrNum&#123; <span class="number">0</span> &#125;;  <span class="comment">//空闲线程数量</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">inline</span> <span class="title">threadpool</span><span class="params">(<span class="type">unsigned</span> <span class="type">short</span> size = <span class="number">4</span>)</span> </span>&#123; _initSize = size; <span class="built_in">addThread</span>(size); &#125;</span><br><span class="line">	<span class="keyword">inline</span> ~<span class="built_in">threadpool</span>()</span><br><span class="line">	&#123;</span><br><span class="line">		_run=<span class="literal">false</span>;</span><br><span class="line">		_task_cv.<span class="built_in">notify_all</span>(); <span class="comment">// 唤醒所有线程执行</span></span><br><span class="line">		<span class="keyword">for</span> (thread&amp; thread : _pool) &#123;</span><br><span class="line">			<span class="comment">//thread.detach(); // 让线程“自生自灭”</span></span><br><span class="line">			<span class="keyword">if</span> (thread.<span class="built_in">joinable</span>())</span><br><span class="line">				thread.<span class="built_in">join</span>(); <span class="comment">// 等待任务结束， 前提：线程一定会执行完</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">// 提交一个任务</span></span><br><span class="line">	<span class="comment">// 调用.get()获取返回值会等待任务执行完,获取返回值</span></span><br><span class="line">	<span class="comment">// 有两种方法可以实现调用类成员，</span></span><br><span class="line">	<span class="comment">// 一种是使用   bind： .commit(std::bind(&amp;Dog::sayHello, &amp;dog));</span></span><br><span class="line">	<span class="comment">// 一种是用   mem_fn： .commit(std::mem_fn(&amp;Dog::sayHello), this)</span></span><br><span class="line">	<span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> F, <span class="keyword">class</span>... Args&gt;</span></span><br><span class="line"><span class="function">	<span class="keyword">auto</span> <span class="title">commit</span><span class="params">(F&amp;&amp; f, Args&amp;&amp;... args)</span> -&gt; future&lt;<span class="title">decltype</span><span class="params">(f(args...))</span>&gt;</span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (!_run)    <span class="comment">// stoped ??</span></span><br><span class="line">			<span class="keyword">throw</span> <span class="built_in">runtime_error</span>(<span class="string">&quot;commit on ThreadPool is stopped.&quot;</span>);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">using</span> RetType = <span class="keyword">decltype</span>(<span class="built_in">f</span>(args...)); <span class="comment">// typename std::result_of&lt;F(Args...)&gt;::type, 函数 f 的返回值类型</span></span><br><span class="line">		<span class="keyword">auto</span> task = make_shared&lt;packaged_task&lt;<span class="built_in">RetType</span>()&gt;&gt;(</span><br><span class="line">			<span class="built_in">bind</span>(forward&lt;F&gt;(f), forward&lt;Args&gt;(args)...)</span><br><span class="line">		); <span class="comment">// 把函数入口及参数,打包(绑定)</span></span><br><span class="line">		future&lt;RetType&gt; future = task-&gt;<span class="built_in">get_future</span>();</span><br><span class="line">		&#123;    <span class="comment">// 添加任务到队列</span></span><br><span class="line">			lock_guard&lt;mutex&gt; lock&#123; _lock &#125;;<span class="comment">//对当前块的语句加锁  lock_guard 是 mutex 的 stack 封装类，构造的时候 lock()，析构的时候 unlock()</span></span><br><span class="line">			_tasks.<span class="built_in">emplace</span>([task]() &#123; <span class="comment">// push(Task&#123;...&#125;) 放到队列后面</span></span><br><span class="line">				(*task)();</span><br><span class="line">			&#125;);</span><br><span class="line">		&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> THREADPOOL_AUTO_GROW</span></span><br><span class="line">		<span class="keyword">if</span> (_idlThrNum &lt; <span class="number">1</span> &amp;&amp; _pool.<span class="built_in">size</span>() &lt; THREADPOOL_MAX_NUM)</span><br><span class="line">			<span class="built_in">addThread</span>(<span class="number">1</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">// !THREADPOOL_AUTO_GROW</span></span></span><br><span class="line">		_task_cv.<span class="built_in">notify_one</span>(); <span class="comment">// 唤醒一个线程执行</span></span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> future;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 提交一个无参任务, 且无返回值</span></span><br><span class="line">	<span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">F</span>&gt;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">commit2</span><span class="params">(F&amp;&amp; task)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (!_run) <span class="keyword">return</span>;</span><br><span class="line">		&#123;</span><br><span class="line">			lock_guard&lt;mutex&gt; lock&#123; _lock &#125;;</span><br><span class="line">			_tasks.<span class="built_in">emplace</span>(std::forward&lt;F&gt;(task));</span><br><span class="line">		&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> THREADPOOL_AUTO_GROW</span></span><br><span class="line">		<span class="keyword">if</span> (_idlThrNum &lt; <span class="number">1</span> &amp;&amp; _pool.<span class="built_in">size</span>() &lt; THREADPOOL_MAX_NUM)</span><br><span class="line">			<span class="built_in">addThread</span>(<span class="number">1</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">// !THREADPOOL_AUTO_GROW</span></span></span><br><span class="line">		_task_cv.<span class="built_in">notify_one</span>();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//空闲线程数量</span></span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">idlCount</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> _idlThrNum; &#125;</span><br><span class="line">	<span class="comment">//线程数量</span></span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">thrCount</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> _pool.<span class="built_in">size</span>(); &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> THREADPOOL_AUTO_GROW</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">// !THREADPOOL_AUTO_GROW</span></span></span><br><span class="line">	<span class="comment">//添加指定数量的线程</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">addThread</span><span class="params">(<span class="type">unsigned</span> <span class="type">short</span> size)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> THREADPOOL_AUTO_GROW</span></span><br><span class="line">		<span class="keyword">if</span> (!_run)    <span class="comment">// stoped ??</span></span><br><span class="line">			<span class="keyword">throw</span> <span class="built_in">runtime_error</span>(<span class="string">&quot;Grow on ThreadPool is stopped.&quot;</span>);</span><br><span class="line">		unique_lock&lt;mutex&gt; lockGrow&#123; _lockGrow &#125;; <span class="comment">//自动增长锁</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">// !THREADPOOL_AUTO_GROW</span></span></span><br><span class="line">		<span class="keyword">for</span> (; _pool.<span class="built_in">size</span>() &lt; THREADPOOL_MAX_NUM &amp;&amp; size &gt; <span class="number">0</span>; --size)</span><br><span class="line">		&#123;   <span class="comment">//增加线程数量,但不超过 预定义数量 THREADPOOL_MAX_NUM</span></span><br><span class="line">			_pool.<span class="built_in">emplace_back</span>( [<span class="keyword">this</span>]&#123; <span class="comment">//工作线程函数</span></span><br><span class="line">				<span class="keyword">while</span> (<span class="literal">true</span>) <span class="comment">//防止 _run==false 时立即结束,此时任务队列可能不为空</span></span><br><span class="line">				&#123;</span><br><span class="line">					Task task; <span class="comment">// 获取一个待执行的 task</span></span><br><span class="line">					&#123;</span><br><span class="line">						<span class="comment">// unique_lock 相比 lock_guard 的好处是：可以随时 unlock() 和 lock()</span></span><br><span class="line">						unique_lock&lt;mutex&gt; lock&#123; _lock &#125;;</span><br><span class="line">						_task_cv.<span class="built_in">wait</span>(lock, [<span class="keyword">this</span>] &#123; <span class="comment">// wait 直到有 task, 或需要停止</span></span><br><span class="line">							<span class="keyword">return</span> !_run || !_tasks.<span class="built_in">empty</span>();</span><br><span class="line">						&#125;);</span><br><span class="line">						<span class="keyword">if</span> (!_run &amp;&amp; _tasks.<span class="built_in">empty</span>())</span><br><span class="line">							<span class="keyword">return</span>;</span><br><span class="line">						_idlThrNum--;</span><br><span class="line">						task = <span class="built_in">move</span>(_tasks.<span class="built_in">front</span>()); <span class="comment">// 按先进先出从队列取一个 task</span></span><br><span class="line">						_tasks.<span class="built_in">pop</span>();</span><br><span class="line">					&#125;</span><br><span class="line">					<span class="built_in">task</span>();<span class="comment">//执行任务</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> THREADPOOL_AUTO_GROW</span></span><br><span class="line">					<span class="keyword">if</span> (_idlThrNum&gt;<span class="number">0</span> &amp;&amp; _pool.<span class="built_in">size</span>() &gt; _initSize) <span class="comment">//支持自动释放空闲线程,避免峰值过后大量空闲线程</span></span><br><span class="line">						<span class="keyword">return</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">// !THREADPOOL_AUTO_GROW</span></span></span><br><span class="line">					&#123;</span><br><span class="line">						unique_lock&lt;mutex&gt; lock&#123; _lock &#125;;</span><br><span class="line">						_idlThrNum++;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;);</span><br><span class="line">			&#123;</span><br><span class="line">				unique_lock&lt;mutex&gt; lock&#123; _lock &#125;;</span><br><span class="line">				_idlThrNum++;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span>  <span class="comment">//https://github.com/lzpong/</span></span></span><br></pre></td></tr></table></figure><p></p><p><code>main.cpp</code>：<br></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;threadpool.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">fun1</span><span class="params">(<span class="type">int</span> slp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;  hello, fun1 !  %d\n&quot;</span> ,std::this_thread::<span class="built_in">get_id</span>());</span><br><span class="line">	<span class="keyword">if</span> (slp&gt;<span class="number">0</span>) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot; ======= fun1 sleep %d  =========  %d\n&quot;</span>,slp, std::this_thread::<span class="built_in">get_id</span>());</span><br><span class="line">		std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">milliseconds</span>(slp));</span><br><span class="line">		<span class="comment">//Sleep(slp );</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">gfun</span> &#123;</span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%d  hello, gfun !  %d\n&quot;</span> ,n, std::this_thread::<span class="built_in">get_id</span>() );</span><br><span class="line">		<span class="keyword">return</span> <span class="number">42</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;    <span class="comment">//函数必须是 static 的才能使用线程池</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">Afun</span><span class="params">(<span class="type">int</span> n = <span class="number">0</span>)</span> </span>&#123;</span><br><span class="line">		std::cout &lt;&lt; n &lt;&lt; <span class="string">&quot;  hello, Afun !  &quot;</span> &lt;&lt; std::this_thread::<span class="built_in">get_id</span>() &lt;&lt; std::endl;</span><br><span class="line">		<span class="keyword">return</span> n;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="type">static</span> std::string <span class="title">Bfun</span><span class="params">(<span class="type">int</span> n, std::string str, <span class="type">char</span> c)</span> </span>&#123;</span><br><span class="line">		std::cout &lt;&lt; n &lt;&lt; <span class="string">&quot;  hello, Bfun !  &quot;</span>&lt;&lt; str.<span class="built_in">c_str</span>() &lt;&lt;<span class="string">&quot;  &quot;</span> &lt;&lt; (<span class="type">int</span>)c &lt;&lt;<span class="string">&quot;  &quot;</span> &lt;&lt; std::this_thread::<span class="built_in">get_id</span>() &lt;&lt; std::endl;</span><br><span class="line">		<span class="keyword">return</span> str;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		std::threadpool executor&#123; <span class="number">50</span> &#125;;</span><br><span class="line">		A a;</span><br><span class="line">		std::future&lt;<span class="type">void</span>&gt; ff = executor.<span class="built_in">commit</span>(fun1,<span class="number">0</span>);</span><br><span class="line">		std::future&lt;<span class="type">int</span>&gt; fg = executor.<span class="built_in">commit</span>(gfun&#123;&#125;,<span class="number">0</span>);</span><br><span class="line">		std::future&lt;<span class="type">int</span>&gt; gg = executor.<span class="built_in">commit</span>(a.Afun, <span class="number">9999</span>); <span class="comment">//IDE提示错误,但可以编译运行</span></span><br><span class="line">		std::future&lt;std::string&gt; gh = executor.<span class="built_in">commit</span>(A::Bfun, <span class="number">9998</span>,<span class="string">&quot;mult args&quot;</span>, <span class="number">123</span>);</span><br><span class="line">		std::future&lt;std::string&gt; fh = executor.<span class="built_in">commit</span>([]()-&gt;std::string &#123; std::cout &lt;&lt; <span class="string">&quot;hello, fh !  &quot;</span> &lt;&lt; std::this_thread::<span class="built_in">get_id</span>() &lt;&lt; std::endl; <span class="keyword">return</span> <span class="string">&quot;hello,fh ret !&quot;</span>; &#125;);</span><br><span class="line"></span><br><span class="line">		std::cout &lt;&lt; <span class="string">&quot; =======  sleep ========= &quot;</span> &lt;&lt; std::this_thread::<span class="built_in">get_id</span>() &lt;&lt; std::endl;</span><br><span class="line">		std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">microseconds</span>(<span class="number">900</span>));</span><br><span class="line"></span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">50</span>; i++) &#123;</span><br><span class="line">			executor.<span class="built_in">commit</span>(fun1,i*<span class="number">100</span> );</span><br><span class="line">		&#125;</span><br><span class="line">		std::cout &lt;&lt; <span class="string">&quot; =======  commit all ========= &quot;</span> &lt;&lt; std::this_thread::<span class="built_in">get_id</span>()&lt;&lt; <span class="string">&quot; idlsize=&quot;</span>&lt;&lt;executor.<span class="built_in">idlCount</span>() &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">		std::cout &lt;&lt; <span class="string">&quot; =======  sleep ========= &quot;</span> &lt;&lt; std::this_thread::<span class="built_in">get_id</span>() &lt;&lt; std::endl;</span><br><span class="line">		std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">seconds</span>(<span class="number">3</span>));</span><br><span class="line"></span><br><span class="line">		ff.<span class="built_in">get</span>(); <span class="comment">//调用.get()获取返回值会等待线程执行完,获取返回值</span></span><br><span class="line">		std::cout &lt;&lt; fg.<span class="built_in">get</span>() &lt;&lt; <span class="string">&quot;  &quot;</span> &lt;&lt; fh.<span class="built_in">get</span>().<span class="built_in">c_str</span>()&lt;&lt; <span class="string">&quot;  &quot;</span> &lt;&lt; std::this_thread::<span class="built_in">get_id</span>() &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">		std::cout &lt;&lt; <span class="string">&quot; =======  sleep ========= &quot;</span> &lt;&lt; std::this_thread::<span class="built_in">get_id</span>() &lt;&lt; std::endl;</span><br><span class="line">		std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">seconds</span>(<span class="number">3</span>));</span><br><span class="line"></span><br><span class="line">		std::cout &lt;&lt; <span class="string">&quot; =======  fun1,55 ========= &quot;</span> &lt;&lt; std::this_thread::<span class="built_in">get_id</span>() &lt;&lt; std::endl;</span><br><span class="line">		executor.<span class="built_in">commit</span>(fun1,<span class="number">55</span>).<span class="built_in">get</span>();    <span class="comment">//调用.get()获取返回值会等待线程执行完</span></span><br><span class="line"></span><br><span class="line">		std::cout &lt;&lt; <span class="string">&quot;end... &quot;</span> &lt;&lt; std::this_thread::<span class="built_in">get_id</span>() &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">		<span class="function">std::threadpool <span class="title">pool</span><span class="params">(<span class="number">4</span>)</span></span>;</span><br><span class="line">		std::vector&lt; std::future&lt;<span class="type">int</span>&gt; &gt; results;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">8</span>; ++i) &#123;</span><br><span class="line">			results.<span class="built_in">emplace_back</span>(</span><br><span class="line">				pool.<span class="built_in">commit</span>([i] &#123;</span><br><span class="line">					std::cout &lt;&lt; <span class="string">&quot;hello &quot;</span> &lt;&lt; i &lt;&lt; std::endl;</span><br><span class="line">					std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">seconds</span>(<span class="number">1</span>));</span><br><span class="line">					std::cout &lt;&lt; <span class="string">&quot;world &quot;</span> &lt;&lt; i &lt;&lt; std::endl;</span><br><span class="line">					<span class="keyword">return</span> i*i;</span><br><span class="line">				&#125;)</span><br><span class="line">			);</span><br><span class="line">		&#125;</span><br><span class="line">		std::cout &lt;&lt; <span class="string">&quot; =======  commit all2 ========= &quot;</span> &lt;&lt; std::this_thread::<span class="built_in">get_id</span>() &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">auto</span> &amp;&amp; result : results)</span><br><span class="line">			std::cout &lt;&lt; result.<span class="built_in">get</span>() &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">		std::cout &lt;&lt; std::endl;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">catch</span> (std::exception&amp; e) &#123;</span><br><span class="line">		std::cout &lt;&lt; <span class="string">&quot;some unhappy happened...  &quot;</span> &lt;&lt; std::this_thread::<span class="built_in">get_id</span>() &lt;&lt; e.<span class="built_in">what</span>() &lt;&lt; std::endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>C++11 语言细节：<p></p><ol><li><code>using Task = function&lt;void()&gt;</code> 是类型别名，简化了 <code>typedef</code> 的用法。<code>function&lt;void()&gt;</code> 可以认为是一个函数类型，接受任意原型是 <code>void()</code> 的函数，或是函数对象，或是匿名函数。<code>void()</code> 意思是不带参数，没有返回值。</li><li><code>pool.emplace_back([this]&#123;...&#125;)</code> 和 <code>pool.push_back([this]&#123;...&#125;)</code> 功能一样，只不过前者性能会更好。</li><li><code>pool.emplace_back([this]&#123;...&#125;)</code> 构造了一个线程对象，执行函数是 Lambda匿名函数。</li><li>所有对象的初始化方式均采用了 <code>&#123;&#125;</code>，而不再使用 <code>()</code> 方式，因为风格不够一致且容易出错。</li><li>匿名函数： <code>[this]&#123;...&#125;</code> 不多说。<code>[]</code> 是捕捉器，<code>this</code> 是引用域外的变量 this指针，内部使用死循环, 由 <code>cv_task.wait(lock,[this]&#123;...&#125;)</code> 来阻塞线程。</li><li><code>delctype(expr)</code> 用来推断 <code>expr</code> 的类型，和 <code>auto</code> 是类似的，相当于类型占位符，占据一个类型的位置；<code>auto f(A a, B b) -&gt; decltype(a+b)</code> 是一种用法，不能写作 <code>decltype(a+b) f(A a, B b)</code>。</li><li><code>commit</code> 方法是不是略奇葩！可以带任意多的参数，第一个参数是 f，后面依次是函数 f 的参数(<em>注意:参数要传struct/class的话,建议用pointer,小心变量的作用域</em>)！可变参数模板是 c++11 的一大亮点。</li><li><code>commit</code> 直接使用智能调用 <code>stdcall</code> 函数，但有两种方法可以实现调用类成员，一种是使用 bind：<code>commit(std::bind(&amp;Dog::sayHello, &amp;dog));</code> 一种是用 mem_fn： <code>commit(std::mem_fn(&amp;Dog::sayHello), &amp;dog)；</code>。</li><li><code>make_shared()</code> 用来构造 <code>shared_ptr</code> 智能指针。用法大体是 <code>shared_ptr p = make_shared(4)</code> 然后 <code>*p == 4</code> 。智能指针的好处就是自动 delete。</li><li><code>bind</code> 函数，接受函数 f 和部分参数，返回currying后的匿名函数，譬如 <code>bind(add, 4)</code> 可以实现类似 <code>add(4)</code> 的函数。</li><li><code>forward()</code> 函数，类似于 <code>move()</code> 函数，后者是将参数右值化，前者是不改变最初传入的类型的引用类型(左值还是左值，右值还是右值)。</li><li><code>packaged_task</code> 就是任务函数的封装类，通过 <code>get_future()</code> 获取 <code>future</code> ，然后通过 <code>future</code> 可以获取函数的返回值(<code>future.get()</code>)；<code>packaged_task</code> 本身可以像函数一样调用。</li><li><code>queue</code> 是队列类， <code>front()</code> 获取头部元素， <code>pop()</code> 移除头部元素；<code>back()</code> 获取尾部元素，<code>push()</code> 尾部添加元素。</li><li><code>lock_guard</code> 是 <code>mutex</code> 的 stack 封装类，构造的时候 <code>lock()</code>，析构的时候 <code>unlock()</code>，是 C++ RAII 的 idea。</li><li><code>condition_variable cv;</code> 条件变量，需要配合 <code>unique_lock</code> 使用；<code>unique_lock</code> 相比 <code>lock_guard</code> 的好处是：可以随时 <code>unlock()</code> 和 <code>lock()</code>。 <code>cv.wait()</code> 之前需要持有 mutex，<code>wait()</code> 本身会解锁，如果条件满足则会重新持有锁。</li><li>最后线程池析构的时候，<code>join()</code> 可以等待任务都执行完再结束，很安全。</li></ol><h4 id="简单写法"><a href="#简单写法" class="headerlink" title="简单写法"></a>简单写法</h4><p><code>ThreadPool.hpp</code>：<br></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once  </span></span><br><span class="line">  </span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;future&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;condition_variable&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;type_traits&gt;</span>  </span></span><br><span class="line">  </span><br><span class="line"><span class="comment">//线程池  </span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ThreadPool</span>  </span><br><span class="line">&#123;  </span><br><span class="line"><span class="keyword">public</span>:  </span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">ThreadPool</span><span class="params">(<span class="type">int</span> ThreadNums)</span></span>;    <span class="comment">//加上explicit避免产生诸如ThreadPool pool = 1;这样的隐式转换  </span></span><br><span class="line">    ~<span class="built_in">ThreadPool</span>();  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">//添加任务到队列  </span></span><br><span class="line">    <span class="comment">//F&amp;&amp;万能引用，如果F是左值，那得到的就是左值；如果F是右值，那得到的就是右值  </span></span><br><span class="line">    <span class="comment">//F为可调用对象类型，Arg为其对应的参数类型  </span></span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> F, <span class="keyword">typename</span> ...Arg&gt;   <span class="comment">//...Arg为可变参数模板，任意个数的参数  </span></span><br><span class="line">    <span class="function"><span class="keyword">auto</span> <span class="title">EnterQueues</span><span class="params">(F&amp;&amp; f, Arg&amp;&amp;... arg)</span> -&gt; std::future&lt;<span class="keyword">typename</span> std::invoke_result&lt;F, Arg...&gt;::type&gt;</span>;  </span><br><span class="line">    <span class="comment">//result_of是类型萃取工具，利用::type来推导出可调用对象F在传入参数Arg...时的返回类型。头文件&lt;type_traits&gt;  </span></span><br><span class="line">    <span class="comment">//C++17中result_of被启用，使用invoke_result  </span></span><br><span class="line">  </span><br><span class="line"><span class="keyword">private</span>:  </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">worker</span><span class="params">()</span></span>;  <span class="comment">//线程的执行内容  </span></span><br><span class="line">    <span class="type">bool</span> IsStop;    <span class="comment">//标识，当前线程池是不是停止  </span></span><br><span class="line">    std::condition_variable cv;  </span><br><span class="line">    std::mutex mtx;  </span><br><span class="line">    std::vector&lt;std::thread&gt; workers;   <span class="comment">//线程集合（线程池）  </span></span><br><span class="line">    std::queue&lt;std::function&lt;<span class="type">void</span>()&gt;&gt; MyQueue;  <span class="comment">//任务队列，任务封装成了void返回类型的函数  </span></span><br><span class="line">    <span class="comment">//如果用户放进来的函数有返回值，要想获得这个返回值，就需要利用packaged_task返回一个future对象，利用该对象获取返回值  </span></span><br><span class="line">&#125;;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">//构造函数  </span></span><br><span class="line">ThreadPool::<span class="built_in">ThreadPool</span>(<span class="type">int</span> ThreadNums) : <span class="built_in">IsStop</span>(<span class="literal">false</span>)  </span><br><span class="line">&#123;  </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; ThreadNums; ++i) &#123;  </span><br><span class="line">        workers.<span class="built_in">emplace_back</span>([<span class="keyword">this</span>]() &#123;  </span><br><span class="line">            <span class="keyword">this</span>-&gt;<span class="built_in">worker</span>(); <span class="comment">//此时线程就开始运行了  </span></span><br><span class="line">        &#125;);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">//析构函数  </span></span><br><span class="line">ThreadPool::~<span class="built_in">ThreadPool</span>()  </span><br><span class="line">&#123;  </span><br><span class="line">    <span class="comment">//更改停止标识  </span></span><br><span class="line">    &#123;   <span class="comment">//添加作用域，离开后自动释放。加锁保证线程安全地将IsStop置为true  </span></span><br><span class="line">        <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mtx)</span></span>;  </span><br><span class="line">        IsStop = <span class="literal">true</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">//通知所有阻塞中的线程，让它们继续进行  </span></span><br><span class="line">    cv.<span class="built_in">notify_all</span>();  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">//确保线程执行完成  </span></span><br><span class="line">    <span class="keyword">for</span> (std::thread&amp; OneThread : workers)  </span><br><span class="line">    &#123;  </span><br><span class="line">        OneThread.<span class="built_in">join</span>();   <span class="comment">//都加入（阻塞）到主线程中（不是指执行），当所有子线程释放以后，主线程才能释放  </span></span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">//添加任务  </span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> F, <span class="keyword">typename</span> ...Arg&gt;   <span class="comment">//...Arg为可变参数模板，任意个数的参数  </span></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">ThreadPool::EnterQueues</span><span class="params">(F&amp;&amp; f, Arg&amp;&amp;... arg)</span> -&gt; std::future&lt;<span class="keyword">typename</span> std::invoke_result&lt;F, Arg...&gt;::type&gt;  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="comment">//获得f执行后的类型  </span></span><br><span class="line">    <span class="keyword">using</span> functype = <span class="keyword">typename</span> std::result_of&lt;<span class="built_in">F</span>(Arg...)&gt;::type;  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">//获得一个智能指针，指向一个被包装为functype()的task  </span></span><br><span class="line">    <span class="comment">//之所以使用指针而不是使用局部变量，是为了延长生命周期  </span></span><br><span class="line">    <span class="keyword">auto</span> task = std::make_shared&lt;std::packaged_task&lt;<span class="built_in">functype</span>()&gt;&gt;(  </span><br><span class="line">            std::<span class="built_in">bind</span>(std::forward&lt;F&gt;(f), std::forward&lt;Arg&gt;(arg)...)    <span class="comment">//绑定成function&lt;void()&gt;类型  </span></span><br><span class="line">            );  </span><br><span class="line">    <span class="comment">//std::forward完美转发，发的是右值则传右值，发的是左值则传左值  </span></span><br><span class="line">  </span><br><span class="line">    <span class="comment">//获得future  </span></span><br><span class="line">    std::future&lt;functype&gt; rsFuture = task-&gt;<span class="built_in">get_future</span>();  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">//将任务添加到队列  </span></span><br><span class="line">    &#123;  </span><br><span class="line">        <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lockGuard</span><span class="params">(mtx)</span></span>;  </span><br><span class="line">        <span class="keyword">if</span> (IsStop)  </span><br><span class="line">        &#123;  </span><br><span class="line">            <span class="keyword">throw</span> std::<span class="built_in">runtime_error</span>(<span class="string">&quot;出错：线程池已经停止了&quot;</span>);  </span><br><span class="line">        &#125;  </span><br><span class="line">  </span><br><span class="line">        MyQueue.<span class="built_in">emplace</span>([task]() &#123;  </span><br><span class="line">            (*task)();  </span><br><span class="line">        &#125;);  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">//通知线程去执行任务  </span></span><br><span class="line">    cv.<span class="built_in">notify_one</span>();  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">return</span> rsFuture;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">//每个具体的工作任务  </span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ThreadPool::worker</span><span class="params">()</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>)  </span><br><span class="line">    &#123;  </span><br><span class="line">        <span class="comment">//定义任务  </span></span><br><span class="line">        std::function&lt;<span class="type">void</span>()&gt; task;  </span><br><span class="line">  </span><br><span class="line">        <span class="comment">//从队列中取得一个任务  </span></span><br><span class="line">        &#123;  </span><br><span class="line">            <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">uniqueLock</span><span class="params">(mtx)</span></span>;  </span><br><span class="line">  </span><br><span class="line">            cv.<span class="built_in">wait</span>(uniqueLock, [<span class="keyword">this</span>]() &#123;  </span><br><span class="line">                <span class="keyword">return</span> !<span class="keyword">this</span>-&gt;MyQueue.<span class="built_in">empty</span>() || <span class="keyword">this</span>-&gt;IsStop;  </span><br><span class="line">            &#125;);  </span><br><span class="line">  </span><br><span class="line">            <span class="keyword">if</span> (IsStop &amp;&amp; MyQueue.<span class="built_in">empty</span>())  </span><br><span class="line">            &#123;  </span><br><span class="line">                <span class="keyword">return</span>;  </span><br><span class="line">            &#125;  </span><br><span class="line">            task = std::<span class="built_in">move</span>(MyQueue.<span class="built_in">front</span>());  </span><br><span class="line">            MyQueue.<span class="built_in">pop</span>();  </span><br><span class="line">        &#125;  </span><br><span class="line">  </span><br><span class="line">        <span class="comment">//执行任务  </span></span><br><span class="line">        <span class="built_in">task</span>();  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p><code>main.cpp</code>：<br></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;ThreadPool.hpp&quot;</span>  </span></span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;chcp 65001&quot;</span>);  </span><br><span class="line">    <span class="function">ThreadPool <span class="title">MyPool</span><span class="params">(<span class="number">4</span>)</span></span>;  </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; ++i) &#123;  <span class="comment">//即使是i &lt; 20，仍然只有4个线程运行  </span></span><br><span class="line">        std::future&lt;<span class="type">int</span>&gt; MyFuture = MyPool.<span class="built_in">EnterQueues</span>([](<span class="type">int</span> a, <span class="type">int</span> b) -&gt; <span class="type">int</span> &#123;  </span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;当前线程: &quot;</span> &lt;&lt; std::this_thread::<span class="built_in">get_id</span>() &lt;&lt; std::endl;  </span><br><span class="line">            <span class="keyword">return</span> a + b;  </span><br><span class="line">        &#125;, <span class="number">10</span> * i, <span class="number">10</span> * i);  </span><br><span class="line">  </span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;thread rs: &quot;</span> &lt;&lt; MyFuture.<span class="built_in">get</span>() &lt;&lt; std::endl;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>✅注：关于 hpp 文件<br>HPP（Header Plus Plus）是C++中的一种特殊头文件格式，它将类的声明和实现代码放在同一个文件中。与传统的 <code>.h</code> 和 <code>.cpp</code> 文件不同，HPP文件允许在头文件中直接包含实现代码，从而减少了代码文件的数量和编译次数。这种文件格式特别适合用于编写模板类和开源库，因为它简化了代码的管理和使用。</p><p>输出结果：<br></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">thread rs: 当前线程: 2</span><br><span class="line">0</span><br><span class="line">thread rs: 当前线程: 3</span><br><span class="line">20</span><br><span class="line">thread rs: 当前线程: 4</span><br><span class="line">40</span><br><span class="line">thread rs: 当前线程: 5</span><br><span class="line">60</span><br><span class="line">thread rs: 当前线程: 2</span><br><span class="line">80</span><br><span class="line">thread rs: 当前线程: 3</span><br><span class="line">100</span><br><span class="line">thread rs: 当前线程: 4</span><br><span class="line">120</span><br><span class="line">thread rs: 当前线程: 5</span><br><span class="line">140</span><br><span class="line">thread rs: 当前线程: 2</span><br><span class="line">160</span><br><span class="line">thread rs: 当前线程: 3</span><br><span class="line">180</span><br><span class="line">thread rs: 当前线程: 4</span><br><span class="line">200</span><br><span class="line">thread rs: 当前线程: 5</span><br><span class="line">220</span><br><span class="line">thread rs: 当前线程: 2</span><br><span class="line">240</span><br><span class="line">thread rs: 当前线程: 3</span><br><span class="line">260</span><br><span class="line">thread rs: 当前线程: 4</span><br><span class="line">280</span><br><span class="line">thread rs: 当前线程: 5</span><br><span class="line">300</span><br><span class="line">thread rs: 当前线程: 2</span><br><span class="line">320</span><br><span class="line">thread rs: 当前线程: 3</span><br><span class="line">340</span><br><span class="line">thread rs: 当前线程: 4</span><br><span class="line">360</span><br><span class="line">thread rs: 当前线程: 5</span><br><span class="line">380</span><br></pre></td></tr></table></figure><p></p></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者:</span> <span class="post-copyright-info"><a href="https://sumikiru.top">Sumikiru</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接:</span> <span class="post-copyright-info"><a href="https://sumikiru.top/posts/4fee29fb.html">https://sumikiru.top/posts/4fee29fb.html</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明:</span> <span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://sumikiru.top" target="_blank">SumikiruのBlog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/C/">C++</a><a class="post-meta__tags" href="/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/">多线程</a></div><div class="post_share"><div class="social-share" data-image="https://pic.imgdb.cn/item/6692a239d9c307b7e99355e5.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/css/share.min.css" media="print" onload='this.media="all"'><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/posts/31d79f30.html" title="CLion配置C++与Lua"><img class="cover" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://pic1.imgdb.cn/item/6798b1eed0e0a243d4f84e1b.webp" onerror='onerror=null,src="/img/404.jpg"' alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">CLion配置C++与Lua</div></div></a></div><div class="next-post pull-right"><a href="/posts/d0ae354a.html" title="GAS中文文档（更新中）"><img class="cover" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://pic.imgdb.cn/item/660e52719f345e8d03a5e677.jpg" onerror='onerror=null,src="/img/404.jpg"' alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">GAS中文文档（更新中）</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/posts/f83528c7.html" title="3.数与位篇"><img class="cover" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://pic.imgdb.cn/item/660e52719f345e8d03a5e677.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-04-25</div><div class="title">3.数与位篇</div></div></a></div><div><a href="/posts/31d79f30.html" title="CLion配置C++与Lua"><img class="cover" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://pic1.imgdb.cn/item/6798b1eed0e0a243d4f84e1b.webp" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2025-01-28</div><div class="title">CLion配置C++与Lua</div></div></a></div><div><a href="/posts/123456.html" title="0.常用的C++ STL用法"><img class="cover" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://pic.imgdb.cn/item/660e52719f345e8d03a5e677.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-04-05</div><div class="title">0.常用的C++ STL用法</div></div></a></div><div><a href="/posts/254d58d4.html" title="1.数组篇"><img class="cover" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://pic.imgdb.cn/item/660e52719f345e8d03a5e677.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-04-05</div><div class="title">1.数组篇</div></div></a></div><div><a href="/posts/10e5d792.html" title="2.0字符串篇"><img class="cover" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://pic.imgdb.cn/item/660e52719f345e8d03a5e677.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-04-05</div><div class="title">2.0字符串篇</div></div></a></div><div><a href="/posts/283bba67.html" title="2.1字符串篇(2)"><img class="cover" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://pic.imgdb.cn/item/660e52719f345e8d03a5e677.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-04-05</div><div class="title">2.1字符串篇(2)</div></div></a></div></div></div><hr class="custom-hr"><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i> <span>评论</span></div></div><div class="comment-wrap"><div><div id="twikoo-wrap"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-text">基本概念</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E7%BA%BF%E7%A8%8B%E3%80%81%E8%BF%9B%E7%A8%8B%E3%80%81%E5%B9%B6%E5%8F%91"><span class="toc-text">什么是线程、进程、并发</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%85%B3%E7%B3%BB"><span class="toc-text">进程与线程的关系</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E7%9A%84%E7%89%B9%E7%82%B9"><span class="toc-text">线程的特点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%BC%96%E7%A8%8B"><span class="toc-text">什么是多线程编程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BD%BF%E7%94%A8%E5%A4%9A%E7%BA%BF%E7%A8%8B-%E5%B9%B6%E5%8F%91%EF%BC%88%E4%BC%98%E7%82%B9%EF%BC%89"><span class="toc-text">为什么使用多线程&#x2F;并发（优点）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B9%B6%E5%8F%91%E4%B8%8E%E5%B9%B6%E8%A1%8C%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">并发与并行的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%A3%B0%E6%98%8E%E5%91%A8%E6%9C%9F"><span class="toc-text">线程的声明周期</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Thread-%E5%88%9B%E5%BB%BA%E7%BA%BF%E7%A8%8B"><span class="toc-text">Thread 创建线程</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%BB%E4%BD%93%E4%BB%A3%E7%A0%81"><span class="toc-text">总体代码</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%80%9A%E8%BF%87%E5%8F%AF%E8%B0%83%E7%94%A8%E5%AF%B9%E8%B1%A1%E5%88%9B%E5%BB%BA%E7%BA%BF%E7%A8%8B"><span class="toc-text">通过可调用对象创建线程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E5%8F%82%E6%95%B0%E4%BC%A0%E9%80%92"><span class="toc-text">线程参数传递</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%9A%E8%BF%87%E5%80%BC%E4%BC%A0%E9%80%92"><span class="toc-text">通过值传递</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%9A%E8%BF%87%E5%BC%95%E7%94%A8%E4%BC%A0%E9%80%92"><span class="toc-text">通过引用传递</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#join-%E4%B8%8E-detach-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">join 与 detach 的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%BB%E7%BA%BF%E7%A8%8B%E5%8C%85%E5%90%AB%E7%9A%84%E5%86%85%E5%AE%B9"><span class="toc-text">主线程包含的内容</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#this-thread"><span class="toc-text">this_thread</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5"><span class="toc-text">线程同步</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A6%82%E5%BF%B5"><span class="toc-text">概念</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%F0%9F%9A%A9%E4%BA%92%E6%96%A5%E9%94%81-mutex"><span class="toc-text">🚩互斥锁 mutex</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="toc-text">注意事项</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%9C%85%E5%85%B3%E4%BA%8ERAII"><span class="toc-text">✅关于RAII</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#mutex-%E7%9A%84%E5%9B%9B%E7%A7%8D%E7%B1%BB%E5%9E%8B"><span class="toc-text">mutex 的四种类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#lock-guard"><span class="toc-text">lock_guard</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#unique-lock"><span class="toc-text">unique_lock</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%F0%9F%92%BB%E4%BB%A3%E7%A0%81%E7%A4%BA%E4%BE%8B"><span class="toc-text">💻代码示例</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%F0%9F%9A%A9%E6%9D%A1%E4%BB%B6%E5%8F%98%E9%87%8F-condition-variable"><span class="toc-text">🚩条件变量 condition_variable</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%F0%9F%92%BB%E4%BB%A3%E7%A0%81%E7%A4%BA%E4%BE%8B-1"><span class="toc-text">💻代码示例</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%F0%9F%9A%A9%E8%AF%BB%E5%86%99%E9%94%81-shared-mutex"><span class="toc-text">🚩读写锁 shared_mutex</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5-1"><span class="toc-text">基本概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0"><span class="toc-text">代码实现</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#shared-mutex"><span class="toc-text">shared_mutex</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#shared-lock"><span class="toc-text">shared_lock</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%F0%9F%9A%A9%E5%8E%9F%E5%AD%90%E5%8F%98%E9%87%8F%E5%92%8C%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9C-atomic"><span class="toc-text">🚩原子变量和原子操作 atomic</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5-2"><span class="toc-text">基本概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E7%A4%BA%E4%BE%8B"><span class="toc-text">代码示例</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E8%A7%81%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9C%E6%96%B9%E6%B3%95"><span class="toc-text">常见原子操作方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9C%E7%9A%84%E5%86%85%E5%AD%98%E5%BA%8F%E9%97%AE%E9%A2%98"><span class="toc-text">原子操作的内存序问题</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%F0%9F%9A%A9%E4%BF%A1%E5%8F%B7%E9%87%8F-semaphore"><span class="toc-text">🚩信号量 semaphore</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5-3"><span class="toc-text">基本概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#counting-semaphore"><span class="toc-text">counting_semaphore</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%F0%9F%92%BB%E4%BB%A3%E7%A0%81%E7%A4%BA%E4%BE%8B-2"><span class="toc-text">💻代码示例</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A0%85%E6%A0%8F-barrier"><span class="toc-text">栅栏 barrier</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5-4"><span class="toc-text">基本概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%F0%9F%92%BB%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0"><span class="toc-text">💻代码实现</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%AD%BB%E9%94%81"><span class="toc-text">死锁</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%F0%9F%92%BB%E4%BB%A3%E7%A0%81%E7%A4%BA%E4%BE%8B-3"><span class="toc-text">💻代码示例</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B"><span class="toc-text">异步编程</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A6%82%E5%BF%B5-1"><span class="toc-text">概念</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%F0%9F%9A%A9async"><span class="toc-text">🚩async</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5-5"><span class="toc-text">基本概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%F0%9F%92%BB%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0-1"><span class="toc-text">💻代码实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%89%E7%A7%8D%E5%90%AF%E5%8A%A8%E7%AD%96%E7%95%A5"><span class="toc-text">三种启动策略</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%F0%9F%9A%A9promise"><span class="toc-text">🚩promise</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5-6"><span class="toc-text">基本概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%F0%9F%92%BB%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0-2"><span class="toc-text">💻代码实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9-1"><span class="toc-text">注意事项</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%F0%9F%9A%A9packaged-task"><span class="toc-text">🚩packaged_task</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5-7"><span class="toc-text">基本概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%F0%9F%92%BB%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0-3"><span class="toc-text">💻代码实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9-2"><span class="toc-text">注意事项</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89%E7%A7%8D%E5%BC%82%E6%AD%A5%E5%B7%A5%E5%85%B7%E7%9A%84%E6%AF%94%E8%BE%83"><span class="toc-text">三种异步工具的比较</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B9%8B%E9%97%B4%E7%9A%84%E5%85%B3%E7%B3%BB"><span class="toc-text">之间的关系</span></a></li></ol></li></ol></li></ol><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0"><span class="toc-text">线程池</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5-8"><span class="toc-text">基本概念</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%F0%9F%92%BB%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0-4"><span class="toc-text">💻代码实现</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AE%80%E5%8D%95%E5%86%99%E6%B3%95"><span class="toc-text">简单写法</span></a></li></ol></li></ol></li></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2025 By Sumikiru</div><div class="framework-info"><span>框架</span> <a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题</span> <a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=4.13.0"></script><script src="/js/main.js?v=4.13.0"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.33/dist/fancybox/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page@5.2.0/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload@17.8.8/dist/lazyload.iife.min.js"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar@0.1.16/dist/snackbar.min.js"></script><div class="js-pjax"><script>if (!window.MathJax) {
  window.MathJax = {
    tex: {
      inlineMath: [['$', '$'], ['\\(', '\\)']],
      tags: 'ams'
    },
    chtml: {
      scale: 1.1
    },
    options: {
      renderActions: {
        findScript: [10, doc => {
          for (const node of document.querySelectorAll('script[type^="math/tex"]')) {
            const display = !!node.type.match(/; *mode=display/)
            const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display)
            const text = document.createTextNode('')
            node.parentNode.replaceChild(text, node)
            math.start = {node: text, delim: '', n: 0}
            math.end = {node: text, delim: '', n: 0}
            doc.math.push(math)
          }
        }, '']
      }
    }
  }
  
  const script = document.createElement('script')
  script.src = 'https://cdn.jsdelivr.net/npm/mathjax@3.2.2/es5/tex-mml-chtml.min.js'
  script.id = 'MathJax-script'
  script.async = true
  document.head.appendChild(script)
} else {
  MathJax.startup.document.state(0)
  MathJax.texReset()
  MathJax.typesetPromise()
}</script><script>(() => {
  const $mermaid = document.querySelectorAll('#article-container .mermaid-wrap')
  if ($mermaid.length === 0) return
  const runMermaid = () => {
    window.loadMermaid = true
    const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark' : 'default'

    Array.from($mermaid).forEach((item, index) => {
      const mermaidSrc = item.firstElementChild
      const mermaidThemeConfig = '%%{init:{ \'theme\':\'' + theme + '\'}}%%\n'
      const mermaidID = 'mermaid-' + index
      const mermaidDefinition = mermaidThemeConfig + mermaidSrc.textContent

      const renderFn = mermaid.render(mermaidID, mermaidDefinition)

      const renderV10 = () => {
        renderFn.then(({svg}) => {
          mermaidSrc.insertAdjacentHTML('afterend', svg)
        })
      }

      const renderV9 = svg => {
        mermaidSrc.insertAdjacentHTML('afterend', svg)
      }

      typeof renderFn === 'string' ? renderV9(renderFn) : renderV10()
    })
  }

  const loadMermaid = () => {
    window.loadMermaid ? runMermaid() : getScript('https://cdn.jsdelivr.net/npm/mermaid@10.8.0/dist/mermaid.min.js').then(runMermaid)
  }

  btf.addGlobalFn('themeChange', runMermaid, 'mermaid')

  window.pjax ? loadMermaid() : document.addEventListener('DOMContentLoaded', loadMermaid)
})()</script><script>(() => {
  const getCount = () => {
    const countELement = document.getElementById('twikoo-count')
    if(!countELement) return
    twikoo.getCommentsCount({
      envId: 'https://twikoo-netlify.sumikiru.top/.netlify/functions/twikoo',
      region: '',
      urls: [window.location.pathname],
      includeReply: false
    }).then(res => {
      countELement.textContent = res[0].count
    }).catch(err => {
      console.error(err)
    })
  }

  const init = () => {
    twikoo.init(Object.assign({
      el: '#twikoo-wrap',
      envId: 'https://twikoo-netlify.sumikiru.top/.netlify/functions/twikoo',
      region: '',
      onCommentLoaded: () => {
        btf.loadLightbox(document.querySelectorAll('#twikoo .tk-content img:not(.tk-owo-emotion)'))
      }
    }, null))

    
  }

  const loadTwikoo = () => {
    if (typeof twikoo === 'object') setTimeout(init,0)
    else getScript('https://cdn.jsdelivr.net/npm/twikoo@1.6.31/dist/twikoo.all.min.js').then(init)
  }

  if ('Twikoo' === 'Twikoo' || !true) {
    if (true) btf.loadComment(document.getElementById('twikoo-wrap'), loadTwikoo)
    else loadTwikoo()
  } else {
    window.loadOtherComment = loadTwikoo
  }
})()</script></div><div class="aplayer no-destroy" data-id="2125653815" data-server="netease" data-type="playlist" data-order="list" data-fixed="true" data-preload="auto" data-autoplay="false" data-mutex="true"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer@1.10.1/dist/APlayer.min.css" media="print" onload='this.media="all"'><script src="https://cdn.jsdelivr.net/npm/aplayer@1.10.1/dist/APlayer.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/metingjs/dist/Meting.min.js"></script><script src="https://cdn.jsdelivr.net/npm/pjax@0.2.8/pjax.min.js"></script><script>let pjaxSelectors = ["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]

var pjax = new Pjax({
  elements: 'a:not([target="_blank"]):not([href="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"]):not([href="https://twikoo-netlify.sumikiru.top/.netlify/functions/twikoo"])',
  selectors: pjaxSelectors,
  cacheBust: false,
  analytics: false,
  scrollRestoration: false
})

document.addEventListener('pjax:send', function () {

  // removeEventListener
  btf.removeGlobalFnEvent('pjax')
  btf.removeGlobalFnEvent('themeChange')

  document.getElementById('rightside').classList.remove('rightside-show')
  
  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  //reset readmode
  const $bodyClassList = document.body.classList
  $bodyClassList.contains('read-mode') && $bodyClassList.remove('read-mode')

  typeof disqusjs === 'object' && disqusjs.destroy()
})

document.addEventListener('pjax:complete', function () {
  window.refreshFn()

  document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
  })

  GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

  typeof panguInit === 'function' && panguInit()

  // google analytics
  typeof gtag === 'function' && gtag('config', '', {'page_path': window.location.pathname});

  // baidu analytics
  typeof _hmt === 'object' && _hmt.push(['_trackPageview',window.location.pathname]);

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

  // prismjs
  typeof Prism === 'object' && Prism.highlightAll()
})

document.addEventListener('pjax:error', e => {
  if (e.request.status === 404) {
    pjax.loadUrl('/404.html')
  }
})</script><div class="app-refresh" id="app-refresh" style="position:fixed;top:-2.2rem;left:0;right:0;z-index:99999;padding:0 1rem;font-size:15px;height:2.2rem;transition:all .3s ease"><div class="app-refresh-wrap" style="display:flex;color:#fff;height:100%;align-items:center;justify-content:center"><label>✨ 有新文章啦！ 👉</label><a href="javascript:void(0)" onclick="location.reload()"><span style="color:#fff;text-decoration:underline;cursor:pointer">🍗点击食用🍔</span></a></div></div><script>if ('serviceWorker' in navigator) {
  if (navigator.serviceWorker.controller) {
    navigator.serviceWorker.addEventListener('controllerchange', function() {
      showNotification()
    })
  }
  window.addEventListener('load', function() {
    navigator.serviceWorker.register('/sw.js')
  })
}
function showNotification() {
  if (GLOBAL_CONFIG.Snackbar) {
    var snackbarBg = document.documentElement.getAttribute('data-theme') === 'light' ? GLOBAL_CONFIG.Snackbar.bgLight : GLOBAL_CONFIG.Snackbar.bgDark
    var snackbarPos = GLOBAL_CONFIG.Snackbar.position
    Snackbar.show({
      text: '✨ 有新文章啦！ 👉',
      backgroundColor: snackbarBg,
      duration: 500000,
      pos: snackbarPos,
      actionText: '🍗点击食用🍔',
      actionTextColor: '#fff',
      onActionClick: function(e) {
        location.reload()
      },
    })
  } else {
    var showBg = document.documentElement.getAttribute('data-theme') === 'light' ? '#3b70fc' : '#1f1f1f'
    var cssText = `top: 0; background: ${showBg};`
    document.getElementById('app-refresh').style.cssText = cssText
  }
}</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i> <span>数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"></div></div><hr><div id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js?v=4.13.0"></script></div></div><script data-pjax>function butterfly_clock_anzhiyu_injector_config(){var a=document.getElementsByClassName("sticky_layout")[0];console.log("已挂载butterfly_clock_anzhiyu"),a&&a.insertAdjacentHTML("afterbegin",'<div class="card-widget card-clock"><div class="card-glass"><div class="card-background"><div class="card-content"><div id="hexo_electric_clock"><img class="entered loading" id="card-clock-loading" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.cbd.int/hexo-butterfly-clock-anzhiyu/lib/loading.gif" style="height: 120px; width: 100%;" data-ll-status="loading"/></div></div></div></div></div>')}for(var elist="/posts/".split(","),cpage=location.pathname,epage="all",qweather_key="814574b8a08a439aaf0c4e65c598bde2",gaud_map_key="7d331966e19a65abf8cc5fdd3d0a735a",baidu_ak_key="undefined",flag=0,clock_rectangle="112.6534116,27.96920845",clock_default_rectangle_enable="false",i=0;i<elist.length;i++)cpage.includes(elist[i])&&flag++;"all"===epage&&0==flag?butterfly_clock_anzhiyu_injector_config():epage===cpage&&butterfly_clock_anzhiyu_injector_config()</script><script src="https://widget.qweather.net/simple/static/js/he-simple-common.js?v=2.0"></script><script data-pjax src="https://cdn.cbd.int/hexo-butterfly-clock-anzhiyu/lib/clock.min.js"></script><script data-pjax>function butterfly_footer_beautify_injector_config(){var A=document.getElementById("footer-wrap");console.log("已挂载butterfly_footer_beautify"),A.insertAdjacentHTML("beforeend",'<div id="workboard"></div><p id="ghbdages"><a class="github-badge" target="_blank" href="https://hexo.io/" style="margin-inline:5px" title=""><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.shields.io/badge/Frame-Hexo-blue?style=flat&amp;logo=hexo" alt=""/></a><a class="github-badge" target="_blank" href="https://butterfly.js.org/" style="margin-inline:5px" title=""><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.shields.io/badge/Theme-Butterfly-6513df?style=flat&amp;logo=bitdefender" alt=""/></a><a class="github-badge" target="_blank" href="https://www.jsdelivr.com/" style="margin-inline:5px" title=""><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.shields.io/badge/CDN-jsDelivr-orange?style=flat&amp;logo=jsDelivr" alt=""/></a><a class="github-badge" target="_blank" href="https://github.com/" style="margin-inline:5px" data-title="本站项目由Github托管" title=""><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.shields.io/badge/Source-Github-d021d6?style=flat&amp;logo=GitHub" alt=""/></a><a class="github-badge" target="_blank" href="http://creativecommons.org/licenses/by-nc-sa/4.0/" style="margin-inline:5px" data-title="本站采用知识共享署名-非商业性使用-相同方式共享4.0国际许可协议进行许可" title=""><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.shields.io/badge/Copyright-BY--NC--SA%204.0-d42328?style=flat&amp;logo=Claris" alt=""/></a></p>')}for(var elist="null".split(","),cpage=location.pathname,epage="all",flag=0,i=0;i<elist.length;i++)cpage.includes(elist[i])&&flag++;"all"===epage&&0==flag?butterfly_footer_beautify_injector_config():epage===cpage&&butterfly_footer_beautify_injector_config()</script><script async src="/js/runtime/runtime.min.js"></script><script data-pjax>function butterfly_swiper_injector_config(){var a=document.getElementById("recent-posts");console.log("已挂载butterfly_swiper"),a.insertAdjacentHTML("afterbegin",'<div class="recent-post-item" style="height: auto;width: 100%"><div class="blog-slider swiper-container-fade swiper-container-horizontal" id="swiper_container"><div class="blog-slider__wrp swiper-wrapper" style="transition-duration: 0ms;"><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/9b94e219.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://pic.imgdb.cn/item/660f797468eb93571307d888.jpg" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2024-04-05</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/9b94e219.html&quot;);" href="javascript:void(0);" alt="">欢迎来到本站</a><div class="blog-slider__text">欢迎，一起来研究C++吧~</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/9b94e219.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/d0ae354a.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://pic.imgdb.cn/item/660e52719f345e8d03a5e677.jpg" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2024-12-10</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/d0ae354a.html&quot;);" href="javascript:void(0);" alt="">GAS中文文档（更新中）</a><div class="blog-slider__text">GAS中文文档，更新至5.3版本（更新中，images以后配置）</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/d0ae354a.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/4fee29fb.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://pic.imgdb.cn/item/6692a239d9c307b7e99355e5.jpg" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2024-12-15</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/4fee29fb.html&quot;);" href="javascript:void(0);" alt="">语言基础4.并发与多线程</a><div class="blog-slider__text">C++基础：多线程</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/4fee29fb.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/9da932c7.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://pic.imgdb.cn/item/6692a239d9c307b7e99355e5.jpg" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2024-09-12</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/9da932c7.html&quot;);" href="javascript:void(0);" alt="">语言基础3.文件操作与C++11新特性</a><div class="blog-slider__text">C++基础：文件操作与C++11新特性</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/9da932c7.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/816de279.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://pic.imgdb.cn/item/6692a239d9c307b7e99355e5.jpg" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2024-08-10</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/816de279.html&quot;);" href="javascript:void(0);" alt="">语言基础2.面向对象</a><div class="blog-slider__text">C++基础：面向对象</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/816de279.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/31d79f30.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://pic1.imgdb.cn/item/6798b1eed0e0a243d4f84e1b.webp" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2025-01-28</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/31d79f30.html&quot;);" href="javascript:void(0);" alt="">CLion配置C++与Lua</a><div class="blog-slider__text">CLion配置C++和Lua的运行与调试</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/31d79f30.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/10e5d792.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://pic.imgdb.cn/item/660e52719f345e8d03a5e677.jpg" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2024-04-05</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/10e5d792.html&quot;);" href="javascript:void(0);" alt="">2.0字符串篇</a><div class="blog-slider__text">字符串基础部分</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/10e5d792.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/123456.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://pic.imgdb.cn/item/660e52719f345e8d03a5e677.jpg" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2024-04-05</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/123456.html&quot;);" href="javascript:void(0);" alt="">0.常用的C++ STL用法</a><div class="blog-slider__text">转载自github</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/123456.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div></div><div class="blog-slider__pagination swiper-pagination-clickable swiper-pagination-bullets"></div></div></div>')}for(var elist="undefined".split(","),cpage=location.pathname,epage="/",flag=0,i=0;i<elist.length;i++)cpage.includes(elist[i])&&flag++;"all"===epage&&0==flag?butterfly_swiper_injector_config():epage===cpage&&butterfly_swiper_injector_config()</script><script defer src="https://npm.elemecdn.com/hexo-butterfly-swiper/lib/swiper.min.js"></script><script defer data-pjax src="https://npm.elemecdn.com/hexo-butterfly-swiper/lib/swiper_init.js"></script><script async src="/js/ali_font.js"></script><div class="js-pjax"><script async>for(var arr=document.getElementsByClassName("recent-post-item"),i=0;i<arr.length;i++)arr[i].classList.add("wow"),arr[i].classList.add("animate__zoomIn"),arr[i].setAttribute("data-wow-duration","1.5s"),arr[i].setAttribute("data-wow-delay","200ms"),arr[i].setAttribute("data-wow-offset","30"),arr[i].setAttribute("data-wow-iteration","1")</script><script async>for(var arr=document.getElementsByClassName("card-widget"),i=0;i<arr.length;i++)arr[i].classList.add("wow"),arr[i].classList.add("animate__zoomIn"),arr[i].setAttribute("data-wow-duration",""),arr[i].setAttribute("data-wow-delay","200ms"),arr[i].setAttribute("data-wow-offset",""),arr[i].setAttribute("data-wow-iteration","")</script><script async>for(var arr=document.getElementsByClassName("flink-list-card"),i=0;i<arr.length;i++)arr[i].classList.add("wow"),arr[i].classList.add("animate__flipInY"),arr[i].setAttribute("data-wow-duration","3s"),arr[i].setAttribute("data-wow-delay",""),arr[i].setAttribute("data-wow-offset",""),arr[i].setAttribute("data-wow-iteration","")</script><script async>for(var arr=document.getElementsByClassName("flink-list-card"),i=0;i<arr.length;i++)arr[i].classList.add("wow"),arr[i].classList.add("animate__animated"),arr[i].setAttribute("data-wow-duration","3s"),arr[i].setAttribute("data-wow-delay",""),arr[i].setAttribute("data-wow-offset",""),arr[i].setAttribute("data-wow-iteration","")</script><script async>for(var arr=document.getElementsByClassName("article-sort-item"),i=0;i<arr.length;i++)arr[i].classList.add("wow"),arr[i].classList.add("animate__slideInRight"),arr[i].setAttribute("data-wow-duration","1.5s"),arr[i].setAttribute("data-wow-delay",""),arr[i].setAttribute("data-wow-offset",""),arr[i].setAttribute("data-wow-iteration","")</script><script async>for(var arr=document.getElementsByClassName("site-card"),i=0;i<arr.length;i++)arr[i].classList.add("wow"),arr[i].classList.add("animate__flipInY"),arr[i].setAttribute("data-wow-duration","3s"),arr[i].setAttribute("data-wow-delay",""),arr[i].setAttribute("data-wow-offset",""),arr[i].setAttribute("data-wow-iteration","")</script><script async>for(var arr=document.getElementsByClassName("site-card"),i=0;i<arr.length;i++)arr[i].classList.add("wow"),arr[i].classList.add("animate__animated"),arr[i].setAttribute("data-wow-duration","3s"),arr[i].setAttribute("data-wow-delay",""),arr[i].setAttribute("data-wow-offset",""),arr[i].setAttribute("data-wow-iteration","")</script></div><script defer src="https://cdn.cbd.int/hexo-butterfly-wowjs/lib/wow.min.js"></script><script defer src="https://cdn.cbd.int/hexo-butterfly-wowjs/lib/wow_init.js"></script><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({tagMode:!1,debug:!1,model:{jsonPath:"/live2dw/assets/haruto.model.json"},display:{position:"right",width:150,height:300},mobile:{show:!1},log:!1,pluginJsPath:"lib/",pluginModelPath:"assets/",pluginRootPath:"live2dw/"})</script></body></html>